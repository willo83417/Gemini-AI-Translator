var IH=Object.defineProperty;var PH=(e,t,n)=>t in e?IH(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var fe=(e,t,n)=>PH(e,typeof t!="symbol"?t+"":t,n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&i(a)}).observe(document,{childList:!0,subtree:!0});function n(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(r){if(r.ep)return;r.ep=!0;const s=n(r);fetch(r.href,s)}})();var kH=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function M1(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var Cz={exports:{}},kg={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var DH=Symbol.for("react.transitional.element"),OH=Symbol.for("react.fragment");function $z(e,t,n){var i=null;if(n!==void 0&&(i=""+n),t.key!==void 0&&(i=""+t.key),"key"in t){n={};for(var r in t)r!=="key"&&(n[r]=t[r])}else n=t;return t=n.ref,{$$typeof:DH,type:e,key:i,ref:t!==void 0?t:null,props:n}}kg.Fragment=OH;kg.jsx=$z;kg.jsxs=$z;Cz.exports=kg;var se=Cz.exports,Az={exports:{}},yn={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var E1=Symbol.for("react.transitional.element"),RH=Symbol.for("react.portal"),NH=Symbol.for("react.fragment"),LH=Symbol.for("react.strict_mode"),zH=Symbol.for("react.profiler"),FH=Symbol.for("react.consumer"),BH=Symbol.for("react.context"),UH=Symbol.for("react.forward_ref"),VH=Symbol.for("react.suspense"),GH=Symbol.for("react.memo"),Iz=Symbol.for("react.lazy"),jH=Symbol.for("react.activity"),$$=Symbol.iterator;function WH(e){return e===null||typeof e!="object"?null:(e=$$&&e[$$]||e["@@iterator"],typeof e=="function"?e:null)}var Pz={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},kz=Object.assign,Dz={};function Id(e,t,n){this.props=e,this.context=t,this.refs=Dz,this.updater=n||Pz}Id.prototype.isReactComponent={};Id.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};Id.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function Oz(){}Oz.prototype=Id.prototype;function S1(e,t,n){this.props=e,this.context=t,this.refs=Dz,this.updater=n||Pz}var C1=S1.prototype=new Oz;C1.constructor=S1;kz(C1,Id.prototype);C1.isPureReactComponent=!0;var A$=Array.isArray;function Tw(){}var Oi={H:null,A:null,T:null,S:null},Rz=Object.prototype.hasOwnProperty;function $1(e,t,n){var i=n.ref;return{$$typeof:E1,type:e,key:t,ref:i!==void 0?i:null,props:n}}function HH(e,t){return $1(e.type,t,e.props)}function A1(e){return typeof e=="object"&&e!==null&&e.$$typeof===E1}function qH(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var I$=/\/+/g;function Dy(e,t){return typeof e=="object"&&e!==null&&e.key!=null?qH(""+e.key):t.toString(36)}function KH(e){switch(e.status){case"fulfilled":return e.value;case"rejected":throw e.reason;default:switch(typeof e.status=="string"?e.then(Tw,Tw):(e.status="pending",e.then(function(t){e.status==="pending"&&(e.status="fulfilled",e.value=t)},function(t){e.status==="pending"&&(e.status="rejected",e.reason=t)})),e.status){case"fulfilled":return e.value;case"rejected":throw e.reason}}throw e}function Rc(e,t,n,i,r){var s=typeof e;(s==="undefined"||s==="boolean")&&(e=null);var a=!1;if(e===null)a=!0;else switch(s){case"bigint":case"string":case"number":a=!0;break;case"object":switch(e.$$typeof){case E1:case RH:a=!0;break;case Iz:return a=e._init,Rc(a(e._payload),t,n,i,r)}}if(a)return r=r(e),a=i===""?"."+Dy(e,0):i,A$(r)?(n="",a!=null&&(n=a.replace(I$,"$&/")+"/"),Rc(r,t,n,"",function(u){return u})):r!=null&&(A1(r)&&(r=HH(r,n+(r.key==null||e&&e.key===r.key?"":(""+r.key).replace(I$,"$&/")+"/")+a)),t.push(r)),1;a=0;var o=i===""?".":i+":";if(A$(e))for(var l=0;l<e.length;l++)i=e[l],s=o+Dy(i,l),a+=Rc(i,t,n,s,r);else if(l=WH(e),typeof l=="function")for(e=l.call(e),l=0;!(i=e.next()).done;)i=i.value,s=o+Dy(i,l++),a+=Rc(i,t,n,s,r);else if(s==="object"){if(typeof e.then=="function")return Rc(KH(e),t,n,i,r);throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.")}return a}function ah(e,t,n){if(e==null)return e;var i=[],r=0;return Rc(e,i,"","",function(s){return t.call(n,s,r++)}),i}function JH(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var P$=typeof reportError=="function"?reportError:function(e){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof e=="object"&&e!==null&&typeof e.message=="string"?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",e);return}console.error(e)},YH={map:ah,forEach:function(e,t,n){ah(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return ah(e,function(){t++}),t},toArray:function(e){return ah(e,function(t){return t})||[]},only:function(e){if(!A1(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};yn.Activity=jH;yn.Children=YH;yn.Component=Id;yn.Fragment=NH;yn.Profiler=zH;yn.PureComponent=S1;yn.StrictMode=LH;yn.Suspense=VH;yn.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=Oi;yn.__COMPILER_RUNTIME={__proto__:null,c:function(e){return Oi.H.useMemoCache(e)}};yn.cache=function(e){return function(){return e.apply(null,arguments)}};yn.cacheSignal=function(){return null};yn.cloneElement=function(e,t,n){if(e==null)throw Error("The argument must be a React element, but you passed "+e+".");var i=kz({},e.props),r=e.key;if(t!=null)for(s in t.key!==void 0&&(r=""+t.key),t)!Rz.call(t,s)||s==="key"||s==="__self"||s==="__source"||s==="ref"&&t.ref===void 0||(i[s]=t[s]);var s=arguments.length-2;if(s===1)i.children=n;else if(1<s){for(var a=Array(s),o=0;o<s;o++)a[o]=arguments[o+2];i.children=a}return $1(e.type,r,i)};yn.createContext=function(e){return e={$$typeof:BH,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null},e.Provider=e,e.Consumer={$$typeof:FH,_context:e},e};yn.createElement=function(e,t,n){var i,r={},s=null;if(t!=null)for(i in t.key!==void 0&&(s=""+t.key),t)Rz.call(t,i)&&i!=="key"&&i!=="__self"&&i!=="__source"&&(r[i]=t[i]);var a=arguments.length-2;if(a===1)r.children=n;else if(1<a){for(var o=Array(a),l=0;l<a;l++)o[l]=arguments[l+2];r.children=o}if(e&&e.defaultProps)for(i in a=e.defaultProps,a)r[i]===void 0&&(r[i]=a[i]);return $1(e,s,r)};yn.createRef=function(){return{current:null}};yn.forwardRef=function(e){return{$$typeof:UH,render:e}};yn.isValidElement=A1;yn.lazy=function(e){return{$$typeof:Iz,_payload:{_status:-1,_result:e},_init:JH}};yn.memo=function(e,t){return{$$typeof:GH,type:e,compare:t===void 0?null:t}};yn.startTransition=function(e){var t=Oi.T,n={};Oi.T=n;try{var i=e(),r=Oi.S;r!==null&&r(n,i),typeof i=="object"&&i!==null&&typeof i.then=="function"&&i.then(Tw,P$)}catch(s){P$(s)}finally{t!==null&&n.types!==null&&(t.types=n.types),Oi.T=t}};yn.unstable_useCacheRefresh=function(){return Oi.H.useCacheRefresh()};yn.use=function(e){return Oi.H.use(e)};yn.useActionState=function(e,t,n){return Oi.H.useActionState(e,t,n)};yn.useCallback=function(e,t){return Oi.H.useCallback(e,t)};yn.useContext=function(e){return Oi.H.useContext(e)};yn.useDebugValue=function(){};yn.useDeferredValue=function(e,t){return Oi.H.useDeferredValue(e,t)};yn.useEffect=function(e,t){return Oi.H.useEffect(e,t)};yn.useEffectEvent=function(e){return Oi.H.useEffectEvent(e)};yn.useId=function(){return Oi.H.useId()};yn.useImperativeHandle=function(e,t,n){return Oi.H.useImperativeHandle(e,t,n)};yn.useInsertionEffect=function(e,t){return Oi.H.useInsertionEffect(e,t)};yn.useLayoutEffect=function(e,t){return Oi.H.useLayoutEffect(e,t)};yn.useMemo=function(e,t){return Oi.H.useMemo(e,t)};yn.useOptimistic=function(e,t){return Oi.H.useOptimistic(e,t)};yn.useReducer=function(e,t,n){return Oi.H.useReducer(e,t,n)};yn.useRef=function(e){return Oi.H.useRef(e)};yn.useState=function(e){return Oi.H.useState(e)};yn.useSyncExternalStore=function(e,t,n){return Oi.H.useSyncExternalStore(e,t,n)};yn.useTransition=function(){return Oi.H.useTransition()};yn.version="19.2.3";Az.exports=yn;var Ie=Az.exports;const k$=M1(Ie);var Nz={exports:{}},Dg={},Lz={exports:{}},zz={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function t(j,Y){var X=j.length;j.push(Y);e:for(;0<X;){var ce=X-1>>>1,me=j[ce];if(0<r(me,Y))j[ce]=Y,j[X]=me,X=ce;else break e}}function n(j){return j.length===0?null:j[0]}function i(j){if(j.length===0)return null;var Y=j[0],X=j.pop();if(X!==Y){j[0]=X;e:for(var ce=0,me=j.length,Q=me>>>1;ce<Q;){var H=2*(ce+1)-1,B=j[H],ee=H+1,_e=j[ee];if(0>r(B,X))ee<me&&0>r(_e,B)?(j[ce]=_e,j[ee]=X,ce=ee):(j[ce]=B,j[H]=X,ce=H);else if(ee<me&&0>r(_e,X))j[ce]=_e,j[ee]=X,ce=ee;else break e}}return Y}function r(j,Y){var X=j.sortIndex-Y.sortIndex;return X!==0?X:j.id-Y.id}if(e.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var s=performance;e.unstable_now=function(){return s.now()}}else{var a=Date,o=a.now();e.unstable_now=function(){return a.now()-o}}var l=[],u=[],c=1,f=null,d=3,h=!1,m=!1,y=!1,M=!1,g=typeof setTimeout=="function"?setTimeout:null,_=typeof clearTimeout=="function"?clearTimeout:null,T=typeof setImmediate<"u"?setImmediate:null;function x(j){for(var Y=n(u);Y!==null;){if(Y.callback===null)i(u);else if(Y.startTime<=j)i(u),Y.sortIndex=Y.expirationTime,t(l,Y);else break;Y=n(u)}}function S(j){if(y=!1,x(j),!m)if(n(l)!==null)m=!0,$||($=!0,W());else{var Y=n(u);Y!==null&&J(S,Y.startTime-j)}}var $=!1,C=-1,P=5,O=-1;function R(){return M?!0:!(e.unstable_now()-O<P)}function G(){if(M=!1,$){var j=e.unstable_now();O=j;var Y=!0;try{e:{m=!1,y&&(y=!1,_(C),C=-1),h=!0;var X=d;try{t:{for(x(j),f=n(l);f!==null&&!(f.expirationTime>j&&R());){var ce=f.callback;if(typeof ce=="function"){f.callback=null,d=f.priorityLevel;var me=ce(f.expirationTime<=j);if(j=e.unstable_now(),typeof me=="function"){f.callback=me,x(j),Y=!0;break t}f===n(l)&&i(l),x(j)}else i(l);f=n(l)}if(f!==null)Y=!0;else{var Q=n(u);Q!==null&&J(S,Q.startTime-j),Y=!1}}break e}finally{f=null,d=X,h=!1}Y=void 0}}finally{Y?W():$=!1}}}var W;if(typeof T=="function")W=function(){T(G)};else if(typeof MessageChannel<"u"){var V=new MessageChannel,te=V.port2;V.port1.onmessage=G,W=function(){te.postMessage(null)}}else W=function(){g(G,0)};function J(j,Y){C=g(function(){j(e.unstable_now())},Y)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(j){j.callback=null},e.unstable_forceFrameRate=function(j){0>j||125<j?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<j?Math.floor(1e3/j):5},e.unstable_getCurrentPriorityLevel=function(){return d},e.unstable_next=function(j){switch(d){case 1:case 2:case 3:var Y=3;break;default:Y=d}var X=d;d=Y;try{return j()}finally{d=X}},e.unstable_requestPaint=function(){M=!0},e.unstable_runWithPriority=function(j,Y){switch(j){case 1:case 2:case 3:case 4:case 5:break;default:j=3}var X=d;d=j;try{return Y()}finally{d=X}},e.unstable_scheduleCallback=function(j,Y,X){var ce=e.unstable_now();switch(typeof X=="object"&&X!==null?(X=X.delay,X=typeof X=="number"&&0<X?ce+X:ce):X=ce,j){case 1:var me=-1;break;case 2:me=250;break;case 5:me=1073741823;break;case 4:me=1e4;break;default:me=5e3}return me=X+me,j={id:c++,callback:Y,priorityLevel:j,startTime:X,expirationTime:me,sortIndex:-1},X>ce?(j.sortIndex=X,t(u,j),n(l)===null&&j===n(u)&&(y?(_(C),C=-1):y=!0,J(S,X-ce))):(j.sortIndex=me,t(l,j),m||h||(m=!0,$||($=!0,W()))),j},e.unstable_shouldYield=R,e.unstable_wrapCallback=function(j){var Y=d;return function(){var X=d;d=Y;try{return j.apply(this,arguments)}finally{d=X}}}})(zz);Lz.exports=zz;var XH=Lz.exports,Fz={exports:{}},Jr={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var QH=Ie;function Bz(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function cl(){}var qr={d:{f:cl,r:function(){throw Error(Bz(522))},D:cl,C:cl,L:cl,m:cl,X:cl,S:cl,M:cl},p:0,findDOMNode:null},ZH=Symbol.for("react.portal");function eq(e,t,n){var i=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:ZH,key:i==null?null:""+i,children:e,containerInfo:t,implementation:n}}var zf=QH.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function Og(e,t){if(e==="font")return"";if(typeof t=="string")return t==="use-credentials"?t:""}Jr.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=qr;Jr.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11)throw Error(Bz(299));return eq(e,t,null,n)};Jr.flushSync=function(e){var t=zf.T,n=qr.p;try{if(zf.T=null,qr.p=2,e)return e()}finally{zf.T=t,qr.p=n,qr.d.f()}};Jr.preconnect=function(e,t){typeof e=="string"&&(t?(t=t.crossOrigin,t=typeof t=="string"?t==="use-credentials"?t:"":void 0):t=null,qr.d.C(e,t))};Jr.prefetchDNS=function(e){typeof e=="string"&&qr.d.D(e)};Jr.preinit=function(e,t){if(typeof e=="string"&&t&&typeof t.as=="string"){var n=t.as,i=Og(n,t.crossOrigin),r=typeof t.integrity=="string"?t.integrity:void 0,s=typeof t.fetchPriority=="string"?t.fetchPriority:void 0;n==="style"?qr.d.S(e,typeof t.precedence=="string"?t.precedence:void 0,{crossOrigin:i,integrity:r,fetchPriority:s}):n==="script"&&qr.d.X(e,{crossOrigin:i,integrity:r,fetchPriority:s,nonce:typeof t.nonce=="string"?t.nonce:void 0})}};Jr.preinitModule=function(e,t){if(typeof e=="string")if(typeof t=="object"&&t!==null){if(t.as==null||t.as==="script"){var n=Og(t.as,t.crossOrigin);qr.d.M(e,{crossOrigin:n,integrity:typeof t.integrity=="string"?t.integrity:void 0,nonce:typeof t.nonce=="string"?t.nonce:void 0})}}else t==null&&qr.d.M(e)};Jr.preload=function(e,t){if(typeof e=="string"&&typeof t=="object"&&t!==null&&typeof t.as=="string"){var n=t.as,i=Og(n,t.crossOrigin);qr.d.L(e,n,{crossOrigin:i,integrity:typeof t.integrity=="string"?t.integrity:void 0,nonce:typeof t.nonce=="string"?t.nonce:void 0,type:typeof t.type=="string"?t.type:void 0,fetchPriority:typeof t.fetchPriority=="string"?t.fetchPriority:void 0,referrerPolicy:typeof t.referrerPolicy=="string"?t.referrerPolicy:void 0,imageSrcSet:typeof t.imageSrcSet=="string"?t.imageSrcSet:void 0,imageSizes:typeof t.imageSizes=="string"?t.imageSizes:void 0,media:typeof t.media=="string"?t.media:void 0})}};Jr.preloadModule=function(e,t){if(typeof e=="string")if(t){var n=Og(t.as,t.crossOrigin);qr.d.m(e,{as:typeof t.as=="string"&&t.as!=="script"?t.as:void 0,crossOrigin:n,integrity:typeof t.integrity=="string"?t.integrity:void 0})}else qr.d.m(e)};Jr.requestFormReset=function(e){qr.d.r(e)};Jr.unstable_batchedUpdates=function(e,t){return e(t)};Jr.useFormState=function(e,t,n){return zf.H.useFormState(e,t,n)};Jr.useFormStatus=function(){return zf.H.useHostTransitionStatus()};Jr.version="19.2.3";function Uz(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Uz)}catch(e){console.error(e)}}Uz(),Fz.exports=Jr;var tq=Fz.exports;/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var gr=XH,Vz=Ie,nq=tq;function rt(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function Gz(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function Tp(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function jz(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function Wz(e){if(e.tag===31){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function D$(e){if(Tp(e)!==e)throw Error(rt(188))}function iq(e){var t=e.alternate;if(!t){if(t=Tp(e),t===null)throw Error(rt(188));return t!==e?null:e}for(var n=e,i=t;;){var r=n.return;if(r===null)break;var s=r.alternate;if(s===null){if(i=r.return,i!==null){n=i;continue}break}if(r.child===s.child){for(s=r.child;s;){if(s===n)return D$(r),e;if(s===i)return D$(r),t;s=s.sibling}throw Error(rt(188))}if(n.return!==i.return)n=r,i=s;else{for(var a=!1,o=r.child;o;){if(o===n){a=!0,n=r,i=s;break}if(o===i){a=!0,i=r,n=s;break}o=o.sibling}if(!a){for(o=s.child;o;){if(o===n){a=!0,n=s,i=r;break}if(o===i){a=!0,i=s,n=r;break}o=o.sibling}if(!a)throw Error(rt(189))}}if(n.alternate!==i)throw Error(rt(190))}if(n.tag!==3)throw Error(rt(188));return n.stateNode.current===n?e:t}function Hz(e){var t=e.tag;if(t===5||t===26||t===27||t===6)return e;for(e=e.child;e!==null;){if(t=Hz(e),t!==null)return t;e=e.sibling}return null}var Ri=Object.assign,rq=Symbol.for("react.element"),oh=Symbol.for("react.transitional.element"),Mf=Symbol.for("react.portal"),Uc=Symbol.for("react.fragment"),qz=Symbol.for("react.strict_mode"),Mw=Symbol.for("react.profiler"),Kz=Symbol.for("react.consumer"),Co=Symbol.for("react.context"),I1=Symbol.for("react.forward_ref"),Ew=Symbol.for("react.suspense"),Sw=Symbol.for("react.suspense_list"),P1=Symbol.for("react.memo"),yl=Symbol.for("react.lazy"),Cw=Symbol.for("react.activity"),sq=Symbol.for("react.memo_cache_sentinel"),O$=Symbol.iterator;function Wd(e){return e===null||typeof e!="object"?null:(e=O$&&e[O$]||e["@@iterator"],typeof e=="function"?e:null)}var aq=Symbol.for("react.client.reference");function $w(e){if(e==null)return null;if(typeof e=="function")return e.$$typeof===aq?null:e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case Uc:return"Fragment";case Mw:return"Profiler";case qz:return"StrictMode";case Ew:return"Suspense";case Sw:return"SuspenseList";case Cw:return"Activity"}if(typeof e=="object")switch(e.$$typeof){case Mf:return"Portal";case Co:return e.displayName||"Context";case Kz:return(e._context.displayName||"Context")+".Consumer";case I1:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case P1:return t=e.displayName||null,t!==null?t:$w(e.type)||"Memo";case yl:t=e._payload,e=e._init;try{return $w(e(t))}catch{}}return null}var Ef=Array.isArray,on=Vz.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,ai=nq.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,zu={pending:!1,data:null,method:null,action:null},Aw=[],Vc=-1;function eo(e){return{current:e}}function Er(e){0>Vc||(e.current=Aw[Vc],Aw[Vc]=null,Vc--)}function Ai(e,t){Vc++,Aw[Vc]=e.current,e.current=t}var Qa=eo(null),tp=eo(null),Al=eo(null),Im=eo(null);function Pm(e,t){switch(Ai(Al,t),Ai(tp,e),Ai(Qa,null),t.nodeType){case 9:case 11:e=(e=t.documentElement)&&(e=e.namespaceURI)?BA(e):0;break;default:if(e=t.tagName,t=t.namespaceURI)t=BA(t),e=h4(t,e);else switch(e){case"svg":e=1;break;case"math":e=2;break;default:e=0}}Er(Qa),Ai(Qa,e)}function hd(){Er(Qa),Er(tp),Er(Al)}function Iw(e){e.memoizedState!==null&&Ai(Im,e);var t=Qa.current,n=h4(t,e.type);t!==n&&(Ai(tp,e),Ai(Qa,n))}function km(e){tp.current===e&&(Er(Qa),Er(tp)),Im.current===e&&(Er(Im),fp._currentValue=zu)}var Oy,R$;function Mu(e){if(Oy===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);Oy=t&&t[1]||"",R$=-1<n.stack.indexOf(`
    at`)?" (<anonymous>)":-1<n.stack.indexOf("@")?"@unknown:0:0":""}return`
`+Oy+e+R$}var Ry=!1;function Ny(e,t){if(!e||Ry)return"";Ry=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var i={DetermineComponentFrameRoot:function(){try{if(t){var f=function(){throw Error()};if(Object.defineProperty(f.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(f,[])}catch(h){var d=h}Reflect.construct(e,[],f)}else{try{f.call()}catch(h){d=h}e.call(f.prototype)}}else{try{throw Error()}catch(h){d=h}(f=e())&&typeof f.catch=="function"&&f.catch(function(){})}}catch(h){if(h&&d&&typeof h.stack=="string")return[h.stack,d.stack]}return[null,null]}};i.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var r=Object.getOwnPropertyDescriptor(i.DetermineComponentFrameRoot,"name");r&&r.configurable&&Object.defineProperty(i.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var s=i.DetermineComponentFrameRoot(),a=s[0],o=s[1];if(a&&o){var l=a.split(`
`),u=o.split(`
`);for(r=i=0;i<l.length&&!l[i].includes("DetermineComponentFrameRoot");)i++;for(;r<u.length&&!u[r].includes("DetermineComponentFrameRoot");)r++;if(i===l.length||r===u.length)for(i=l.length-1,r=u.length-1;1<=i&&0<=r&&l[i]!==u[r];)r--;for(;1<=i&&0<=r;i--,r--)if(l[i]!==u[r]){if(i!==1||r!==1)do if(i--,r--,0>r||l[i]!==u[r]){var c=`
`+l[i].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}while(1<=i&&0<=r);break}}}finally{Ry=!1,Error.prepareStackTrace=n}return(n=e?e.displayName||e.name:"")?Mu(n):""}function oq(e,t){switch(e.tag){case 26:case 27:case 5:return Mu(e.type);case 16:return Mu("Lazy");case 13:return e.child!==t&&t!==null?Mu("Suspense Fallback"):Mu("Suspense");case 19:return Mu("SuspenseList");case 0:case 15:return Ny(e.type,!1);case 11:return Ny(e.type.render,!1);case 1:return Ny(e.type,!0);case 31:return Mu("Activity");default:return""}}function N$(e){try{var t="",n=null;do t+=oq(e,n),n=e,e=e.return;while(e);return t}catch(i){return`
Error generating stack: `+i.message+`
`+i.stack}}var Pw=Object.prototype.hasOwnProperty,k1=gr.unstable_scheduleCallback,Ly=gr.unstable_cancelCallback,lq=gr.unstable_shouldYield,uq=gr.unstable_requestPaint,ws=gr.unstable_now,cq=gr.unstable_getCurrentPriorityLevel,Jz=gr.unstable_ImmediatePriority,Yz=gr.unstable_UserBlockingPriority,Dm=gr.unstable_NormalPriority,dq=gr.unstable_LowPriority,Xz=gr.unstable_IdlePriority,fq=gr.log,pq=gr.unstable_setDisableYieldValue,Mp=null,bs=null;function Ml(e){if(typeof fq=="function"&&pq(e),bs&&typeof bs.setStrictMode=="function")try{bs.setStrictMode(Mp,e)}catch{}}var xs=Math.clz32?Math.clz32:gq,hq=Math.log,mq=Math.LN2;function gq(e){return e>>>=0,e===0?32:31-(hq(e)/mq|0)|0}var lh=256,uh=262144,ch=4194304;function Eu(e){var t=e&42;if(t!==0)return t;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return e&261888;case 262144:case 524288:case 1048576:case 2097152:return e&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return e&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function Rg(e,t,n){var i=e.pendingLanes;if(i===0)return 0;var r=0,s=e.suspendedLanes,a=e.pingedLanes;e=e.warmLanes;var o=i&134217727;return o!==0?(i=o&~s,i!==0?r=Eu(i):(a&=o,a!==0?r=Eu(a):n||(n=o&~e,n!==0&&(r=Eu(n))))):(o=i&~s,o!==0?r=Eu(o):a!==0?r=Eu(a):n||(n=i&~e,n!==0&&(r=Eu(n)))),r===0?0:t!==0&&t!==r&&!(t&s)&&(s=r&-r,n=t&-t,s>=n||s===32&&(n&4194048)!==0)?t:r}function Ep(e,t){return(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&t)===0}function _q(e,t){switch(e){case 1:case 2:case 4:case 8:case 64:return t+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Qz(){var e=ch;return ch<<=1,!(ch&62914560)&&(ch=4194304),e}function zy(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Sp(e,t){e.pendingLanes|=t,t!==268435456&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function yq(e,t,n,i,r,s){var a=e.pendingLanes;e.pendingLanes=n,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=n,e.entangledLanes&=n,e.errorRecoveryDisabledLanes&=n,e.shellSuspendCounter=0;var o=e.entanglements,l=e.expirationTimes,u=e.hiddenUpdates;for(n=a&~n;0<n;){var c=31-xs(n),f=1<<c;o[c]=0,l[c]=-1;var d=u[c];if(d!==null)for(u[c]=null,c=0;c<d.length;c++){var h=d[c];h!==null&&(h.lane&=-536870913)}n&=~f}i!==0&&Zz(e,i,0),s!==0&&r===0&&e.tag!==0&&(e.suspendedLanes|=s&~(a&~t))}function Zz(e,t,n){e.pendingLanes|=t,e.suspendedLanes&=~t;var i=31-xs(t);e.entangledLanes|=t,e.entanglements[i]=e.entanglements[i]|1073741824|n&261930}function eF(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var i=31-xs(n),r=1<<i;r&t|e[i]&t&&(e[i]|=t),n&=~r}}function tF(e,t){var n=t&-t;return n=n&42?1:D1(n),n&(e.suspendedLanes|t)?0:n}function D1(e){switch(e){case 2:e=1;break;case 8:e=4;break;case 32:e=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:e=128;break;case 268435456:e=134217728;break;default:e=0}return e}function O1(e){return e&=-e,2<e?8<e?e&134217727?32:268435456:8:2}function nF(){var e=ai.p;return e!==0?e:(e=window.event,e===void 0?32:E4(e.type))}function L$(e,t){var n=ai.p;try{return ai.p=e,t()}finally{ai.p=n}}var Hl=Math.random().toString(36).slice(2),Pr="__reactFiber$"+Hl,ss="__reactProps$"+Hl,Pd="__reactContainer$"+Hl,kw="__reactEvents$"+Hl,vq="__reactListeners$"+Hl,wq="__reactHandles$"+Hl,z$="__reactResources$"+Hl,Cp="__reactMarker$"+Hl;function R1(e){delete e[Pr],delete e[ss],delete e[kw],delete e[vq],delete e[wq]}function Gc(e){var t=e[Pr];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Pd]||n[Pr]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=WA(e);e!==null;){if(n=e[Pr])return n;e=WA(e)}return t}e=n,n=e.parentNode}return null}function kd(e){if(e=e[Pr]||e[Pd]){var t=e.tag;if(t===5||t===6||t===13||t===31||t===26||t===27||t===3)return e}return null}function Sf(e){var t=e.tag;if(t===5||t===26||t===27||t===6)return e.stateNode;throw Error(rt(33))}function sd(e){var t=e[z$];return t||(t=e[z$]={hoistableStyles:new Map,hoistableScripts:new Map}),t}function Mr(e){e[Cp]=!0}var iF=new Set,rF={};function rc(e,t){md(e,t),md(e+"Capture",t)}function md(e,t){for(rF[e]=t,e=0;e<t.length;e++)iF.add(t[e])}var bq=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),F$={},B$={};function xq(e){return Pw.call(B$,e)?!0:Pw.call(F$,e)?!1:bq.test(e)?B$[e]=!0:(F$[e]=!0,!1)}function sm(e,t,n){if(xq(t))if(n===null)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":e.removeAttribute(t);return;case"boolean":var i=t.toLowerCase().slice(0,5);if(i!=="data-"&&i!=="aria-"){e.removeAttribute(t);return}}e.setAttribute(t,""+n)}}function dh(e,t,n){if(n===null)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":case"boolean":e.removeAttribute(t);return}e.setAttribute(t,""+n)}}function mo(e,t,n,i){if(i===null)e.removeAttribute(n);else{switch(typeof i){case"undefined":case"function":case"symbol":case"boolean":e.removeAttribute(n);return}e.setAttributeNS(t,n,""+i)}}function Vs(e){switch(typeof e){case"bigint":case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function sF(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function Tq(e,t,n){var i=Object.getOwnPropertyDescriptor(e.constructor.prototype,t);if(!e.hasOwnProperty(t)&&typeof i<"u"&&typeof i.get=="function"&&typeof i.set=="function"){var r=i.get,s=i.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return r.call(this)},set:function(a){n=""+a,s.call(this,a)}}),Object.defineProperty(e,t,{enumerable:i.enumerable}),{getValue:function(){return n},setValue:function(a){n=""+a},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function Dw(e){if(!e._valueTracker){var t=sF(e)?"checked":"value";e._valueTracker=Tq(e,t,""+e[t])}}function aF(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),i="";return e&&(i=sF(e)?e.checked?"true":"false":e.value),e=i,e!==n?(t.setValue(e),!0):!1}function Om(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}var Mq=/[\n"\\]/g;function Ws(e){return e.replace(Mq,function(t){return"\\"+t.charCodeAt(0).toString(16)+" "})}function Ow(e,t,n,i,r,s,a,o){e.name="",a!=null&&typeof a!="function"&&typeof a!="symbol"&&typeof a!="boolean"?e.type=a:e.removeAttribute("type"),t!=null?a==="number"?(t===0&&e.value===""||e.value!=t)&&(e.value=""+Vs(t)):e.value!==""+Vs(t)&&(e.value=""+Vs(t)):a!=="submit"&&a!=="reset"||e.removeAttribute("value"),t!=null?Rw(e,a,Vs(t)):n!=null?Rw(e,a,Vs(n)):i!=null&&e.removeAttribute("value"),r==null&&s!=null&&(e.defaultChecked=!!s),r!=null&&(e.checked=r&&typeof r!="function"&&typeof r!="symbol"),o!=null&&typeof o!="function"&&typeof o!="symbol"&&typeof o!="boolean"?e.name=""+Vs(o):e.removeAttribute("name")}function oF(e,t,n,i,r,s,a,o){if(s!=null&&typeof s!="function"&&typeof s!="symbol"&&typeof s!="boolean"&&(e.type=s),t!=null||n!=null){if(!(s!=="submit"&&s!=="reset"||t!=null)){Dw(e);return}n=n!=null?""+Vs(n):"",t=t!=null?""+Vs(t):n,o||t===e.value||(e.value=t),e.defaultValue=t}i=i??r,i=typeof i!="function"&&typeof i!="symbol"&&!!i,e.checked=o?e.checked:!!i,e.defaultChecked=!!i,a!=null&&typeof a!="function"&&typeof a!="symbol"&&typeof a!="boolean"&&(e.name=a),Dw(e)}function Rw(e,t,n){t==="number"&&Om(e.ownerDocument)===e||e.defaultValue===""+n||(e.defaultValue=""+n)}function ad(e,t,n,i){if(e=e.options,t){t={};for(var r=0;r<n.length;r++)t["$"+n[r]]=!0;for(n=0;n<e.length;n++)r=t.hasOwnProperty("$"+e[n].value),e[n].selected!==r&&(e[n].selected=r),r&&i&&(e[n].defaultSelected=!0)}else{for(n=""+Vs(n),t=null,r=0;r<e.length;r++){if(e[r].value===n){e[r].selected=!0,i&&(e[r].defaultSelected=!0);return}t!==null||e[r].disabled||(t=e[r])}t!==null&&(t.selected=!0)}}function lF(e,t,n){if(t!=null&&(t=""+Vs(t),t!==e.value&&(e.value=t),n==null)){e.defaultValue!==t&&(e.defaultValue=t);return}e.defaultValue=n!=null?""+Vs(n):""}function uF(e,t,n,i){if(t==null){if(i!=null){if(n!=null)throw Error(rt(92));if(Ef(i)){if(1<i.length)throw Error(rt(93));i=i[0]}n=i}n==null&&(n=""),t=n}n=Vs(t),e.defaultValue=n,i=e.textContent,i===n&&i!==""&&i!==null&&(e.value=i),Dw(e)}function gd(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var Eq=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function U$(e,t,n){var i=t.indexOf("--")===0;n==null||typeof n=="boolean"||n===""?i?e.setProperty(t,""):t==="float"?e.cssFloat="":e[t]="":i?e.setProperty(t,n):typeof n!="number"||n===0||Eq.has(t)?t==="float"?e.cssFloat=n:e[t]=(""+n).trim():e[t]=n+"px"}function cF(e,t,n){if(t!=null&&typeof t!="object")throw Error(rt(62));if(e=e.style,n!=null){for(var i in n)!n.hasOwnProperty(i)||t!=null&&t.hasOwnProperty(i)||(i.indexOf("--")===0?e.setProperty(i,""):i==="float"?e.cssFloat="":e[i]="");for(var r in t)i=t[r],t.hasOwnProperty(r)&&n[r]!==i&&U$(e,r,i)}else for(var s in t)t.hasOwnProperty(s)&&U$(e,s,t[s])}function N1(e){if(e.indexOf("-")===-1)return!1;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Sq=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Cq=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function am(e){return Cq.test(""+e)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":e}function $o(){}var Nw=null;function L1(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var jc=null,od=null;function V$(e){var t=kd(e);if(t&&(e=t.stateNode)){var n=e[ss]||null;e:switch(e=t.stateNode,t.type){case"input":if(Ow(e,n.value,n.defaultValue,n.defaultValue,n.checked,n.defaultChecked,n.type,n.name),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll('input[name="'+Ws(""+t)+'"][type="radio"]'),t=0;t<n.length;t++){var i=n[t];if(i!==e&&i.form===e.form){var r=i[ss]||null;if(!r)throw Error(rt(90));Ow(i,r.value,r.defaultValue,r.defaultValue,r.checked,r.defaultChecked,r.type,r.name)}}for(t=0;t<n.length;t++)i=n[t],i.form===e.form&&aF(i)}break e;case"textarea":lF(e,n.value,n.defaultValue);break e;case"select":t=n.value,t!=null&&ad(e,!!n.multiple,t,!1)}}}var Fy=!1;function dF(e,t,n){if(Fy)return e(t,n);Fy=!0;try{var i=e(t);return i}finally{if(Fy=!1,(jc!==null||od!==null)&&(qg(),jc&&(t=jc,e=od,od=jc=null,V$(t),e)))for(t=0;t<e.length;t++)V$(e[t])}}function np(e,t){var n=e.stateNode;if(n===null)return null;var i=n[ss]||null;if(i===null)return null;n=i[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(i=!i.disabled)||(e=e.type,i=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!i;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(rt(231,t,typeof n));return n}var Do=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Lw=!1;if(Do)try{var Hd={};Object.defineProperty(Hd,"passive",{get:function(){Lw=!0}}),window.addEventListener("test",Hd,Hd),window.removeEventListener("test",Hd,Hd)}catch{Lw=!1}var El=null,z1=null,om=null;function fF(){if(om)return om;var e,t=z1,n=t.length,i,r="value"in El?El.value:El.textContent,s=r.length;for(e=0;e<n&&t[e]===r[e];e++);var a=n-e;for(i=1;i<=a&&t[n-i]===r[s-i];i++);return om=r.slice(e,1<i?1-i:void 0)}function lm(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function fh(){return!0}function G$(){return!1}function as(e){function t(n,i,r,s,a){this._reactName=n,this._targetInst=r,this.type=i,this.nativeEvent=s,this.target=a,this.currentTarget=null;for(var o in e)e.hasOwnProperty(o)&&(n=e[o],this[o]=n?n(s):s[o]);return this.isDefaultPrevented=(s.defaultPrevented!=null?s.defaultPrevented:s.returnValue===!1)?fh:G$,this.isPropagationStopped=G$,this}return Ri(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=fh)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=fh)},persist:function(){},isPersistent:fh}),t}var sc={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Ng=as(sc),$p=Ri({},sc,{view:0,detail:0}),$q=as($p),By,Uy,qd,Lg=Ri({},$p,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:F1,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==qd&&(qd&&e.type==="mousemove"?(By=e.screenX-qd.screenX,Uy=e.screenY-qd.screenY):Uy=By=0,qd=e),By)},movementY:function(e){return"movementY"in e?e.movementY:Uy}}),j$=as(Lg),Aq=Ri({},Lg,{dataTransfer:0}),Iq=as(Aq),Pq=Ri({},$p,{relatedTarget:0}),Vy=as(Pq),kq=Ri({},sc,{animationName:0,elapsedTime:0,pseudoElement:0}),Dq=as(kq),Oq=Ri({},sc,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),Rq=as(Oq),Nq=Ri({},sc,{data:0}),W$=as(Nq),Lq={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},zq={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Fq={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Bq(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=Fq[e])?!!t[e]:!1}function F1(){return Bq}var Uq=Ri({},$p,{key:function(e){if(e.key){var t=Lq[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=lm(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?zq[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:F1,charCode:function(e){return e.type==="keypress"?lm(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?lm(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),Vq=as(Uq),Gq=Ri({},Lg,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),H$=as(Gq),jq=Ri({},$p,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:F1}),Wq=as(jq),Hq=Ri({},sc,{propertyName:0,elapsedTime:0,pseudoElement:0}),qq=as(Hq),Kq=Ri({},Lg,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Jq=as(Kq),Yq=Ri({},sc,{newState:0,oldState:0}),Xq=as(Yq),Qq=[9,13,27,32],B1=Do&&"CompositionEvent"in window,Ff=null;Do&&"documentMode"in document&&(Ff=document.documentMode);var Zq=Do&&"TextEvent"in window&&!Ff,pF=Do&&(!B1||Ff&&8<Ff&&11>=Ff),q$=" ",K$=!1;function hF(e,t){switch(e){case"keyup":return Qq.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function mF(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var Wc=!1;function eK(e,t){switch(e){case"compositionend":return mF(t);case"keypress":return t.which!==32?null:(K$=!0,q$);case"textInput":return e=t.data,e===q$&&K$?null:e;default:return null}}function tK(e,t){if(Wc)return e==="compositionend"||!B1&&hF(e,t)?(e=fF(),om=z1=El=null,Wc=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return pF&&t.locale!=="ko"?null:t.data;default:return null}}var nK={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function J$(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!nK[e.type]:t==="textarea"}function gF(e,t,n,i){jc?od?od.push(i):od=[i]:jc=i,t=Qm(t,"onChange"),0<t.length&&(n=new Ng("onChange","change",null,n,i),e.push({event:n,listeners:t}))}var Bf=null,ip=null;function iK(e){d4(e,0)}function zg(e){var t=Sf(e);if(aF(t))return e}function Y$(e,t){if(e==="change")return t}var _F=!1;if(Do){var Gy;if(Do){var jy="oninput"in document;if(!jy){var X$=document.createElement("div");X$.setAttribute("oninput","return;"),jy=typeof X$.oninput=="function"}Gy=jy}else Gy=!1;_F=Gy&&(!document.documentMode||9<document.documentMode)}function Q$(){Bf&&(Bf.detachEvent("onpropertychange",yF),ip=Bf=null)}function yF(e){if(e.propertyName==="value"&&zg(ip)){var t=[];gF(t,ip,e,L1(e)),dF(iK,t)}}function rK(e,t,n){e==="focusin"?(Q$(),Bf=t,ip=n,Bf.attachEvent("onpropertychange",yF)):e==="focusout"&&Q$()}function sK(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return zg(ip)}function aK(e,t){if(e==="click")return zg(t)}function oK(e,t){if(e==="input"||e==="change")return zg(t)}function lK(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var Ss=typeof Object.is=="function"?Object.is:lK;function rp(e,t){if(Ss(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),i=Object.keys(t);if(n.length!==i.length)return!1;for(i=0;i<n.length;i++){var r=n[i];if(!Pw.call(t,r)||!Ss(e[r],t[r]))return!1}return!0}function Z$(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function eA(e,t){var n=Z$(e);e=0;for(var i;n;){if(n.nodeType===3){if(i=e+n.textContent.length,e<=t&&i>=t)return{node:n,offset:t-e};e=i}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=Z$(n)}}function vF(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?vF(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function wF(e){e=e!=null&&e.ownerDocument!=null&&e.ownerDocument.defaultView!=null?e.ownerDocument.defaultView:window;for(var t=Om(e.document);t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=Om(e.document)}return t}function U1(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}var uK=Do&&"documentMode"in document&&11>=document.documentMode,Hc=null,zw=null,Uf=null,Fw=!1;function tA(e,t,n){var i=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;Fw||Hc==null||Hc!==Om(i)||(i=Hc,"selectionStart"in i&&U1(i)?i={start:i.selectionStart,end:i.selectionEnd}:(i=(i.ownerDocument&&i.ownerDocument.defaultView||window).getSelection(),i={anchorNode:i.anchorNode,anchorOffset:i.anchorOffset,focusNode:i.focusNode,focusOffset:i.focusOffset}),Uf&&rp(Uf,i)||(Uf=i,i=Qm(zw,"onSelect"),0<i.length&&(t=new Ng("onSelect","select",null,t,n),e.push({event:t,listeners:i}),t.target=Hc)))}function mu(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var qc={animationend:mu("Animation","AnimationEnd"),animationiteration:mu("Animation","AnimationIteration"),animationstart:mu("Animation","AnimationStart"),transitionrun:mu("Transition","TransitionRun"),transitionstart:mu("Transition","TransitionStart"),transitioncancel:mu("Transition","TransitionCancel"),transitionend:mu("Transition","TransitionEnd")},Wy={},bF={};Do&&(bF=document.createElement("div").style,"AnimationEvent"in window||(delete qc.animationend.animation,delete qc.animationiteration.animation,delete qc.animationstart.animation),"TransitionEvent"in window||delete qc.transitionend.transition);function ac(e){if(Wy[e])return Wy[e];if(!qc[e])return e;var t=qc[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in bF)return Wy[e]=t[n];return e}var xF=ac("animationend"),TF=ac("animationiteration"),MF=ac("animationstart"),cK=ac("transitionrun"),dK=ac("transitionstart"),fK=ac("transitioncancel"),EF=ac("transitionend"),SF=new Map,Bw="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Bw.push("scrollEnd");function ka(e,t){SF.set(e,t),rc(t,[e])}var Rm=typeof reportError=="function"?reportError:function(e){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof e=="object"&&e!==null&&typeof e.message=="string"?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",e);return}console.error(e)},Bs=[],Kc=0,V1=0;function Fg(){for(var e=Kc,t=V1=Kc=0;t<e;){var n=Bs[t];Bs[t++]=null;var i=Bs[t];Bs[t++]=null;var r=Bs[t];Bs[t++]=null;var s=Bs[t];if(Bs[t++]=null,i!==null&&r!==null){var a=i.pending;a===null?r.next=r:(r.next=a.next,a.next=r),i.pending=r}s!==0&&CF(n,r,s)}}function Bg(e,t,n,i){Bs[Kc++]=e,Bs[Kc++]=t,Bs[Kc++]=n,Bs[Kc++]=i,V1|=i,e.lanes|=i,e=e.alternate,e!==null&&(e.lanes|=i)}function G1(e,t,n,i){return Bg(e,t,n,i),Nm(e)}function oc(e,t){return Bg(e,null,null,t),Nm(e)}function CF(e,t,n){e.lanes|=n;var i=e.alternate;i!==null&&(i.lanes|=n);for(var r=!1,s=e.return;s!==null;)s.childLanes|=n,i=s.alternate,i!==null&&(i.childLanes|=n),s.tag===22&&(e=s.stateNode,e===null||e._visibility&1||(r=!0)),e=s,s=s.return;return e.tag===3?(s=e.stateNode,r&&t!==null&&(r=31-xs(n),e=s.hiddenUpdates,i=e[r],i===null?e[r]=[t]:i.push(t),t.lane=n|536870912),s):null}function Nm(e){if(50<Yf)throw Yf=0,ob=null,Error(rt(185));for(var t=e.return;t!==null;)e=t,t=e.return;return e.tag===3?e.stateNode:null}var Jc={};function pK(e,t,n,i){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=i,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ys(e,t,n,i){return new pK(e,t,n,i)}function j1(e){return e=e.prototype,!(!e||!e.isReactComponent)}function Io(e,t){var n=e.alternate;return n===null?(n=ys(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&65011712,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n.refCleanup=e.refCleanup,n}function $F(e,t){e.flags&=65011714;var n=e.alternate;return n===null?(e.childLanes=0,e.lanes=t,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=n.childLanes,e.lanes=n.lanes,e.child=n.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=n.memoizedProps,e.memoizedState=n.memoizedState,e.updateQueue=n.updateQueue,e.type=n.type,t=n.dependencies,e.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext}),e}function um(e,t,n,i,r,s){var a=0;if(i=e,typeof e=="function")j1(e)&&(a=1);else if(typeof e=="string")a=y9(e,n,Qa.current)?26:e==="html"||e==="head"||e==="body"?27:5;else e:switch(e){case Cw:return e=ys(31,n,t,r),e.elementType=Cw,e.lanes=s,e;case Uc:return Fu(n.children,r,s,t);case qz:a=8,r|=24;break;case Mw:return e=ys(12,n,t,r|2),e.elementType=Mw,e.lanes=s,e;case Ew:return e=ys(13,n,t,r),e.elementType=Ew,e.lanes=s,e;case Sw:return e=ys(19,n,t,r),e.elementType=Sw,e.lanes=s,e;default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case Co:a=10;break e;case Kz:a=9;break e;case I1:a=11;break e;case P1:a=14;break e;case yl:a=16,i=null;break e}a=29,n=Error(rt(130,e===null?"null":typeof e,"")),i=null}return t=ys(a,n,t,r),t.elementType=e,t.type=i,t.lanes=s,t}function Fu(e,t,n,i){return e=ys(7,e,i,t),e.lanes=n,e}function Hy(e,t,n){return e=ys(6,e,null,t),e.lanes=n,e}function AF(e){var t=ys(18,null,null,0);return t.stateNode=e,t}function qy(e,t,n){return t=ys(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}var nA=new WeakMap;function Hs(e,t){if(typeof e=="object"&&e!==null){var n=nA.get(e);return n!==void 0?n:(t={value:e,source:t,stack:N$(t)},nA.set(e,t),t)}return{value:e,source:t,stack:N$(t)}}var Yc=[],Xc=0,Lm=null,sp=0,Gs=[],js=0,Bl=null,Ka=1,Ja="";function To(e,t){Yc[Xc++]=sp,Yc[Xc++]=Lm,Lm=e,sp=t}function IF(e,t,n){Gs[js++]=Ka,Gs[js++]=Ja,Gs[js++]=Bl,Bl=e;var i=Ka;e=Ja;var r=32-xs(i)-1;i&=~(1<<r),n+=1;var s=32-xs(t)+r;if(30<s){var a=r-r%5;s=(i&(1<<a)-1).toString(32),i>>=a,r-=a,Ka=1<<32-xs(t)+r|n<<r|i,Ja=s+e}else Ka=1<<s|n<<r|i,Ja=e}function W1(e){e.return!==null&&(To(e,1),IF(e,1,0))}function H1(e){for(;e===Lm;)Lm=Yc[--Xc],Yc[Xc]=null,sp=Yc[--Xc],Yc[Xc]=null;for(;e===Bl;)Bl=Gs[--js],Gs[js]=null,Ja=Gs[--js],Gs[js]=null,Ka=Gs[--js],Gs[js]=null}function PF(e,t){Gs[js++]=Ka,Gs[js++]=Ja,Gs[js++]=Bl,Ka=t.id,Ja=t.overflow,Bl=e}var kr=null,Di=null,jn=!1,Il=null,qs=!1,Uw=Error(rt(519));function Ul(e){var t=Error(rt(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw ap(Hs(t,e)),Uw}function iA(e){var t=e.stateNode,n=e.type,i=e.memoizedProps;switch(t[Pr]=e,t[ss]=i,n){case"dialog":On("cancel",t),On("close",t);break;case"iframe":case"object":case"embed":On("load",t);break;case"video":case"audio":for(n=0;n<cp.length;n++)On(cp[n],t);break;case"source":On("error",t);break;case"img":case"image":case"link":On("error",t),On("load",t);break;case"details":On("toggle",t);break;case"input":On("invalid",t),oF(t,i.value,i.defaultValue,i.checked,i.defaultChecked,i.type,i.name,!0);break;case"select":On("invalid",t);break;case"textarea":On("invalid",t),uF(t,i.value,i.defaultValue,i.children)}n=i.children,typeof n!="string"&&typeof n!="number"&&typeof n!="bigint"||t.textContent===""+n||i.suppressHydrationWarning===!0||p4(t.textContent,n)?(i.popover!=null&&(On("beforetoggle",t),On("toggle",t)),i.onScroll!=null&&On("scroll",t),i.onScrollEnd!=null&&On("scrollend",t),i.onClick!=null&&(t.onclick=$o),t=!0):t=!1,t||Ul(e,!0)}function rA(e){for(kr=e.return;kr;)switch(kr.tag){case 5:case 31:case 13:qs=!1;return;case 27:case 3:qs=!0;return;default:kr=kr.return}}function Sc(e){if(e!==kr)return!1;if(!jn)return rA(e),jn=!0,!1;var t=e.tag,n;if((n=t!==3&&t!==27)&&((n=t===5)&&(n=e.type,n=!(n!=="form"&&n!=="button")||fb(e.type,e.memoizedProps)),n=!n),n&&Di&&Ul(e),rA(e),t===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(rt(317));Di=jA(e)}else if(t===31){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(rt(317));Di=jA(e)}else t===27?(t=Di,ql(e.type)?(e=gb,gb=null,Di=e):Di=t):Di=kr?Ys(e.stateNode.nextSibling):null;return!0}function Hu(){Di=kr=null,jn=!1}function Ky(){var e=Il;return e!==null&&(is===null?is=e:is.push.apply(is,e),Il=null),e}function ap(e){Il===null?Il=[e]:Il.push(e)}var Vw=eo(null),lc=null,Ao=null;function wl(e,t,n){Ai(Vw,t._currentValue),t._currentValue=n}function Po(e){e._currentValue=Vw.current,Er(Vw)}function Gw(e,t,n){for(;e!==null;){var i=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,i!==null&&(i.childLanes|=t)):i!==null&&(i.childLanes&t)!==t&&(i.childLanes|=t),e===n)break;e=e.return}}function jw(e,t,n,i){var r=e.child;for(r!==null&&(r.return=e);r!==null;){var s=r.dependencies;if(s!==null){var a=r.child;s=s.firstContext;e:for(;s!==null;){var o=s;s=r;for(var l=0;l<t.length;l++)if(o.context===t[l]){s.lanes|=n,o=s.alternate,o!==null&&(o.lanes|=n),Gw(s.return,n,e),i||(a=null);break e}s=o.next}}else if(r.tag===18){if(a=r.return,a===null)throw Error(rt(341));a.lanes|=n,s=a.alternate,s!==null&&(s.lanes|=n),Gw(a,n,e),a=null}else a=r.child;if(a!==null)a.return=r;else for(a=r;a!==null;){if(a===e){a=null;break}if(r=a.sibling,r!==null){r.return=a.return,a=r;break}a=a.return}r=a}}function Dd(e,t,n,i){e=null;for(var r=t,s=!1;r!==null;){if(!s){if(r.flags&524288)s=!0;else if(r.flags&262144)break}if(r.tag===10){var a=r.alternate;if(a===null)throw Error(rt(387));if(a=a.memoizedProps,a!==null){var o=r.type;Ss(r.pendingProps.value,a.value)||(e!==null?e.push(o):e=[o])}}else if(r===Im.current){if(a=r.alternate,a===null)throw Error(rt(387));a.memoizedState.memoizedState!==r.memoizedState.memoizedState&&(e!==null?e.push(fp):e=[fp])}r=r.return}e!==null&&jw(t,e,n,i),t.flags|=262144}function zm(e){for(e=e.firstContext;e!==null;){if(!Ss(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function qu(e){lc=e,Ao=null,e=e.dependencies,e!==null&&(e.firstContext=null)}function Dr(e){return kF(lc,e)}function ph(e,t){return lc===null&&qu(e),kF(e,t)}function kF(e,t){var n=t._currentValue;if(t={context:t,memoizedValue:n,next:null},Ao===null){if(e===null)throw Error(rt(308));Ao=t,e.dependencies={lanes:0,firstContext:t},e.flags|=524288}else Ao=Ao.next=t;return n}var hK=typeof AbortController<"u"?AbortController:function(){var e=[],t=this.signal={aborted:!1,addEventListener:function(n,i){e.push(i)}};this.abort=function(){t.aborted=!0,e.forEach(function(n){return n()})}},mK=gr.unstable_scheduleCallback,gK=gr.unstable_NormalPriority,ur={$$typeof:Co,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function q1(){return{controller:new hK,data:new Map,refCount:0}}function Ap(e){e.refCount--,e.refCount===0&&mK(gK,function(){e.controller.abort()})}var Vf=null,Ww=0,_d=0,ld=null;function _K(e,t){if(Vf===null){var n=Vf=[];Ww=0,_d=yx(),ld={status:"pending",value:void 0,then:function(i){n.push(i)}}}return Ww++,t.then(sA,sA),t}function sA(){if(--Ww===0&&Vf!==null){ld!==null&&(ld.status="fulfilled");var e=Vf;Vf=null,_d=0,ld=null;for(var t=0;t<e.length;t++)(0,e[t])()}}function yK(e,t){var n=[],i={status:"pending",value:null,reason:null,then:function(r){n.push(r)}};return e.then(function(){i.status="fulfilled",i.value=t;for(var r=0;r<n.length;r++)(0,n[r])(t)},function(r){for(i.status="rejected",i.reason=r,r=0;r<n.length;r++)(0,n[r])(void 0)}),i}var aA=on.S;on.S=function(e,t){HB=ws(),typeof t=="object"&&t!==null&&typeof t.then=="function"&&_K(e,t),aA!==null&&aA(e,t)};var Bu=eo(null);function K1(){var e=Bu.current;return e!==null?e:xi.pooledCache}function cm(e,t){t===null?Ai(Bu,Bu.current):Ai(Bu,t.pool)}function DF(){var e=K1();return e===null?null:{parent:ur._currentValue,pool:e}}var Od=Error(rt(460)),J1=Error(rt(474)),Ug=Error(rt(542)),Fm={then:function(){}};function oA(e){return e=e.status,e==="fulfilled"||e==="rejected"}function OF(e,t,n){switch(n=e[n],n===void 0?e.push(t):n!==t&&(t.then($o,$o),t=n),t.status){case"fulfilled":return t.value;case"rejected":throw e=t.reason,uA(e),e;default:if(typeof t.status=="string")t.then($o,$o);else{if(e=xi,e!==null&&100<e.shellSuspendCounter)throw Error(rt(482));e=t,e.status="pending",e.then(function(i){if(t.status==="pending"){var r=t;r.status="fulfilled",r.value=i}},function(i){if(t.status==="pending"){var r=t;r.status="rejected",r.reason=i}})}switch(t.status){case"fulfilled":return t.value;case"rejected":throw e=t.reason,uA(e),e}throw Uu=t,Od}}function Su(e){try{var t=e._init;return t(e._payload)}catch(n){throw n!==null&&typeof n=="object"&&typeof n.then=="function"?(Uu=n,Od):n}}var Uu=null;function lA(){if(Uu===null)throw Error(rt(459));var e=Uu;return Uu=null,e}function uA(e){if(e===Od||e===Ug)throw Error(rt(483))}var ud=null,op=0;function hh(e){var t=op;return op+=1,ud===null&&(ud=[]),OF(ud,e,t)}function Kd(e,t){t=t.props.ref,e.ref=t!==void 0?t:null}function mh(e,t){throw t.$$typeof===rq?Error(rt(525)):(e=Object.prototype.toString.call(t),Error(rt(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e)))}function RF(e){function t(g,_){if(e){var T=g.deletions;T===null?(g.deletions=[_],g.flags|=16):T.push(_)}}function n(g,_){if(!e)return null;for(;_!==null;)t(g,_),_=_.sibling;return null}function i(g){for(var _=new Map;g!==null;)g.key!==null?_.set(g.key,g):_.set(g.index,g),g=g.sibling;return _}function r(g,_){return g=Io(g,_),g.index=0,g.sibling=null,g}function s(g,_,T){return g.index=T,e?(T=g.alternate,T!==null?(T=T.index,T<_?(g.flags|=67108866,_):T):(g.flags|=67108866,_)):(g.flags|=1048576,_)}function a(g){return e&&g.alternate===null&&(g.flags|=67108866),g}function o(g,_,T,x){return _===null||_.tag!==6?(_=Hy(T,g.mode,x),_.return=g,_):(_=r(_,T),_.return=g,_)}function l(g,_,T,x){var S=T.type;return S===Uc?c(g,_,T.props.children,x,T.key):_!==null&&(_.elementType===S||typeof S=="object"&&S!==null&&S.$$typeof===yl&&Su(S)===_.type)?(_=r(_,T.props),Kd(_,T),_.return=g,_):(_=um(T.type,T.key,T.props,null,g.mode,x),Kd(_,T),_.return=g,_)}function u(g,_,T,x){return _===null||_.tag!==4||_.stateNode.containerInfo!==T.containerInfo||_.stateNode.implementation!==T.implementation?(_=qy(T,g.mode,x),_.return=g,_):(_=r(_,T.children||[]),_.return=g,_)}function c(g,_,T,x,S){return _===null||_.tag!==7?(_=Fu(T,g.mode,x,S),_.return=g,_):(_=r(_,T),_.return=g,_)}function f(g,_,T){if(typeof _=="string"&&_!==""||typeof _=="number"||typeof _=="bigint")return _=Hy(""+_,g.mode,T),_.return=g,_;if(typeof _=="object"&&_!==null){switch(_.$$typeof){case oh:return T=um(_.type,_.key,_.props,null,g.mode,T),Kd(T,_),T.return=g,T;case Mf:return _=qy(_,g.mode,T),_.return=g,_;case yl:return _=Su(_),f(g,_,T)}if(Ef(_)||Wd(_))return _=Fu(_,g.mode,T,null),_.return=g,_;if(typeof _.then=="function")return f(g,hh(_),T);if(_.$$typeof===Co)return f(g,ph(g,_),T);mh(g,_)}return null}function d(g,_,T,x){var S=_!==null?_.key:null;if(typeof T=="string"&&T!==""||typeof T=="number"||typeof T=="bigint")return S!==null?null:o(g,_,""+T,x);if(typeof T=="object"&&T!==null){switch(T.$$typeof){case oh:return T.key===S?l(g,_,T,x):null;case Mf:return T.key===S?u(g,_,T,x):null;case yl:return T=Su(T),d(g,_,T,x)}if(Ef(T)||Wd(T))return S!==null?null:c(g,_,T,x,null);if(typeof T.then=="function")return d(g,_,hh(T),x);if(T.$$typeof===Co)return d(g,_,ph(g,T),x);mh(g,T)}return null}function h(g,_,T,x,S){if(typeof x=="string"&&x!==""||typeof x=="number"||typeof x=="bigint")return g=g.get(T)||null,o(_,g,""+x,S);if(typeof x=="object"&&x!==null){switch(x.$$typeof){case oh:return g=g.get(x.key===null?T:x.key)||null,l(_,g,x,S);case Mf:return g=g.get(x.key===null?T:x.key)||null,u(_,g,x,S);case yl:return x=Su(x),h(g,_,T,x,S)}if(Ef(x)||Wd(x))return g=g.get(T)||null,c(_,g,x,S,null);if(typeof x.then=="function")return h(g,_,T,hh(x),S);if(x.$$typeof===Co)return h(g,_,T,ph(_,x),S);mh(_,x)}return null}function m(g,_,T,x){for(var S=null,$=null,C=_,P=_=0,O=null;C!==null&&P<T.length;P++){C.index>P?(O=C,C=null):O=C.sibling;var R=d(g,C,T[P],x);if(R===null){C===null&&(C=O);break}e&&C&&R.alternate===null&&t(g,C),_=s(R,_,P),$===null?S=R:$.sibling=R,$=R,C=O}if(P===T.length)return n(g,C),jn&&To(g,P),S;if(C===null){for(;P<T.length;P++)C=f(g,T[P],x),C!==null&&(_=s(C,_,P),$===null?S=C:$.sibling=C,$=C);return jn&&To(g,P),S}for(C=i(C);P<T.length;P++)O=h(C,g,P,T[P],x),O!==null&&(e&&O.alternate!==null&&C.delete(O.key===null?P:O.key),_=s(O,_,P),$===null?S=O:$.sibling=O,$=O);return e&&C.forEach(function(G){return t(g,G)}),jn&&To(g,P),S}function y(g,_,T,x){if(T==null)throw Error(rt(151));for(var S=null,$=null,C=_,P=_=0,O=null,R=T.next();C!==null&&!R.done;P++,R=T.next()){C.index>P?(O=C,C=null):O=C.sibling;var G=d(g,C,R.value,x);if(G===null){C===null&&(C=O);break}e&&C&&G.alternate===null&&t(g,C),_=s(G,_,P),$===null?S=G:$.sibling=G,$=G,C=O}if(R.done)return n(g,C),jn&&To(g,P),S;if(C===null){for(;!R.done;P++,R=T.next())R=f(g,R.value,x),R!==null&&(_=s(R,_,P),$===null?S=R:$.sibling=R,$=R);return jn&&To(g,P),S}for(C=i(C);!R.done;P++,R=T.next())R=h(C,g,P,R.value,x),R!==null&&(e&&R.alternate!==null&&C.delete(R.key===null?P:R.key),_=s(R,_,P),$===null?S=R:$.sibling=R,$=R);return e&&C.forEach(function(W){return t(g,W)}),jn&&To(g,P),S}function M(g,_,T,x){if(typeof T=="object"&&T!==null&&T.type===Uc&&T.key===null&&(T=T.props.children),typeof T=="object"&&T!==null){switch(T.$$typeof){case oh:e:{for(var S=T.key;_!==null;){if(_.key===S){if(S=T.type,S===Uc){if(_.tag===7){n(g,_.sibling),x=r(_,T.props.children),x.return=g,g=x;break e}}else if(_.elementType===S||typeof S=="object"&&S!==null&&S.$$typeof===yl&&Su(S)===_.type){n(g,_.sibling),x=r(_,T.props),Kd(x,T),x.return=g,g=x;break e}n(g,_);break}else t(g,_);_=_.sibling}T.type===Uc?(x=Fu(T.props.children,g.mode,x,T.key),x.return=g,g=x):(x=um(T.type,T.key,T.props,null,g.mode,x),Kd(x,T),x.return=g,g=x)}return a(g);case Mf:e:{for(S=T.key;_!==null;){if(_.key===S)if(_.tag===4&&_.stateNode.containerInfo===T.containerInfo&&_.stateNode.implementation===T.implementation){n(g,_.sibling),x=r(_,T.children||[]),x.return=g,g=x;break e}else{n(g,_);break}else t(g,_);_=_.sibling}x=qy(T,g.mode,x),x.return=g,g=x}return a(g);case yl:return T=Su(T),M(g,_,T,x)}if(Ef(T))return m(g,_,T,x);if(Wd(T)){if(S=Wd(T),typeof S!="function")throw Error(rt(150));return T=S.call(T),y(g,_,T,x)}if(typeof T.then=="function")return M(g,_,hh(T),x);if(T.$$typeof===Co)return M(g,_,ph(g,T),x);mh(g,T)}return typeof T=="string"&&T!==""||typeof T=="number"||typeof T=="bigint"?(T=""+T,_!==null&&_.tag===6?(n(g,_.sibling),x=r(_,T),x.return=g,g=x):(n(g,_),x=Hy(T,g.mode,x),x.return=g,g=x),a(g)):n(g,_)}return function(g,_,T,x){try{op=0;var S=M(g,_,T,x);return ud=null,S}catch(C){if(C===Od||C===Ug)throw C;var $=ys(29,C,null,g.mode);return $.lanes=x,$.return=g,$}finally{}}}var Ku=RF(!0),NF=RF(!1),vl=!1;function Y1(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Hw(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function Pl(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function kl(e,t,n){var i=e.updateQueue;if(i===null)return null;if(i=i.shared,si&2){var r=i.pending;return r===null?t.next=t:(t.next=r.next,r.next=t),i.pending=t,t=Nm(e),CF(e,null,n),t}return Bg(e,i,t,n),Nm(e)}function Gf(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194048)!==0)){var i=t.lanes;i&=e.pendingLanes,n|=i,t.lanes=n,eF(e,n)}}function Jy(e,t){var n=e.updateQueue,i=e.alternate;if(i!==null&&(i=i.updateQueue,n===i)){var r=null,s=null;if(n=n.firstBaseUpdate,n!==null){do{var a={lane:n.lane,tag:n.tag,payload:n.payload,callback:null,next:null};s===null?r=s=a:s=s.next=a,n=n.next}while(n!==null);s===null?r=s=t:s=s.next=t}else r=s=t;n={baseState:i.baseState,firstBaseUpdate:r,lastBaseUpdate:s,shared:i.shared,callbacks:i.callbacks},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}var qw=!1;function jf(){if(qw){var e=ld;if(e!==null)throw e}}function Wf(e,t,n,i){qw=!1;var r=e.updateQueue;vl=!1;var s=r.firstBaseUpdate,a=r.lastBaseUpdate,o=r.shared.pending;if(o!==null){r.shared.pending=null;var l=o,u=l.next;l.next=null,a===null?s=u:a.next=u,a=l;var c=e.alternate;c!==null&&(c=c.updateQueue,o=c.lastBaseUpdate,o!==a&&(o===null?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(s!==null){var f=r.baseState;a=0,c=u=l=null,o=s;do{var d=o.lane&-536870913,h=d!==o.lane;if(h?(Fn&d)===d:(i&d)===d){d!==0&&d===_d&&(qw=!0),c!==null&&(c=c.next={lane:0,tag:o.tag,payload:o.payload,callback:null,next:null});e:{var m=e,y=o;d=t;var M=n;switch(y.tag){case 1:if(m=y.payload,typeof m=="function"){f=m.call(M,f,d);break e}f=m;break e;case 3:m.flags=m.flags&-65537|128;case 0:if(m=y.payload,d=typeof m=="function"?m.call(M,f,d):m,d==null)break e;f=Ri({},f,d);break e;case 2:vl=!0}}d=o.callback,d!==null&&(e.flags|=64,h&&(e.flags|=8192),h=r.callbacks,h===null?r.callbacks=[d]:h.push(d))}else h={lane:d,tag:o.tag,payload:o.payload,callback:o.callback,next:null},c===null?(u=c=h,l=f):c=c.next=h,a|=d;if(o=o.next,o===null){if(o=r.shared.pending,o===null)break;h=o,o=h.next,h.next=null,r.lastBaseUpdate=h,r.shared.pending=null}}while(!0);c===null&&(l=f),r.baseState=l,r.firstBaseUpdate=u,r.lastBaseUpdate=c,s===null&&(r.shared.lanes=0),Gl|=a,e.lanes=a,e.memoizedState=f}}function LF(e,t){if(typeof e!="function")throw Error(rt(191,e));e.call(t)}function zF(e,t){var n=e.callbacks;if(n!==null)for(e.callbacks=null,e=0;e<n.length;e++)LF(n[e],t)}var yd=eo(null),Bm=eo(0);function cA(e,t){e=Lo,Ai(Bm,e),Ai(yd,t),Lo=e|t.baseLanes}function Kw(){Ai(Bm,Lo),Ai(yd,yd.current)}function X1(){Lo=Bm.current,Er(yd),Er(Bm)}var Cs=eo(null),Js=null;function bl(e){var t=e.alternate;Ai(Zi,Zi.current&1),Ai(Cs,e),Js===null&&(t===null||yd.current!==null||t.memoizedState!==null)&&(Js=e)}function Jw(e){Ai(Zi,Zi.current),Ai(Cs,e),Js===null&&(Js=e)}function FF(e){e.tag===22?(Ai(Zi,Zi.current),Ai(Cs,e),Js===null&&(Js=e)):xl()}function xl(){Ai(Zi,Zi.current),Ai(Cs,Cs.current)}function ms(e){Er(Cs),Js===e&&(Js=null),Er(Zi)}var Zi=eo(0);function Um(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||hb(n)||mb(n)))return t}else if(t.tag===19&&(t.memoizedProps.revealOrder==="forwards"||t.memoizedProps.revealOrder==="backwards"||t.memoizedProps.revealOrder==="unstable_legacy-backwards"||t.memoizedProps.revealOrder==="together")){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var Oo=0,xn=null,_i=null,or=null,Vm=!1,cd=!1,Ju=!1,Gm=0,lp=0,dd=null,vK=0;function qi(){throw Error(rt(321))}function Q1(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Ss(e[n],t[n]))return!1;return!0}function Z1(e,t,n,i,r,s){return Oo=s,xn=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,on.H=e===null||e.memoizedState===null?gB:cx,Ju=!1,s=n(i,r),Ju=!1,cd&&(s=UF(t,n,i,r)),BF(e),s}function BF(e){on.H=up;var t=_i!==null&&_i.next!==null;if(Oo=0,or=_i=xn=null,Vm=!1,lp=0,dd=null,t)throw Error(rt(300));e===null||cr||(e=e.dependencies,e!==null&&zm(e)&&(cr=!0))}function UF(e,t,n,i){xn=e;var r=0;do{if(cd&&(dd=null),lp=0,cd=!1,25<=r)throw Error(rt(301));if(r+=1,or=_i=null,e.updateQueue!=null){var s=e.updateQueue;s.lastEffect=null,s.events=null,s.stores=null,s.memoCache!=null&&(s.memoCache.index=0)}on.H=_B,s=t(n,i)}while(cd);return s}function wK(){var e=on.H,t=e.useState()[0];return t=typeof t.then=="function"?Ip(t):t,e=e.useState()[0],(_i!==null?_i.memoizedState:null)!==e&&(xn.flags|=1024),t}function ex(){var e=Gm!==0;return Gm=0,e}function tx(e,t,n){t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~n}function nx(e){if(Vm){for(e=e.memoizedState;e!==null;){var t=e.queue;t!==null&&(t.pending=null),e=e.next}Vm=!1}Oo=0,or=_i=xn=null,cd=!1,lp=Gm=0,dd=null}function Wr(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return or===null?xn.memoizedState=or=e:or=or.next=e,or}function er(){if(_i===null){var e=xn.alternate;e=e!==null?e.memoizedState:null}else e=_i.next;var t=or===null?xn.memoizedState:or.next;if(t!==null)or=t,_i=e;else{if(e===null)throw xn.alternate===null?Error(rt(467)):Error(rt(310));_i=e,e={memoizedState:_i.memoizedState,baseState:_i.baseState,baseQueue:_i.baseQueue,queue:_i.queue,next:null},or===null?xn.memoizedState=or=e:or=or.next=e}return or}function Vg(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Ip(e){var t=lp;return lp+=1,dd===null&&(dd=[]),e=OF(dd,e,t),t=xn,(or===null?t.memoizedState:or.next)===null&&(t=t.alternate,on.H=t===null||t.memoizedState===null?gB:cx),e}function Gg(e){if(e!==null&&typeof e=="object"){if(typeof e.then=="function")return Ip(e);if(e.$$typeof===Co)return Dr(e)}throw Error(rt(438,String(e)))}function ix(e){var t=null,n=xn.updateQueue;if(n!==null&&(t=n.memoCache),t==null){var i=xn.alternate;i!==null&&(i=i.updateQueue,i!==null&&(i=i.memoCache,i!=null&&(t={data:i.data.map(function(r){return r.slice()}),index:0})))}if(t==null&&(t={data:[],index:0}),n===null&&(n=Vg(),xn.updateQueue=n),n.memoCache=t,n=t.data[t.index],n===void 0)for(n=t.data[t.index]=Array(e),i=0;i<e;i++)n[i]=sq;return t.index++,n}function Ro(e,t){return typeof t=="function"?t(e):t}function dm(e){var t=er();return rx(t,_i,e)}function rx(e,t,n){var i=e.queue;if(i===null)throw Error(rt(311));i.lastRenderedReducer=n;var r=e.baseQueue,s=i.pending;if(s!==null){if(r!==null){var a=r.next;r.next=s.next,s.next=a}t.baseQueue=r=s,i.pending=null}if(s=e.baseState,r===null)e.memoizedState=s;else{t=r.next;var o=a=null,l=null,u=t,c=!1;do{var f=u.lane&-536870913;if(f!==u.lane?(Fn&f)===f:(Oo&f)===f){var d=u.revertLane;if(d===0)l!==null&&(l=l.next={lane:0,revertLane:0,gesture:null,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),f===_d&&(c=!0);else if((Oo&d)===d){u=u.next,d===_d&&(c=!0);continue}else f={lane:0,revertLane:u.revertLane,gesture:null,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null},l===null?(o=l=f,a=s):l=l.next=f,xn.lanes|=d,Gl|=d;f=u.action,Ju&&n(s,f),s=u.hasEagerState?u.eagerState:n(s,f)}else d={lane:f,revertLane:u.revertLane,gesture:u.gesture,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null},l===null?(o=l=d,a=s):l=l.next=d,xn.lanes|=f,Gl|=f;u=u.next}while(u!==null&&u!==t);if(l===null?a=s:l.next=o,!Ss(s,e.memoizedState)&&(cr=!0,c&&(n=ld,n!==null)))throw n;e.memoizedState=s,e.baseState=a,e.baseQueue=l,i.lastRenderedState=s}return r===null&&(i.lanes=0),[e.memoizedState,i.dispatch]}function Yy(e){var t=er(),n=t.queue;if(n===null)throw Error(rt(311));n.lastRenderedReducer=e;var i=n.dispatch,r=n.pending,s=t.memoizedState;if(r!==null){n.pending=null;var a=r=r.next;do s=e(s,a.action),a=a.next;while(a!==r);Ss(s,t.memoizedState)||(cr=!0),t.memoizedState=s,t.baseQueue===null&&(t.baseState=s),n.lastRenderedState=s}return[s,i]}function VF(e,t,n){var i=xn,r=er(),s=jn;if(s){if(n===void 0)throw Error(rt(407));n=n()}else n=t();var a=!Ss((_i||r).memoizedState,n);if(a&&(r.memoizedState=n,cr=!0),r=r.queue,sx(WF.bind(null,i,r,e),[e]),r.getSnapshot!==t||a||or!==null&&or.memoizedState.tag&1){if(i.flags|=2048,vd(9,{destroy:void 0},jF.bind(null,i,r,n,t),null),xi===null)throw Error(rt(349));s||Oo&127||GF(i,t,n)}return n}function GF(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=xn.updateQueue,t===null?(t=Vg(),xn.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function jF(e,t,n,i){t.value=n,t.getSnapshot=i,HF(t)&&qF(e)}function WF(e,t,n){return n(function(){HF(t)&&qF(e)})}function HF(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Ss(e,n)}catch{return!0}}function qF(e){var t=oc(e,2);t!==null&&rs(t,e,2)}function Yw(e){var t=Wr();if(typeof e=="function"){var n=e;if(e=n(),Ju){Ml(!0);try{n()}finally{Ml(!1)}}}return t.memoizedState=t.baseState=e,t.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ro,lastRenderedState:e},t}function KF(e,t,n,i){return e.baseState=n,rx(e,_i,typeof i=="function"?i:Ro)}function bK(e,t,n,i,r){if(Wg(e))throw Error(rt(485));if(e=t.action,e!==null){var s={payload:r,action:e,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(a){s.listeners.push(a)}};on.T!==null?n(!0):s.isTransition=!1,i(s),n=t.pending,n===null?(s.next=t.pending=s,JF(t,s)):(s.next=n.next,t.pending=n.next=s)}}function JF(e,t){var n=t.action,i=t.payload,r=e.state;if(t.isTransition){var s=on.T,a={};on.T=a;try{var o=n(r,i),l=on.S;l!==null&&l(a,o),dA(e,t,o)}catch(u){Xw(e,t,u)}finally{s!==null&&a.types!==null&&(s.types=a.types),on.T=s}}else try{s=n(r,i),dA(e,t,s)}catch(u){Xw(e,t,u)}}function dA(e,t,n){n!==null&&typeof n=="object"&&typeof n.then=="function"?n.then(function(i){fA(e,t,i)},function(i){return Xw(e,t,i)}):fA(e,t,n)}function fA(e,t,n){t.status="fulfilled",t.value=n,YF(t),e.state=n,t=e.pending,t!==null&&(n=t.next,n===t?e.pending=null:(n=n.next,t.next=n,JF(e,n)))}function Xw(e,t,n){var i=e.pending;if(e.pending=null,i!==null){i=i.next;do t.status="rejected",t.reason=n,YF(t),t=t.next;while(t!==i)}e.action=null}function YF(e){e=e.listeners;for(var t=0;t<e.length;t++)(0,e[t])()}function XF(e,t){return t}function pA(e,t){if(jn){var n=xi.formState;if(n!==null){e:{var i=xn;if(jn){if(Di){t:{for(var r=Di,s=qs;r.nodeType!==8;){if(!s){r=null;break t}if(r=Ys(r.nextSibling),r===null){r=null;break t}}s=r.data,r=s==="F!"||s==="F"?r:null}if(r){Di=Ys(r.nextSibling),i=r.data==="F!";break e}}Ul(i)}i=!1}i&&(t=n[0])}}return n=Wr(),n.memoizedState=n.baseState=t,i={pending:null,lanes:0,dispatch:null,lastRenderedReducer:XF,lastRenderedState:t},n.queue=i,n=pB.bind(null,xn,i),i.dispatch=n,i=Yw(!1),s=ux.bind(null,xn,!1,i.queue),i=Wr(),r={state:t,dispatch:null,action:e,pending:null},i.queue=r,n=bK.bind(null,xn,r,s,n),r.dispatch=n,i.memoizedState=e,[t,n,!1]}function hA(e){var t=er();return QF(t,_i,e)}function QF(e,t,n){if(t=rx(e,t,XF)[0],e=dm(Ro)[0],typeof t=="object"&&t!==null&&typeof t.then=="function")try{var i=Ip(t)}catch(a){throw a===Od?Ug:a}else i=t;t=er();var r=t.queue,s=r.dispatch;return n!==t.memoizedState&&(xn.flags|=2048,vd(9,{destroy:void 0},xK.bind(null,r,n),null)),[i,s,e]}function xK(e,t){e.action=t}function mA(e){var t=er(),n=_i;if(n!==null)return QF(t,n,e);er(),t=t.memoizedState,n=er();var i=n.queue.dispatch;return n.memoizedState=e,[t,i,!1]}function vd(e,t,n,i){return e={tag:e,create:n,deps:i,inst:t,next:null},t=xn.updateQueue,t===null&&(t=Vg(),xn.updateQueue=t),n=t.lastEffect,n===null?t.lastEffect=e.next=e:(i=n.next,n.next=e,e.next=i,t.lastEffect=e),e}function ZF(){return er().memoizedState}function fm(e,t,n,i){var r=Wr();xn.flags|=e,r.memoizedState=vd(1|t,{destroy:void 0},n,i===void 0?null:i)}function jg(e,t,n,i){var r=er();i=i===void 0?null:i;var s=r.memoizedState.inst;_i!==null&&i!==null&&Q1(i,_i.memoizedState.deps)?r.memoizedState=vd(t,s,n,i):(xn.flags|=e,r.memoizedState=vd(1|t,s,n,i))}function gA(e,t){fm(8390656,8,e,t)}function sx(e,t){jg(2048,8,e,t)}function TK(e){xn.flags|=4;var t=xn.updateQueue;if(t===null)t=Vg(),xn.updateQueue=t,t.events=[e];else{var n=t.events;n===null?t.events=[e]:n.push(e)}}function eB(e){var t=er().memoizedState;return TK({ref:t,nextImpl:e}),function(){if(si&2)throw Error(rt(440));return t.impl.apply(void 0,arguments)}}function tB(e,t){return jg(4,2,e,t)}function nB(e,t){return jg(4,4,e,t)}function iB(e,t){if(typeof t=="function"){e=e();var n=t(e);return function(){typeof n=="function"?n():t(null)}}if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function rB(e,t,n){n=n!=null?n.concat([e]):null,jg(4,4,iB.bind(null,t,e),n)}function ax(){}function sB(e,t){var n=er();t=t===void 0?null:t;var i=n.memoizedState;return t!==null&&Q1(t,i[1])?i[0]:(n.memoizedState=[e,t],e)}function aB(e,t){var n=er();t=t===void 0?null:t;var i=n.memoizedState;if(t!==null&&Q1(t,i[1]))return i[0];if(i=e(),Ju){Ml(!0);try{e()}finally{Ml(!1)}}return n.memoizedState=[i,t],i}function ox(e,t,n){return n===void 0||Oo&1073741824&&!(Fn&261930)?e.memoizedState=t:(e.memoizedState=n,e=KB(),xn.lanes|=e,Gl|=e,n)}function oB(e,t,n,i){return Ss(n,t)?n:yd.current!==null?(e=ox(e,n,i),Ss(e,t)||(cr=!0),e):!(Oo&42)||Oo&1073741824&&!(Fn&261930)?(cr=!0,e.memoizedState=n):(e=KB(),xn.lanes|=e,Gl|=e,t)}function lB(e,t,n,i,r){var s=ai.p;ai.p=s!==0&&8>s?s:8;var a=on.T,o={};on.T=o,ux(e,!1,t,n);try{var l=r(),u=on.S;if(u!==null&&u(o,l),l!==null&&typeof l=="object"&&typeof l.then=="function"){var c=yK(l,i);Hf(e,t,c,Ts(e))}else Hf(e,t,i,Ts(e))}catch(f){Hf(e,t,{then:function(){},status:"rejected",reason:f},Ts())}finally{ai.p=s,a!==null&&o.types!==null&&(a.types=o.types),on.T=a}}function MK(){}function Qw(e,t,n,i){if(e.tag!==5)throw Error(rt(476));var r=uB(e).queue;lB(e,r,t,zu,n===null?MK:function(){return cB(e),n(i)})}function uB(e){var t=e.memoizedState;if(t!==null)return t;t={memoizedState:zu,baseState:zu,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ro,lastRenderedState:zu},next:null};var n={};return t.next={memoizedState:n,baseState:n,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ro,lastRenderedState:n},next:null},e.memoizedState=t,e=e.alternate,e!==null&&(e.memoizedState=t),t}function cB(e){var t=uB(e);t.next===null&&(t=e.alternate.memoizedState),Hf(e,t.next.queue,{},Ts())}function lx(){return Dr(fp)}function dB(){return er().memoizedState}function fB(){return er().memoizedState}function EK(e){for(var t=e.return;t!==null;){switch(t.tag){case 24:case 3:var n=Ts();e=Pl(n);var i=kl(t,e,n);i!==null&&(rs(i,t,n),Gf(i,t,n)),t={cache:q1()},e.payload=t;return}t=t.return}}function SK(e,t,n){var i=Ts();n={lane:i,revertLane:0,gesture:null,action:n,hasEagerState:!1,eagerState:null,next:null},Wg(e)?hB(t,n):(n=G1(e,t,n,i),n!==null&&(rs(n,e,i),mB(n,t,i)))}function pB(e,t,n){var i=Ts();Hf(e,t,n,i)}function Hf(e,t,n,i){var r={lane:i,revertLane:0,gesture:null,action:n,hasEagerState:!1,eagerState:null,next:null};if(Wg(e))hB(t,r);else{var s=e.alternate;if(e.lanes===0&&(s===null||s.lanes===0)&&(s=t.lastRenderedReducer,s!==null))try{var a=t.lastRenderedState,o=s(a,n);if(r.hasEagerState=!0,r.eagerState=o,Ss(o,a))return Bg(e,t,r,0),xi===null&&Fg(),!1}catch{}finally{}if(n=G1(e,t,r,i),n!==null)return rs(n,e,i),mB(n,t,i),!0}return!1}function ux(e,t,n,i){if(i={lane:2,revertLane:yx(),gesture:null,action:i,hasEagerState:!1,eagerState:null,next:null},Wg(e)){if(t)throw Error(rt(479))}else t=G1(e,n,i,2),t!==null&&rs(t,e,2)}function Wg(e){var t=e.alternate;return e===xn||t!==null&&t===xn}function hB(e,t){cd=Vm=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function mB(e,t,n){if(n&4194048){var i=t.lanes;i&=e.pendingLanes,n|=i,t.lanes=n,eF(e,n)}}var up={readContext:Dr,use:Gg,useCallback:qi,useContext:qi,useEffect:qi,useImperativeHandle:qi,useLayoutEffect:qi,useInsertionEffect:qi,useMemo:qi,useReducer:qi,useRef:qi,useState:qi,useDebugValue:qi,useDeferredValue:qi,useTransition:qi,useSyncExternalStore:qi,useId:qi,useHostTransitionStatus:qi,useFormState:qi,useActionState:qi,useOptimistic:qi,useMemoCache:qi,useCacheRefresh:qi};up.useEffectEvent=qi;var gB={readContext:Dr,use:Gg,useCallback:function(e,t){return Wr().memoizedState=[e,t===void 0?null:t],e},useContext:Dr,useEffect:gA,useImperativeHandle:function(e,t,n){n=n!=null?n.concat([e]):null,fm(4194308,4,iB.bind(null,t,e),n)},useLayoutEffect:function(e,t){return fm(4194308,4,e,t)},useInsertionEffect:function(e,t){fm(4,2,e,t)},useMemo:function(e,t){var n=Wr();t=t===void 0?null:t;var i=e();if(Ju){Ml(!0);try{e()}finally{Ml(!1)}}return n.memoizedState=[i,t],i},useReducer:function(e,t,n){var i=Wr();if(n!==void 0){var r=n(t);if(Ju){Ml(!0);try{n(t)}finally{Ml(!1)}}}else r=t;return i.memoizedState=i.baseState=r,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:r},i.queue=e,e=e.dispatch=SK.bind(null,xn,e),[i.memoizedState,e]},useRef:function(e){var t=Wr();return e={current:e},t.memoizedState=e},useState:function(e){e=Yw(e);var t=e.queue,n=pB.bind(null,xn,t);return t.dispatch=n,[e.memoizedState,n]},useDebugValue:ax,useDeferredValue:function(e,t){var n=Wr();return ox(n,e,t)},useTransition:function(){var e=Yw(!1);return e=lB.bind(null,xn,e.queue,!0,!1),Wr().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,t,n){var i=xn,r=Wr();if(jn){if(n===void 0)throw Error(rt(407));n=n()}else{if(n=t(),xi===null)throw Error(rt(349));Fn&127||GF(i,t,n)}r.memoizedState=n;var s={value:n,getSnapshot:t};return r.queue=s,gA(WF.bind(null,i,s,e),[e]),i.flags|=2048,vd(9,{destroy:void 0},jF.bind(null,i,s,n,t),null),n},useId:function(){var e=Wr(),t=xi.identifierPrefix;if(jn){var n=Ja,i=Ka;n=(i&~(1<<32-xs(i)-1)).toString(32)+n,t="_"+t+"R_"+n,n=Gm++,0<n&&(t+="H"+n.toString(32)),t+="_"}else n=vK++,t="_"+t+"r_"+n.toString(32)+"_";return e.memoizedState=t},useHostTransitionStatus:lx,useFormState:pA,useActionState:pA,useOptimistic:function(e){var t=Wr();t.memoizedState=t.baseState=e;var n={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return t.queue=n,t=ux.bind(null,xn,!0,n),n.dispatch=t,[e,t]},useMemoCache:ix,useCacheRefresh:function(){return Wr().memoizedState=EK.bind(null,xn)},useEffectEvent:function(e){var t=Wr(),n={impl:e};return t.memoizedState=n,function(){if(si&2)throw Error(rt(440));return n.impl.apply(void 0,arguments)}}},cx={readContext:Dr,use:Gg,useCallback:sB,useContext:Dr,useEffect:sx,useImperativeHandle:rB,useInsertionEffect:tB,useLayoutEffect:nB,useMemo:aB,useReducer:dm,useRef:ZF,useState:function(){return dm(Ro)},useDebugValue:ax,useDeferredValue:function(e,t){var n=er();return oB(n,_i.memoizedState,e,t)},useTransition:function(){var e=dm(Ro)[0],t=er().memoizedState;return[typeof e=="boolean"?e:Ip(e),t]},useSyncExternalStore:VF,useId:dB,useHostTransitionStatus:lx,useFormState:hA,useActionState:hA,useOptimistic:function(e,t){var n=er();return KF(n,_i,e,t)},useMemoCache:ix,useCacheRefresh:fB};cx.useEffectEvent=eB;var _B={readContext:Dr,use:Gg,useCallback:sB,useContext:Dr,useEffect:sx,useImperativeHandle:rB,useInsertionEffect:tB,useLayoutEffect:nB,useMemo:aB,useReducer:Yy,useRef:ZF,useState:function(){return Yy(Ro)},useDebugValue:ax,useDeferredValue:function(e,t){var n=er();return _i===null?ox(n,e,t):oB(n,_i.memoizedState,e,t)},useTransition:function(){var e=Yy(Ro)[0],t=er().memoizedState;return[typeof e=="boolean"?e:Ip(e),t]},useSyncExternalStore:VF,useId:dB,useHostTransitionStatus:lx,useFormState:mA,useActionState:mA,useOptimistic:function(e,t){var n=er();return _i!==null?KF(n,_i,e,t):(n.baseState=e,[e,n.queue.dispatch])},useMemoCache:ix,useCacheRefresh:fB};_B.useEffectEvent=eB;function Xy(e,t,n,i){t=e.memoizedState,n=n(i,t),n=n==null?t:Ri({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var Zw={enqueueSetState:function(e,t,n){e=e._reactInternals;var i=Ts(),r=Pl(i);r.payload=t,n!=null&&(r.callback=n),t=kl(e,r,i),t!==null&&(rs(t,e,i),Gf(t,e,i))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var i=Ts(),r=Pl(i);r.tag=1,r.payload=t,n!=null&&(r.callback=n),t=kl(e,r,i),t!==null&&(rs(t,e,i),Gf(t,e,i))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=Ts(),i=Pl(n);i.tag=2,t!=null&&(i.callback=t),t=kl(e,i,n),t!==null&&(rs(t,e,n),Gf(t,e,n))}};function _A(e,t,n,i,r,s,a){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(i,s,a):t.prototype&&t.prototype.isPureReactComponent?!rp(n,i)||!rp(r,s):!0}function yA(e,t,n,i){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,i),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,i),t.state!==e&&Zw.enqueueReplaceState(t,t.state,null)}function Yu(e,t){var n=t;if("ref"in t){n={};for(var i in t)i!=="ref"&&(n[i]=t[i])}if(e=e.defaultProps){n===t&&(n=Ri({},n));for(var r in e)n[r]===void 0&&(n[r]=e[r])}return n}function yB(e){Rm(e)}function vB(e){console.error(e)}function wB(e){Rm(e)}function jm(e,t){try{var n=e.onUncaughtError;n(t.value,{componentStack:t.stack})}catch(i){setTimeout(function(){throw i})}}function vA(e,t,n){try{var i=e.onCaughtError;i(n.value,{componentStack:n.stack,errorBoundary:t.tag===1?t.stateNode:null})}catch(r){setTimeout(function(){throw r})}}function eb(e,t,n){return n=Pl(n),n.tag=3,n.payload={element:null},n.callback=function(){jm(e,t)},n}function bB(e){return e=Pl(e),e.tag=3,e}function xB(e,t,n,i){var r=n.type.getDerivedStateFromError;if(typeof r=="function"){var s=i.value;e.payload=function(){return r(s)},e.callback=function(){vA(t,n,i)}}var a=n.stateNode;a!==null&&typeof a.componentDidCatch=="function"&&(e.callback=function(){vA(t,n,i),typeof r!="function"&&(Dl===null?Dl=new Set([this]):Dl.add(this));var o=i.stack;this.componentDidCatch(i.value,{componentStack:o!==null?o:""})})}function CK(e,t,n,i,r){if(n.flags|=32768,i!==null&&typeof i=="object"&&typeof i.then=="function"){if(t=n.alternate,t!==null&&Dd(t,n,r,!0),n=Cs.current,n!==null){switch(n.tag){case 31:case 13:return Js===null?Jm():n.alternate===null&&Ki===0&&(Ki=3),n.flags&=-257,n.flags|=65536,n.lanes=r,i===Fm?n.flags|=16384:(t=n.updateQueue,t===null?n.updateQueue=new Set([i]):t.add(i),l0(e,i,r)),!1;case 22:return n.flags|=65536,i===Fm?n.flags|=16384:(t=n.updateQueue,t===null?(t={transitions:null,markerInstances:null,retryQueue:new Set([i])},n.updateQueue=t):(n=t.retryQueue,n===null?t.retryQueue=new Set([i]):n.add(i)),l0(e,i,r)),!1}throw Error(rt(435,n.tag))}return l0(e,i,r),Jm(),!1}if(jn)return t=Cs.current,t!==null?(!(t.flags&65536)&&(t.flags|=256),t.flags|=65536,t.lanes=r,i!==Uw&&(e=Error(rt(422),{cause:i}),ap(Hs(e,n)))):(i!==Uw&&(t=Error(rt(423),{cause:i}),ap(Hs(t,n))),e=e.current.alternate,e.flags|=65536,r&=-r,e.lanes|=r,i=Hs(i,n),r=eb(e.stateNode,i,r),Jy(e,r),Ki!==4&&(Ki=2)),!1;var s=Error(rt(520),{cause:i});if(s=Hs(s,n),Jf===null?Jf=[s]:Jf.push(s),Ki!==4&&(Ki=2),t===null)return!0;i=Hs(i,n),n=t;do{switch(n.tag){case 3:return n.flags|=65536,e=r&-r,n.lanes|=e,e=eb(n.stateNode,i,e),Jy(n,e),!1;case 1:if(t=n.type,s=n.stateNode,(n.flags&128)===0&&(typeof t.getDerivedStateFromError=="function"||s!==null&&typeof s.componentDidCatch=="function"&&(Dl===null||!Dl.has(s))))return n.flags|=65536,r&=-r,n.lanes|=r,r=bB(r),xB(r,e,n,i),Jy(n,r),!1}n=n.return}while(n!==null);return!1}var dx=Error(rt(461)),cr=!1;function Ir(e,t,n,i){t.child=e===null?NF(t,null,n,i):Ku(t,e.child,n,i)}function wA(e,t,n,i,r){n=n.render;var s=t.ref;if("ref"in i){var a={};for(var o in i)o!=="ref"&&(a[o]=i[o])}else a=i;return qu(t),i=Z1(e,t,n,a,s,r),o=ex(),e!==null&&!cr?(tx(e,t,r),No(e,t,r)):(jn&&o&&W1(t),t.flags|=1,Ir(e,t,i,r),t.child)}function bA(e,t,n,i,r){if(e===null){var s=n.type;return typeof s=="function"&&!j1(s)&&s.defaultProps===void 0&&n.compare===null?(t.tag=15,t.type=s,TB(e,t,s,i,r)):(e=um(n.type,null,i,t,t.mode,r),e.ref=t.ref,e.return=t,t.child=e)}if(s=e.child,!fx(e,r)){var a=s.memoizedProps;if(n=n.compare,n=n!==null?n:rp,n(a,i)&&e.ref===t.ref)return No(e,t,r)}return t.flags|=1,e=Io(s,i),e.ref=t.ref,e.return=t,t.child=e}function TB(e,t,n,i,r){if(e!==null){var s=e.memoizedProps;if(rp(s,i)&&e.ref===t.ref)if(cr=!1,t.pendingProps=i=s,fx(e,r))e.flags&131072&&(cr=!0);else return t.lanes=e.lanes,No(e,t,r)}return tb(e,t,n,i,r)}function MB(e,t,n,i){var r=i.children,s=e!==null?e.memoizedState:null;if(e===null&&t.stateNode===null&&(t.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),i.mode==="hidden"){if(t.flags&128){if(s=s!==null?s.baseLanes|n:n,e!==null){for(i=t.child=e.child,r=0;i!==null;)r=r|i.lanes|i.childLanes,i=i.sibling;i=r&~s}else i=0,t.child=null;return xA(e,t,s,n,i)}if(n&536870912)t.memoizedState={baseLanes:0,cachePool:null},e!==null&&cm(t,s!==null?s.cachePool:null),s!==null?cA(t,s):Kw(),FF(t);else return i=t.lanes=536870912,xA(e,t,s!==null?s.baseLanes|n:n,n,i)}else s!==null?(cm(t,s.cachePool),cA(t,s),xl(),t.memoizedState=null):(e!==null&&cm(t,null),Kw(),xl());return Ir(e,t,r,n),t.child}function Cf(e,t){return e!==null&&e.tag===22||t.stateNode!==null||(t.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),t.sibling}function xA(e,t,n,i,r){var s=K1();return s=s===null?null:{parent:ur._currentValue,pool:s},t.memoizedState={baseLanes:n,cachePool:s},e!==null&&cm(t,null),Kw(),FF(t),e!==null&&Dd(e,t,i,!0),t.childLanes=r,null}function pm(e,t){return t=Wm({mode:t.mode,children:t.children},e.mode),t.ref=e.ref,e.child=t,t.return=e,t}function TA(e,t,n){return Ku(t,e.child,null,n),e=pm(t,t.pendingProps),e.flags|=2,ms(t),t.memoizedState=null,e}function $K(e,t,n){var i=t.pendingProps,r=(t.flags&128)!==0;if(t.flags&=-129,e===null){if(jn){if(i.mode==="hidden")return e=pm(t,i),t.lanes=536870912,Cf(null,e);if(Jw(t),(e=Di)?(e=g4(e,qs),e=e!==null&&e.data==="&"?e:null,e!==null&&(t.memoizedState={dehydrated:e,treeContext:Bl!==null?{id:Ka,overflow:Ja}:null,retryLane:536870912,hydrationErrors:null},n=AF(e),n.return=t,t.child=n,kr=t,Di=null)):e=null,e===null)throw Ul(t);return t.lanes=536870912,null}return pm(t,i)}var s=e.memoizedState;if(s!==null){var a=s.dehydrated;if(Jw(t),r)if(t.flags&256)t.flags&=-257,t=TA(e,t,n);else if(t.memoizedState!==null)t.child=e.child,t.flags|=128,t=null;else throw Error(rt(558));else if(cr||Dd(e,t,n,!1),r=(n&e.childLanes)!==0,cr||r){if(i=xi,i!==null&&(a=tF(i,n),a!==0&&a!==s.retryLane))throw s.retryLane=a,oc(e,a),rs(i,e,a),dx;Jm(),t=TA(e,t,n)}else e=s.treeContext,Di=Ys(a.nextSibling),kr=t,jn=!0,Il=null,qs=!1,e!==null&&PF(t,e),t=pm(t,i),t.flags|=4096;return t}return e=Io(e.child,{mode:i.mode,children:i.children}),e.ref=t.ref,t.child=e,e.return=t,e}function hm(e,t){var n=t.ref;if(n===null)e!==null&&e.ref!==null&&(t.flags|=4194816);else{if(typeof n!="function"&&typeof n!="object")throw Error(rt(284));(e===null||e.ref!==n)&&(t.flags|=4194816)}}function tb(e,t,n,i,r){return qu(t),n=Z1(e,t,n,i,void 0,r),i=ex(),e!==null&&!cr?(tx(e,t,r),No(e,t,r)):(jn&&i&&W1(t),t.flags|=1,Ir(e,t,n,r),t.child)}function MA(e,t,n,i,r,s){return qu(t),t.updateQueue=null,n=UF(t,i,n,r),BF(e),i=ex(),e!==null&&!cr?(tx(e,t,s),No(e,t,s)):(jn&&i&&W1(t),t.flags|=1,Ir(e,t,n,s),t.child)}function EA(e,t,n,i,r){if(qu(t),t.stateNode===null){var s=Jc,a=n.contextType;typeof a=="object"&&a!==null&&(s=Dr(a)),s=new n(i,s),t.memoizedState=s.state!==null&&s.state!==void 0?s.state:null,s.updater=Zw,t.stateNode=s,s._reactInternals=t,s=t.stateNode,s.props=i,s.state=t.memoizedState,s.refs={},Y1(t),a=n.contextType,s.context=typeof a=="object"&&a!==null?Dr(a):Jc,s.state=t.memoizedState,a=n.getDerivedStateFromProps,typeof a=="function"&&(Xy(t,n,a,i),s.state=t.memoizedState),typeof n.getDerivedStateFromProps=="function"||typeof s.getSnapshotBeforeUpdate=="function"||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(a=s.state,typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount(),a!==s.state&&Zw.enqueueReplaceState(s,s.state,null),Wf(t,i,s,r),jf(),s.state=t.memoizedState),typeof s.componentDidMount=="function"&&(t.flags|=4194308),i=!0}else if(e===null){s=t.stateNode;var o=t.memoizedProps,l=Yu(n,o);s.props=l;var u=s.context,c=n.contextType;a=Jc,typeof c=="object"&&c!==null&&(a=Dr(c));var f=n.getDerivedStateFromProps;c=typeof f=="function"||typeof s.getSnapshotBeforeUpdate=="function",o=t.pendingProps!==o,c||typeof s.UNSAFE_componentWillReceiveProps!="function"&&typeof s.componentWillReceiveProps!="function"||(o||u!==a)&&yA(t,s,i,a),vl=!1;var d=t.memoizedState;s.state=d,Wf(t,i,s,r),jf(),u=t.memoizedState,o||d!==u||vl?(typeof f=="function"&&(Xy(t,n,f,i),u=t.memoizedState),(l=vl||_A(t,n,l,i,d,u,a))?(c||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount()),typeof s.componentDidMount=="function"&&(t.flags|=4194308)):(typeof s.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=i,t.memoizedState=u),s.props=i,s.state=u,s.context=a,i=l):(typeof s.componentDidMount=="function"&&(t.flags|=4194308),i=!1)}else{s=t.stateNode,Hw(e,t),a=t.memoizedProps,c=Yu(n,a),s.props=c,f=t.pendingProps,d=s.context,u=n.contextType,l=Jc,typeof u=="object"&&u!==null&&(l=Dr(u)),o=n.getDerivedStateFromProps,(u=typeof o=="function"||typeof s.getSnapshotBeforeUpdate=="function")||typeof s.UNSAFE_componentWillReceiveProps!="function"&&typeof s.componentWillReceiveProps!="function"||(a!==f||d!==l)&&yA(t,s,i,l),vl=!1,d=t.memoizedState,s.state=d,Wf(t,i,s,r),jf();var h=t.memoizedState;a!==f||d!==h||vl||e!==null&&e.dependencies!==null&&zm(e.dependencies)?(typeof o=="function"&&(Xy(t,n,o,i),h=t.memoizedState),(c=vl||_A(t,n,c,i,d,h,l)||e!==null&&e.dependencies!==null&&zm(e.dependencies))?(u||typeof s.UNSAFE_componentWillUpdate!="function"&&typeof s.componentWillUpdate!="function"||(typeof s.componentWillUpdate=="function"&&s.componentWillUpdate(i,h,l),typeof s.UNSAFE_componentWillUpdate=="function"&&s.UNSAFE_componentWillUpdate(i,h,l)),typeof s.componentDidUpdate=="function"&&(t.flags|=4),typeof s.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof s.componentDidUpdate!="function"||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),typeof s.getSnapshotBeforeUpdate!="function"||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=i,t.memoizedState=h),s.props=i,s.state=h,s.context=l,i=c):(typeof s.componentDidUpdate!="function"||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),typeof s.getSnapshotBeforeUpdate!="function"||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),i=!1)}return s=i,hm(e,t),i=(t.flags&128)!==0,s||i?(s=t.stateNode,n=i&&typeof n.getDerivedStateFromError!="function"?null:s.render(),t.flags|=1,e!==null&&i?(t.child=Ku(t,e.child,null,r),t.child=Ku(t,null,n,r)):Ir(e,t,n,r),t.memoizedState=s.state,e=t.child):e=No(e,t,r),e}function SA(e,t,n,i){return Hu(),t.flags|=256,Ir(e,t,n,i),t.child}var Qy={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Zy(e){return{baseLanes:e,cachePool:DF()}}function e0(e,t,n){return e=e!==null?e.childLanes&~n:0,t&&(e|=vs),e}function EB(e,t,n){var i=t.pendingProps,r=!1,s=(t.flags&128)!==0,a;if((a=s)||(a=e!==null&&e.memoizedState===null?!1:(Zi.current&2)!==0),a&&(r=!0,t.flags&=-129),a=(t.flags&32)!==0,t.flags&=-33,e===null){if(jn){if(r?bl(t):xl(),(e=Di)?(e=g4(e,qs),e=e!==null&&e.data!=="&"?e:null,e!==null&&(t.memoizedState={dehydrated:e,treeContext:Bl!==null?{id:Ka,overflow:Ja}:null,retryLane:536870912,hydrationErrors:null},n=AF(e),n.return=t,t.child=n,kr=t,Di=null)):e=null,e===null)throw Ul(t);return mb(e)?t.lanes=32:t.lanes=536870912,null}var o=i.children;return i=i.fallback,r?(xl(),r=t.mode,o=Wm({mode:"hidden",children:o},r),i=Fu(i,r,n,null),o.return=t,i.return=t,o.sibling=i,t.child=o,i=t.child,i.memoizedState=Zy(n),i.childLanes=e0(e,a,n),t.memoizedState=Qy,Cf(null,i)):(bl(t),nb(t,o))}var l=e.memoizedState;if(l!==null&&(o=l.dehydrated,o!==null)){if(s)t.flags&256?(bl(t),t.flags&=-257,t=t0(e,t,n)):t.memoizedState!==null?(xl(),t.child=e.child,t.flags|=128,t=null):(xl(),o=i.fallback,r=t.mode,i=Wm({mode:"visible",children:i.children},r),o=Fu(o,r,n,null),o.flags|=2,i.return=t,o.return=t,i.sibling=o,t.child=i,Ku(t,e.child,null,n),i=t.child,i.memoizedState=Zy(n),i.childLanes=e0(e,a,n),t.memoizedState=Qy,t=Cf(null,i));else if(bl(t),mb(o)){if(a=o.nextSibling&&o.nextSibling.dataset,a)var u=a.dgst;a=u,i=Error(rt(419)),i.stack="",i.digest=a,ap({value:i,source:null,stack:null}),t=t0(e,t,n)}else if(cr||Dd(e,t,n,!1),a=(n&e.childLanes)!==0,cr||a){if(a=xi,a!==null&&(i=tF(a,n),i!==0&&i!==l.retryLane))throw l.retryLane=i,oc(e,i),rs(a,e,i),dx;hb(o)||Jm(),t=t0(e,t,n)}else hb(o)?(t.flags|=192,t.child=e.child,t=null):(e=l.treeContext,Di=Ys(o.nextSibling),kr=t,jn=!0,Il=null,qs=!1,e!==null&&PF(t,e),t=nb(t,i.children),t.flags|=4096);return t}return r?(xl(),o=i.fallback,r=t.mode,l=e.child,u=l.sibling,i=Io(l,{mode:"hidden",children:i.children}),i.subtreeFlags=l.subtreeFlags&65011712,u!==null?o=Io(u,o):(o=Fu(o,r,n,null),o.flags|=2),o.return=t,i.return=t,i.sibling=o,t.child=i,Cf(null,i),i=t.child,o=e.child.memoizedState,o===null?o=Zy(n):(r=o.cachePool,r!==null?(l=ur._currentValue,r=r.parent!==l?{parent:l,pool:l}:r):r=DF(),o={baseLanes:o.baseLanes|n,cachePool:r}),i.memoizedState=o,i.childLanes=e0(e,a,n),t.memoizedState=Qy,Cf(e.child,i)):(bl(t),n=e.child,e=n.sibling,n=Io(n,{mode:"visible",children:i.children}),n.return=t,n.sibling=null,e!==null&&(a=t.deletions,a===null?(t.deletions=[e],t.flags|=16):a.push(e)),t.child=n,t.memoizedState=null,n)}function nb(e,t){return t=Wm({mode:"visible",children:t},e.mode),t.return=e,e.child=t}function Wm(e,t){return e=ys(22,e,null,t),e.lanes=0,e}function t0(e,t,n){return Ku(t,e.child,null,n),e=nb(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function CA(e,t,n){e.lanes|=t;var i=e.alternate;i!==null&&(i.lanes|=t),Gw(e.return,t,n)}function n0(e,t,n,i,r,s){var a=e.memoizedState;a===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:i,tail:n,tailMode:r,treeForkCount:s}:(a.isBackwards=t,a.rendering=null,a.renderingStartTime=0,a.last=i,a.tail=n,a.tailMode=r,a.treeForkCount=s)}function SB(e,t,n){var i=t.pendingProps,r=i.revealOrder,s=i.tail;i=i.children;var a=Zi.current,o=(a&2)!==0;if(o?(a=a&1|2,t.flags|=128):a&=1,Ai(Zi,a),Ir(e,t,i,n),i=jn?sp:0,!o&&e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&CA(e,n,t);else if(e.tag===19)CA(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}switch(r){case"forwards":for(n=t.child,r=null;n!==null;)e=n.alternate,e!==null&&Um(e)===null&&(r=n),n=n.sibling;n=r,n===null?(r=t.child,t.child=null):(r=n.sibling,n.sibling=null),n0(t,!1,r,n,s,i);break;case"backwards":case"unstable_legacy-backwards":for(n=null,r=t.child,t.child=null;r!==null;){if(e=r.alternate,e!==null&&Um(e)===null){t.child=r;break}e=r.sibling,r.sibling=n,n=r,r=e}n0(t,!0,n,null,s,i);break;case"together":n0(t,!1,null,null,void 0,i);break;default:t.memoizedState=null}return t.child}function No(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),Gl|=t.lanes,!(n&t.childLanes))if(e!==null){if(Dd(e,t,n,!1),(n&t.childLanes)===0)return null}else return null;if(e!==null&&t.child!==e.child)throw Error(rt(153));if(t.child!==null){for(e=t.child,n=Io(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=Io(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function fx(e,t){return e.lanes&t?!0:(e=e.dependencies,!!(e!==null&&zm(e)))}function AK(e,t,n){switch(t.tag){case 3:Pm(t,t.stateNode.containerInfo),wl(t,ur,e.memoizedState.cache),Hu();break;case 27:case 5:Iw(t);break;case 4:Pm(t,t.stateNode.containerInfo);break;case 10:wl(t,t.type,t.memoizedProps.value);break;case 31:if(t.memoizedState!==null)return t.flags|=128,Jw(t),null;break;case 13:var i=t.memoizedState;if(i!==null)return i.dehydrated!==null?(bl(t),t.flags|=128,null):n&t.child.childLanes?EB(e,t,n):(bl(t),e=No(e,t,n),e!==null?e.sibling:null);bl(t);break;case 19:var r=(e.flags&128)!==0;if(i=(n&t.childLanes)!==0,i||(Dd(e,t,n,!1),i=(n&t.childLanes)!==0),r){if(i)return SB(e,t,n);t.flags|=128}if(r=t.memoizedState,r!==null&&(r.rendering=null,r.tail=null,r.lastEffect=null),Ai(Zi,Zi.current),i)break;return null;case 22:return t.lanes=0,MB(e,t,n,t.pendingProps);case 24:wl(t,ur,e.memoizedState.cache)}return No(e,t,n)}function CB(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps)cr=!0;else{if(!fx(e,n)&&!(t.flags&128))return cr=!1,AK(e,t,n);cr=!!(e.flags&131072)}else cr=!1,jn&&t.flags&1048576&&IF(t,sp,t.index);switch(t.lanes=0,t.tag){case 16:e:{var i=t.pendingProps;if(e=Su(t.elementType),t.type=e,typeof e=="function")j1(e)?(i=Yu(e,i),t.tag=1,t=EA(null,t,e,i,n)):(t.tag=0,t=tb(null,t,e,i,n));else{if(e!=null){var r=e.$$typeof;if(r===I1){t.tag=11,t=wA(null,t,e,i,n);break e}else if(r===P1){t.tag=14,t=bA(null,t,e,i,n);break e}}throw t=$w(e)||e,Error(rt(306,t,""))}}return t;case 0:return tb(e,t,t.type,t.pendingProps,n);case 1:return i=t.type,r=Yu(i,t.pendingProps),EA(e,t,i,r,n);case 3:e:{if(Pm(t,t.stateNode.containerInfo),e===null)throw Error(rt(387));i=t.pendingProps;var s=t.memoizedState;r=s.element,Hw(e,t),Wf(t,i,null,n);var a=t.memoizedState;if(i=a.cache,wl(t,ur,i),i!==s.cache&&jw(t,[ur],n,!0),jf(),i=a.element,s.isDehydrated)if(s={element:i,isDehydrated:!1,cache:a.cache},t.updateQueue.baseState=s,t.memoizedState=s,t.flags&256){t=SA(e,t,i,n);break e}else if(i!==r){r=Hs(Error(rt(424)),t),ap(r),t=SA(e,t,i,n);break e}else{switch(e=t.stateNode.containerInfo,e.nodeType){case 9:e=e.body;break;default:e=e.nodeName==="HTML"?e.ownerDocument.body:e}for(Di=Ys(e.firstChild),kr=t,jn=!0,Il=null,qs=!0,n=NF(t,null,i,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling}else{if(Hu(),i===r){t=No(e,t,n);break e}Ir(e,t,i,n)}t=t.child}return t;case 26:return hm(e,t),e===null?(n=qA(t.type,null,t.pendingProps,null))?t.memoizedState=n:jn||(n=t.type,e=t.pendingProps,i=Zm(Al.current).createElement(n),i[Pr]=t,i[ss]=e,Or(i,n,e),Mr(i),t.stateNode=i):t.memoizedState=qA(t.type,e.memoizedProps,t.pendingProps,e.memoizedState),null;case 27:return Iw(t),e===null&&jn&&(i=t.stateNode=_4(t.type,t.pendingProps,Al.current),kr=t,qs=!0,r=Di,ql(t.type)?(gb=r,Di=Ys(i.firstChild)):Di=r),Ir(e,t,t.pendingProps.children,n),hm(e,t),e===null&&(t.flags|=4194304),t.child;case 5:return e===null&&jn&&((r=i=Di)&&(i=s9(i,t.type,t.pendingProps,qs),i!==null?(t.stateNode=i,kr=t,Di=Ys(i.firstChild),qs=!1,r=!0):r=!1),r||Ul(t)),Iw(t),r=t.type,s=t.pendingProps,a=e!==null?e.memoizedProps:null,i=s.children,fb(r,s)?i=null:a!==null&&fb(r,a)&&(t.flags|=32),t.memoizedState!==null&&(r=Z1(e,t,wK,null,null,n),fp._currentValue=r),hm(e,t),Ir(e,t,i,n),t.child;case 6:return e===null&&jn&&((e=n=Di)&&(n=a9(n,t.pendingProps,qs),n!==null?(t.stateNode=n,kr=t,Di=null,e=!0):e=!1),e||Ul(t)),null;case 13:return EB(e,t,n);case 4:return Pm(t,t.stateNode.containerInfo),i=t.pendingProps,e===null?t.child=Ku(t,null,i,n):Ir(e,t,i,n),t.child;case 11:return wA(e,t,t.type,t.pendingProps,n);case 7:return Ir(e,t,t.pendingProps,n),t.child;case 8:return Ir(e,t,t.pendingProps.children,n),t.child;case 12:return Ir(e,t,t.pendingProps.children,n),t.child;case 10:return i=t.pendingProps,wl(t,t.type,i.value),Ir(e,t,i.children,n),t.child;case 9:return r=t.type._context,i=t.pendingProps.children,qu(t),r=Dr(r),i=i(r),t.flags|=1,Ir(e,t,i,n),t.child;case 14:return bA(e,t,t.type,t.pendingProps,n);case 15:return TB(e,t,t.type,t.pendingProps,n);case 19:return SB(e,t,n);case 31:return $K(e,t,n);case 22:return MB(e,t,n,t.pendingProps);case 24:return qu(t),i=Dr(ur),e===null?(r=K1(),r===null&&(r=xi,s=q1(),r.pooledCache=s,s.refCount++,s!==null&&(r.pooledCacheLanes|=n),r=s),t.memoizedState={parent:i,cache:r},Y1(t),wl(t,ur,r)):(e.lanes&n&&(Hw(e,t),Wf(t,null,null,n),jf()),r=e.memoizedState,s=t.memoizedState,r.parent!==i?(r={parent:i,cache:i},t.memoizedState=r,t.lanes===0&&(t.memoizedState=t.updateQueue.baseState=r),wl(t,ur,i)):(i=s.cache,wl(t,ur,i),i!==r.cache&&jw(t,[ur],n,!0))),Ir(e,t,t.pendingProps.children,n),t.child;case 29:throw t.pendingProps}throw Error(rt(156,t.tag))}function go(e){e.flags|=4}function i0(e,t,n,i,r){if((t=(e.mode&32)!==0)&&(t=!1),t){if(e.flags|=16777216,(r&335544128)===r)if(e.stateNode.complete)e.flags|=8192;else if(XB())e.flags|=8192;else throw Uu=Fm,J1}else e.flags&=-16777217}function $A(e,t){if(t.type!=="stylesheet"||t.state.loading&4)e.flags&=-16777217;else if(e.flags|=16777216,!w4(t))if(XB())e.flags|=8192;else throw Uu=Fm,J1}function gh(e,t){t!==null&&(e.flags|=4),e.flags&16384&&(t=e.tag!==22?Qz():536870912,e.lanes|=t,wd|=t)}function Jd(e,t){if(!jn)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var i=null;n!==null;)n.alternate!==null&&(i=n),n=n.sibling;i===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:i.sibling=null}}function ki(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,i=0;if(t)for(var r=e.child;r!==null;)n|=r.lanes|r.childLanes,i|=r.subtreeFlags&65011712,i|=r.flags&65011712,r.return=e,r=r.sibling;else for(r=e.child;r!==null;)n|=r.lanes|r.childLanes,i|=r.subtreeFlags,i|=r.flags,r.return=e,r=r.sibling;return e.subtreeFlags|=i,e.childLanes=n,t}function IK(e,t,n){var i=t.pendingProps;switch(H1(t),t.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ki(t),null;case 1:return ki(t),null;case 3:return n=t.stateNode,i=null,e!==null&&(i=e.memoizedState.cache),t.memoizedState.cache!==i&&(t.flags|=2048),Po(ur),hd(),n.pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),(e===null||e.child===null)&&(Sc(t)?go(t):e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,Ky())),ki(t),null;case 26:var r=t.type,s=t.memoizedState;return e===null?(go(t),s!==null?(ki(t),$A(t,s)):(ki(t),i0(t,r,null,i,n))):s?s!==e.memoizedState?(go(t),ki(t),$A(t,s)):(ki(t),t.flags&=-16777217):(e=e.memoizedProps,e!==i&&go(t),ki(t),i0(t,r,e,i,n)),null;case 27:if(km(t),n=Al.current,r=t.type,e!==null&&t.stateNode!=null)e.memoizedProps!==i&&go(t);else{if(!i){if(t.stateNode===null)throw Error(rt(166));return ki(t),null}e=Qa.current,Sc(t)?iA(t):(e=_4(r,i,n),t.stateNode=e,go(t))}return ki(t),null;case 5:if(km(t),r=t.type,e!==null&&t.stateNode!=null)e.memoizedProps!==i&&go(t);else{if(!i){if(t.stateNode===null)throw Error(rt(166));return ki(t),null}if(s=Qa.current,Sc(t))iA(t);else{var a=Zm(Al.current);switch(s){case 1:s=a.createElementNS("http://www.w3.org/2000/svg",r);break;case 2:s=a.createElementNS("http://www.w3.org/1998/Math/MathML",r);break;default:switch(r){case"svg":s=a.createElementNS("http://www.w3.org/2000/svg",r);break;case"math":s=a.createElementNS("http://www.w3.org/1998/Math/MathML",r);break;case"script":s=a.createElement("div"),s.innerHTML="<script><\/script>",s=s.removeChild(s.firstChild);break;case"select":s=typeof i.is=="string"?a.createElement("select",{is:i.is}):a.createElement("select"),i.multiple?s.multiple=!0:i.size&&(s.size=i.size);break;default:s=typeof i.is=="string"?a.createElement(r,{is:i.is}):a.createElement(r)}}s[Pr]=t,s[ss]=i;e:for(a=t.child;a!==null;){if(a.tag===5||a.tag===6)s.appendChild(a.stateNode);else if(a.tag!==4&&a.tag!==27&&a.child!==null){a.child.return=a,a=a.child;continue}if(a===t)break e;for(;a.sibling===null;){if(a.return===null||a.return===t)break e;a=a.return}a.sibling.return=a.return,a=a.sibling}t.stateNode=s;e:switch(Or(s,r,i),r){case"button":case"input":case"select":case"textarea":i=!!i.autoFocus;break e;case"img":i=!0;break e;default:i=!1}i&&go(t)}}return ki(t),i0(t,t.type,e===null?null:e.memoizedProps,t.pendingProps,n),null;case 6:if(e&&t.stateNode!=null)e.memoizedProps!==i&&go(t);else{if(typeof i!="string"&&t.stateNode===null)throw Error(rt(166));if(e=Al.current,Sc(t)){if(e=t.stateNode,n=t.memoizedProps,i=null,r=kr,r!==null)switch(r.tag){case 27:case 5:i=r.memoizedProps}e[Pr]=t,e=!!(e.nodeValue===n||i!==null&&i.suppressHydrationWarning===!0||p4(e.nodeValue,n)),e||Ul(t,!0)}else e=Zm(e).createTextNode(i),e[Pr]=t,t.stateNode=e}return ki(t),null;case 31:if(n=t.memoizedState,e===null||e.memoizedState!==null){if(i=Sc(t),n!==null){if(e===null){if(!i)throw Error(rt(318));if(e=t.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(rt(557));e[Pr]=t}else Hu(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;ki(t),e=!1}else n=Ky(),e!==null&&e.memoizedState!==null&&(e.memoizedState.hydrationErrors=n),e=!0;if(!e)return t.flags&256?(ms(t),t):(ms(t),null);if(t.flags&128)throw Error(rt(558))}return ki(t),null;case 13:if(i=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(r=Sc(t),i!==null&&i.dehydrated!==null){if(e===null){if(!r)throw Error(rt(318));if(r=t.memoizedState,r=r!==null?r.dehydrated:null,!r)throw Error(rt(317));r[Pr]=t}else Hu(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;ki(t),r=!1}else r=Ky(),e!==null&&e.memoizedState!==null&&(e.memoizedState.hydrationErrors=r),r=!0;if(!r)return t.flags&256?(ms(t),t):(ms(t),null)}return ms(t),t.flags&128?(t.lanes=n,t):(n=i!==null,e=e!==null&&e.memoizedState!==null,n&&(i=t.child,r=null,i.alternate!==null&&i.alternate.memoizedState!==null&&i.alternate.memoizedState.cachePool!==null&&(r=i.alternate.memoizedState.cachePool.pool),s=null,i.memoizedState!==null&&i.memoizedState.cachePool!==null&&(s=i.memoizedState.cachePool.pool),s!==r&&(i.flags|=2048)),n!==e&&n&&(t.child.flags|=8192),gh(t,t.updateQueue),ki(t),null);case 4:return hd(),e===null&&vx(t.stateNode.containerInfo),ki(t),null;case 10:return Po(t.type),ki(t),null;case 19:if(Er(Zi),i=t.memoizedState,i===null)return ki(t),null;if(r=(t.flags&128)!==0,s=i.rendering,s===null)if(r)Jd(i,!1);else{if(Ki!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(s=Um(e),s!==null){for(t.flags|=128,Jd(i,!1),e=s.updateQueue,t.updateQueue=e,gh(t,e),t.subtreeFlags=0,e=n,n=t.child;n!==null;)$F(n,e),n=n.sibling;return Ai(Zi,Zi.current&1|2),jn&&To(t,i.treeForkCount),t.child}e=e.sibling}i.tail!==null&&ws()>qm&&(t.flags|=128,r=!0,Jd(i,!1),t.lanes=4194304)}else{if(!r)if(e=Um(s),e!==null){if(t.flags|=128,r=!0,e=e.updateQueue,t.updateQueue=e,gh(t,e),Jd(i,!0),i.tail===null&&i.tailMode==="hidden"&&!s.alternate&&!jn)return ki(t),null}else 2*ws()-i.renderingStartTime>qm&&n!==536870912&&(t.flags|=128,r=!0,Jd(i,!1),t.lanes=4194304);i.isBackwards?(s.sibling=t.child,t.child=s):(e=i.last,e!==null?e.sibling=s:t.child=s,i.last=s)}return i.tail!==null?(e=i.tail,i.rendering=e,i.tail=e.sibling,i.renderingStartTime=ws(),e.sibling=null,n=Zi.current,Ai(Zi,r?n&1|2:n&1),jn&&To(t,i.treeForkCount),e):(ki(t),null);case 22:case 23:return ms(t),X1(),i=t.memoizedState!==null,e!==null?e.memoizedState!==null!==i&&(t.flags|=8192):i&&(t.flags|=8192),i?n&536870912&&!(t.flags&128)&&(ki(t),t.subtreeFlags&6&&(t.flags|=8192)):ki(t),n=t.updateQueue,n!==null&&gh(t,n.retryQueue),n=null,e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(n=e.memoizedState.cachePool.pool),i=null,t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(i=t.memoizedState.cachePool.pool),i!==n&&(t.flags|=2048),e!==null&&Er(Bu),null;case 24:return n=null,e!==null&&(n=e.memoizedState.cache),t.memoizedState.cache!==n&&(t.flags|=2048),Po(ur),ki(t),null;case 25:return null;case 30:return null}throw Error(rt(156,t.tag))}function PK(e,t){switch(H1(t),t.tag){case 1:return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return Po(ur),hd(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 26:case 27:case 5:return km(t),null;case 31:if(t.memoizedState!==null){if(ms(t),t.alternate===null)throw Error(rt(340));Hu()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 13:if(ms(t),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(rt(340));Hu()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return Er(Zi),null;case 4:return hd(),null;case 10:return Po(t.type),null;case 22:case 23:return ms(t),X1(),e!==null&&Er(Bu),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 24:return Po(ur),null;case 25:return null;default:return null}}function $B(e,t){switch(H1(t),t.tag){case 3:Po(ur),hd();break;case 26:case 27:case 5:km(t);break;case 4:hd();break;case 31:t.memoizedState!==null&&ms(t);break;case 13:ms(t);break;case 19:Er(Zi);break;case 10:Po(t.type);break;case 22:case 23:ms(t),X1(),e!==null&&Er(Bu);break;case 24:Po(ur)}}function Pp(e,t){try{var n=t.updateQueue,i=n!==null?n.lastEffect:null;if(i!==null){var r=i.next;n=r;do{if((n.tag&e)===e){i=void 0;var s=n.create,a=n.inst;i=s(),a.destroy=i}n=n.next}while(n!==r)}}catch(o){fi(t,t.return,o)}}function Vl(e,t,n){try{var i=t.updateQueue,r=i!==null?i.lastEffect:null;if(r!==null){var s=r.next;i=s;do{if((i.tag&e)===e){var a=i.inst,o=a.destroy;if(o!==void 0){a.destroy=void 0,r=t;var l=n,u=o;try{u()}catch(c){fi(r,l,c)}}}i=i.next}while(i!==s)}}catch(c){fi(t,t.return,c)}}function AB(e){var t=e.updateQueue;if(t!==null){var n=e.stateNode;try{zF(t,n)}catch(i){fi(e,e.return,i)}}}function IB(e,t,n){n.props=Yu(e.type,e.memoizedProps),n.state=e.memoizedState;try{n.componentWillUnmount()}catch(i){fi(e,t,i)}}function qf(e,t){try{var n=e.ref;if(n!==null){switch(e.tag){case 26:case 27:case 5:var i=e.stateNode;break;case 30:i=e.stateNode;break;default:i=e.stateNode}typeof n=="function"?e.refCleanup=n(i):n.current=i}}catch(r){fi(e,t,r)}}function Ya(e,t){var n=e.ref,i=e.refCleanup;if(n!==null)if(typeof i=="function")try{i()}catch(r){fi(e,t,r)}finally{e.refCleanup=null,e=e.alternate,e!=null&&(e.refCleanup=null)}else if(typeof n=="function")try{n(null)}catch(r){fi(e,t,r)}else n.current=null}function PB(e){var t=e.type,n=e.memoizedProps,i=e.stateNode;try{e:switch(t){case"button":case"input":case"select":case"textarea":n.autoFocus&&i.focus();break e;case"img":n.src?i.src=n.src:n.srcSet&&(i.srcset=n.srcSet)}}catch(r){fi(e,e.return,r)}}function r0(e,t,n){try{var i=e.stateNode;ZK(i,e.type,n,t),i[ss]=t}catch(r){fi(e,e.return,r)}}function kB(e){return e.tag===5||e.tag===3||e.tag===26||e.tag===27&&ql(e.type)||e.tag===4}function s0(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||kB(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.tag===27&&ql(e.type)||e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function ib(e,t,n){var i=e.tag;if(i===5||i===6)e=e.stateNode,t?(n.nodeType===9?n.body:n.nodeName==="HTML"?n.ownerDocument.body:n).insertBefore(e,t):(t=n.nodeType===9?n.body:n.nodeName==="HTML"?n.ownerDocument.body:n,t.appendChild(e),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=$o));else if(i!==4&&(i===27&&ql(e.type)&&(n=e.stateNode,t=null),e=e.child,e!==null))for(ib(e,t,n),e=e.sibling;e!==null;)ib(e,t,n),e=e.sibling}function Hm(e,t,n){var i=e.tag;if(i===5||i===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(i!==4&&(i===27&&ql(e.type)&&(n=e.stateNode),e=e.child,e!==null))for(Hm(e,t,n),e=e.sibling;e!==null;)Hm(e,t,n),e=e.sibling}function DB(e){var t=e.stateNode,n=e.memoizedProps;try{for(var i=e.type,r=t.attributes;r.length;)t.removeAttributeNode(r[0]);Or(t,i,n),t[Pr]=e,t[ss]=n}catch(s){fi(e,e.return,s)}}var Mo=!1,lr=!1,a0=!1,AA=typeof WeakSet=="function"?WeakSet:Set,Tr=null;function kK(e,t){if(e=e.containerInfo,cb=ig,e=wF(e),U1(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var i=n.getSelection&&n.getSelection();if(i&&i.rangeCount!==0){n=i.anchorNode;var r=i.anchorOffset,s=i.focusNode;i=i.focusOffset;try{n.nodeType,s.nodeType}catch{n=null;break e}var a=0,o=-1,l=-1,u=0,c=0,f=e,d=null;t:for(;;){for(var h;f!==n||r!==0&&f.nodeType!==3||(o=a+r),f!==s||i!==0&&f.nodeType!==3||(l=a+i),f.nodeType===3&&(a+=f.nodeValue.length),(h=f.firstChild)!==null;)d=f,f=h;for(;;){if(f===e)break t;if(d===n&&++u===r&&(o=a),d===s&&++c===i&&(l=a),(h=f.nextSibling)!==null)break;f=d,d=f.parentNode}f=h}n=o===-1||l===-1?null:{start:o,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(db={focusedElem:e,selectionRange:n},ig=!1,Tr=t;Tr!==null;)if(t=Tr,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,Tr=e;else for(;Tr!==null;){switch(t=Tr,s=t.alternate,e=t.flags,t.tag){case 0:if(e&4&&(e=t.updateQueue,e=e!==null?e.events:null,e!==null))for(n=0;n<e.length;n++)r=e[n],r.ref.impl=r.nextImpl;break;case 11:case 15:break;case 1:if(e&1024&&s!==null){e=void 0,n=t,r=s.memoizedProps,s=s.memoizedState,i=n.stateNode;try{var m=Yu(n.type,r);e=i.getSnapshotBeforeUpdate(m,s),i.__reactInternalSnapshotBeforeUpdate=e}catch(y){fi(n,n.return,y)}}break;case 3:if(e&1024){if(e=t.stateNode.containerInfo,n=e.nodeType,n===9)pb(e);else if(n===1)switch(e.nodeName){case"HEAD":case"HTML":case"BODY":pb(e);break;default:e.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if(e&1024)throw Error(rt(163))}if(e=t.sibling,e!==null){e.return=t.return,Tr=e;break}Tr=t.return}}function OB(e,t,n){var i=n.flags;switch(n.tag){case 0:case 11:case 15:yo(e,n),i&4&&Pp(5,n);break;case 1:if(yo(e,n),i&4)if(e=n.stateNode,t===null)try{e.componentDidMount()}catch(a){fi(n,n.return,a)}else{var r=Yu(n.type,t.memoizedProps);t=t.memoizedState;try{e.componentDidUpdate(r,t,e.__reactInternalSnapshotBeforeUpdate)}catch(a){fi(n,n.return,a)}}i&64&&AB(n),i&512&&qf(n,n.return);break;case 3:if(yo(e,n),i&64&&(e=n.updateQueue,e!==null)){if(t=null,n.child!==null)switch(n.child.tag){case 27:case 5:t=n.child.stateNode;break;case 1:t=n.child.stateNode}try{zF(e,t)}catch(a){fi(n,n.return,a)}}break;case 27:t===null&&i&4&&DB(n);case 26:case 5:yo(e,n),t===null&&i&4&&PB(n),i&512&&qf(n,n.return);break;case 12:yo(e,n);break;case 31:yo(e,n),i&4&&LB(e,n);break;case 13:yo(e,n),i&4&&zB(e,n),i&64&&(e=n.memoizedState,e!==null&&(e=e.dehydrated,e!==null&&(n=UK.bind(null,n),o9(e,n))));break;case 22:if(i=n.memoizedState!==null||Mo,!i){t=t!==null&&t.memoizedState!==null||lr,r=Mo;var s=lr;Mo=i,(lr=t)&&!s?xo(e,n,(n.subtreeFlags&8772)!==0):yo(e,n),Mo=r,lr=s}break;case 30:break;default:yo(e,n)}}function RB(e){var t=e.alternate;t!==null&&(e.alternate=null,RB(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&R1(t)),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var Li=null,ns=!1;function _o(e,t,n){for(n=n.child;n!==null;)NB(e,t,n),n=n.sibling}function NB(e,t,n){if(bs&&typeof bs.onCommitFiberUnmount=="function")try{bs.onCommitFiberUnmount(Mp,n)}catch{}switch(n.tag){case 26:lr||Ya(n,t),_o(e,t,n),n.memoizedState?n.memoizedState.count--:n.stateNode&&(n=n.stateNode,n.parentNode.removeChild(n));break;case 27:lr||Ya(n,t);var i=Li,r=ns;ql(n.type)&&(Li=n.stateNode,ns=!1),_o(e,t,n),Xf(n.stateNode),Li=i,ns=r;break;case 5:lr||Ya(n,t);case 6:if(i=Li,r=ns,Li=null,_o(e,t,n),Li=i,ns=r,Li!==null)if(ns)try{(Li.nodeType===9?Li.body:Li.nodeName==="HTML"?Li.ownerDocument.body:Li).removeChild(n.stateNode)}catch(s){fi(n,t,s)}else try{Li.removeChild(n.stateNode)}catch(s){fi(n,t,s)}break;case 18:Li!==null&&(ns?(e=Li,VA(e.nodeType===9?e.body:e.nodeName==="HTML"?e.ownerDocument.body:e,n.stateNode),Md(e)):VA(Li,n.stateNode));break;case 4:i=Li,r=ns,Li=n.stateNode.containerInfo,ns=!0,_o(e,t,n),Li=i,ns=r;break;case 0:case 11:case 14:case 15:Vl(2,n,t),lr||Vl(4,n,t),_o(e,t,n);break;case 1:lr||(Ya(n,t),i=n.stateNode,typeof i.componentWillUnmount=="function"&&IB(n,t,i)),_o(e,t,n);break;case 21:_o(e,t,n);break;case 22:lr=(i=lr)||n.memoizedState!==null,_o(e,t,n),lr=i;break;default:_o(e,t,n)}}function LB(e,t){if(t.memoizedState===null&&(e=t.alternate,e!==null&&(e=e.memoizedState,e!==null))){e=e.dehydrated;try{Md(e)}catch(n){fi(t,t.return,n)}}}function zB(e,t){if(t.memoizedState===null&&(e=t.alternate,e!==null&&(e=e.memoizedState,e!==null&&(e=e.dehydrated,e!==null))))try{Md(e)}catch(n){fi(t,t.return,n)}}function DK(e){switch(e.tag){case 31:case 13:case 19:var t=e.stateNode;return t===null&&(t=e.stateNode=new AA),t;case 22:return e=e.stateNode,t=e._retryCache,t===null&&(t=e._retryCache=new AA),t;default:throw Error(rt(435,e.tag))}}function _h(e,t){var n=DK(e);t.forEach(function(i){if(!n.has(i)){n.add(i);var r=VK.bind(null,e,i);i.then(r,r)}})}function Qr(e,t){var n=t.deletions;if(n!==null)for(var i=0;i<n.length;i++){var r=n[i],s=e,a=t,o=a;e:for(;o!==null;){switch(o.tag){case 27:if(ql(o.type)){Li=o.stateNode,ns=!1;break e}break;case 5:Li=o.stateNode,ns=!1;break e;case 3:case 4:Li=o.stateNode.containerInfo,ns=!0;break e}o=o.return}if(Li===null)throw Error(rt(160));NB(s,a,r),Li=null,ns=!1,s=r.alternate,s!==null&&(s.return=null),r.return=null}if(t.subtreeFlags&13886)for(t=t.child;t!==null;)FB(t,e),t=t.sibling}var ba=null;function FB(e,t){var n=e.alternate,i=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:Qr(t,e),Zr(e),i&4&&(Vl(3,e,e.return),Pp(3,e),Vl(5,e,e.return));break;case 1:Qr(t,e),Zr(e),i&512&&(lr||n===null||Ya(n,n.return)),i&64&&Mo&&(e=e.updateQueue,e!==null&&(i=e.callbacks,i!==null&&(n=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=n===null?i:n.concat(i))));break;case 26:var r=ba;if(Qr(t,e),Zr(e),i&512&&(lr||n===null||Ya(n,n.return)),i&4){var s=n!==null?n.memoizedState:null;if(i=e.memoizedState,n===null)if(i===null)if(e.stateNode===null){e:{i=e.type,n=e.memoizedProps,r=r.ownerDocument||r;t:switch(i){case"title":s=r.getElementsByTagName("title")[0],(!s||s[Cp]||s[Pr]||s.namespaceURI==="http://www.w3.org/2000/svg"||s.hasAttribute("itemprop"))&&(s=r.createElement(i),r.head.insertBefore(s,r.querySelector("head > title"))),Or(s,i,n),s[Pr]=e,Mr(s),i=s;break e;case"link":var a=JA("link","href",r).get(i+(n.href||""));if(a){for(var o=0;o<a.length;o++)if(s=a[o],s.getAttribute("href")===(n.href==null||n.href===""?null:n.href)&&s.getAttribute("rel")===(n.rel==null?null:n.rel)&&s.getAttribute("title")===(n.title==null?null:n.title)&&s.getAttribute("crossorigin")===(n.crossOrigin==null?null:n.crossOrigin)){a.splice(o,1);break t}}s=r.createElement(i),Or(s,i,n),r.head.appendChild(s);break;case"meta":if(a=JA("meta","content",r).get(i+(n.content||""))){for(o=0;o<a.length;o++)if(s=a[o],s.getAttribute("content")===(n.content==null?null:""+n.content)&&s.getAttribute("name")===(n.name==null?null:n.name)&&s.getAttribute("property")===(n.property==null?null:n.property)&&s.getAttribute("http-equiv")===(n.httpEquiv==null?null:n.httpEquiv)&&s.getAttribute("charset")===(n.charSet==null?null:n.charSet)){a.splice(o,1);break t}}s=r.createElement(i),Or(s,i,n),r.head.appendChild(s);break;default:throw Error(rt(468,i))}s[Pr]=e,Mr(s),i=s}e.stateNode=i}else YA(r,e.type,e.stateNode);else e.stateNode=KA(r,i,e.memoizedProps);else s!==i?(s===null?n.stateNode!==null&&(n=n.stateNode,n.parentNode.removeChild(n)):s.count--,i===null?YA(r,e.type,e.stateNode):KA(r,i,e.memoizedProps)):i===null&&e.stateNode!==null&&r0(e,e.memoizedProps,n.memoizedProps)}break;case 27:Qr(t,e),Zr(e),i&512&&(lr||n===null||Ya(n,n.return)),n!==null&&i&4&&r0(e,e.memoizedProps,n.memoizedProps);break;case 5:if(Qr(t,e),Zr(e),i&512&&(lr||n===null||Ya(n,n.return)),e.flags&32){r=e.stateNode;try{gd(r,"")}catch(m){fi(e,e.return,m)}}i&4&&e.stateNode!=null&&(r=e.memoizedProps,r0(e,r,n!==null?n.memoizedProps:r)),i&1024&&(a0=!0);break;case 6:if(Qr(t,e),Zr(e),i&4){if(e.stateNode===null)throw Error(rt(162));i=e.memoizedProps,n=e.stateNode;try{n.nodeValue=i}catch(m){fi(e,e.return,m)}}break;case 3:if(_m=null,r=ba,ba=eg(t.containerInfo),Qr(t,e),ba=r,Zr(e),i&4&&n!==null&&n.memoizedState.isDehydrated)try{Md(t.containerInfo)}catch(m){fi(e,e.return,m)}a0&&(a0=!1,BB(e));break;case 4:i=ba,ba=eg(e.stateNode.containerInfo),Qr(t,e),Zr(e),ba=i;break;case 12:Qr(t,e),Zr(e);break;case 31:Qr(t,e),Zr(e),i&4&&(i=e.updateQueue,i!==null&&(e.updateQueue=null,_h(e,i)));break;case 13:Qr(t,e),Zr(e),e.child.flags&8192&&e.memoizedState!==null!=(n!==null&&n.memoizedState!==null)&&(Hg=ws()),i&4&&(i=e.updateQueue,i!==null&&(e.updateQueue=null,_h(e,i)));break;case 22:r=e.memoizedState!==null;var l=n!==null&&n.memoizedState!==null,u=Mo,c=lr;if(Mo=u||r,lr=c||l,Qr(t,e),lr=c,Mo=u,Zr(e),i&8192)e:for(t=e.stateNode,t._visibility=r?t._visibility&-2:t._visibility|1,r&&(n===null||l||Mo||lr||Cu(e)),n=null,t=e;;){if(t.tag===5||t.tag===26){if(n===null){l=n=t;try{if(s=l.stateNode,r)a=s.style,typeof a.setProperty=="function"?a.setProperty("display","none","important"):a.display="none";else{o=l.stateNode;var f=l.memoizedProps.style,d=f!=null&&f.hasOwnProperty("display")?f.display:null;o.style.display=d==null||typeof d=="boolean"?"":(""+d).trim()}}catch(m){fi(l,l.return,m)}}}else if(t.tag===6){if(n===null){l=t;try{l.stateNode.nodeValue=r?"":l.memoizedProps}catch(m){fi(l,l.return,m)}}}else if(t.tag===18){if(n===null){l=t;try{var h=l.stateNode;r?GA(h,!0):GA(l.stateNode,!1)}catch(m){fi(l,l.return,m)}}}else if((t.tag!==22&&t.tag!==23||t.memoizedState===null||t===e)&&t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;t.sibling===null;){if(t.return===null||t.return===e)break e;n===t&&(n=null),t=t.return}n===t&&(n=null),t.sibling.return=t.return,t=t.sibling}i&4&&(i=e.updateQueue,i!==null&&(n=i.retryQueue,n!==null&&(i.retryQueue=null,_h(e,n))));break;case 19:Qr(t,e),Zr(e),i&4&&(i=e.updateQueue,i!==null&&(e.updateQueue=null,_h(e,i)));break;case 30:break;case 21:break;default:Qr(t,e),Zr(e)}}function Zr(e){var t=e.flags;if(t&2){try{for(var n,i=e.return;i!==null;){if(kB(i)){n=i;break}i=i.return}if(n==null)throw Error(rt(160));switch(n.tag){case 27:var r=n.stateNode,s=s0(e);Hm(e,s,r);break;case 5:var a=n.stateNode;n.flags&32&&(gd(a,""),n.flags&=-33);var o=s0(e);Hm(e,o,a);break;case 3:case 4:var l=n.stateNode.containerInfo,u=s0(e);ib(e,u,l);break;default:throw Error(rt(161))}}catch(c){fi(e,e.return,c)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function BB(e){if(e.subtreeFlags&1024)for(e=e.child;e!==null;){var t=e;BB(t),t.tag===5&&t.flags&1024&&t.stateNode.reset(),e=e.sibling}}function yo(e,t){if(t.subtreeFlags&8772)for(t=t.child;t!==null;)OB(e,t.alternate,t),t=t.sibling}function Cu(e){for(e=e.child;e!==null;){var t=e;switch(t.tag){case 0:case 11:case 14:case 15:Vl(4,t,t.return),Cu(t);break;case 1:Ya(t,t.return);var n=t.stateNode;typeof n.componentWillUnmount=="function"&&IB(t,t.return,n),Cu(t);break;case 27:Xf(t.stateNode);case 26:case 5:Ya(t,t.return),Cu(t);break;case 22:t.memoizedState===null&&Cu(t);break;case 30:Cu(t);break;default:Cu(t)}e=e.sibling}}function xo(e,t,n){for(n=n&&(t.subtreeFlags&8772)!==0,t=t.child;t!==null;){var i=t.alternate,r=e,s=t,a=s.flags;switch(s.tag){case 0:case 11:case 15:xo(r,s,n),Pp(4,s);break;case 1:if(xo(r,s,n),i=s,r=i.stateNode,typeof r.componentDidMount=="function")try{r.componentDidMount()}catch(u){fi(i,i.return,u)}if(i=s,r=i.updateQueue,r!==null){var o=i.stateNode;try{var l=r.shared.hiddenCallbacks;if(l!==null)for(r.shared.hiddenCallbacks=null,r=0;r<l.length;r++)LF(l[r],o)}catch(u){fi(i,i.return,u)}}n&&a&64&&AB(s),qf(s,s.return);break;case 27:DB(s);case 26:case 5:xo(r,s,n),n&&i===null&&a&4&&PB(s),qf(s,s.return);break;case 12:xo(r,s,n);break;case 31:xo(r,s,n),n&&a&4&&LB(r,s);break;case 13:xo(r,s,n),n&&a&4&&zB(r,s);break;case 22:s.memoizedState===null&&xo(r,s,n),qf(s,s.return);break;case 30:break;default:xo(r,s,n)}t=t.sibling}}function px(e,t){var n=null;e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(n=e.memoizedState.cachePool.pool),e=null,t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(e=t.memoizedState.cachePool.pool),e!==n&&(e!=null&&e.refCount++,n!=null&&Ap(n))}function hx(e,t){e=null,t.alternate!==null&&(e=t.alternate.memoizedState.cache),t=t.memoizedState.cache,t!==e&&(t.refCount++,e!=null&&Ap(e))}function ca(e,t,n,i){if(t.subtreeFlags&10256)for(t=t.child;t!==null;)UB(e,t,n,i),t=t.sibling}function UB(e,t,n,i){var r=t.flags;switch(t.tag){case 0:case 11:case 15:ca(e,t,n,i),r&2048&&Pp(9,t);break;case 1:ca(e,t,n,i);break;case 3:ca(e,t,n,i),r&2048&&(e=null,t.alternate!==null&&(e=t.alternate.memoizedState.cache),t=t.memoizedState.cache,t!==e&&(t.refCount++,e!=null&&Ap(e)));break;case 12:if(r&2048){ca(e,t,n,i),e=t.stateNode;try{var s=t.memoizedProps,a=s.id,o=s.onPostCommit;typeof o=="function"&&o(a,t.alternate===null?"mount":"update",e.passiveEffectDuration,-0)}catch(l){fi(t,t.return,l)}}else ca(e,t,n,i);break;case 31:ca(e,t,n,i);break;case 13:ca(e,t,n,i);break;case 23:break;case 22:s=t.stateNode,a=t.alternate,t.memoizedState!==null?s._visibility&2?ca(e,t,n,i):Kf(e,t):s._visibility&2?ca(e,t,n,i):(s._visibility|=2,Nc(e,t,n,i,(t.subtreeFlags&10256)!==0||!1)),r&2048&&px(a,t);break;case 24:ca(e,t,n,i),r&2048&&hx(t.alternate,t);break;default:ca(e,t,n,i)}}function Nc(e,t,n,i,r){for(r=r&&((t.subtreeFlags&10256)!==0||!1),t=t.child;t!==null;){var s=e,a=t,o=n,l=i,u=a.flags;switch(a.tag){case 0:case 11:case 15:Nc(s,a,o,l,r),Pp(8,a);break;case 23:break;case 22:var c=a.stateNode;a.memoizedState!==null?c._visibility&2?Nc(s,a,o,l,r):Kf(s,a):(c._visibility|=2,Nc(s,a,o,l,r)),r&&u&2048&&px(a.alternate,a);break;case 24:Nc(s,a,o,l,r),r&&u&2048&&hx(a.alternate,a);break;default:Nc(s,a,o,l,r)}t=t.sibling}}function Kf(e,t){if(t.subtreeFlags&10256)for(t=t.child;t!==null;){var n=e,i=t,r=i.flags;switch(i.tag){case 22:Kf(n,i),r&2048&&px(i.alternate,i);break;case 24:Kf(n,i),r&2048&&hx(i.alternate,i);break;default:Kf(n,i)}t=t.sibling}}var $f=8192;function Cc(e,t,n){if(e.subtreeFlags&$f)for(e=e.child;e!==null;)VB(e,t,n),e=e.sibling}function VB(e,t,n){switch(e.tag){case 26:Cc(e,t,n),e.flags&$f&&e.memoizedState!==null&&v9(n,ba,e.memoizedState,e.memoizedProps);break;case 5:Cc(e,t,n);break;case 3:case 4:var i=ba;ba=eg(e.stateNode.containerInfo),Cc(e,t,n),ba=i;break;case 22:e.memoizedState===null&&(i=e.alternate,i!==null&&i.memoizedState!==null?(i=$f,$f=16777216,Cc(e,t,n),$f=i):Cc(e,t,n));break;default:Cc(e,t,n)}}function GB(e){var t=e.alternate;if(t!==null&&(e=t.child,e!==null)){t.child=null;do t=e.sibling,e.sibling=null,e=t;while(e!==null)}}function Yd(e){var t=e.deletions;if(e.flags&16){if(t!==null)for(var n=0;n<t.length;n++){var i=t[n];Tr=i,WB(i,e)}GB(e)}if(e.subtreeFlags&10256)for(e=e.child;e!==null;)jB(e),e=e.sibling}function jB(e){switch(e.tag){case 0:case 11:case 15:Yd(e),e.flags&2048&&Vl(9,e,e.return);break;case 3:Yd(e);break;case 12:Yd(e);break;case 22:var t=e.stateNode;e.memoizedState!==null&&t._visibility&2&&(e.return===null||e.return.tag!==13)?(t._visibility&=-3,mm(e)):Yd(e);break;default:Yd(e)}}function mm(e){var t=e.deletions;if(e.flags&16){if(t!==null)for(var n=0;n<t.length;n++){var i=t[n];Tr=i,WB(i,e)}GB(e)}for(e=e.child;e!==null;){switch(t=e,t.tag){case 0:case 11:case 15:Vl(8,t,t.return),mm(t);break;case 22:n=t.stateNode,n._visibility&2&&(n._visibility&=-3,mm(t));break;default:mm(t)}e=e.sibling}}function WB(e,t){for(;Tr!==null;){var n=Tr;switch(n.tag){case 0:case 11:case 15:Vl(8,n,t);break;case 23:case 22:if(n.memoizedState!==null&&n.memoizedState.cachePool!==null){var i=n.memoizedState.cachePool.pool;i!=null&&i.refCount++}break;case 24:Ap(n.memoizedState.cache)}if(i=n.child,i!==null)i.return=n,Tr=i;else e:for(n=e;Tr!==null;){i=Tr;var r=i.sibling,s=i.return;if(RB(i),i===n){Tr=null;break e}if(r!==null){r.return=s,Tr=r;break e}Tr=s}}}var OK={getCacheForType:function(e){var t=Dr(ur),n=t.data.get(e);return n===void 0&&(n=e(),t.data.set(e,n)),n},cacheSignal:function(){return Dr(ur).controller.signal}},RK=typeof WeakMap=="function"?WeakMap:Map,si=0,xi=null,Rn=null,Fn=0,di=0,hs=null,Sl=!1,Rd=!1,mx=!1,Lo=0,Ki=0,Gl=0,Vu=0,gx=0,vs=0,wd=0,Jf=null,is=null,rb=!1,Hg=0,HB=0,qm=1/0,Km=null,Dl=null,pr=0,Ol=null,bd=null,ko=0,sb=0,ab=null,qB=null,Yf=0,ob=null;function Ts(){return si&2&&Fn!==0?Fn&-Fn:on.T!==null?yx():nF()}function KB(){if(vs===0)if(!(Fn&536870912)||jn){var e=uh;uh<<=1,!(uh&3932160)&&(uh=262144),vs=e}else vs=536870912;return e=Cs.current,e!==null&&(e.flags|=32),vs}function rs(e,t,n){(e===xi&&(di===2||di===9)||e.cancelPendingCommit!==null)&&(xd(e,0),Cl(e,Fn,vs,!1)),Sp(e,n),(!(si&2)||e!==xi)&&(e===xi&&(!(si&2)&&(Vu|=n),Ki===4&&Cl(e,Fn,vs,!1)),to(e))}function JB(e,t,n){if(si&6)throw Error(rt(327));var i=!n&&(t&127)===0&&(t&e.expiredLanes)===0||Ep(e,t),r=i?zK(e,t):o0(e,t,!0),s=i;do{if(r===0){Rd&&!i&&Cl(e,t,0,!1);break}else{if(n=e.current.alternate,s&&!NK(n)){r=o0(e,t,!1),s=!1;continue}if(r===2){if(s=t,e.errorRecoveryDisabledLanes&s)var a=0;else a=e.pendingLanes&-536870913,a=a!==0?a:a&536870912?536870912:0;if(a!==0){t=a;e:{var o=e;r=Jf;var l=o.current.memoizedState.isDehydrated;if(l&&(xd(o,a).flags|=256),a=o0(o,a,!1),a!==2){if(mx&&!l){o.errorRecoveryDisabledLanes|=s,Vu|=s,r=4;break e}s=is,is=r,s!==null&&(is===null?is=s:is.push.apply(is,s))}r=a}if(s=!1,r!==2)continue}}if(r===1){xd(e,0),Cl(e,t,0,!0);break}e:{switch(i=e,s=r,s){case 0:case 1:throw Error(rt(345));case 4:if((t&4194048)!==t)break;case 6:Cl(i,t,vs,!Sl);break e;case 2:is=null;break;case 3:case 5:break;default:throw Error(rt(329))}if((t&62914560)===t&&(r=Hg+300-ws(),10<r)){if(Cl(i,t,vs,!Sl),Rg(i,0,!0)!==0)break e;ko=t,i.timeoutHandle=m4(IA.bind(null,i,n,is,Km,rb,t,vs,Vu,wd,Sl,s,"Throttled",-0,0),r);break e}IA(i,n,is,Km,rb,t,vs,Vu,wd,Sl,s,null,-0,0)}}break}while(!0);to(e)}function IA(e,t,n,i,r,s,a,o,l,u,c,f,d,h){if(e.timeoutHandle=-1,f=t.subtreeFlags,f&8192||(f&16785408)===16785408){f={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:$o},VB(t,s,f);var m=(s&62914560)===s?Hg-ws():(s&4194048)===s?HB-ws():0;if(m=w9(f,m),m!==null){ko=s,e.cancelPendingCommit=m(kA.bind(null,e,t,s,n,i,r,a,o,l,c,f,null,d,h)),Cl(e,s,a,!u);return}}kA(e,t,s,n,i,r,a,o,l)}function NK(e){for(var t=e;;){var n=t.tag;if((n===0||n===11||n===15)&&t.flags&16384&&(n=t.updateQueue,n!==null&&(n=n.stores,n!==null)))for(var i=0;i<n.length;i++){var r=n[i],s=r.getSnapshot;r=r.value;try{if(!Ss(s(),r))return!1}catch{return!1}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Cl(e,t,n,i){t&=~gx,t&=~Vu,e.suspendedLanes|=t,e.pingedLanes&=~t,i&&(e.warmLanes|=t),i=e.expirationTimes;for(var r=t;0<r;){var s=31-xs(r),a=1<<s;i[s]=-1,r&=~a}n!==0&&Zz(e,n,t)}function qg(){return si&6?!0:(kp(0),!1)}function _x(){if(Rn!==null){if(di===0)var e=Rn.return;else e=Rn,Ao=lc=null,nx(e),ud=null,op=0,e=Rn;for(;e!==null;)$B(e.alternate,e),e=e.return;Rn=null}}function xd(e,t){var n=e.timeoutHandle;n!==-1&&(e.timeoutHandle=-1,n9(n)),n=e.cancelPendingCommit,n!==null&&(e.cancelPendingCommit=null,n()),ko=0,_x(),xi=e,Rn=n=Io(e.current,null),Fn=t,di=0,hs=null,Sl=!1,Rd=Ep(e,t),mx=!1,wd=vs=gx=Vu=Gl=Ki=0,is=Jf=null,rb=!1,t&8&&(t|=t&32);var i=e.entangledLanes;if(i!==0)for(e=e.entanglements,i&=t;0<i;){var r=31-xs(i),s=1<<r;t|=e[r],i&=~s}return Lo=t,Fg(),n}function YB(e,t){xn=null,on.H=up,t===Od||t===Ug?(t=lA(),di=3):t===J1?(t=lA(),di=4):di=t===dx?8:t!==null&&typeof t=="object"&&typeof t.then=="function"?6:1,hs=t,Rn===null&&(Ki=1,jm(e,Hs(t,e.current)))}function XB(){var e=Cs.current;return e===null?!0:(Fn&4194048)===Fn?Js===null:(Fn&62914560)===Fn||Fn&536870912?e===Js:!1}function QB(){var e=on.H;return on.H=up,e===null?up:e}function ZB(){var e=on.A;return on.A=OK,e}function Jm(){Ki=4,Sl||(Fn&4194048)!==Fn&&Cs.current!==null||(Rd=!0),!(Gl&134217727)&&!(Vu&134217727)||xi===null||Cl(xi,Fn,vs,!1)}function o0(e,t,n){var i=si;si|=2;var r=QB(),s=ZB();(xi!==e||Fn!==t)&&(Km=null,xd(e,t)),t=!1;var a=Ki;e:do try{if(di!==0&&Rn!==null){var o=Rn,l=hs;switch(di){case 8:_x(),a=6;break e;case 3:case 2:case 9:case 6:Cs.current===null&&(t=!0);var u=di;if(di=0,hs=null,Qc(e,o,l,u),n&&Rd){a=0;break e}break;default:u=di,di=0,hs=null,Qc(e,o,l,u)}}LK(),a=Ki;break}catch(c){YB(e,c)}while(!0);return t&&e.shellSuspendCounter++,Ao=lc=null,si=i,on.H=r,on.A=s,Rn===null&&(xi=null,Fn=0,Fg()),a}function LK(){for(;Rn!==null;)e4(Rn)}function zK(e,t){var n=si;si|=2;var i=QB(),r=ZB();xi!==e||Fn!==t?(Km=null,qm=ws()+500,xd(e,t)):Rd=Ep(e,t);e:do try{if(di!==0&&Rn!==null){t=Rn;var s=hs;t:switch(di){case 1:di=0,hs=null,Qc(e,t,s,1);break;case 2:case 9:if(oA(s)){di=0,hs=null,PA(t);break}t=function(){di!==2&&di!==9||xi!==e||(di=7),to(e)},s.then(t,t);break e;case 3:di=7;break e;case 4:di=5;break e;case 7:oA(s)?(di=0,hs=null,PA(t)):(di=0,hs=null,Qc(e,t,s,7));break;case 5:var a=null;switch(Rn.tag){case 26:a=Rn.memoizedState;case 5:case 27:var o=Rn;if(a?w4(a):o.stateNode.complete){di=0,hs=null;var l=o.sibling;if(l!==null)Rn=l;else{var u=o.return;u!==null?(Rn=u,Kg(u)):Rn=null}break t}}di=0,hs=null,Qc(e,t,s,5);break;case 6:di=0,hs=null,Qc(e,t,s,6);break;case 8:_x(),Ki=6;break e;default:throw Error(rt(462))}}FK();break}catch(c){YB(e,c)}while(!0);return Ao=lc=null,on.H=i,on.A=r,si=n,Rn!==null?0:(xi=null,Fn=0,Fg(),Ki)}function FK(){for(;Rn!==null&&!lq();)e4(Rn)}function e4(e){var t=CB(e.alternate,e,Lo);e.memoizedProps=e.pendingProps,t===null?Kg(e):Rn=t}function PA(e){var t=e,n=t.alternate;switch(t.tag){case 15:case 0:t=MA(n,t,t.pendingProps,t.type,void 0,Fn);break;case 11:t=MA(n,t,t.pendingProps,t.type.render,t.ref,Fn);break;case 5:nx(t);default:$B(n,t),t=Rn=$F(t,Lo),t=CB(n,t,Lo)}e.memoizedProps=e.pendingProps,t===null?Kg(e):Rn=t}function Qc(e,t,n,i){Ao=lc=null,nx(t),ud=null,op=0;var r=t.return;try{if(CK(e,r,t,n,Fn)){Ki=1,jm(e,Hs(n,e.current)),Rn=null;return}}catch(s){if(r!==null)throw Rn=r,s;Ki=1,jm(e,Hs(n,e.current)),Rn=null;return}t.flags&32768?(jn||i===1?e=!0:Rd||Fn&536870912?e=!1:(Sl=e=!0,(i===2||i===9||i===3||i===6)&&(i=Cs.current,i!==null&&i.tag===13&&(i.flags|=16384))),t4(t,e)):Kg(t)}function Kg(e){var t=e;do{if(t.flags&32768){t4(t,Sl);return}e=t.return;var n=IK(t.alternate,t,Lo);if(n!==null){Rn=n;return}if(t=t.sibling,t!==null){Rn=t;return}Rn=t=e}while(t!==null);Ki===0&&(Ki=5)}function t4(e,t){do{var n=PK(e.alternate,e);if(n!==null){n.flags&=32767,Rn=n;return}if(n=e.return,n!==null&&(n.flags|=32768,n.subtreeFlags=0,n.deletions=null),!t&&(e=e.sibling,e!==null)){Rn=e;return}Rn=e=n}while(e!==null);Ki=6,Rn=null}function kA(e,t,n,i,r,s,a,o,l){e.cancelPendingCommit=null;do Jg();while(pr!==0);if(si&6)throw Error(rt(327));if(t!==null){if(t===e.current)throw Error(rt(177));if(s=t.lanes|t.childLanes,s|=V1,yq(e,n,s,a,o,l),e===xi&&(Rn=xi=null,Fn=0),bd=t,Ol=e,ko=n,sb=s,ab=r,qB=i,t.subtreeFlags&10256||t.flags&10256?(e.callbackNode=null,e.callbackPriority=0,GK(Dm,function(){return a4(),null})):(e.callbackNode=null,e.callbackPriority=0),i=(t.flags&13878)!==0,t.subtreeFlags&13878||i){i=on.T,on.T=null,r=ai.p,ai.p=2,a=si,si|=4;try{kK(e,t,n)}finally{si=a,ai.p=r,on.T=i}}pr=1,n4(),i4(),r4()}}function n4(){if(pr===1){pr=0;var e=Ol,t=bd,n=(t.flags&13878)!==0;if(t.subtreeFlags&13878||n){n=on.T,on.T=null;var i=ai.p;ai.p=2;var r=si;si|=4;try{FB(t,e);var s=db,a=wF(e.containerInfo),o=s.focusedElem,l=s.selectionRange;if(a!==o&&o&&o.ownerDocument&&vF(o.ownerDocument.documentElement,o)){if(l!==null&&U1(o)){var u=l.start,c=l.end;if(c===void 0&&(c=u),"selectionStart"in o)o.selectionStart=u,o.selectionEnd=Math.min(c,o.value.length);else{var f=o.ownerDocument||document,d=f&&f.defaultView||window;if(d.getSelection){var h=d.getSelection(),m=o.textContent.length,y=Math.min(l.start,m),M=l.end===void 0?y:Math.min(l.end,m);!h.extend&&y>M&&(a=M,M=y,y=a);var g=eA(o,y),_=eA(o,M);if(g&&_&&(h.rangeCount!==1||h.anchorNode!==g.node||h.anchorOffset!==g.offset||h.focusNode!==_.node||h.focusOffset!==_.offset)){var T=f.createRange();T.setStart(g.node,g.offset),h.removeAllRanges(),y>M?(h.addRange(T),h.extend(_.node,_.offset)):(T.setEnd(_.node,_.offset),h.addRange(T))}}}}for(f=[],h=o;h=h.parentNode;)h.nodeType===1&&f.push({element:h,left:h.scrollLeft,top:h.scrollTop});for(typeof o.focus=="function"&&o.focus(),o=0;o<f.length;o++){var x=f[o];x.element.scrollLeft=x.left,x.element.scrollTop=x.top}}ig=!!cb,db=cb=null}finally{si=r,ai.p=i,on.T=n}}e.current=t,pr=2}}function i4(){if(pr===2){pr=0;var e=Ol,t=bd,n=(t.flags&8772)!==0;if(t.subtreeFlags&8772||n){n=on.T,on.T=null;var i=ai.p;ai.p=2;var r=si;si|=4;try{OB(e,t.alternate,t)}finally{si=r,ai.p=i,on.T=n}}pr=3}}function r4(){if(pr===4||pr===3){pr=0,uq();var e=Ol,t=bd,n=ko,i=qB;t.subtreeFlags&10256||t.flags&10256?pr=5:(pr=0,bd=Ol=null,s4(e,e.pendingLanes));var r=e.pendingLanes;if(r===0&&(Dl=null),O1(n),t=t.stateNode,bs&&typeof bs.onCommitFiberRoot=="function")try{bs.onCommitFiberRoot(Mp,t,void 0,(t.current.flags&128)===128)}catch{}if(i!==null){t=on.T,r=ai.p,ai.p=2,on.T=null;try{for(var s=e.onRecoverableError,a=0;a<i.length;a++){var o=i[a];s(o.value,{componentStack:o.stack})}}finally{on.T=t,ai.p=r}}ko&3&&Jg(),to(e),r=e.pendingLanes,n&261930&&r&42?e===ob?Yf++:(Yf=0,ob=e):Yf=0,kp(0)}}function s4(e,t){(e.pooledCacheLanes&=t)===0&&(t=e.pooledCache,t!=null&&(e.pooledCache=null,Ap(t)))}function Jg(){return n4(),i4(),r4(),a4()}function a4(){if(pr!==5)return!1;var e=Ol,t=sb;sb=0;var n=O1(ko),i=on.T,r=ai.p;try{ai.p=32>n?32:n,on.T=null,n=ab,ab=null;var s=Ol,a=ko;if(pr=0,bd=Ol=null,ko=0,si&6)throw Error(rt(331));var o=si;if(si|=4,jB(s.current),UB(s,s.current,a,n),si=o,kp(0,!1),bs&&typeof bs.onPostCommitFiberRoot=="function")try{bs.onPostCommitFiberRoot(Mp,s)}catch{}return!0}finally{ai.p=r,on.T=i,s4(e,t)}}function DA(e,t,n){t=Hs(n,t),t=eb(e.stateNode,t,2),e=kl(e,t,2),e!==null&&(Sp(e,2),to(e))}function fi(e,t,n){if(e.tag===3)DA(e,e,n);else for(;t!==null;){if(t.tag===3){DA(t,e,n);break}else if(t.tag===1){var i=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof i.componentDidCatch=="function"&&(Dl===null||!Dl.has(i))){e=Hs(n,e),n=bB(2),i=kl(t,n,2),i!==null&&(xB(n,i,t,e),Sp(i,2),to(i));break}}t=t.return}}function l0(e,t,n){var i=e.pingCache;if(i===null){i=e.pingCache=new RK;var r=new Set;i.set(t,r)}else r=i.get(t),r===void 0&&(r=new Set,i.set(t,r));r.has(n)||(mx=!0,r.add(n),e=BK.bind(null,e,t,n),t.then(e,e))}function BK(e,t,n){var i=e.pingCache;i!==null&&i.delete(t),e.pingedLanes|=e.suspendedLanes&n,e.warmLanes&=~n,xi===e&&(Fn&n)===n&&(Ki===4||Ki===3&&(Fn&62914560)===Fn&&300>ws()-Hg?!(si&2)&&xd(e,0):gx|=n,wd===Fn&&(wd=0)),to(e)}function o4(e,t){t===0&&(t=Qz()),e=oc(e,t),e!==null&&(Sp(e,t),to(e))}function UK(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),o4(e,n)}function VK(e,t){var n=0;switch(e.tag){case 31:case 13:var i=e.stateNode,r=e.memoizedState;r!==null&&(n=r.retryLane);break;case 19:i=e.stateNode;break;case 22:i=e.stateNode._retryCache;break;default:throw Error(rt(314))}i!==null&&i.delete(t),o4(e,n)}function GK(e,t){return k1(e,t)}var Ym=null,Lc=null,lb=!1,Xm=!1,u0=!1,$l=0;function to(e){e!==Lc&&e.next===null&&(Lc===null?Ym=Lc=e:Lc=Lc.next=e),Xm=!0,lb||(lb=!0,WK())}function kp(e,t){if(!u0&&Xm){u0=!0;do for(var n=!1,i=Ym;i!==null;){if(e!==0){var r=i.pendingLanes;if(r===0)var s=0;else{var a=i.suspendedLanes,o=i.pingedLanes;s=(1<<31-xs(42|e)+1)-1,s&=r&~(a&~o),s=s&201326741?s&201326741|1:s?s|2:0}s!==0&&(n=!0,OA(i,s))}else s=Fn,s=Rg(i,i===xi?s:0,i.cancelPendingCommit!==null||i.timeoutHandle!==-1),!(s&3)||Ep(i,s)||(n=!0,OA(i,s));i=i.next}while(n);u0=!1}}function jK(){l4()}function l4(){Xm=lb=!1;var e=0;$l!==0&&t9()&&(e=$l);for(var t=ws(),n=null,i=Ym;i!==null;){var r=i.next,s=u4(i,t);s===0?(i.next=null,n===null?Ym=r:n.next=r,r===null&&(Lc=n)):(n=i,(e!==0||s&3)&&(Xm=!0)),i=r}pr!==0&&pr!==5||kp(e),$l!==0&&($l=0)}function u4(e,t){for(var n=e.suspendedLanes,i=e.pingedLanes,r=e.expirationTimes,s=e.pendingLanes&-62914561;0<s;){var a=31-xs(s),o=1<<a,l=r[a];l===-1?(!(o&n)||o&i)&&(r[a]=_q(o,t)):l<=t&&(e.expiredLanes|=o),s&=~o}if(t=xi,n=Fn,n=Rg(e,e===t?n:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),i=e.callbackNode,n===0||e===t&&(di===2||di===9)||e.cancelPendingCommit!==null)return i!==null&&i!==null&&Ly(i),e.callbackNode=null,e.callbackPriority=0;if(!(n&3)||Ep(e,n)){if(t=n&-n,t===e.callbackPriority)return t;switch(i!==null&&Ly(i),O1(n)){case 2:case 8:n=Yz;break;case 32:n=Dm;break;case 268435456:n=Xz;break;default:n=Dm}return i=c4.bind(null,e),n=k1(n,i),e.callbackPriority=t,e.callbackNode=n,t}return i!==null&&i!==null&&Ly(i),e.callbackPriority=2,e.callbackNode=null,2}function c4(e,t){if(pr!==0&&pr!==5)return e.callbackNode=null,e.callbackPriority=0,null;var n=e.callbackNode;if(Jg()&&e.callbackNode!==n)return null;var i=Fn;return i=Rg(e,e===xi?i:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),i===0?null:(JB(e,i,t),u4(e,ws()),e.callbackNode!=null&&e.callbackNode===n?c4.bind(null,e):null)}function OA(e,t){if(Jg())return null;JB(e,t,!0)}function WK(){i9(function(){si&6?k1(Jz,jK):l4()})}function yx(){if($l===0){var e=_d;e===0&&(e=lh,lh<<=1,!(lh&261888)&&(lh=256)),$l=e}return $l}function RA(e){return e==null||typeof e=="symbol"||typeof e=="boolean"?null:typeof e=="function"?e:am(""+e)}function NA(e,t){var n=t.ownerDocument.createElement("input");return n.name=t.name,n.value=t.value,e.id&&n.setAttribute("form",e.id),t.parentNode.insertBefore(n,t),e=new FormData(e),n.parentNode.removeChild(n),e}function HK(e,t,n,i,r){if(t==="submit"&&n&&n.stateNode===r){var s=RA((r[ss]||null).action),a=i.submitter;a&&(t=(t=a[ss]||null)?RA(t.formAction):a.getAttribute("formAction"),t!==null&&(s=t,a=null));var o=new Ng("action","action",null,i,r);e.push({event:o,listeners:[{instance:null,listener:function(){if(i.defaultPrevented){if($l!==0){var l=a?NA(r,a):new FormData(r);Qw(n,{pending:!0,data:l,method:r.method,action:s},null,l)}}else typeof s=="function"&&(o.preventDefault(),l=a?NA(r,a):new FormData(r),Qw(n,{pending:!0,data:l,method:r.method,action:s},s,l))},currentTarget:r}]})}}for(var c0=0;c0<Bw.length;c0++){var d0=Bw[c0],qK=d0.toLowerCase(),KK=d0[0].toUpperCase()+d0.slice(1);ka(qK,"on"+KK)}ka(xF,"onAnimationEnd");ka(TF,"onAnimationIteration");ka(MF,"onAnimationStart");ka("dblclick","onDoubleClick");ka("focusin","onFocus");ka("focusout","onBlur");ka(cK,"onTransitionRun");ka(dK,"onTransitionStart");ka(fK,"onTransitionCancel");ka(EF,"onTransitionEnd");md("onMouseEnter",["mouseout","mouseover"]);md("onMouseLeave",["mouseout","mouseover"]);md("onPointerEnter",["pointerout","pointerover"]);md("onPointerLeave",["pointerout","pointerover"]);rc("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));rc("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));rc("onBeforeInput",["compositionend","keypress","textInput","paste"]);rc("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));rc("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));rc("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var cp="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),JK=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(cp));function d4(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var i=e[n],r=i.event;i=i.listeners;e:{var s=void 0;if(t)for(var a=i.length-1;0<=a;a--){var o=i[a],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==s&&r.isPropagationStopped())break e;s=o,r.currentTarget=u;try{s(r)}catch(c){Rm(c)}r.currentTarget=null,s=l}else for(a=0;a<i.length;a++){if(o=i[a],l=o.instance,u=o.currentTarget,o=o.listener,l!==s&&r.isPropagationStopped())break e;s=o,r.currentTarget=u;try{s(r)}catch(c){Rm(c)}r.currentTarget=null,s=l}}}}function On(e,t){var n=t[kw];n===void 0&&(n=t[kw]=new Set);var i=e+"__bubble";n.has(i)||(f4(t,e,2,!1),n.add(i))}function f0(e,t,n){var i=0;t&&(i|=4),f4(n,e,i,t)}var yh="_reactListening"+Math.random().toString(36).slice(2);function vx(e){if(!e[yh]){e[yh]=!0,iF.forEach(function(n){n!=="selectionchange"&&(JK.has(n)||f0(n,!1,e),f0(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[yh]||(t[yh]=!0,f0("selectionchange",!1,t))}}function f4(e,t,n,i){switch(E4(t)){case 2:var r=T9;break;case 8:r=M9;break;default:r=Tx}n=r.bind(null,t,n,e),r=void 0,!Lw||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(r=!0),i?r!==void 0?e.addEventListener(t,n,{capture:!0,passive:r}):e.addEventListener(t,n,!0):r!==void 0?e.addEventListener(t,n,{passive:r}):e.addEventListener(t,n,!1)}function p0(e,t,n,i,r){var s=i;if(!(t&1)&&!(t&2)&&i!==null)e:for(;;){if(i===null)return;var a=i.tag;if(a===3||a===4){var o=i.stateNode.containerInfo;if(o===r)break;if(a===4)for(a=i.return;a!==null;){var l=a.tag;if((l===3||l===4)&&a.stateNode.containerInfo===r)return;a=a.return}for(;o!==null;){if(a=Gc(o),a===null)return;if(l=a.tag,l===5||l===6||l===26||l===27){i=s=a;continue e}o=o.parentNode}}i=i.return}dF(function(){var u=s,c=L1(n),f=[];e:{var d=SF.get(e);if(d!==void 0){var h=Ng,m=e;switch(e){case"keypress":if(lm(n)===0)break e;case"keydown":case"keyup":h=Vq;break;case"focusin":m="focus",h=Vy;break;case"focusout":m="blur",h=Vy;break;case"beforeblur":case"afterblur":h=Vy;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":h=j$;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":h=Iq;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":h=Wq;break;case xF:case TF:case MF:h=Dq;break;case EF:h=qq;break;case"scroll":case"scrollend":h=$q;break;case"wheel":h=Jq;break;case"copy":case"cut":case"paste":h=Rq;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":h=H$;break;case"toggle":case"beforetoggle":h=Xq}var y=(t&4)!==0,M=!y&&(e==="scroll"||e==="scrollend"),g=y?d!==null?d+"Capture":null:d;y=[];for(var _=u,T;_!==null;){var x=_;if(T=x.stateNode,x=x.tag,x!==5&&x!==26&&x!==27||T===null||g===null||(x=np(_,g),x!=null&&y.push(dp(_,x,T))),M)break;_=_.return}0<y.length&&(d=new h(d,m,null,n,c),f.push({event:d,listeners:y}))}}if(!(t&7)){e:{if(d=e==="mouseover"||e==="pointerover",h=e==="mouseout"||e==="pointerout",d&&n!==Nw&&(m=n.relatedTarget||n.fromElement)&&(Gc(m)||m[Pd]))break e;if((h||d)&&(d=c.window===c?c:(d=c.ownerDocument)?d.defaultView||d.parentWindow:window,h?(m=n.relatedTarget||n.toElement,h=u,m=m?Gc(m):null,m!==null&&(M=Tp(m),y=m.tag,m!==M||y!==5&&y!==27&&y!==6)&&(m=null)):(h=null,m=u),h!==m)){if(y=j$,x="onMouseLeave",g="onMouseEnter",_="mouse",(e==="pointerout"||e==="pointerover")&&(y=H$,x="onPointerLeave",g="onPointerEnter",_="pointer"),M=h==null?d:Sf(h),T=m==null?d:Sf(m),d=new y(x,_+"leave",h,n,c),d.target=M,d.relatedTarget=T,x=null,Gc(c)===u&&(y=new y(g,_+"enter",m,n,c),y.target=T,y.relatedTarget=M,x=y),M=x,h&&m)t:{for(y=YK,g=h,_=m,T=0,x=g;x;x=y(x))T++;x=0;for(var S=_;S;S=y(S))x++;for(;0<T-x;)g=y(g),T--;for(;0<x-T;)_=y(_),x--;for(;T--;){if(g===_||_!==null&&g===_.alternate){y=g;break t}g=y(g),_=y(_)}y=null}else y=null;h!==null&&LA(f,d,h,y,!1),m!==null&&M!==null&&LA(f,M,m,y,!0)}}e:{if(d=u?Sf(u):window,h=d.nodeName&&d.nodeName.toLowerCase(),h==="select"||h==="input"&&d.type==="file")var $=Y$;else if(J$(d))if(_F)$=oK;else{$=sK;var C=rK}else h=d.nodeName,!h||h.toLowerCase()!=="input"||d.type!=="checkbox"&&d.type!=="radio"?u&&N1(u.elementType)&&($=Y$):$=aK;if($&&($=$(e,u))){gF(f,$,n,c);break e}C&&C(e,d,u),e==="focusout"&&u&&d.type==="number"&&u.memoizedProps.value!=null&&Rw(d,"number",d.value)}switch(C=u?Sf(u):window,e){case"focusin":(J$(C)||C.contentEditable==="true")&&(Hc=C,zw=u,Uf=null);break;case"focusout":Uf=zw=Hc=null;break;case"mousedown":Fw=!0;break;case"contextmenu":case"mouseup":case"dragend":Fw=!1,tA(f,n,c);break;case"selectionchange":if(uK)break;case"keydown":case"keyup":tA(f,n,c)}var P;if(B1)e:{switch(e){case"compositionstart":var O="onCompositionStart";break e;case"compositionend":O="onCompositionEnd";break e;case"compositionupdate":O="onCompositionUpdate";break e}O=void 0}else Wc?hF(e,n)&&(O="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(O="onCompositionStart");O&&(pF&&n.locale!=="ko"&&(Wc||O!=="onCompositionStart"?O==="onCompositionEnd"&&Wc&&(P=fF()):(El=c,z1="value"in El?El.value:El.textContent,Wc=!0)),C=Qm(u,O),0<C.length&&(O=new W$(O,e,null,n,c),f.push({event:O,listeners:C}),P?O.data=P:(P=mF(n),P!==null&&(O.data=P)))),(P=Zq?eK(e,n):tK(e,n))&&(O=Qm(u,"onBeforeInput"),0<O.length&&(C=new W$("onBeforeInput","beforeinput",null,n,c),f.push({event:C,listeners:O}),C.data=P)),HK(f,e,u,n,c)}d4(f,t)})}function dp(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Qm(e,t){for(var n=t+"Capture",i=[];e!==null;){var r=e,s=r.stateNode;if(r=r.tag,r!==5&&r!==26&&r!==27||s===null||(r=np(e,n),r!=null&&i.unshift(dp(e,r,s)),r=np(e,t),r!=null&&i.push(dp(e,r,s))),e.tag===3)return i;e=e.return}return[]}function YK(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5&&e.tag!==27);return e||null}function LA(e,t,n,i,r){for(var s=t._reactName,a=[];n!==null&&n!==i;){var o=n,l=o.alternate,u=o.stateNode;if(o=o.tag,l!==null&&l===i)break;o!==5&&o!==26&&o!==27||u===null||(l=u,r?(u=np(n,s),u!=null&&a.unshift(dp(n,u,l))):r||(u=np(n,s),u!=null&&a.push(dp(n,u,l)))),n=n.return}a.length!==0&&e.push({event:t,listeners:a})}var XK=/\r\n?/g,QK=/\u0000|\uFFFD/g;function zA(e){return(typeof e=="string"?e:""+e).replace(XK,`
`).replace(QK,"")}function p4(e,t){return t=zA(t),zA(e)===t}function hi(e,t,n,i,r,s){switch(n){case"children":typeof i=="string"?t==="body"||t==="textarea"&&i===""||gd(e,i):(typeof i=="number"||typeof i=="bigint")&&t!=="body"&&gd(e,""+i);break;case"className":dh(e,"class",i);break;case"tabIndex":dh(e,"tabindex",i);break;case"dir":case"role":case"viewBox":case"width":case"height":dh(e,n,i);break;case"style":cF(e,i,s);break;case"data":if(t!=="object"){dh(e,"data",i);break}case"src":case"href":if(i===""&&(t!=="a"||n!=="href")){e.removeAttribute(n);break}if(i==null||typeof i=="function"||typeof i=="symbol"||typeof i=="boolean"){e.removeAttribute(n);break}i=am(""+i),e.setAttribute(n,i);break;case"action":case"formAction":if(typeof i=="function"){e.setAttribute(n,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof s=="function"&&(n==="formAction"?(t!=="input"&&hi(e,t,"name",r.name,r,null),hi(e,t,"formEncType",r.formEncType,r,null),hi(e,t,"formMethod",r.formMethod,r,null),hi(e,t,"formTarget",r.formTarget,r,null)):(hi(e,t,"encType",r.encType,r,null),hi(e,t,"method",r.method,r,null),hi(e,t,"target",r.target,r,null)));if(i==null||typeof i=="symbol"||typeof i=="boolean"){e.removeAttribute(n);break}i=am(""+i),e.setAttribute(n,i);break;case"onClick":i!=null&&(e.onclick=$o);break;case"onScroll":i!=null&&On("scroll",e);break;case"onScrollEnd":i!=null&&On("scrollend",e);break;case"dangerouslySetInnerHTML":if(i!=null){if(typeof i!="object"||!("__html"in i))throw Error(rt(61));if(n=i.__html,n!=null){if(r.children!=null)throw Error(rt(60));e.innerHTML=n}}break;case"multiple":e.multiple=i&&typeof i!="function"&&typeof i!="symbol";break;case"muted":e.muted=i&&typeof i!="function"&&typeof i!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(i==null||typeof i=="function"||typeof i=="boolean"||typeof i=="symbol"){e.removeAttribute("xlink:href");break}n=am(""+i),e.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",n);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":i!=null&&typeof i!="function"&&typeof i!="symbol"?e.setAttribute(n,""+i):e.removeAttribute(n);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":i&&typeof i!="function"&&typeof i!="symbol"?e.setAttribute(n,""):e.removeAttribute(n);break;case"capture":case"download":i===!0?e.setAttribute(n,""):i!==!1&&i!=null&&typeof i!="function"&&typeof i!="symbol"?e.setAttribute(n,i):e.removeAttribute(n);break;case"cols":case"rows":case"size":case"span":i!=null&&typeof i!="function"&&typeof i!="symbol"&&!isNaN(i)&&1<=i?e.setAttribute(n,i):e.removeAttribute(n);break;case"rowSpan":case"start":i==null||typeof i=="function"||typeof i=="symbol"||isNaN(i)?e.removeAttribute(n):e.setAttribute(n,i);break;case"popover":On("beforetoggle",e),On("toggle",e),sm(e,"popover",i);break;case"xlinkActuate":mo(e,"http://www.w3.org/1999/xlink","xlink:actuate",i);break;case"xlinkArcrole":mo(e,"http://www.w3.org/1999/xlink","xlink:arcrole",i);break;case"xlinkRole":mo(e,"http://www.w3.org/1999/xlink","xlink:role",i);break;case"xlinkShow":mo(e,"http://www.w3.org/1999/xlink","xlink:show",i);break;case"xlinkTitle":mo(e,"http://www.w3.org/1999/xlink","xlink:title",i);break;case"xlinkType":mo(e,"http://www.w3.org/1999/xlink","xlink:type",i);break;case"xmlBase":mo(e,"http://www.w3.org/XML/1998/namespace","xml:base",i);break;case"xmlLang":mo(e,"http://www.w3.org/XML/1998/namespace","xml:lang",i);break;case"xmlSpace":mo(e,"http://www.w3.org/XML/1998/namespace","xml:space",i);break;case"is":sm(e,"is",i);break;case"innerText":case"textContent":break;default:(!(2<n.length)||n[0]!=="o"&&n[0]!=="O"||n[1]!=="n"&&n[1]!=="N")&&(n=Sq.get(n)||n,sm(e,n,i))}}function ub(e,t,n,i,r,s){switch(n){case"style":cF(e,i,s);break;case"dangerouslySetInnerHTML":if(i!=null){if(typeof i!="object"||!("__html"in i))throw Error(rt(61));if(n=i.__html,n!=null){if(r.children!=null)throw Error(rt(60));e.innerHTML=n}}break;case"children":typeof i=="string"?gd(e,i):(typeof i=="number"||typeof i=="bigint")&&gd(e,""+i);break;case"onScroll":i!=null&&On("scroll",e);break;case"onScrollEnd":i!=null&&On("scrollend",e);break;case"onClick":i!=null&&(e.onclick=$o);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!rF.hasOwnProperty(n))e:{if(n[0]==="o"&&n[1]==="n"&&(r=n.endsWith("Capture"),t=n.slice(2,r?n.length-7:void 0),s=e[ss]||null,s=s!=null?s[n]:null,typeof s=="function"&&e.removeEventListener(t,s,r),typeof i=="function")){typeof s!="function"&&s!==null&&(n in e?e[n]=null:e.hasAttribute(n)&&e.removeAttribute(n)),e.addEventListener(t,i,r);break e}n in e?e[n]=i:i===!0?e.setAttribute(n,""):sm(e,n,i)}}}function Or(e,t,n){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":On("error",e),On("load",e);var i=!1,r=!1,s;for(s in n)if(n.hasOwnProperty(s)){var a=n[s];if(a!=null)switch(s){case"src":i=!0;break;case"srcSet":r=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(rt(137,t));default:hi(e,t,s,a,n,null)}}r&&hi(e,t,"srcSet",n.srcSet,n,null),i&&hi(e,t,"src",n.src,n,null);return;case"input":On("invalid",e);var o=s=a=r=null,l=null,u=null;for(i in n)if(n.hasOwnProperty(i)){var c=n[i];if(c!=null)switch(i){case"name":r=c;break;case"type":a=c;break;case"checked":l=c;break;case"defaultChecked":u=c;break;case"value":s=c;break;case"defaultValue":o=c;break;case"children":case"dangerouslySetInnerHTML":if(c!=null)throw Error(rt(137,t));break;default:hi(e,t,i,c,n,null)}}oF(e,s,o,l,u,a,r,!1);return;case"select":On("invalid",e),i=a=s=null;for(r in n)if(n.hasOwnProperty(r)&&(o=n[r],o!=null))switch(r){case"value":s=o;break;case"defaultValue":a=o;break;case"multiple":i=o;default:hi(e,t,r,o,n,null)}t=s,n=a,e.multiple=!!i,t!=null?ad(e,!!i,t,!1):n!=null&&ad(e,!!i,n,!0);return;case"textarea":On("invalid",e),s=r=i=null;for(a in n)if(n.hasOwnProperty(a)&&(o=n[a],o!=null))switch(a){case"value":i=o;break;case"defaultValue":r=o;break;case"children":s=o;break;case"dangerouslySetInnerHTML":if(o!=null)throw Error(rt(91));break;default:hi(e,t,a,o,n,null)}uF(e,i,r,s);return;case"option":for(l in n)if(n.hasOwnProperty(l)&&(i=n[l],i!=null))switch(l){case"selected":e.selected=i&&typeof i!="function"&&typeof i!="symbol";break;default:hi(e,t,l,i,n,null)}return;case"dialog":On("beforetoggle",e),On("toggle",e),On("cancel",e),On("close",e);break;case"iframe":case"object":On("load",e);break;case"video":case"audio":for(i=0;i<cp.length;i++)On(cp[i],e);break;case"image":On("error",e),On("load",e);break;case"details":On("toggle",e);break;case"embed":case"source":case"link":On("error",e),On("load",e);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(u in n)if(n.hasOwnProperty(u)&&(i=n[u],i!=null))switch(u){case"children":case"dangerouslySetInnerHTML":throw Error(rt(137,t));default:hi(e,t,u,i,n,null)}return;default:if(N1(t)){for(c in n)n.hasOwnProperty(c)&&(i=n[c],i!==void 0&&ub(e,t,c,i,n,void 0));return}}for(o in n)n.hasOwnProperty(o)&&(i=n[o],i!=null&&hi(e,t,o,i,n,null))}function ZK(e,t,n,i){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var r=null,s=null,a=null,o=null,l=null,u=null,c=null;for(h in n){var f=n[h];if(n.hasOwnProperty(h)&&f!=null)switch(h){case"checked":break;case"value":break;case"defaultValue":l=f;default:i.hasOwnProperty(h)||hi(e,t,h,null,i,f)}}for(var d in i){var h=i[d];if(f=n[d],i.hasOwnProperty(d)&&(h!=null||f!=null))switch(d){case"type":s=h;break;case"name":r=h;break;case"checked":u=h;break;case"defaultChecked":c=h;break;case"value":a=h;break;case"defaultValue":o=h;break;case"children":case"dangerouslySetInnerHTML":if(h!=null)throw Error(rt(137,t));break;default:h!==f&&hi(e,t,d,h,i,f)}}Ow(e,a,o,l,u,c,s,r);return;case"select":h=a=o=d=null;for(s in n)if(l=n[s],n.hasOwnProperty(s)&&l!=null)switch(s){case"value":break;case"multiple":h=l;default:i.hasOwnProperty(s)||hi(e,t,s,null,i,l)}for(r in i)if(s=i[r],l=n[r],i.hasOwnProperty(r)&&(s!=null||l!=null))switch(r){case"value":d=s;break;case"defaultValue":o=s;break;case"multiple":a=s;default:s!==l&&hi(e,t,r,s,i,l)}t=o,n=a,i=h,d!=null?ad(e,!!n,d,!1):!!i!=!!n&&(t!=null?ad(e,!!n,t,!0):ad(e,!!n,n?[]:"",!1));return;case"textarea":h=d=null;for(o in n)if(r=n[o],n.hasOwnProperty(o)&&r!=null&&!i.hasOwnProperty(o))switch(o){case"value":break;case"children":break;default:hi(e,t,o,null,i,r)}for(a in i)if(r=i[a],s=n[a],i.hasOwnProperty(a)&&(r!=null||s!=null))switch(a){case"value":d=r;break;case"defaultValue":h=r;break;case"children":break;case"dangerouslySetInnerHTML":if(r!=null)throw Error(rt(91));break;default:r!==s&&hi(e,t,a,r,i,s)}lF(e,d,h);return;case"option":for(var m in n)if(d=n[m],n.hasOwnProperty(m)&&d!=null&&!i.hasOwnProperty(m))switch(m){case"selected":e.selected=!1;break;default:hi(e,t,m,null,i,d)}for(l in i)if(d=i[l],h=n[l],i.hasOwnProperty(l)&&d!==h&&(d!=null||h!=null))switch(l){case"selected":e.selected=d&&typeof d!="function"&&typeof d!="symbol";break;default:hi(e,t,l,d,i,h)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var y in n)d=n[y],n.hasOwnProperty(y)&&d!=null&&!i.hasOwnProperty(y)&&hi(e,t,y,null,i,d);for(u in i)if(d=i[u],h=n[u],i.hasOwnProperty(u)&&d!==h&&(d!=null||h!=null))switch(u){case"children":case"dangerouslySetInnerHTML":if(d!=null)throw Error(rt(137,t));break;default:hi(e,t,u,d,i,h)}return;default:if(N1(t)){for(var M in n)d=n[M],n.hasOwnProperty(M)&&d!==void 0&&!i.hasOwnProperty(M)&&ub(e,t,M,void 0,i,d);for(c in i)d=i[c],h=n[c],!i.hasOwnProperty(c)||d===h||d===void 0&&h===void 0||ub(e,t,c,d,i,h);return}}for(var g in n)d=n[g],n.hasOwnProperty(g)&&d!=null&&!i.hasOwnProperty(g)&&hi(e,t,g,null,i,d);for(f in i)d=i[f],h=n[f],!i.hasOwnProperty(f)||d===h||d==null&&h==null||hi(e,t,f,d,i,h)}function FA(e){switch(e){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function e9(){if(typeof performance.getEntriesByType=="function"){for(var e=0,t=0,n=performance.getEntriesByType("resource"),i=0;i<n.length;i++){var r=n[i],s=r.transferSize,a=r.initiatorType,o=r.duration;if(s&&o&&FA(a)){for(a=0,o=r.responseEnd,i+=1;i<n.length;i++){var l=n[i],u=l.startTime;if(u>o)break;var c=l.transferSize,f=l.initiatorType;c&&FA(f)&&(l=l.responseEnd,a+=c*(l<o?1:(o-u)/(l-u)))}if(--i,t+=8*(s+a)/(r.duration/1e3),e++,10<e)break}}if(0<e)return t/e/1e6}return navigator.connection&&(e=navigator.connection.downlink,typeof e=="number")?e:5}var cb=null,db=null;function Zm(e){return e.nodeType===9?e:e.ownerDocument}function BA(e){switch(e){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function h4(e,t){if(e===0)switch(t){case"svg":return 1;case"math":return 2;default:return 0}return e===1&&t==="foreignObject"?0:e}function fb(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.children=="bigint"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var h0=null;function t9(){var e=window.event;return e&&e.type==="popstate"?e===h0?!1:(h0=e,!0):(h0=null,!1)}var m4=typeof setTimeout=="function"?setTimeout:void 0,n9=typeof clearTimeout=="function"?clearTimeout:void 0,UA=typeof Promise=="function"?Promise:void 0,i9=typeof queueMicrotask=="function"?queueMicrotask:typeof UA<"u"?function(e){return UA.resolve(null).then(e).catch(r9)}:m4;function r9(e){setTimeout(function(){throw e})}function ql(e){return e==="head"}function VA(e,t){var n=t,i=0;do{var r=n.nextSibling;if(e.removeChild(n),r&&r.nodeType===8)if(n=r.data,n==="/$"||n==="/&"){if(i===0){e.removeChild(r),Md(t);return}i--}else if(n==="$"||n==="$?"||n==="$~"||n==="$!"||n==="&")i++;else if(n==="html")Xf(e.ownerDocument.documentElement);else if(n==="head"){n=e.ownerDocument.head,Xf(n);for(var s=n.firstChild;s;){var a=s.nextSibling,o=s.nodeName;s[Cp]||o==="SCRIPT"||o==="STYLE"||o==="LINK"&&s.rel.toLowerCase()==="stylesheet"||n.removeChild(s),s=a}}else n==="body"&&Xf(e.ownerDocument.body);n=r}while(n);Md(t)}function GA(e,t){var n=e;e=0;do{var i=n.nextSibling;if(n.nodeType===1?t?(n._stashedDisplay=n.style.display,n.style.display="none"):(n.style.display=n._stashedDisplay||"",n.getAttribute("style")===""&&n.removeAttribute("style")):n.nodeType===3&&(t?(n._stashedText=n.nodeValue,n.nodeValue=""):n.nodeValue=n._stashedText||""),i&&i.nodeType===8)if(n=i.data,n==="/$"){if(e===0)break;e--}else n!=="$"&&n!=="$?"&&n!=="$~"&&n!=="$!"||e++;n=i}while(n)}function pb(e){var t=e.firstChild;for(t&&t.nodeType===10&&(t=t.nextSibling);t;){var n=t;switch(t=t.nextSibling,n.nodeName){case"HTML":case"HEAD":case"BODY":pb(n),R1(n);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(n.rel.toLowerCase()==="stylesheet")continue}e.removeChild(n)}}function s9(e,t,n,i){for(;e.nodeType===1;){var r=n;if(e.nodeName.toLowerCase()!==t.toLowerCase()){if(!i&&(e.nodeName!=="INPUT"||e.type!=="hidden"))break}else if(i){if(!e[Cp])switch(t){case"meta":if(!e.hasAttribute("itemprop"))break;return e;case"link":if(s=e.getAttribute("rel"),s==="stylesheet"&&e.hasAttribute("data-precedence"))break;if(s!==r.rel||e.getAttribute("href")!==(r.href==null||r.href===""?null:r.href)||e.getAttribute("crossorigin")!==(r.crossOrigin==null?null:r.crossOrigin)||e.getAttribute("title")!==(r.title==null?null:r.title))break;return e;case"style":if(e.hasAttribute("data-precedence"))break;return e;case"script":if(s=e.getAttribute("src"),(s!==(r.src==null?null:r.src)||e.getAttribute("type")!==(r.type==null?null:r.type)||e.getAttribute("crossorigin")!==(r.crossOrigin==null?null:r.crossOrigin))&&s&&e.hasAttribute("async")&&!e.hasAttribute("itemprop"))break;return e;default:return e}}else if(t==="input"&&e.type==="hidden"){var s=r.name==null?null:""+r.name;if(r.type==="hidden"&&e.getAttribute("name")===s)return e}else return e;if(e=Ys(e.nextSibling),e===null)break}return null}function a9(e,t,n){if(t==="")return null;for(;e.nodeType!==3;)if((e.nodeType!==1||e.nodeName!=="INPUT"||e.type!=="hidden")&&!n||(e=Ys(e.nextSibling),e===null))return null;return e}function g4(e,t){for(;e.nodeType!==8;)if((e.nodeType!==1||e.nodeName!=="INPUT"||e.type!=="hidden")&&!t||(e=Ys(e.nextSibling),e===null))return null;return e}function hb(e){return e.data==="$?"||e.data==="$~"}function mb(e){return e.data==="$!"||e.data==="$?"&&e.ownerDocument.readyState!=="loading"}function o9(e,t){var n=e.ownerDocument;if(e.data==="$~")e._reactRetry=t;else if(e.data!=="$?"||n.readyState!=="loading")t();else{var i=function(){t(),n.removeEventListener("DOMContentLoaded",i)};n.addEventListener("DOMContentLoaded",i),e._reactRetry=i}}function Ys(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?"||t==="$~"||t==="&"||t==="F!"||t==="F")break;if(t==="/$"||t==="/&")return null}}return e}var gb=null;function jA(e){e=e.nextSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"||n==="/&"){if(t===0)return Ys(e.nextSibling);t--}else n!=="$"&&n!=="$!"&&n!=="$?"&&n!=="$~"&&n!=="&"||t++}e=e.nextSibling}return null}function WA(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"||n==="$~"||n==="&"){if(t===0)return e;t--}else n!=="/$"&&n!=="/&"||t++}e=e.previousSibling}return null}function _4(e,t,n){switch(t=Zm(n),e){case"html":if(e=t.documentElement,!e)throw Error(rt(452));return e;case"head":if(e=t.head,!e)throw Error(rt(453));return e;case"body":if(e=t.body,!e)throw Error(rt(454));return e;default:throw Error(rt(451))}}function Xf(e){for(var t=e.attributes;t.length;)e.removeAttributeNode(t[0]);R1(e)}var ea=new Map,HA=new Set;function eg(e){return typeof e.getRootNode=="function"?e.getRootNode():e.nodeType===9?e:e.ownerDocument}var Fo=ai.d;ai.d={f:l9,r:u9,D:c9,C:d9,L:f9,m:p9,X:m9,S:h9,M:g9};function l9(){var e=Fo.f(),t=qg();return e||t}function u9(e){var t=kd(e);t!==null&&t.tag===5&&t.type==="form"?cB(t):Fo.r(e)}var Nd=typeof document>"u"?null:document;function y4(e,t,n){var i=Nd;if(i&&typeof t=="string"&&t){var r=Ws(t);r='link[rel="'+e+'"][href="'+r+'"]',typeof n=="string"&&(r+='[crossorigin="'+n+'"]'),HA.has(r)||(HA.add(r),e={rel:e,crossOrigin:n,href:t},i.querySelector(r)===null&&(t=i.createElement("link"),Or(t,"link",e),Mr(t),i.head.appendChild(t)))}}function c9(e){Fo.D(e),y4("dns-prefetch",e,null)}function d9(e,t){Fo.C(e,t),y4("preconnect",e,t)}function f9(e,t,n){Fo.L(e,t,n);var i=Nd;if(i&&e&&t){var r='link[rel="preload"][as="'+Ws(t)+'"]';t==="image"&&n&&n.imageSrcSet?(r+='[imagesrcset="'+Ws(n.imageSrcSet)+'"]',typeof n.imageSizes=="string"&&(r+='[imagesizes="'+Ws(n.imageSizes)+'"]')):r+='[href="'+Ws(e)+'"]';var s=r;switch(t){case"style":s=Td(e);break;case"script":s=Ld(e)}ea.has(s)||(e=Ri({rel:"preload",href:t==="image"&&n&&n.imageSrcSet?void 0:e,as:t},n),ea.set(s,e),i.querySelector(r)!==null||t==="style"&&i.querySelector(Dp(s))||t==="script"&&i.querySelector(Op(s))||(t=i.createElement("link"),Or(t,"link",e),Mr(t),i.head.appendChild(t)))}}function p9(e,t){Fo.m(e,t);var n=Nd;if(n&&e){var i=t&&typeof t.as=="string"?t.as:"script",r='link[rel="modulepreload"][as="'+Ws(i)+'"][href="'+Ws(e)+'"]',s=r;switch(i){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":s=Ld(e)}if(!ea.has(s)&&(e=Ri({rel:"modulepreload",href:e},t),ea.set(s,e),n.querySelector(r)===null)){switch(i){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(n.querySelector(Op(s)))return}i=n.createElement("link"),Or(i,"link",e),Mr(i),n.head.appendChild(i)}}}function h9(e,t,n){Fo.S(e,t,n);var i=Nd;if(i&&e){var r=sd(i).hoistableStyles,s=Td(e);t=t||"default";var a=r.get(s);if(!a){var o={loading:0,preload:null};if(a=i.querySelector(Dp(s)))o.loading=5;else{e=Ri({rel:"stylesheet",href:e,"data-precedence":t},n),(n=ea.get(s))&&wx(e,n);var l=a=i.createElement("link");Mr(l),Or(l,"link",e),l._p=new Promise(function(u,c){l.onload=u,l.onerror=c}),l.addEventListener("load",function(){o.loading|=1}),l.addEventListener("error",function(){o.loading|=2}),o.loading|=4,gm(a,t,i)}a={type:"stylesheet",instance:a,count:1,state:o},r.set(s,a)}}}function m9(e,t){Fo.X(e,t);var n=Nd;if(n&&e){var i=sd(n).hoistableScripts,r=Ld(e),s=i.get(r);s||(s=n.querySelector(Op(r)),s||(e=Ri({src:e,async:!0},t),(t=ea.get(r))&&bx(e,t),s=n.createElement("script"),Mr(s),Or(s,"link",e),n.head.appendChild(s)),s={type:"script",instance:s,count:1,state:null},i.set(r,s))}}function g9(e,t){Fo.M(e,t);var n=Nd;if(n&&e){var i=sd(n).hoistableScripts,r=Ld(e),s=i.get(r);s||(s=n.querySelector(Op(r)),s||(e=Ri({src:e,async:!0,type:"module"},t),(t=ea.get(r))&&bx(e,t),s=n.createElement("script"),Mr(s),Or(s,"link",e),n.head.appendChild(s)),s={type:"script",instance:s,count:1,state:null},i.set(r,s))}}function qA(e,t,n,i){var r=(r=Al.current)?eg(r):null;if(!r)throw Error(rt(446));switch(e){case"meta":case"title":return null;case"style":return typeof n.precedence=="string"&&typeof n.href=="string"?(t=Td(n.href),n=sd(r).hoistableStyles,i=n.get(t),i||(i={type:"style",instance:null,count:0,state:null},n.set(t,i)),i):{type:"void",instance:null,count:0,state:null};case"link":if(n.rel==="stylesheet"&&typeof n.href=="string"&&typeof n.precedence=="string"){e=Td(n.href);var s=sd(r).hoistableStyles,a=s.get(e);if(a||(r=r.ownerDocument||r,a={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},s.set(e,a),(s=r.querySelector(Dp(e)))&&!s._p&&(a.instance=s,a.state.loading=5),ea.has(e)||(n={rel:"preload",as:"style",href:n.href,crossOrigin:n.crossOrigin,integrity:n.integrity,media:n.media,hrefLang:n.hrefLang,referrerPolicy:n.referrerPolicy},ea.set(e,n),s||_9(r,e,n,a.state))),t&&i===null)throw Error(rt(528,""));return a}if(t&&i!==null)throw Error(rt(529,""));return null;case"script":return t=n.async,n=n.src,typeof n=="string"&&t&&typeof t!="function"&&typeof t!="symbol"?(t=Ld(n),n=sd(r).hoistableScripts,i=n.get(t),i||(i={type:"script",instance:null,count:0,state:null},n.set(t,i)),i):{type:"void",instance:null,count:0,state:null};default:throw Error(rt(444,e))}}function Td(e){return'href="'+Ws(e)+'"'}function Dp(e){return'link[rel="stylesheet"]['+e+"]"}function v4(e){return Ri({},e,{"data-precedence":e.precedence,precedence:null})}function _9(e,t,n,i){e.querySelector('link[rel="preload"][as="style"]['+t+"]")?i.loading=1:(t=e.createElement("link"),i.preload=t,t.addEventListener("load",function(){return i.loading|=1}),t.addEventListener("error",function(){return i.loading|=2}),Or(t,"link",n),Mr(t),e.head.appendChild(t))}function Ld(e){return'[src="'+Ws(e)+'"]'}function Op(e){return"script[async]"+e}function KA(e,t,n){if(t.count++,t.instance===null)switch(t.type){case"style":var i=e.querySelector('style[data-href~="'+Ws(n.href)+'"]');if(i)return t.instance=i,Mr(i),i;var r=Ri({},n,{"data-href":n.href,"data-precedence":n.precedence,href:null,precedence:null});return i=(e.ownerDocument||e).createElement("style"),Mr(i),Or(i,"style",r),gm(i,n.precedence,e),t.instance=i;case"stylesheet":r=Td(n.href);var s=e.querySelector(Dp(r));if(s)return t.state.loading|=4,t.instance=s,Mr(s),s;i=v4(n),(r=ea.get(r))&&wx(i,r),s=(e.ownerDocument||e).createElement("link"),Mr(s);var a=s;return a._p=new Promise(function(o,l){a.onload=o,a.onerror=l}),Or(s,"link",i),t.state.loading|=4,gm(s,n.precedence,e),t.instance=s;case"script":return s=Ld(n.src),(r=e.querySelector(Op(s)))?(t.instance=r,Mr(r),r):(i=n,(r=ea.get(s))&&(i=Ri({},n),bx(i,r)),e=e.ownerDocument||e,r=e.createElement("script"),Mr(r),Or(r,"link",i),e.head.appendChild(r),t.instance=r);case"void":return null;default:throw Error(rt(443,t.type))}else t.type==="stylesheet"&&!(t.state.loading&4)&&(i=t.instance,t.state.loading|=4,gm(i,n.precedence,e));return t.instance}function gm(e,t,n){for(var i=n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),r=i.length?i[i.length-1]:null,s=r,a=0;a<i.length;a++){var o=i[a];if(o.dataset.precedence===t)s=o;else if(s!==r)break}s?s.parentNode.insertBefore(e,s.nextSibling):(t=n.nodeType===9?n.head:n,t.insertBefore(e,t.firstChild))}function wx(e,t){e.crossOrigin==null&&(e.crossOrigin=t.crossOrigin),e.referrerPolicy==null&&(e.referrerPolicy=t.referrerPolicy),e.title==null&&(e.title=t.title)}function bx(e,t){e.crossOrigin==null&&(e.crossOrigin=t.crossOrigin),e.referrerPolicy==null&&(e.referrerPolicy=t.referrerPolicy),e.integrity==null&&(e.integrity=t.integrity)}var _m=null;function JA(e,t,n){if(_m===null){var i=new Map,r=_m=new Map;r.set(n,i)}else r=_m,i=r.get(n),i||(i=new Map,r.set(n,i));if(i.has(e))return i;for(i.set(e,null),n=n.getElementsByTagName(e),r=0;r<n.length;r++){var s=n[r];if(!(s[Cp]||s[Pr]||e==="link"&&s.getAttribute("rel")==="stylesheet")&&s.namespaceURI!=="http://www.w3.org/2000/svg"){var a=s.getAttribute(t)||"";a=e+a;var o=i.get(a);o?o.push(s):i.set(a,[s])}}return i}function YA(e,t,n){e=e.ownerDocument||e,e.head.insertBefore(n,t==="title"?e.querySelector("head > title"):null)}function y9(e,t,n){if(n===1||t.itemProp!=null)return!1;switch(e){case"meta":case"title":return!0;case"style":if(typeof t.precedence!="string"||typeof t.href!="string"||t.href==="")break;return!0;case"link":if(typeof t.rel!="string"||typeof t.href!="string"||t.href===""||t.onLoad||t.onError)break;switch(t.rel){case"stylesheet":return e=t.disabled,typeof t.precedence=="string"&&e==null;default:return!0}case"script":if(t.async&&typeof t.async!="function"&&typeof t.async!="symbol"&&!t.onLoad&&!t.onError&&t.src&&typeof t.src=="string")return!0}return!1}function w4(e){return!(e.type==="stylesheet"&&!(e.state.loading&3))}function v9(e,t,n,i){if(n.type==="stylesheet"&&(typeof i.media!="string"||matchMedia(i.media).matches!==!1)&&!(n.state.loading&4)){if(n.instance===null){var r=Td(i.href),s=t.querySelector(Dp(r));if(s){t=s._p,t!==null&&typeof t=="object"&&typeof t.then=="function"&&(e.count++,e=tg.bind(e),t.then(e,e)),n.state.loading|=4,n.instance=s,Mr(s);return}s=t.ownerDocument||t,i=v4(i),(r=ea.get(r))&&wx(i,r),s=s.createElement("link"),Mr(s);var a=s;a._p=new Promise(function(o,l){a.onload=o,a.onerror=l}),Or(s,"link",i),n.instance=s}e.stylesheets===null&&(e.stylesheets=new Map),e.stylesheets.set(n,t),(t=n.state.preload)&&!(n.state.loading&3)&&(e.count++,n=tg.bind(e),t.addEventListener("load",n),t.addEventListener("error",n))}}var m0=0;function w9(e,t){return e.stylesheets&&e.count===0&&ym(e,e.stylesheets),0<e.count||0<e.imgCount?function(n){var i=setTimeout(function(){if(e.stylesheets&&ym(e,e.stylesheets),e.unsuspend){var s=e.unsuspend;e.unsuspend=null,s()}},6e4+t);0<e.imgBytes&&m0===0&&(m0=62500*e9());var r=setTimeout(function(){if(e.waitingForImages=!1,e.count===0&&(e.stylesheets&&ym(e,e.stylesheets),e.unsuspend)){var s=e.unsuspend;e.unsuspend=null,s()}},(e.imgBytes>m0?50:800)+t);return e.unsuspend=n,function(){e.unsuspend=null,clearTimeout(i),clearTimeout(r)}}:null}function tg(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)ym(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}}var ng=null;function ym(e,t){e.stylesheets=null,e.unsuspend!==null&&(e.count++,ng=new Map,t.forEach(b9,e),ng=null,tg.call(e))}function b9(e,t){if(!(t.state.loading&4)){var n=ng.get(e);if(n)var i=n.get(null);else{n=new Map,ng.set(e,n);for(var r=e.querySelectorAll("link[data-precedence],style[data-precedence]"),s=0;s<r.length;s++){var a=r[s];(a.nodeName==="LINK"||a.getAttribute("media")!=="not all")&&(n.set(a.dataset.precedence,a),i=a)}i&&n.set(null,i)}r=t.instance,a=r.getAttribute("data-precedence"),s=n.get(a)||i,s===i&&n.set(null,r),n.set(a,r),this.count++,i=tg.bind(this),r.addEventListener("load",i),r.addEventListener("error",i),s?s.parentNode.insertBefore(r,s.nextSibling):(e=e.nodeType===9?e.head:e,e.insertBefore(r,e.firstChild)),t.state.loading|=4}}var fp={$$typeof:Co,Provider:null,Consumer:null,_currentValue:zu,_currentValue2:zu,_threadCount:0};function x9(e,t,n,i,r,s,a,o,l){this.tag=1,this.containerInfo=e,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=zy(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zy(0),this.hiddenUpdates=zy(null),this.identifierPrefix=i,this.onUncaughtError=r,this.onCaughtError=s,this.onRecoverableError=a,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=l,this.incompleteTransitions=new Map}function b4(e,t,n,i,r,s,a,o,l,u,c,f){return e=new x9(e,t,n,a,l,u,c,f,o),t=1,s===!0&&(t|=24),s=ys(3,null,null,t),e.current=s,s.stateNode=e,t=q1(),t.refCount++,e.pooledCache=t,t.refCount++,s.memoizedState={element:i,isDehydrated:n,cache:t},Y1(s),e}function x4(e){return e?(e=Jc,e):Jc}function T4(e,t,n,i,r,s){r=x4(r),i.context===null?i.context=r:i.pendingContext=r,i=Pl(t),i.payload={element:n},s=s===void 0?null:s,s!==null&&(i.callback=s),n=kl(e,i,t),n!==null&&(rs(n,e,t),Gf(n,e,t))}function XA(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function xx(e,t){XA(e,t),(e=e.alternate)&&XA(e,t)}function M4(e){if(e.tag===13||e.tag===31){var t=oc(e,67108864);t!==null&&rs(t,e,67108864),xx(e,67108864)}}function QA(e){if(e.tag===13||e.tag===31){var t=Ts();t=D1(t);var n=oc(e,t);n!==null&&rs(n,e,t),xx(e,t)}}var ig=!0;function T9(e,t,n,i){var r=on.T;on.T=null;var s=ai.p;try{ai.p=2,Tx(e,t,n,i)}finally{ai.p=s,on.T=r}}function M9(e,t,n,i){var r=on.T;on.T=null;var s=ai.p;try{ai.p=8,Tx(e,t,n,i)}finally{ai.p=s,on.T=r}}function Tx(e,t,n,i){if(ig){var r=_b(i);if(r===null)p0(e,t,i,rg,n),ZA(e,i);else if(S9(r,e,t,n,i))i.stopPropagation();else if(ZA(e,i),t&4&&-1<E9.indexOf(e)){for(;r!==null;){var s=kd(r);if(s!==null)switch(s.tag){case 3:if(s=s.stateNode,s.current.memoizedState.isDehydrated){var a=Eu(s.pendingLanes);if(a!==0){var o=s;for(o.pendingLanes|=2,o.entangledLanes|=2;a;){var l=1<<31-xs(a);o.entanglements[1]|=l,a&=~l}to(s),!(si&6)&&(qm=ws()+500,kp(0))}}break;case 31:case 13:o=oc(s,2),o!==null&&rs(o,s,2),qg(),xx(s,2)}if(s=_b(i),s===null&&p0(e,t,i,rg,n),s===r)break;r=s}r!==null&&i.stopPropagation()}else p0(e,t,i,null,n)}}function _b(e){return e=L1(e),Mx(e)}var rg=null;function Mx(e){if(rg=null,e=Gc(e),e!==null){var t=Tp(e);if(t===null)e=null;else{var n=t.tag;if(n===13){if(e=jz(t),e!==null)return e;e=null}else if(n===31){if(e=Wz(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null)}}return rg=e,null}function E4(e){switch(e){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(cq()){case Jz:return 2;case Yz:return 8;case Dm:case dq:return 32;case Xz:return 268435456;default:return 32}default:return 32}}var yb=!1,Rl=null,Nl=null,Ll=null,pp=new Map,hp=new Map,Tl=[],E9="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function ZA(e,t){switch(e){case"focusin":case"focusout":Rl=null;break;case"dragenter":case"dragleave":Nl=null;break;case"mouseover":case"mouseout":Ll=null;break;case"pointerover":case"pointerout":pp.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":hp.delete(t.pointerId)}}function Xd(e,t,n,i,r,s){return e===null||e.nativeEvent!==s?(e={blockedOn:t,domEventName:n,eventSystemFlags:i,nativeEvent:s,targetContainers:[r]},t!==null&&(t=kd(t),t!==null&&M4(t)),e):(e.eventSystemFlags|=i,t=e.targetContainers,r!==null&&t.indexOf(r)===-1&&t.push(r),e)}function S9(e,t,n,i,r){switch(t){case"focusin":return Rl=Xd(Rl,e,t,n,i,r),!0;case"dragenter":return Nl=Xd(Nl,e,t,n,i,r),!0;case"mouseover":return Ll=Xd(Ll,e,t,n,i,r),!0;case"pointerover":var s=r.pointerId;return pp.set(s,Xd(pp.get(s)||null,e,t,n,i,r)),!0;case"gotpointercapture":return s=r.pointerId,hp.set(s,Xd(hp.get(s)||null,e,t,n,i,r)),!0}return!1}function S4(e){var t=Gc(e.target);if(t!==null){var n=Tp(t);if(n!==null){if(t=n.tag,t===13){if(t=jz(n),t!==null){e.blockedOn=t,L$(e.priority,function(){QA(n)});return}}else if(t===31){if(t=Wz(n),t!==null){e.blockedOn=t,L$(e.priority,function(){QA(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function vm(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=_b(e.nativeEvent);if(n===null){n=e.nativeEvent;var i=new n.constructor(n.type,n);Nw=i,n.target.dispatchEvent(i),Nw=null}else return t=kd(n),t!==null&&M4(t),e.blockedOn=n,!1;t.shift()}return!0}function eI(e,t,n){vm(e)&&n.delete(t)}function C9(){yb=!1,Rl!==null&&vm(Rl)&&(Rl=null),Nl!==null&&vm(Nl)&&(Nl=null),Ll!==null&&vm(Ll)&&(Ll=null),pp.forEach(eI),hp.forEach(eI)}function vh(e,t){e.blockedOn===t&&(e.blockedOn=null,yb||(yb=!0,gr.unstable_scheduleCallback(gr.unstable_NormalPriority,C9)))}var wh=null;function tI(e){wh!==e&&(wh=e,gr.unstable_scheduleCallback(gr.unstable_NormalPriority,function(){wh===e&&(wh=null);for(var t=0;t<e.length;t+=3){var n=e[t],i=e[t+1],r=e[t+2];if(typeof i!="function"){if(Mx(i||n)===null)continue;break}var s=kd(n);s!==null&&(e.splice(t,3),t-=3,Qw(s,{pending:!0,data:r,method:n.method,action:i},i,r))}}))}function Md(e){function t(l){return vh(l,e)}Rl!==null&&vh(Rl,e),Nl!==null&&vh(Nl,e),Ll!==null&&vh(Ll,e),pp.forEach(t),hp.forEach(t);for(var n=0;n<Tl.length;n++){var i=Tl[n];i.blockedOn===e&&(i.blockedOn=null)}for(;0<Tl.length&&(n=Tl[0],n.blockedOn===null);)S4(n),n.blockedOn===null&&Tl.shift();if(n=(e.ownerDocument||e).$$reactFormReplay,n!=null)for(i=0;i<n.length;i+=3){var r=n[i],s=n[i+1],a=r[ss]||null;if(typeof s=="function")a||tI(n);else if(a){var o=null;if(s&&s.hasAttribute("formAction")){if(r=s,a=s[ss]||null)o=a.formAction;else if(Mx(r)!==null)continue}else o=a.action;typeof o=="function"?n[i+1]=o:(n.splice(i,3),i-=3),tI(n)}}}function C4(){function e(s){s.canIntercept&&s.info==="react-transition"&&s.intercept({handler:function(){return new Promise(function(a){return r=a})},focusReset:"manual",scroll:"manual"})}function t(){r!==null&&(r(),r=null),i||setTimeout(n,20)}function n(){if(!i&&!navigation.transition){var s=navigation.currentEntry;s&&s.url!=null&&navigation.navigate(s.url,{state:s.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var i=!1,r=null;return navigation.addEventListener("navigate",e),navigation.addEventListener("navigatesuccess",t),navigation.addEventListener("navigateerror",t),setTimeout(n,100),function(){i=!0,navigation.removeEventListener("navigate",e),navigation.removeEventListener("navigatesuccess",t),navigation.removeEventListener("navigateerror",t),r!==null&&(r(),r=null)}}}function Ex(e){this._internalRoot=e}Yg.prototype.render=Ex.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(rt(409));var n=t.current,i=Ts();T4(n,i,e,t,null,null)};Yg.prototype.unmount=Ex.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;T4(e.current,2,null,e,null,null),qg(),t[Pd]=null}};function Yg(e){this._internalRoot=e}Yg.prototype.unstable_scheduleHydration=function(e){if(e){var t=nF();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Tl.length&&t!==0&&t<Tl[n].priority;n++);Tl.splice(n,0,e),n===0&&S4(e)}};var nI=Vz.version;if(nI!=="19.2.3")throw Error(rt(527,nI,"19.2.3"));ai.findDOMNode=function(e){var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(rt(188)):(e=Object.keys(e).join(","),Error(rt(268,e)));return e=iq(t),e=e!==null?Hz(e):null,e=e===null?null:e.stateNode,e};var $9={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:on,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var bh=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!bh.isDisabled&&bh.supportsFiber)try{Mp=bh.inject($9),bs=bh}catch{}}Dg.createRoot=function(e,t){if(!Gz(e))throw Error(rt(299));var n=!1,i="",r=yB,s=vB,a=wB;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(i=t.identifierPrefix),t.onUncaughtError!==void 0&&(r=t.onUncaughtError),t.onCaughtError!==void 0&&(s=t.onCaughtError),t.onRecoverableError!==void 0&&(a=t.onRecoverableError)),t=b4(e,1,!1,null,null,n,i,null,r,s,a,C4),e[Pd]=t.current,vx(e),new Ex(t)};Dg.hydrateRoot=function(e,t,n){if(!Gz(e))throw Error(rt(299));var i=!1,r="",s=yB,a=vB,o=wB,l=null;return n!=null&&(n.unstable_strictMode===!0&&(i=!0),n.identifierPrefix!==void 0&&(r=n.identifierPrefix),n.onUncaughtError!==void 0&&(s=n.onUncaughtError),n.onCaughtError!==void 0&&(a=n.onCaughtError),n.onRecoverableError!==void 0&&(o=n.onRecoverableError),n.formState!==void 0&&(l=n.formState)),t=b4(e,1,!0,t,n??null,i,r,l,s,a,o,C4),t.context=x4(null),n=t.current,i=Ts(),i=D1(i),r=Pl(i),r.callback=null,kl(n,r,i),n=i,t.current.lanes=n,Sp(t,n),to(t),e[Pd]=t.current,vx(e),new Yg(t)};Dg.version="19.2.3";function $4(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE($4)}catch(e){console.error(e)}}$4(),Nz.exports=Dg;var A9=Nz.exports;const I9=M1(A9),P9=(e,t,n,i)=>{var s,a,o,l;const r=[n,{code:t,...i||{}}];if((a=(s=e==null?void 0:e.services)==null?void 0:s.logger)!=null&&a.forward)return e.services.logger.forward(r,"warn","react-i18next::",!0);Gu(r[0])&&(r[0]=`react-i18next:: ${r[0]}`),(l=(o=e==null?void 0:e.services)==null?void 0:o.logger)!=null&&l.warn?e.services.logger.warn(...r):console!=null&&console.warn&&console.warn(...r)},iI={},vb=(e,t,n,i)=>{Gu(n)&&iI[n]||(Gu(n)&&(iI[n]=new Date),P9(e,t,n,i))},A4=(e,t)=>()=>{if(e.isInitialized)t();else{const n=()=>{setTimeout(()=>{e.off("initialized",n)},0),t()};e.on("initialized",n)}},wb=(e,t,n)=>{e.loadNamespaces(t,A4(e,n))},rI=(e,t,n,i)=>{if(Gu(n)&&(n=[n]),e.options.preload&&e.options.preload.indexOf(t)>-1)return wb(e,n,i);n.forEach(r=>{e.options.ns.indexOf(r)<0&&e.options.ns.push(r)}),e.loadLanguages(t,A4(e,i))},k9=(e,t,n={})=>!t.languages||!t.languages.length?(vb(t,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:t.languages}),!0):t.hasLoadedNamespace(e,{lng:n.lng,precheck:(i,r)=>{if(n.bindI18n&&n.bindI18n.indexOf("languageChanging")>-1&&i.services.backendConnector.backend&&i.isLanguageChangingTo&&!r(i.isLanguageChangingTo,e))return!1}}),Gu=e=>typeof e=="string",D9=e=>typeof e=="object"&&e!==null,O9=/&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,R9={"&amp;":"&","&#38;":"&","&lt;":"<","&#60;":"<","&gt;":">","&#62;":">","&apos;":"'","&#39;":"'","&quot;":'"',"&#34;":'"',"&nbsp;":" ","&#160;":" ","&copy;":"","&#169;":"","&reg;":"","&#174;":"","&hellip;":"","&#8230;":"","&#x2F;":"/","&#47;":"/"},N9=e=>R9[e],L9=e=>e.replace(O9,N9);let bb={bindI18n:"languageChanged",bindI18nStore:"",transEmptyNodeValue:"",transSupportBasicHtmlNodes:!0,transWrapTextNodes:"",transKeepBasicHtmlNodesFor:["br","strong","i","p"],useSuspense:!0,unescape:L9};const z9=(e={})=>{bb={...bb,...e}},F9=()=>bb;let I4;const B9=e=>{I4=e},U9=()=>I4,V9={type:"3rdParty",init(e){z9(e.options.react),B9(e)}},G9=Ie.createContext();class j9{constructor(){this.usedNamespaces={}}addUsedNamespaces(t){t.forEach(n=>{this.usedNamespaces[n]||(this.usedNamespaces[n]=!0)})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const W9=(e,t)=>{const n=Ie.useRef();return Ie.useEffect(()=>{n.current=e},[e,t]),n.current},P4=(e,t,n,i)=>e.getFixedT(t,n,i),H9=(e,t,n,i)=>Ie.useCallback(P4(e,t,n,i),[e,t,n,i]),uc=(e,t={})=>{var x,S,$,C;const{i18n:n}=t,{i18n:i,defaultNS:r}=Ie.useContext(G9)||{},s=n||i||U9();if(s&&!s.reportNamespaces&&(s.reportNamespaces=new j9),!s){vb(s,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const P=(R,G)=>Gu(G)?G:D9(G)&&Gu(G.defaultValue)?G.defaultValue:Array.isArray(R)?R[R.length-1]:R,O=[P,{},!1];return O.t=P,O.i18n={},O.ready=!1,O}(x=s.options.react)!=null&&x.wait&&vb(s,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const a={...F9(),...s.options.react,...t},{useSuspense:o,keyPrefix:l}=a;let u=r||((S=s.options)==null?void 0:S.defaultNS);u=Gu(u)?[u]:u||["translation"],(C=($=s.reportNamespaces).addUsedNamespaces)==null||C.call($,u);const c=(s.isInitialized||s.initializedStoreOnce)&&u.every(P=>k9(P,s,a)),f=H9(s,t.lng||null,a.nsMode==="fallback"?u:u[0],l),d=()=>f,h=()=>P4(s,t.lng||null,a.nsMode==="fallback"?u:u[0],l),[m,y]=Ie.useState(d);let M=u.join();t.lng&&(M=`${t.lng}${M}`);const g=W9(M),_=Ie.useRef(!0);Ie.useEffect(()=>{const{bindI18n:P,bindI18nStore:O}=a;_.current=!0,!c&&!o&&(t.lng?rI(s,t.lng,u,()=>{_.current&&y(h)}):wb(s,u,()=>{_.current&&y(h)})),c&&g&&g!==M&&_.current&&y(h);const R=()=>{_.current&&y(h)};return P&&(s==null||s.on(P,R)),O&&(s==null||s.store.on(O,R)),()=>{_.current=!1,s&&P&&(P==null||P.split(" ").forEach(G=>s.off(G,R))),O&&s&&O.split(" ").forEach(G=>s.store.off(G,R))}},[s,M]),Ie.useEffect(()=>{_.current&&c&&y(d)},[s,l,c]);const T=[m,s,c];if(T.t=m,T.i18n=s,T.ready=c,c||!c&&!o)return T;throw new Promise(P=>{t.lng?rI(s,t.lng,u,()=>P()):wb(s,u,()=>P())})},sg=[{code:"auto",name:"languages.autoDetect"},{code:"en",name:"languages.english",asrCode:"en"},{code:"zh-TW",name:"languages.chineseTraditional",asrCode:"zh"},{code:"zh-HK",name:"languages.chineseTraditionalHK",asrCode:"zh"},{code:"zh-CN",name:"languages.chineseSimplified",asrCode:"zh"},{code:"es",name:"languages.spanish",asrCode:"es"},{code:"ja",name:"languages.japanese",asrCode:"ja"},{code:"fr",name:"languages.french",asrCode:"fr"},{code:"de",name:"languages.german",asrCode:"de"},{code:"ko",name:"languages.korean",asrCode:"ko"},{code:"ru",name:"languages.russian",asrCode:"ru"},{code:"it",name:"languages.italian",asrCode:"it"}],ag=[{name:"Gemma-3n-E2B (3.04 GB)",value:"gemma-3n-E2B-it-int4-Web.litertlm",url:"https://huggingface.co/willopcbeta/Gemma-3n-Web/resolve/main/gemma-3n-E2B-it-int4-Web.litertlm"},{name:"Gemma-3n-E4B (4.28 GB)",value:"gemma-3n-E4B-it-int4-Web.litertlm",url:"https://huggingface.co/willopcbeta/Gemma-3n-Web/resolve/main/gemma-3n-E4B-it-int4-Web.litertlm"}],Ru=[{id:"nicky48/whisper-large-v3-turbo-ONNX",name:"whisper-large-v3-turbo (q4f16)",quantization:{encoder_model:"q4f16",decoder_model_merged:"q4f16"},size:"~600 MB"},{id:"Xenova/whisper-small",name:"Whisper small (q4)",quantization:{encoder_model:"q4",decoder_model_merged:"q4"},size:"~300 MB"},{id:"Xenova/whisper-base",name:"Whisper Base (q4)",quantization:{encoder_model:"q4",decoder_model_merged:"q4"},size:"~150 MB"}],xb={ch_v5:{name:"ch_PP-OCRv5_mobile",description:"Chinese/English/Japanese",paths:{detPath:"https://www.modelscope.cn/models/RapidAI/RapidOCR/resolve/v3.4.0/onnx/PP-OCRv5/det/ch_PP-OCRv5_mobile_det.onnx",recPath:"https://www.modelscope.cn/models/RapidAI/RapidOCR/resolve/v3.4.0/onnx/PP-OCRv5/rec/ch_PP-OCRv5_rec_mobile_infer.onnx",dictPath:"https://www.modelscope.cn/models/RapidAI/RapidOCR/resolve/v3.4.0/paddle/PP-OCRv5/rec/ch_PP-OCRv5_rec_mobile_infer/ppocrv5_dict.txt"}},latin_v5:{name:"latin_PP-OCRv5_mobile",description:"Latin languages (French, German, Spanish, etc.)",paths:{detPath:"https://www.modelscope.cn/models/RapidAI/RapidOCR/resolve/v3.4.0/onnx/PP-OCRv5/det/ch_PP-OCRv5_mobile_det.onnx",recPath:"https://www.modelscope.cn/models/RapidAI/RapidOCR/resolve/v3.4.0/onnx/PP-OCRv5/rec/latin_PP-OCRv5_rec_mobile_infer.onnx",dictPath:"https://www.modelscope.cn/models/RapidAI/RapidOCR/resolve/v3.4.0/paddle/PP-OCRv5/rec/latin_PP-OCRv5_rec_mobile_infer/ppocrv5_latin_dict.txt"}},kr_v5:{name:"korean_PP-OCRv5_mobile",description:"Korean Only",paths:{detPath:"https://www.modelscope.cn/models/RapidAI/RapidOCR/resolve/v3.4.0/onnx/PP-OCRv5/det/ch_PP-OCRv5_mobile_det.onnx",recPath:"https://www.modelscope.cn/models/RapidAI/RapidOCR/resolve/v3.4.0/onnx/PP-OCRv5/rec/korean_PP-OCRv5_rec_mobile_infer.onnx",dictPath:"https://www.modelscope.cn/models/RapidAI/RapidOCR/resolve/v3.4.0/paddle/PP-OCRv5/rec/korean_PP-OCRv5_rec_mobile_infer/ppocrv5_korean_dict.txt"}}},q9=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"})}),K9=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M12 4a4 4 0 100 8 4 4 0 000-8zM8 21v-2a4 4 0 014-4h0a4 4 0 014 4v2"})}),J9=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M12 4a4 4 0 100 8 4 4 0 000-8zM6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"})}),Y9=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"})}),X9=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"})}),Q9=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-5 w-5",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M19 9l-7 7-7-7"})}),Z9=e=>se.jsxs("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:[se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"}),se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M15 13a3 3 0 11-6 0 3 3 0 016 0z"})]}),e7=e=>se.jsxs("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:[se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"}),se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M15 12a3 3 0 11-6 0 3 3 0 016 0z"})]}),t7=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M3 5h12M9 3v2m4 13-4-4-4 4M5 11h10a2 2 0 012 2v2a2 2 0 01-2 2H5a2 2 0 01-2-2v-2a2 2 0 012-2zM19 9l-2 2-2-2"})}),Rp=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M6 18L18 6M6 6l12 12"})}),n7=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",strokeWidth:2,...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M7 16V4m0 12L4 9m3 3l3-3m6 8V4m0 12l3-3m-3 3l-3-3"})}),i7=e=>se.jsxs("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:[se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M17 1l4 4-4 4"}),se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M3 11V9a4 4 0 014-4h14"}),se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M7 23l-4-4 4-4"}),se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M21 13v2a4 4 0 01-4 4H3"})]}),k4=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"})}),Tb=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"})}),r7=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M13 10V3L4 14h7v7l9-11h-7z"})}),s7=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M13.875 18.825L10 14h- hkmet 3L13 10V3L5.125 10.125m13.75 3.75L15 10m-2.125 8.825L18 14h-3l-1.875 4.825zM1 1l22 22"})}),a7=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"})}),o7=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",strokeWidth:"2",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M8.111 16.222c1.733-1.733 4.589-1.733 6.322 0M5.444 13.556c3.222-3.222 8.444-3.222 11.667 0M2.778 10.889c4.711-4.711 12.333-4.711 17.044 0"})}),l7=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",strokeWidth:"2",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M8.111 16.222c1.733-1.733 4.589-1.733 6.322 0M5.444 13.556c.9-1.033 2.022-1.9 3.222-2.589m5.667.122c.711.389 1.356.844 1.933 1.389M2.778 10.889a14.838 14.838 0 012.667-3.022m11.6.022a14.833 14.833 0 012.667 3.022M1 1l22 22"})}),u7=e=>se.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-6 w-6",fill:"currentColor",viewBox:"0 0 24 24",stroke:"currentColor",strokeWidth:"1.5",...e,children:se.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M5.25 7.5A2.25 2.25 0 017.5 5.25h9a2.25 2.25 0 012.25 2.25v9a2.25 2.25 0 01-2.25 2.25h-9a2.25 2.25 0 01-2.25-2.25v-9z"})}),D4=({selectedLang:e,setSelectedLang:t,languages:n})=>{const{t:i}=uc(),[r,s]=Ie.useState(!1),[a,o]=Ie.useState("bottom"),l=Ie.useRef(null),u=Ie.useRef(null),c=d=>{t(d),s(!1)};Ie.useEffect(()=>{if(r&&u.current){const d=u.current.getBoundingClientRect(),h=240;window.innerHeight-d.bottom<h&&d.top>h?o("top"):o("bottom")}},[r]),Ie.useEffect(()=>{const d=h=>{l.current&&!l.current.contains(h.target)&&s(!1)};return document.addEventListener("mousedown",d),()=>{document.removeEventListener("mousedown",d)}},[]);const f=a==="top"?"bottom-full mb-2":"mt-2";return se.jsxs("div",{className:"relative",ref:l,children:[se.jsxs("button",{ref:u,onClick:()=>s(!r),className:"flex items-center space-x-2 text-lg font-semibold text-gray-700 hover:text-blue-600",children:[se.jsx("span",{children:i(e.name)}),se.jsx(Q9,{className:`h-2.5 w-2.5 transition-transform ${r?"rotate-180":""}`})]}),r&&se.jsx("div",{className:`absolute z-10 ${f} w-56 bg-white rounded-md shadow-lg border border-gray-100 max-h-60 overflow-y-auto`,children:se.jsx("ul",{className:"py-1",children:n.map(d=>se.jsx("li",{children:se.jsx("button",{onClick:()=>c(d),className:`w-full text-left px-4 py-2 text-sm ${e.code===d.code?"bg-blue-50 text-blue-600":"text-gray-700 hover:bg-gray-100"}`,children:i(d.name)})},d.code))})})]})},sI=3e3,c7=({inputText:e,setInputText:t,sourceLang:n,setSourceLang:i,isLoading:r,onTranslate:s,onCancel:a,isRecording:o,onToggleRecording:l,onOpenCamera:u,onOpenSettings:c,isOnline:f,isOfflineModeEnabled:d,isOfflineModelReady:h,recordingCountdown:m})=>{const{t:y}=uc(),M=T=>{T.target.value.length<=sI&&t(T.target.value)},g=!e.trim()||o||(d?!h:!f),_=()=>{r?a():s()};return se.jsxs("div",{className:"bg-white rounded-xl shadow-md h-full flex flex-col p-4",children:[se.jsxs("div",{className:"flex justify-between items-center mb-2",children:[se.jsx(D4,{selectedLang:n,setSelectedLang:i,languages:sg}),se.jsxs("div",{className:"flex items-center space-x-4 text-gray-500",children:[se.jsx("div",{title:y(f?"translationInput.online":"translationInput.offline"),children:f?se.jsx(o7,{className:"text-green-500"}):se.jsx(l7,{className:"text-gray-400"})}),se.jsx("button",{onClick:u,className:"hover:text-blue-500","aria-label":y("translationInput.cameraAriaLabel"),children:se.jsx(Z9,{})}),se.jsx("button",{onClick:c,className:"hover:text-blue-500","aria-label":y("translationInput.settingsAriaLabel"),children:se.jsx(e7,{})})]})]}),se.jsxs("div",{className:"relative border border-gray-200 rounded-lg flex-grow",children:[se.jsx("textarea",{value:e,onChange:M,placeholder:y(o?"translationInput.placeholderListening":"translationInput.placeholderEnterText"),className:"w-full h-full p-4 pr-12 text-lg border-none focus:ring-0 resize-none bg-transparent",disabled:o}),e&&!o&&se.jsx("button",{onClick:()=>t(""),className:"absolute top-4 right-4 text-gray-400 hover:text-gray-600","aria-label":y("translationInput.clearText"),children:se.jsx(Rp,{})})]}),se.jsxs("div",{className:"flex justify-between items-center mt-2",children:[se.jsx("p",{className:"text-sm text-gray-400 w-20",children:o&&d&&m!==null?se.jsxs("span",{className:"text-red-500 font-semibold text-base tabular-nums",children:[y("translationInput.countdownPrefix"),String(m).padStart(2,"0")]}):`${e.length}/${sI}`}),se.jsxs("div",{className:"flex items-center space-x-2",children:[se.jsx("button",{onClick:l,className:`p-3 rounded-lg flex items-center justify-center transition-colors ${o?"bg-red-500 text-white animate-pulse":"bg-gray-200 text-gray-600 hover:bg-gray-300"}`,"aria-label":y(o?"translationInput.recordingStop":"translationInput.recordingStart"),children:se.jsx(k4,{})}),se.jsx("button",{onClick:_,disabled:!r&&g,title:y(r?"translationInput.cancelTranslation":d?"translationInput.translateOffline":"translationInput.translate"),className:`text-white rounded-lg p-3 flex items-center justify-center transition-colors ${r?"bg-red-500 hover:bg-red-600":"bg-blue-500 hover:bg-blue-600 disabled:bg-blue-300 disabled:cursor-not-allowed"}`,children:r?se.jsx(u7,{}):se.jsx(t7,{})})]})]})]})},d7=({translatedText:e,targetLang:t,setTargetLang:n,isLoading:i,onSpeak:r,onSwapLanguages:s,onOpenHistory:a,onClearText:o,isOfflineModeEnabled:l,isOfflineModelInitializing:u,isOfflineModelReady:c,offlineModelName:f,isSpeaking:d,speakingGender:h,onlineProvider:m,isOfflineTtsEnabled:y,isAstRecording:M,onToggleAstRecording:g})=>{const{t:_}=uc(),[T,x]=Ie.useState(!1),S=()=>{e&&navigator.clipboard.writeText(e)},$=()=>{x(P=>!P)},C=()=>{if(!l){const R=m.charAt(0).toUpperCase()+m.slice(1);return _("translationOutput.modeOnline",{provider:R})}const P=ag.find(R=>R.value===f),O=P?P.name.split(" ")[0]:"";return u?_("translationOutput.modeOfflineInitializing",{modelName:O}):c?_("translationOutput.modeOfflineReady",{modelName:O}):f?_("translationOutput.modeOfflineNotReady",{modelName:O}):_("translationOutput.modeOfflineNoModel")};return se.jsxs("div",{className:`bg-white rounded-xl shadow-md p-4 h-full flex flex-col transition-transform duration-500 ease-in-out ${T?"rotate-180":""}`,children:[se.jsxs("div",{className:"flex-shrink-0",children:[se.jsxs("div",{className:"flex justify-between items-center mb-1",children:[se.jsx(D4,{selectedLang:t,setSelectedLang:n,languages:sg.filter(P=>P.code!=="auto")}),se.jsx("button",{onClick:s,className:"p-2 rounded-full hover:bg-gray-100 transition-colors text-gray-500",children:se.jsx(n7,{})}),se.jsxs("div",{className:"flex items-center space-x-4 text-gray-500",children:[se.jsx("button",{onClick:$,className:"hover:text-blue-500","aria-label":_("translationOutput.flipScreenAriaLabel"),children:se.jsx(i7,{})}),se.jsx("button",{onClick:S,disabled:!e,className:"hover:text-blue-500 disabled:text-gray-300 disabled:cursor-not-allowed","aria-label":_("translationOutput.copyAriaLabel"),children:se.jsx(Y9,{})}),se.jsx("button",{onClick:a,className:"hover:text-blue-500","aria-label":_("translationOutput.historyAriaLabel"),children:se.jsx(X9,{})}),se.jsx("button",{onClick:o,disabled:!e,className:"hover:text-red-500 disabled:text-gray-300 disabled:cursor-not-allowed","aria-label":_("translationOutput.clearAriaLabel"),children:se.jsx(Rp,{})})]})]}),se.jsx("div",{className:"text-right text-xs text-gray-400 mb-2 px-1",children:C()})]}),se.jsx("div",{className:"text-2xl text-gray-800 break-words flex-grow overflow-y-auto min-h-0 whitespace-pre-wrap",children:i&&!e?se.jsxs("div",{className:"space-y-2 animate-pulse",children:[se.jsx("div",{className:"h-6 bg-gray-200 rounded w-3/4"}),se.jsx("div",{className:"h-6 bg-gray-200 rounded w-1/2"})]}):e||se.jsx("span",{className:"text-gray-400",children:_("translationOutput.placeholder")})}),se.jsxs("div",{className:"flex items-center justify-start mt-4 space-x-2 flex-shrink-0",children:[y?se.jsx("button",{onClick:()=>r("female"),disabled:!e,className:`text-white rounded-lg p-3 flex items-center justify-center disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors ${d?"bg-indigo-600 animate-pulse":"bg-indigo-500 hover:bg-indigo-600"}`,"aria-label":_(d?"translationOutput.speakStop":"translationOutput.speakCustomVoice"),children:se.jsx(q9,{})}):se.jsxs(se.Fragment,{children:[se.jsx("button",{onClick:()=>r("female"),disabled:!e,className:`text-white rounded-lg p-3 flex items-center justify-center disabled:bg-pink-200 disabled:cursor-not-allowed transition-colors ${d&&h==="female"?"bg-pink-600 animate-pulse":"bg-pink-400 hover:bg-pink-500"}`,"aria-label":_(d&&h==="female"?"translationOutput.speakStop":"translationOutput.speakFemale"),children:se.jsx(K9,{})}),se.jsx("button",{onClick:()=>r("male"),disabled:!e,className:`text-white rounded-lg p-3 flex items-center justify-center disabled:bg-blue-300 disabled:cursor-not-allowed transition-colors ${d&&h==="male"?"bg-blue-700 animate-pulse":"bg-blue-500 hover:bg-blue-600"}`,"aria-label":_(d&&h==="male"?"translationOutput.speakStop":"translationOutput.speakMale"),children:se.jsx(J9,{})})]}),se.jsx("button",{onClick:g,disabled:i,className:`text-white rounded-lg p-3 flex items-center justify-center transition-colors disabled:bg-gray-300 disabled:cursor-not-allowed ${M?"bg-red-500 animate-pulse":"bg-indigo-500 hover:bg-indigo-600"}`,"aria-label":_(M?"translationOutput.astStop":"translationOutput.astStart"),title:_("translationOutput.astTitle"),children:se.jsx(k4,{})})]})]})};var O4={exports:{}};(function(e,t){(function(i,r){e.exports=r(Ie)})(kH,function(n){return function(i){var r={};function s(a){if(r[a])return r[a].exports;var o=r[a]={i:a,l:!1,exports:{}};return i[a].call(o.exports,o,o.exports,s),o.l=!0,o.exports}return s.m=i,s.c=r,s.d=function(a,o,l){s.o(a,o)||Object.defineProperty(a,o,{enumerable:!0,get:l})},s.r=function(a){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(a,"__esModule",{value:!0})},s.t=function(a,o){if(o&1&&(a=s(a)),o&8||o&4&&typeof a=="object"&&a&&a.__esModule)return a;var l=Object.create(null);if(s.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:a}),o&2&&typeof a!="string")for(var u in a)s.d(l,u,(function(c){return a[c]}).bind(null,u));return l},s.n=function(a){var o=a&&a.__esModule?function(){return a.default}:function(){return a};return s.d(o,"a",o),o},s.o=function(a,o){return Object.prototype.hasOwnProperty.call(a,o)},s.p="",s(s.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(i,r,s){s.r(r);var a=s("react"),o=function(){var d=function(h,m){return d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,M){y.__proto__=M}||function(y,M){for(var g in M)M.hasOwnProperty(g)&&(y[g]=M[g])},d(h,m)};return function(h,m){d(h,m);function y(){this.constructor=h}h.prototype=m===null?Object.create(m):(y.prototype=m.prototype,new y)}}(),l=function(){return l=Object.assign||function(d){for(var h,m=1,y=arguments.length;m<y;m++){h=arguments[m];for(var M in h)Object.prototype.hasOwnProperty.call(h,M)&&(d[M]=h[M])}return d},l.apply(this,arguments)},u=function(d,h){var m={};for(var y in d)Object.prototype.hasOwnProperty.call(d,y)&&h.indexOf(y)<0&&(m[y]=d[y]);if(d!=null&&typeof Object.getOwnPropertySymbols=="function")for(var M=0,y=Object.getOwnPropertySymbols(d);M<y.length;M++)h.indexOf(y[M])<0&&Object.prototype.propertyIsEnumerable.call(d,y[M])&&(m[y[M]]=d[y[M]]);return m};(function(){typeof window>"u"||(navigator.mediaDevices===void 0&&(navigator.mediaDevices={}),navigator.mediaDevices.getUserMedia===void 0&&(navigator.mediaDevices.getUserMedia=function(h){var m=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return m?new Promise(function(y,M){m.call(navigator,h,y,M)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}))})();function c(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}var f=function(d){o(h,d);function h(m){var y=d.call(this,m)||this;return y.canvas=null,y.ctx=null,y.requestUserMediaId=0,y.unmounted=!1,y.state={hasUserMedia:!1},y}return h.prototype.componentDidMount=function(){var m=this,y=m.state,M=m.props;if(this.unmounted=!1,!c()){M.onUserMediaError("getUserMedia not supported");return}y.hasUserMedia||this.requestUserMedia(),M.children&&typeof M.children!="function"&&console.warn("children must be a function")},h.prototype.componentDidUpdate=function(m){var y=this.props;if(!c()){y.onUserMediaError("getUserMedia not supported");return}var M=JSON.stringify(m.audioConstraints)!==JSON.stringify(y.audioConstraints),g=JSON.stringify(m.videoConstraints)!==JSON.stringify(y.videoConstraints),_=m.minScreenshotWidth!==y.minScreenshotWidth,T=m.minScreenshotHeight!==y.minScreenshotHeight;(g||_||T)&&(this.canvas=null,this.ctx=null),(M||g)&&(this.stopAndCleanup(),this.requestUserMedia())},h.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},h.stopMediaStream=function(m){m&&(m.getVideoTracks&&m.getAudioTracks?(m.getVideoTracks().map(function(y){m.removeTrack(y),y.stop()}),m.getAudioTracks().map(function(y){m.removeTrack(y),y.stop()})):m.stop())},h.prototype.stopAndCleanup=function(){var m=this.state;m.hasUserMedia&&(h.stopMediaStream(this.stream),m.src&&window.URL.revokeObjectURL(m.src))},h.prototype.getScreenshot=function(m){var y=this,M=y.state,g=y.props;if(!M.hasUserMedia)return null;var _=this.getCanvas(m);return _&&_.toDataURL(g.screenshotFormat,g.screenshotQuality)},h.prototype.getCanvas=function(m){var y=this,M=y.state,g=y.props;if(!this.video||!M.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var _=this.video.videoWidth,T=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var x=_/T;_=g.minScreenshotWidth||this.video.clientWidth,T=_/x,g.minScreenshotHeight&&T<g.minScreenshotHeight&&(T=g.minScreenshotHeight,_=T*x)}this.canvas=document.createElement("canvas"),this.canvas.width=(m==null?void 0:m.width)||_,this.canvas.height=(m==null?void 0:m.height)||T,this.ctx=this.canvas.getContext("2d")}var S=this,$=S.ctx,C=S.canvas;return $&&C&&(C.width=(m==null?void 0:m.width)||C.width,C.height=(m==null?void 0:m.height)||C.height,g.mirrored&&($.translate(C.width,0),$.scale(-1,1)),$.imageSmoothingEnabled=g.imageSmoothing,$.drawImage(this.video,0,0,(m==null?void 0:m.width)||C.width,(m==null?void 0:m.height)||C.height),g.mirrored&&($.scale(-1,1),$.translate(-C.width,0))),C},h.prototype.requestUserMedia=function(){var m=this,y=this.props,M=function(T,x){var S={video:typeof x<"u"?x:!0};y.audio&&(S.audio=typeof T<"u"?T:!0),m.requestUserMediaId++;var $=m.requestUserMediaId;navigator.mediaDevices.getUserMedia(S).then(function(C){m.unmounted||$!==m.requestUserMediaId?h.stopMediaStream(C):m.handleUserMedia(null,C)}).catch(function(C){m.handleUserMedia(C)})};if("mediaDevices"in navigator)M(y.audioConstraints,y.videoConstraints);else{var g=function(T){return{optional:[{sourceId:T}]}},_=function(T){var x=T.deviceId;return typeof x=="string"?x:Array.isArray(x)&&x.length>0?x[0]:typeof x=="object"&&x.ideal?x.ideal:null};MediaStreamTrack.getSources(function(T){var x=null,S=null;T.forEach(function(P){P.kind==="audio"?x=P.id:P.kind==="video"&&(S=P.id)});var $=_(y.audioConstraints);$&&(x=$);var C=_(y.videoConstraints);C&&(S=C),M(g(x),g(S))})}},h.prototype.handleUserMedia=function(m,y){var M=this.props;if(m||!y){this.setState({hasUserMedia:!1}),M.onUserMediaError(m);return}this.stream=y;try{this.video&&(this.video.srcObject=y),this.setState({hasUserMedia:!0})}catch{this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(y)})}M.onUserMedia(y)},h.prototype.render=function(){var m=this,y=this,M=y.state,g=y.props,_=g.audio;g.forceScreenshotSourceSize;var T=g.disablePictureInPicture;g.onUserMedia,g.onUserMediaError,g.screenshotFormat,g.screenshotQuality,g.minScreenshotWidth,g.minScreenshotHeight,g.audioConstraints,g.videoConstraints,g.imageSmoothing;var x=g.mirrored,S=g.style,$=S===void 0?{}:S,C=g.children,P=u(g,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),O=x?l(l({},$),{transform:($.transform||"")+" scaleX(-1)"}):$,R={getScreenshot:this.getScreenshot.bind(this)};return a.createElement(a.Fragment,null,a.createElement("video",l({autoPlay:!0,disablePictureInPicture:T,src:M.src,muted:!_,playsInline:!0,ref:function(G){m.video=G},style:O},P)),C&&C(R))},h.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},h}(a.Component);r.default=f},react:function(i,r){i.exports=n}}).default})})(O4);var f7=O4.exports;const p7=M1(f7),h7=({onClose:e,onImageCaptured:t})=>{const{t:n}=uc(),i=Ie.useRef(null),r=Ie.useRef(null),[s,a]=Ie.useState(null),[o,l]=Ie.useState(null),[u,c]=Ie.useState(!1),f=Ie.useRef(!1),[d,h]=Ie.useState(!1),[m,y]=Ie.useState(!1),[M,g]=Ie.useState(0),[_,T]=Ie.useState(!1),[x,S]=Ie.useState({min:1,max:1}),$=Ie.useCallback((te,J,j)=>J===j?J:J*Math.pow(j/J,te/100),[]),C=Ie.useCallback((te,J,j)=>J===j?0:Math.log(te/J)/Math.log(j/J)*100,[]),P=Ie.useCallback(te=>{a(te);const J=te.getVideoTracks()[0];if(!J)return;const j=J.getCapabilities()||{};if(j.torch&&y(!0),j.zoom){T(!0),S({min:j.zoom.min,max:j.zoom.max});const Y=J.getSettings().zoom||j.zoom.min;g(C(Y,j.zoom.min,j.zoom.max))}},[C]),O=async te=>{if(!s||!_||f.current)return;const J=parseFloat(te.target.value);g(J);const j=$(J,x.min,x.max),Y=s.getVideoTracks()[0];try{f.current=!0,await Y.applyConstraints({advanced:[{zoom:j}]})}catch(X){console.error("Failed to apply zoom:",X)}finally{f.current=!1}},R=async()=>{if(!s||!m||f.current)return;const te=!d,J=s.getVideoTracks()[0];try{f.current=!0,await J.applyConstraints({advanced:[{torch:te}]}),h(te)}catch(j){console.error("Failed to apply torch:",j)}finally{f.current=!1}},G=Ie.useCallback(()=>{if(!(u||!i.current)){c(!0),l(null);try{const te=i.current.getScreenshot({width:1920,height:1080});if(te)t(te);else throw new Error("Could not get screenshot from camera.")}catch(te){const J=te instanceof Error?te.message:"Capture failed.";l(n("camera.errorCapture",{message:J})),c(!1)}}},[u,t,n]),W=te=>{var j;const J=(j=te.target.files)==null?void 0:j[0];if(!(!J||u)){c(!0);try{const Y=new FileReader;Y.onload=X=>{var me;const ce=(me=X.target)==null?void 0:me.result;ce&&t(ce)},Y.readAsDataURL(J)}catch{l(n("camera.errorLoad",{message:"File read error"})),c(!1)}}},V={facingMode:"environment",width:{ideal:1920},height:{ideal:1080}};return se.jsx("div",{className:"fixed inset-0 bg-black z-50 flex flex-col items-center justify-center overflow-hidden",role:"dialog","aria-modal":"true",children:se.jsxs("div",{className:"relative w-full h-full flex items-center justify-center",children:[se.jsx(p7,{ref:i,audio:!1,screenshotFormat:"image/jpeg",screenshotQuality:1,videoConstraints:V,onUserMedia:P,onUserMediaError:te=>l(n("camera.errorAccess")),className:"w-full h-full object-cover"}),se.jsx("input",{type:"file",accept:"image/*",ref:r,onChange:W,className:"hidden"}),se.jsxs("div",{className:"absolute inset-0 flex flex-col justify-between items-center p-4 z-20 pointer-events-none",children:[se.jsxs("div",{className:"w-full flex justify-between items-start pointer-events-auto",children:[se.jsx("div",{className:"text-white text-xs font-medium bg-black/40 backdrop-blur-sm px-4 py-2 rounded-full shadow-lg border border-white/10"}),se.jsx("button",{onClick:e,className:"text-white bg-black/40 backdrop-blur-sm rounded-full p-2 border border-white/10 hover:bg-black/60 transition-colors shadow-lg","aria-label":n("camera.closeAriaLabel"),children:se.jsx(Rp,{className:"w-8 h-8"})})]}),o&&se.jsx("div",{className:"bg-red-600 text-white px-4 py-2 rounded-full text-sm shadow-xl pointer-events-auto animate-bounce",role:"alert",children:o}),se.jsxs("div",{className:"w-full flex flex-col items-center pb-8 space-y-6 pointer-events-auto",children:[_&&se.jsxs("div",{className:"w-full max-w-xs flex flex-col items-center space-y-2",children:[se.jsxs("div",{className:"flex justify-between w-full px-2 text-[10px] text-white/70 font-bold uppercase tracking-widest",children:[se.jsx("span",{children:"1x"}),se.jsxs("span",{className:"bg-blue-500/80 px-2 py-0.5 rounded text-white",children:[$(M,x.min,x.max).toFixed(1),"x"]}),se.jsxs("span",{children:[x.max.toFixed(0),"x"]})]}),se.jsx("div",{className:"w-full h-12 flex items-center px-2 bg-black/30 backdrop-blur-md rounded-2xl border border-white/5",children:se.jsx("input",{type:"range",min:"0",max:"100",step:"1",value:M,onChange:O,className:"w-full h-1.5 bg-white/20 rounded-lg appearance-none cursor-pointer accent-blue-500","aria-label":n("camera.zoomAriaLabel")})})]}),se.jsxs("div",{className:"w-full flex justify-around items-center max-w-sm",children:[se.jsx("button",{onClick:()=>{var te;return(te=r.current)==null?void 0:te.click()},className:"p-3 bg-white/10 backdrop-blur-md rounded-full border border-white/20 text-white hover:bg-white/20 transition-all shadow-lg","aria-label":n("camera.galleryAriaLabel"),children:se.jsx(a7,{className:"w-8 h-8"})}),se.jsxs("button",{onClick:G,disabled:u,className:"group relative w-20 h-20 flex items-center justify-center disabled:opacity-50","aria-label":n("camera.captureAriaLabel"),children:[se.jsx("div",{className:"absolute inset-0 bg-white/20 rounded-full animate-pulse group-hover:bg-white/30"}),se.jsx("div",{className:"relative w-16 h-16 bg-white rounded-full shadow-2xl flex items-center justify-center transition-transform active:scale-90",children:u&&se.jsx("div",{className:"w-10 h-10 border-4 border-blue-500 border-t-transparent rounded-full animate-spin",role:"status","aria-label":n("camera.processingAriaLabel")})})]}),m?se.jsx("button",{onClick:R,className:`p-3 backdrop-blur-md rounded-full border transition-all shadow-lg ${d?"bg-yellow-400 border-yellow-500 text-black":"bg-white/10 border-white/20 text-white hover:bg-white/20"}`,"aria-label":n(d?"camera.flashOnAriaLabel":"camera.flashOffAriaLabel"),children:d?se.jsx(r7,{className:"w-8 h-8"}):se.jsx(s7,{className:"w-8 h-8"})}):se.jsx("div",{className:"w-14 h-14"})]})]})]})]})})},m7=({isOpen:e,onClose:t,onSave:n,currentApiKey:i,currentModelName:r,currentOnlineProvider:s,currentOpenaiApiUrl:a,currentHuggingFaceApiKey:o,currentOfflineModelName:l,currentIsOfflineModeEnabled:u,currentIsTwoStepJpCnEnabled:c,downloadProgress:f,onStartDownload:d,onResumeDownload:h,onPauseDownload:m,onDeleteModel:y,isOfflineModelInitializing:M,voices:g,targetLang:_,currentIsOfflineTtsEnabled:T,currentOfflineTtsVoiceURI:x,currentOfflineTtsRate:S,currentOfflineTtsPitch:$,currentOfflineMaxTokens:C,currentOfflineTopK:P,currentOfflineTemperature:O,currentOfflineRandomSeed:R,currentOfflineSupportAudio:G,currentOfflineMaxNumImages:W,currentIsOfflineAsrEnabled:V,currentIsWebSpeechApiEnabled:te,currentAsrModelId:J,currentIsNoiseCancellationEnabled:j,currentAudioGainValue:Y,asrModelsCacheStatus:X,isAsrInitializing:ce,asrLoadingProgress:me,onDownloadAsrModel:Q,onClearAsrCache:H,ocrEngineStatus:B,ocrEngineError:ee,onInitializeOcr:_e,currentSelectedOcrModel:le})=>{const{t:ae,i18n:Ne}=uc(),[Ye,ze]=Ie.useState("online"),[ue,U]=Ie.useState(i),[we,Pe]=Ie.useState(r),[ke,Le]=Ie.useState(s),[Ge,$e]=Ie.useState(a),[et,Ce]=Ie.useState(o),[He,at]=Ie.useState(l),[Z,he]=Ie.useState(u),[ye,Ke]=Ie.useState(c),[Be,Se]=Ie.useState(V),[Oe,ct]=Ie.useState(te),[bt,Ct]=Ie.useState(J),[Et,hn]=Ie.useState(j),[En,Kt]=Ie.useState(Y),[yi,Ji]=Ie.useState(T),[tr,Ti]=Ie.useState(x),[Yn,$n]=Ie.useState(S),[Yi,Gi]=Ie.useState($),[xt,ji]=Ie.useState([]),[Wi,Sn]=Ie.useState(C),[Ii,Xt]=Ie.useState(P),[nr,L]=Ie.useState(O),[oe,K]=Ie.useState(R),[re,de]=Ie.useState(G),[xe,Ue]=Ie.useState(W),[_t,$t]=Ie.useState(le);if(Ie.useEffect(()=>{e&&(U(i),Pe(r),Le(s),$e(a),Ce(o),at(l),he(u),Ke(c),Ji(T),Ti(x),$n(S),Gi($),Sn(C),Xt(P),L(O),K(R),de(G),Ue(W),Se(V),ct(te),Ct(J),hn(j),Kt(Y),$t(le))},[e,i,r,s,a,o,l,u,c,T,x,S,$,C,P,O,R,G,W,V,te,J,j,Y,le]),Ie.useEffect(()=>{var Je;if(e&&g.length>0&&_){const qt=g.filter(Pt=>Pt.lang.startsWith(_.code));ji(qt),tr&&!qt.some(Pt=>Pt.voiceURI===tr)&&Ti(((Je=qt[0])==null?void 0:Je.voiceURI)||"")}},[e,g,_,tr]),!e)return null;const mt=()=>{n(ue,we,et,He,bt,Z,Be,Oe,ke,Ge,yi,tr,Yn,Yi,ye,Wi,Ii,nr,oe,re,xe,Et,En,_t),t()},Ht=()=>{U(""),Pe("gemini-2.5-flash"),Le("gemini"),$e(""),Ce(""),at(""),he(!1),Ke(!1),Ji(!1),Ti(""),$n(1),Gi(1),Sn(4096),Xt(40),L(.3),K(101),de(!1),Ue(0),$t("ch_v5"),Se(!1),ct(!0),Ct(Ru[0].id),hn(!1),Kt(1),H(),ag.forEach(Je=>Je.value&&y(Je.value)),n("","gemini-2.5-flash","","",Ru[0].id,!1,!1,!0,"gemini","",!1,"",1,1,!1,4096,40,.3,101,!1,0,!1,1,"ch_v5")},It=Je=>{at(Je.target.value)},Zt=Je=>{Ct(Je.target.value)},St=async()=>{const Je={key:_t,...xb[_t].paths};await _e(Je)},tn=({tabName:Je,label:qt})=>se.jsx("button",{onClick:()=>ze(Je),className:`px-4 py-2 text-sm font-medium rounded-md focus:outline-none ${Ye===Je?"bg-blue-100 text-blue-700":"text-gray-500 hover:text-gray-700"}`,"aria-selected":Ye===Je,role:"tab",children:qt}),vn=(Je,qt=2)=>{if(!Je||Je===0)return"0 Bytes";const Pt=1024,kt=qt<0?0:qt,An=["Bytes","KB","MB","GB","TB"],zn=Math.floor(Math.log(Je)/Math.log(Pt));return parseFloat((Je/Math.pow(Pt,zn)).toFixed(kt))+" "+An[zn]},Wn=Je=>{const qt=f[Je.value]||{status:"not_started",percent:0,downloaded:0,total:0},Pt=M&&He===Je.value,kt=({onClick:Un,text:In,className:ir="bg-blue-500 hover:bg-blue-600",disabled:Mi})=>se.jsx("button",{onClick:Un,disabled:Mi,className:`text-white text-xs font-semibold py-1 px-3 rounded-md transition-colors disabled:bg-gray-300 disabled:cursor-not-allowed ${ir}`,children:In}),An=Pt||qt.status==="consolidating",zn=qt.status,ni=ae(`common.status.${zn}`);return se.jsxs("div",{className:"flex flex-col space-y-2 p-3 border border-gray-200 rounded-lg bg-gray-50",children:[se.jsxs("div",{className:"flex justify-between items-center",children:[se.jsxs("div",{className:"flex items-center",children:[se.jsx("input",{type:"radio",id:`model-${Je.value}`,name:"offline-model-selection",value:Je.value,checked:He===Je.value,onChange:It,disabled:qt.status!=="completed"||An,className:"h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500 disabled:cursor-not-allowed"}),se.jsx("label",{htmlFor:`model-${Je.value}`,className:"ml-2 text-sm font-medium text-gray-800",children:Je.name})]}),se.jsxs("div",{className:"flex items-center space-x-2",children:[qt.status==="not_started"&&se.jsx(kt,{onClick:()=>d(Je.value,Je.url),text:ae("settings.download")}),qt.status==="downloading"&&se.jsx(kt,{onClick:()=>m(Je.value),text:ae("settings.pause"),className:"bg-yellow-500 hover:bg-yellow-600"}),qt.status==="paused"&&se.jsx(kt,{onClick:()=>h(Je.value,Je.url),text:ae("settings.resume")}),qt.status==="error"&&se.jsx(kt,{onClick:()=>h(Je.value,Je.url),text:ae("settings.retry")}),qt.status!=="not_started"&&qt.status!=="downloading"&&qt.status!=="consolidating"&&se.jsx("button",{onClick:()=>y(Je.value),className:"p-1.5 text-gray-500 hover:text-red-600 hover:bg-red-50 rounded-full","aria-label":ae("settings.deleteModelAriaLabel",{modelName:Je.name}),children:se.jsx(Tb,{className:"w-4 h-4"})})]})]}),(qt.status!=="not_started"||An)&&se.jsxs("div",{children:[se.jsx("div",{className:"w-full bg-gray-200 rounded-full h-2 relative overflow-hidden",children:se.jsx("div",{className:`h-2 rounded-full ${An?"bg-green-400 w-full animate-pulse":"bg-blue-500"}`,style:{width:`${qt.percent}%`}})}),se.jsxs("div",{className:"text-xs text-gray-500 mt-1 flex justify-between",children:[se.jsx("span",{children:ni}),qt.status==="downloading"&&!An&&se.jsxs("span",{children:[vn(qt.downloaded)," / ",vn(qt.total)," (",Math.round(qt.percent),"%)"]})]})]}),qt.status==="error"&&se.jsx("p",{className:"text-xs text-red-600 mt-1",children:ae("settings.statusError",{error:qt.error})})]})},ei=({id:Je,label:qt,value:Pt,onChange:kt,min:An,max:zn,step:ni})=>se.jsxs("div",{children:[se.jsxs("label",{htmlFor:Je,className:"flex justify-between items-center text-sm font-medium text-gray-700 mb-1",children:[se.jsx("span",{children:qt}),se.jsx("span",{className:"text-gray-500 font-normal",children:Pt})]}),se.jsx("input",{type:"range",id:Je,min:An,max:zn,step:ni,value:Pt,onChange:kt,className:"w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"})]}),Bn=({id:Je,isEnabled:qt,setIsEnabled:Pt,title:kt,description:An,disabled:zn})=>se.jsxs("div",{className:"flex items-center justify-between",children:[se.jsxs("label",{htmlFor:Je,className:`text-sm font-medium ${zn?"text-gray-400":"text-gray-700"}`,children:[kt,se.jsx("span",{className:`block text-xs ${zn?"text-gray-300":"text-gray-500"}`,children:An})]}),se.jsx("button",{id:Je,onClick:()=>!zn&&Pt(!qt),disabled:zn,className:`relative inline-flex items-center h-6 rounded-full w-11 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 ${qt?"bg-blue-600":"bg-gray-200"} ${zn?"opacity-50 cursor-not-allowed":""}`,role:"switch","aria-checked":qt,children:se.jsx("span",{className:`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${qt?"translate-x-6":"translate-x-1"}`})})]});return se.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4",role:"dialog","aria-modal":"true","aria-labelledby":"settings-title",children:se.jsxs("div",{className:"bg-white rounded-lg shadow-xl h-full w-full max-w-md overflow-auto",children:[se.jsxs("div",{className:"p-6 border-b border-gray-200",children:[se.jsxs("div",{className:"flex justify-between items-center mb-4",children:[se.jsx("h2",{id:"settings-title",className:"text-xl font-semibold text-gray-800",children:ae("settings.title")}),se.jsx("button",{onClick:t,className:"text-gray-400 hover:text-gray-600","aria-label":ae("settings.closeAriaLabel"),children:se.jsx(Rp,{})})]}),se.jsxs("div",{children:[se.jsx("label",{htmlFor:"language-select",className:"block text-sm font-medium text-gray-700 mb-1",children:ae("settings.languageLabel")}),se.jsxs("select",{id:"language-select",value:Ne.language,onChange:Je=>Ne.changeLanguage(Je.target.value),className:"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500",children:[se.jsx("option",{value:"en",children:"English"}),se.jsx("option",{value:"zh-TW",children:""})]})]})]}),se.jsx("div",{className:"border-b border-gray-200",children:se.jsxs("nav",{className:"flex space-x-2 p-2 overflow-x-auto",role:"tablist","aria-label":"Settings tabs",children:[se.jsx(tn,{tabName:"online",label:ae("settings.tabOnline")}),se.jsx(tn,{tabName:"offline",label:ae("settings.tabOffline")}),se.jsx(tn,{tabName:"speech",label:ae("settings.tabSpeech")}),se.jsx(tn,{tabName:"tts",label:ae("settings.tabTts")}),se.jsx(tn,{tabName:"offline-params",label:ae("settings.tabOfflineParams")}),se.jsx(tn,{tabName:"ocr",label:ae("settings.tabOcr")})]})}),se.jsxs("div",{className:"p-6 space-y-6 min-h-[350px]",children:[Ye==="online"&&se.jsxs("div",{role:"tabpanel",id:"online-settings","aria-labelledby":"online-tab",className:"space-y-6",children:[se.jsxs("div",{children:[se.jsx("label",{className:"block text-sm font-medium text-gray-700 mb-2",children:ae("settings.providerLabel")}),se.jsxs("div",{className:"flex space-x-4",children:[se.jsxs("div",{className:"flex items-center",children:[se.jsx("input",{id:"provider-gemini",name:"online-provider",type:"radio",value:"gemini",checked:ke==="gemini",onChange:Je=>Le(Je.target.value),className:"h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500"}),se.jsx("label",{htmlFor:"provider-gemini",className:"ml-2 block text-sm text-gray-900",children:ae("settings.providerGemini")})]}),se.jsxs("div",{className:"flex items-center",children:[se.jsx("input",{id:"provider-openai",name:"online-provider",type:"radio",value:"openai",checked:ke==="openai",onChange:Je=>Le(Je.target.value),className:"h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500"}),se.jsx("label",{htmlFor:"provider-openai",className:"ml-2 block text-sm text-gray-900",children:ae("settings.providerOpenAI")})]})]})]}),ke==="openai"&&se.jsxs("div",{children:[se.jsx("label",{htmlFor:"openai-api-url",className:"block text-sm font-medium text-gray-700 mb-1",children:ae("settings.openaiUrlLabel")}),se.jsx("input",{type:"text",id:"openai-api-url",value:Ge,onChange:Je=>$e(Je.target.value),className:"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500",placeholder:ae("settings.openaiUrlPlaceholder")})]}),se.jsxs("div",{children:[se.jsx("label",{htmlFor:"api-key",className:"block text-sm font-medium text-gray-700 mb-1",children:ae("settings.apiKeyLabel")}),se.jsx("input",{type:"password",id:"api-key",value:ue,onChange:Je=>U(Je.target.value),className:"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500",placeholder:ae("settings.apiKeyPlaceholder")})]}),se.jsxs("div",{children:[se.jsx("label",{htmlFor:"model-name",className:"block text-sm font-medium text-gray-700 mb-1",children:ae("settings.modelNameLabel")}),se.jsx("input",{type:"text",id:"model-name",value:we,onChange:Je=>Pe(Je.target.value),className:"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 bg-white",placeholder:ae(ke==="gemini"?"settings.modelNameGeminiPlaceholder":"settings.modelNameOpenAIPlaceholder")})]})]}),Ye==="offline"&&se.jsxs("div",{role:"tabpanel",id:"offline-settings","aria-labelledby":"offline-tab",className:"space-y-6",children:[se.jsxs("div",{className:"space-y-3",children:[se.jsx("label",{className:"block text-sm font-medium text-gray-700",children:ae("settings.manageModelsLabel")}),ag.filter(Je=>Je.value).map(Je=>se.jsx("div",{children:Wn(Je)},Je.value))]}),se.jsxs("div",{className:"space-y-4 pt-2",children:[se.jsx(Bn,{id:"offline-toggle",isEnabled:Z,setIsEnabled:he,title:ae("settings.enableOfflineLabel"),description:ae("settings.enableOfflineDescription")}),se.jsx(Bn,{id:"twostep-toggle",isEnabled:ye,setIsEnabled:Ke,title:ae("settings.enableTwoStepLabel"),description:ae("settings.enableTwoStepDescription")})]})]}),Ye==="speech"&&se.jsxs("div",{role:"tabpanel",id:"speech-settings","aria-labelledby":"speech-tab",className:"space-y-6",children:[se.jsx(Bn,{id:"web-speech-toggle",isEnabled:Oe,setIsEnabled:Je=>{ct(Je)},title:ae("settings.enableWebSpeechLabel"),description:ae("settings.enableWebSpeechDescription")}),se.jsx("div",{className:"border-t border-gray-200"}),se.jsx(Bn,{id:"asr-toggle",isEnabled:Be,setIsEnabled:Je=>{Se(Je),Je&&de(!1)},title:ae("settings.enableOfflineAsrLabel"),description:ae("settings.enableOfflineAsrDescription")}),se.jsxs("div",{className:`space-y-3 transition-opacity ${Be?"":"opacity-50"}`,children:[se.jsx("label",{className:`block text-sm font-medium ${Be?"text-gray-700":"text-gray-400"}`,children:ae("settings.asrModelLabel")}),Ru.map(Je=>{const qt=X[Je.id]||!1,Pt=ce&&bt===Je.id;return se.jsxs("div",{className:"p-3 border border-gray-200 rounded-lg bg-gray-50 space-y-2",children:[se.jsxs("div",{className:"flex items-center justify-between",children:[se.jsxs("div",{className:"flex items-center",children:[se.jsx("input",{type:"radio",id:`asr-model-${Je.id}`,name:"asr-model-selection",value:Je.id,checked:bt===Je.id,onChange:Zt,className:"h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500",disabled:!Be}),se.jsxs("label",{htmlFor:`asr-model-${Je.id}`,className:`ml-3 text-sm font-medium ${Be?"text-gray-800":"text-gray-400"}`,children:[Je.name," ",se.jsxs("span",{className:"text-gray-500 font-normal",children:["(",Je.size,")"]})]})]}),se.jsx("div",{className:"flex items-center space-x-3",children:!Pt&&(qt?se.jsx("span",{className:"text-sm font-medium text-green-600",children:ae("settings.modelCached")||"Cached"}):se.jsx("button",{onClick:()=>Q(Je.id),disabled:ce||!Be,className:"text-sm font-medium text-blue-600 hover:text-blue-800 disabled:text-gray-400 disabled:cursor-not-allowed",children:ae("settings.modelDownload")||"Download"}))})]}),Pt&&se.jsxs("div",{className:"pt-1 text-center text-sm text-blue-600",children:[me.file," (",Math.round(me.progress),"%)"]})]},Je.id)}),se.jsx("div",{children:se.jsxs("button",{onClick:H,disabled:!Be,className:"w-full flex items-center justify-center space-x-2 text-red-600 font-medium py-2 px-4 rounded-lg border border-red-200 hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors mt-2 disabled:opacity-50 disabled:cursor-not-allowed",children:[se.jsx(Tb,{className:"h-5 w-5"}),se.jsx("span",{children:ae("settings.clearAsrCacheButton")})]})})]}),se.jsx("div",{className:"border-t border-gray-200"}),se.jsxs("div",{className:`space-y-4 transition-opacity ${Be?"":"opacity-50"}`,children:[se.jsx("label",{className:`block text-sm font-medium -mb-2 ${Be?"text-gray-700":"text-gray-400"}`,children:ae("settings.audioProcessingLabel")}),se.jsx(Bn,{id:"noise-cancellation-toggle",isEnabled:Et,setIsEnabled:hn,title:ae("settings.enableNoiseCancellationLabel"),description:ae("settings.enableNoiseCancellationDescription"),disabled:!Be}),se.jsxs("div",{children:[se.jsxs("label",{htmlFor:"gain-slider",className:`flex justify-between items-center text-sm font-medium mb-1 ${Be?"text-gray-700":"text-gray-400"}`,children:[se.jsx("span",{children:ae("settings.audioGainLabel")}),se.jsxs("span",{className:"font-normal text-gray-500",children:[En.toFixed(1),"x"]})]}),se.jsx("input",{type:"range",id:"gain-slider",min:.5,max:5,step:.1,value:En,onChange:Je=>Kt(parseFloat(Je.target.value)),className:"w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer",disabled:!Be})]})]}),se.jsx("div",{className:"border-t border-gray-200"}),se.jsx(Bn,{id:"support-audio-toggle",isEnabled:re,setIsEnabled:Je=>{de(Je),Je&&Se(!1)},title:ae("settings.enableGemmaAudioLabel"),description:ae("settings.enableGemmaAudioDescription"),disabled:!Z}),!Z&&se.jsx("p",{className:"text-xs text-amber-600 mt-1 ml-1",children:'* Requires "Enable Offline Translation" to be ON.'})]}),Ye==="tts"&&se.jsxs("div",{role:"tabpanel",id:"tts-settings","aria-labelledby":"tts-tab",className:"space-y-6",children:[se.jsx(Bn,{id:"tts-toggle",isEnabled:yi,setIsEnabled:Ji,title:ae("settings.enableCustomTtsLabel"),description:ae("settings.enableCustomTtsDescription")}),se.jsxs("div",{children:[se.jsx("label",{htmlFor:"voice-select",className:"block text-sm font-medium text-gray-700 mb-1",children:ae("settings.voiceLabel")}),se.jsx("select",{id:"voice-select",value:tr,onChange:Je=>Ti(Je.target.value),className:"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100",disabled:xt.length===0,children:xt.length>0?xt.map(Je=>se.jsxs("option",{value:Je.voiceURI,children:[Je.name," (",Je.lang,")"]},Je.voiceURI)):se.jsx("option",{value:"",children:ae("settings.voicePlaceholder",{languageName:ae(_.name)})})})]}),se.jsx(ei,{id:"rate-slider",label:ae("settings.rateLabel"),value:Yn,onChange:Je=>$n(parseFloat(Je.target.value)),min:.5,max:2,step:.1}),se.jsx(ei,{id:"pitch-slider",label:ae("settings.pitchLabel"),value:Yi,onChange:Je=>Gi(parseFloat(Je.target.value)),min:0,max:2,step:.1})]}),Ye==="offline-params"&&se.jsxs("div",{role:"tabpanel",id:"offline-params-settings","aria-labelledby":"offline-params-tab",className:"space-y-6",children:[se.jsx("p",{className:"text-sm text-gray-500",children:ae("settings.offlineParamsDescription")}),se.jsx(ei,{id:"max-tokens-slider",label:ae("settings.maxTokensLabel"),value:Wi,onChange:Je=>Sn(parseInt(Je.target.value,10)),min:256,max:8192,step:256}),se.jsx(ei,{id:"top-k-slider",label:ae("settings.topKLabel"),value:Ii,onChange:Je=>Xt(parseInt(Je.target.value,10)),min:1,max:100,step:1}),se.jsx(ei,{id:"temperature-slider",label:ae("settings.temperatureLabel"),value:nr,onChange:Je=>L(parseFloat(Je.target.value)),min:0,max:1,step:.05}),se.jsxs("div",{children:[se.jsx("label",{htmlFor:"random-seed",className:"block text-sm font-medium text-gray-700 mb-1",children:ae("settings.randomSeedLabel")}),se.jsx("input",{type:"number",id:"random-seed",value:oe,onChange:Je=>K(parseInt(Je.target.value,10)),className:"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"})]}),se.jsx(Bn,{id:"max-num-images-toggle",isEnabled:xe===1,setIsEnabled:Je=>Ue(Je?1:0),title:ae("settings.maxNumImagesLabel"),description:ae("settings.maxNumImagesDescription")})]}),Ye==="ocr"&&se.jsxs("div",{role:"tabpanel",id:"ocr-settings","aria-labelledby":"ocr-tab",className:"space-y-6",children:[se.jsxs("div",{children:[se.jsx("label",{htmlFor:"ocr-model-select",className:"block text-sm font-medium text-gray-700 mb-1",children:ae("settings.ocrModelLabel")}),se.jsx("select",{id:"ocr-model-select",value:_t,onChange:Je=>$t(Je.target.value),className:"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500",children:Object.entries(xb).map(([Je,qt])=>se.jsx("option",{value:Je,children:qt.description},Je))})]}),se.jsx("button",{onClick:St,disabled:B==="initializing",className:"w-full bg-indigo-600 hover:bg-indigo-500 text-white py-2 rounded-lg text-sm font-medium transition disabled:bg-indigo-300 disabled:cursor-wait",children:ae(B==="initializing"?"common.status.initializing":B==="ready"?"settings.switchOcr":"settings.initializeOcr")}),B==="ready"&&se.jsx("p",{className:"text-sm text-center text-green-600",children:"OCR Engine Ready."}),B==="error"&&se.jsxs("p",{className:"text-sm text-center text-red-600",children:["OCR Engine failed to initialize: ",ee]})]})]}),se.jsxs("div",{className:"p-6 bg-gray-50 rounded-b-lg flex justify-between items-center",children:[se.jsx("button",{onClick:Ht,className:"text-red-600 font-medium py-2 px-4 rounded-lg hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors","aria-label":ae("history.clearAriaLabel"),children:ae("settings.clearSettingsButton")}),se.jsx("button",{onClick:mt,className:"bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors",children:ae("settings.saveSettingsButton")})]})]})})},g7=({isOpen:e,onClose:t,history:n,onSelectHistory:i,onClearHistory:r})=>{const{t:s}=uc();return e?se.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4",role:"dialog","aria-modal":"true","aria-labelledby":"history-title",children:se.jsxs("div",{className:"bg-white rounded-lg shadow-xl w-full max-w-md h-[70vh] flex flex-col",children:[se.jsxs("div",{className:"p-6 border-b border-gray-200 flex justify-between items-center",children:[se.jsx("h2",{id:"history-title",className:"text-xl font-semibold text-gray-800",children:s("history.title")}),se.jsx("button",{onClick:t,className:"text-gray-400 hover:text-gray-600","aria-label":s("history.closeAriaLabel"),children:se.jsx(Rp,{})})]}),se.jsx("div",{className:"p-2 flex-grow overflow-y-auto",children:n.length===0?se.jsx("div",{className:"flex items-center justify-center h-full text-gray-500",children:s("history.empty")}):se.jsx("ul",{children:n.map(a=>se.jsx("li",{className:"border-b border-gray-200 last:border-b-0",children:se.jsxs("button",{onClick:()=>i(a),className:"w-full text-left p-4 hover:bg-gray-50 transition-colors","aria-label":s("history.selectAriaLabel",{sourceLang:s(a.sourceLang.name),targetLang:s(a.targetLang.name)}),children:[se.jsxs("div",{className:"mb-2",children:[se.jsx("span",{className:"text-xs font-semibold text-gray-500 bg-gray-100 py-1 px-2 rounded-full",children:s(a.sourceLang.name)}),se.jsx("p",{className:"text-gray-800 mt-1 truncate",children:a.inputText})]}),se.jsxs("div",{children:[se.jsx("span",{className:"text-xs font-semibold text-blue-500 bg-blue-50 py-1 px-2 rounded-full",children:s(a.targetLang.name)}),se.jsx("p",{className:"text-blue-700 font-medium mt-1 truncate",children:a.translatedText})]})]})},a.id))})}),n.length>0&&se.jsx("div",{className:"p-4 bg-gray-50 rounded-b-lg flex justify-end items-center",children:se.jsxs("button",{onClick:r,className:"flex items-center space-x-2 text-red-600 font-medium py-2 px-4 rounded-lg hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors","aria-label":s("history.clearAriaLabel"),children:[se.jsx(Tb,{className:"h-5 w-5"}),se.jsx("span",{children:s("history.clearButton")})]})})]})}):null};var _7={};/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */let y7,v7;function w7(){return{geminiUrl:y7,vertexUrl:v7}}function b7(e,t,n,i){var r,s;if(!(e!=null&&e.baseUrl)){const a=w7();return t?(r=a.vertexUrl)!==null&&r!==void 0?r:n:(s=a.geminiUrl)!==null&&s!==void 0?s:i}return e.baseUrl}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Bo{}function Dt(e,t){const n=/\{([^}]+)\}/g;return e.replace(n,(i,r)=>{if(Object.prototype.hasOwnProperty.call(t,r)){const s=t[r];return s!=null?String(s):""}else throw new Error(`Key '${r}' not found in valueMap.`)})}function b(e,t,n){for(let s=0;s<t.length-1;s++){const a=t[s];if(a.endsWith("[]")){const o=a.slice(0,-2);if(!(o in e))if(Array.isArray(n))e[o]=Array.from({length:n.length},()=>({}));else throw new Error(`Value must be a list given an array path ${a}`);if(Array.isArray(e[o])){const l=e[o];if(Array.isArray(n))for(let u=0;u<l.length;u++){const c=l[u];b(c,t.slice(s+1),n[u])}else for(const u of l)b(u,t.slice(s+1),n)}return}else if(a.endsWith("[0]")){const o=a.slice(0,-3);o in e||(e[o]=[{}]);const l=e[o];b(l[0],t.slice(s+1),n);return}(!e[a]||typeof e[a]!="object")&&(e[a]={}),e=e[a]}const i=t[t.length-1],r=e[i];if(r!==void 0){if(!n||typeof n=="object"&&Object.keys(n).length===0||n===r)return;if(typeof r=="object"&&typeof n=="object"&&r!==null&&n!==null)Object.assign(r,n);else throw new Error(`Cannot set value for an existing key. Key: ${i}`)}else i==="_self"&&typeof n=="object"&&n!==null&&!Array.isArray(n)?Object.assign(e,n):e[i]=n}function w(e,t,n=void 0){try{if(t.length===1&&t[0]==="_self")return e;for(let i=0;i<t.length;i++){if(typeof e!="object"||e===null)return n;const r=t[i];if(r.endsWith("[]")){const s=r.slice(0,-2);if(s in e){const a=e[s];return Array.isArray(a)?a.map(o=>w(o,t.slice(i+1),n)):n}else return n}else e=e[r]}return e}catch(i){if(i instanceof TypeError)return n;throw i}}function x7(e,t){for(const[n,i]of Object.entries(t)){const r=n.split("."),s=i.split("."),a=new Set;let o=-1;for(let l=0;l<r.length;l++)if(r[l]==="*"){o=l;break}if(o!==-1&&s.length>o)for(let l=o;l<s.length;l++){const u=s[l];u!=="*"&&!u.endsWith("[]")&&!u.endsWith("[0]")&&a.add(u)}Mb(e,r,s,0,a)}}function Mb(e,t,n,i,r){if(i>=t.length||typeof e!="object"||e===null)return;const s=t[i];if(s.endsWith("[]")){const a=s.slice(0,-2),o=e;if(a in o&&Array.isArray(o[a]))for(const l of o[a])Mb(l,t,n,i+1,r)}else if(s==="*"){if(typeof e=="object"&&e!==null&&!Array.isArray(e)){const a=e,o=Object.keys(a).filter(u=>!u.startsWith("_")&&!r.has(u)),l={};for(const u of o)l[u]=a[u];for(const[u,c]of Object.entries(l)){const f=[];for(const d of n.slice(i))d==="*"?f.push(u):f.push(d);b(a,f,c)}for(const u of o)delete a[u]}}else{const a=e;s in a&&Mb(a[s],t,n,i+1,r)}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Sx(e){if(typeof e!="string")throw new Error("fromImageBytes must be a string");return e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function T7(e){const t={},n=w(e,["operationName"]);n!=null&&b(t,["operationName"],n);const i=w(e,["resourceName"]);return i!=null&&b(t,["_url","resourceName"],i),t}function M7(e){const t={},n=w(e,["name"]);n!=null&&b(t,["name"],n);const i=w(e,["metadata"]);i!=null&&b(t,["metadata"],i);const r=w(e,["done"]);r!=null&&b(t,["done"],r);const s=w(e,["error"]);s!=null&&b(t,["error"],s);const a=w(e,["response","generateVideoResponse"]);return a!=null&&b(t,["response"],S7(a)),t}function E7(e){const t={},n=w(e,["name"]);n!=null&&b(t,["name"],n);const i=w(e,["metadata"]);i!=null&&b(t,["metadata"],i);const r=w(e,["done"]);r!=null&&b(t,["done"],r);const s=w(e,["error"]);s!=null&&b(t,["error"],s);const a=w(e,["response"]);return a!=null&&b(t,["response"],C7(a)),t}function S7(e){const t={},n=w(e,["generatedSamples"]);if(n!=null){let s=n;Array.isArray(s)&&(s=s.map(a=>$7(a))),b(t,["generatedVideos"],s)}const i=w(e,["raiMediaFilteredCount"]);i!=null&&b(t,["raiMediaFilteredCount"],i);const r=w(e,["raiMediaFilteredReasons"]);return r!=null&&b(t,["raiMediaFilteredReasons"],r),t}function C7(e){const t={},n=w(e,["videos"]);if(n!=null){let s=n;Array.isArray(s)&&(s=s.map(a=>A7(a))),b(t,["generatedVideos"],s)}const i=w(e,["raiMediaFilteredCount"]);i!=null&&b(t,["raiMediaFilteredCount"],i);const r=w(e,["raiMediaFilteredReasons"]);return r!=null&&b(t,["raiMediaFilteredReasons"],r),t}function $7(e){const t={},n=w(e,["video"]);return n!=null&&b(t,["video"],R7(n)),t}function A7(e){const t={},n=w(e,["_self"]);return n!=null&&b(t,["video"],N7(n)),t}function I7(e){const t={},n=w(e,["operationName"]);return n!=null&&b(t,["_url","operationName"],n),t}function P7(e){const t={},n=w(e,["operationName"]);return n!=null&&b(t,["_url","operationName"],n),t}function k7(e){const t={},n=w(e,["name"]);n!=null&&b(t,["name"],n);const i=w(e,["metadata"]);i!=null&&b(t,["metadata"],i);const r=w(e,["done"]);r!=null&&b(t,["done"],r);const s=w(e,["error"]);s!=null&&b(t,["error"],s);const a=w(e,["response"]);return a!=null&&b(t,["response"],D7(a)),t}function D7(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["parent"]);i!=null&&b(t,["parent"],i);const r=w(e,["documentName"]);return r!=null&&b(t,["documentName"],r),t}function R4(e){const t={},n=w(e,["name"]);n!=null&&b(t,["name"],n);const i=w(e,["metadata"]);i!=null&&b(t,["metadata"],i);const r=w(e,["done"]);r!=null&&b(t,["done"],r);const s=w(e,["error"]);s!=null&&b(t,["error"],s);const a=w(e,["response"]);return a!=null&&b(t,["response"],O7(a)),t}function O7(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["parent"]);i!=null&&b(t,["parent"],i);const r=w(e,["documentName"]);return r!=null&&b(t,["documentName"],r),t}function R7(e){const t={},n=w(e,["uri"]);n!=null&&b(t,["uri"],n);const i=w(e,["encodedVideo"]);i!=null&&b(t,["videoBytes"],Sx(i));const r=w(e,["encoding"]);return r!=null&&b(t,["mimeType"],r),t}function N7(e){const t={},n=w(e,["gcsUri"]);n!=null&&b(t,["uri"],n);const i=w(e,["bytesBase64Encoded"]);i!=null&&b(t,["videoBytes"],Sx(i));const r=w(e,["mimeType"]);return r!=null&&b(t,["mimeType"],r),t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var aI;(function(e){e.OUTCOME_UNSPECIFIED="OUTCOME_UNSPECIFIED",e.OUTCOME_OK="OUTCOME_OK",e.OUTCOME_FAILED="OUTCOME_FAILED",e.OUTCOME_DEADLINE_EXCEEDED="OUTCOME_DEADLINE_EXCEEDED"})(aI||(aI={}));var oI;(function(e){e.LANGUAGE_UNSPECIFIED="LANGUAGE_UNSPECIFIED",e.PYTHON="PYTHON"})(oI||(oI={}));var lI;(function(e){e.SCHEDULING_UNSPECIFIED="SCHEDULING_UNSPECIFIED",e.SILENT="SILENT",e.WHEN_IDLE="WHEN_IDLE",e.INTERRUPT="INTERRUPT"})(lI||(lI={}));var Sa;(function(e){e.TYPE_UNSPECIFIED="TYPE_UNSPECIFIED",e.STRING="STRING",e.NUMBER="NUMBER",e.INTEGER="INTEGER",e.BOOLEAN="BOOLEAN",e.ARRAY="ARRAY",e.OBJECT="OBJECT",e.NULL="NULL"})(Sa||(Sa={}));var uI;(function(e){e.MODE_UNSPECIFIED="MODE_UNSPECIFIED",e.MODE_DYNAMIC="MODE_DYNAMIC"})(uI||(uI={}));var cI;(function(e){e.API_SPEC_UNSPECIFIED="API_SPEC_UNSPECIFIED",e.SIMPLE_SEARCH="SIMPLE_SEARCH",e.ELASTIC_SEARCH="ELASTIC_SEARCH"})(cI||(cI={}));var dI;(function(e){e.AUTH_TYPE_UNSPECIFIED="AUTH_TYPE_UNSPECIFIED",e.NO_AUTH="NO_AUTH",e.API_KEY_AUTH="API_KEY_AUTH",e.HTTP_BASIC_AUTH="HTTP_BASIC_AUTH",e.GOOGLE_SERVICE_ACCOUNT_AUTH="GOOGLE_SERVICE_ACCOUNT_AUTH",e.OAUTH="OAUTH",e.OIDC_AUTH="OIDC_AUTH"})(dI||(dI={}));var fI;(function(e){e.HTTP_IN_UNSPECIFIED="HTTP_IN_UNSPECIFIED",e.HTTP_IN_QUERY="HTTP_IN_QUERY",e.HTTP_IN_HEADER="HTTP_IN_HEADER",e.HTTP_IN_PATH="HTTP_IN_PATH",e.HTTP_IN_BODY="HTTP_IN_BODY",e.HTTP_IN_COOKIE="HTTP_IN_COOKIE"})(fI||(fI={}));var pI;(function(e){e.PHISH_BLOCK_THRESHOLD_UNSPECIFIED="PHISH_BLOCK_THRESHOLD_UNSPECIFIED",e.BLOCK_LOW_AND_ABOVE="BLOCK_LOW_AND_ABOVE",e.BLOCK_MEDIUM_AND_ABOVE="BLOCK_MEDIUM_AND_ABOVE",e.BLOCK_HIGH_AND_ABOVE="BLOCK_HIGH_AND_ABOVE",e.BLOCK_HIGHER_AND_ABOVE="BLOCK_HIGHER_AND_ABOVE",e.BLOCK_VERY_HIGH_AND_ABOVE="BLOCK_VERY_HIGH_AND_ABOVE",e.BLOCK_ONLY_EXTREMELY_HIGH="BLOCK_ONLY_EXTREMELY_HIGH"})(pI||(pI={}));var hI;(function(e){e.THINKING_LEVEL_UNSPECIFIED="THINKING_LEVEL_UNSPECIFIED",e.LOW="LOW",e.MEDIUM="MEDIUM",e.HIGH="HIGH",e.MINIMAL="MINIMAL"})(hI||(hI={}));var mI;(function(e){e.HARM_CATEGORY_UNSPECIFIED="HARM_CATEGORY_UNSPECIFIED",e.HARM_CATEGORY_HARASSMENT="HARM_CATEGORY_HARASSMENT",e.HARM_CATEGORY_HATE_SPEECH="HARM_CATEGORY_HATE_SPEECH",e.HARM_CATEGORY_SEXUALLY_EXPLICIT="HARM_CATEGORY_SEXUALLY_EXPLICIT",e.HARM_CATEGORY_DANGEROUS_CONTENT="HARM_CATEGORY_DANGEROUS_CONTENT",e.HARM_CATEGORY_CIVIC_INTEGRITY="HARM_CATEGORY_CIVIC_INTEGRITY",e.HARM_CATEGORY_IMAGE_HATE="HARM_CATEGORY_IMAGE_HATE",e.HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT="HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT",e.HARM_CATEGORY_IMAGE_HARASSMENT="HARM_CATEGORY_IMAGE_HARASSMENT",e.HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT="HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT",e.HARM_CATEGORY_JAILBREAK="HARM_CATEGORY_JAILBREAK"})(mI||(mI={}));var gI;(function(e){e.HARM_BLOCK_METHOD_UNSPECIFIED="HARM_BLOCK_METHOD_UNSPECIFIED",e.SEVERITY="SEVERITY",e.PROBABILITY="PROBABILITY"})(gI||(gI={}));var _I;(function(e){e.HARM_BLOCK_THRESHOLD_UNSPECIFIED="HARM_BLOCK_THRESHOLD_UNSPECIFIED",e.BLOCK_LOW_AND_ABOVE="BLOCK_LOW_AND_ABOVE",e.BLOCK_MEDIUM_AND_ABOVE="BLOCK_MEDIUM_AND_ABOVE",e.BLOCK_ONLY_HIGH="BLOCK_ONLY_HIGH",e.BLOCK_NONE="BLOCK_NONE",e.OFF="OFF"})(_I||(_I={}));var yI;(function(e){e.FINISH_REASON_UNSPECIFIED="FINISH_REASON_UNSPECIFIED",e.STOP="STOP",e.MAX_TOKENS="MAX_TOKENS",e.SAFETY="SAFETY",e.RECITATION="RECITATION",e.LANGUAGE="LANGUAGE",e.OTHER="OTHER",e.BLOCKLIST="BLOCKLIST",e.PROHIBITED_CONTENT="PROHIBITED_CONTENT",e.SPII="SPII",e.MALFORMED_FUNCTION_CALL="MALFORMED_FUNCTION_CALL",e.IMAGE_SAFETY="IMAGE_SAFETY",e.UNEXPECTED_TOOL_CALL="UNEXPECTED_TOOL_CALL",e.IMAGE_PROHIBITED_CONTENT="IMAGE_PROHIBITED_CONTENT",e.NO_IMAGE="NO_IMAGE",e.IMAGE_RECITATION="IMAGE_RECITATION",e.IMAGE_OTHER="IMAGE_OTHER"})(yI||(yI={}));var vI;(function(e){e.HARM_PROBABILITY_UNSPECIFIED="HARM_PROBABILITY_UNSPECIFIED",e.NEGLIGIBLE="NEGLIGIBLE",e.LOW="LOW",e.MEDIUM="MEDIUM",e.HIGH="HIGH"})(vI||(vI={}));var wI;(function(e){e.HARM_SEVERITY_UNSPECIFIED="HARM_SEVERITY_UNSPECIFIED",e.HARM_SEVERITY_NEGLIGIBLE="HARM_SEVERITY_NEGLIGIBLE",e.HARM_SEVERITY_LOW="HARM_SEVERITY_LOW",e.HARM_SEVERITY_MEDIUM="HARM_SEVERITY_MEDIUM",e.HARM_SEVERITY_HIGH="HARM_SEVERITY_HIGH"})(wI||(wI={}));var bI;(function(e){e.URL_RETRIEVAL_STATUS_UNSPECIFIED="URL_RETRIEVAL_STATUS_UNSPECIFIED",e.URL_RETRIEVAL_STATUS_SUCCESS="URL_RETRIEVAL_STATUS_SUCCESS",e.URL_RETRIEVAL_STATUS_ERROR="URL_RETRIEVAL_STATUS_ERROR",e.URL_RETRIEVAL_STATUS_PAYWALL="URL_RETRIEVAL_STATUS_PAYWALL",e.URL_RETRIEVAL_STATUS_UNSAFE="URL_RETRIEVAL_STATUS_UNSAFE"})(bI||(bI={}));var xI;(function(e){e.BLOCKED_REASON_UNSPECIFIED="BLOCKED_REASON_UNSPECIFIED",e.SAFETY="SAFETY",e.OTHER="OTHER",e.BLOCKLIST="BLOCKLIST",e.PROHIBITED_CONTENT="PROHIBITED_CONTENT",e.IMAGE_SAFETY="IMAGE_SAFETY",e.MODEL_ARMOR="MODEL_ARMOR",e.JAILBREAK="JAILBREAK"})(xI||(xI={}));var TI;(function(e){e.TRAFFIC_TYPE_UNSPECIFIED="TRAFFIC_TYPE_UNSPECIFIED",e.ON_DEMAND="ON_DEMAND",e.PROVISIONED_THROUGHPUT="PROVISIONED_THROUGHPUT"})(TI||(TI={}));var og;(function(e){e.MODALITY_UNSPECIFIED="MODALITY_UNSPECIFIED",e.TEXT="TEXT",e.IMAGE="IMAGE",e.AUDIO="AUDIO"})(og||(og={}));var MI;(function(e){e.MEDIA_RESOLUTION_UNSPECIFIED="MEDIA_RESOLUTION_UNSPECIFIED",e.MEDIA_RESOLUTION_LOW="MEDIA_RESOLUTION_LOW",e.MEDIA_RESOLUTION_MEDIUM="MEDIA_RESOLUTION_MEDIUM",e.MEDIA_RESOLUTION_HIGH="MEDIA_RESOLUTION_HIGH"})(MI||(MI={}));var EI;(function(e){e.TUNING_MODE_UNSPECIFIED="TUNING_MODE_UNSPECIFIED",e.TUNING_MODE_FULL="TUNING_MODE_FULL",e.TUNING_MODE_PEFT_ADAPTER="TUNING_MODE_PEFT_ADAPTER"})(EI||(EI={}));var SI;(function(e){e.ADAPTER_SIZE_UNSPECIFIED="ADAPTER_SIZE_UNSPECIFIED",e.ADAPTER_SIZE_ONE="ADAPTER_SIZE_ONE",e.ADAPTER_SIZE_TWO="ADAPTER_SIZE_TWO",e.ADAPTER_SIZE_FOUR="ADAPTER_SIZE_FOUR",e.ADAPTER_SIZE_EIGHT="ADAPTER_SIZE_EIGHT",e.ADAPTER_SIZE_SIXTEEN="ADAPTER_SIZE_SIXTEEN",e.ADAPTER_SIZE_THIRTY_TWO="ADAPTER_SIZE_THIRTY_TWO"})(SI||(SI={}));var Eb;(function(e){e.JOB_STATE_UNSPECIFIED="JOB_STATE_UNSPECIFIED",e.JOB_STATE_QUEUED="JOB_STATE_QUEUED",e.JOB_STATE_PENDING="JOB_STATE_PENDING",e.JOB_STATE_RUNNING="JOB_STATE_RUNNING",e.JOB_STATE_SUCCEEDED="JOB_STATE_SUCCEEDED",e.JOB_STATE_FAILED="JOB_STATE_FAILED",e.JOB_STATE_CANCELLING="JOB_STATE_CANCELLING",e.JOB_STATE_CANCELLED="JOB_STATE_CANCELLED",e.JOB_STATE_PAUSED="JOB_STATE_PAUSED",e.JOB_STATE_EXPIRED="JOB_STATE_EXPIRED",e.JOB_STATE_UPDATING="JOB_STATE_UPDATING",e.JOB_STATE_PARTIALLY_SUCCEEDED="JOB_STATE_PARTIALLY_SUCCEEDED"})(Eb||(Eb={}));var CI;(function(e){e.TUNING_TASK_UNSPECIFIED="TUNING_TASK_UNSPECIFIED",e.TUNING_TASK_I2V="TUNING_TASK_I2V",e.TUNING_TASK_T2V="TUNING_TASK_T2V",e.TUNING_TASK_R2V="TUNING_TASK_R2V"})(CI||(CI={}));var $I;(function(e){e.MEDIA_RESOLUTION_UNSPECIFIED="MEDIA_RESOLUTION_UNSPECIFIED",e.MEDIA_RESOLUTION_LOW="MEDIA_RESOLUTION_LOW",e.MEDIA_RESOLUTION_MEDIUM="MEDIA_RESOLUTION_MEDIUM",e.MEDIA_RESOLUTION_HIGH="MEDIA_RESOLUTION_HIGH",e.MEDIA_RESOLUTION_ULTRA_HIGH="MEDIA_RESOLUTION_ULTRA_HIGH"})($I||($I={}));var AI;(function(e){e.FEATURE_SELECTION_PREFERENCE_UNSPECIFIED="FEATURE_SELECTION_PREFERENCE_UNSPECIFIED",e.PRIORITIZE_QUALITY="PRIORITIZE_QUALITY",e.BALANCED="BALANCED",e.PRIORITIZE_COST="PRIORITIZE_COST"})(AI||(AI={}));var II;(function(e){e.UNSPECIFIED="UNSPECIFIED",e.BLOCKING="BLOCKING",e.NON_BLOCKING="NON_BLOCKING"})(II||(II={}));var PI;(function(e){e.MODE_UNSPECIFIED="MODE_UNSPECIFIED",e.MODE_DYNAMIC="MODE_DYNAMIC"})(PI||(PI={}));var kI;(function(e){e.ENVIRONMENT_UNSPECIFIED="ENVIRONMENT_UNSPECIFIED",e.ENVIRONMENT_BROWSER="ENVIRONMENT_BROWSER"})(kI||(kI={}));var DI;(function(e){e.MODE_UNSPECIFIED="MODE_UNSPECIFIED",e.AUTO="AUTO",e.ANY="ANY",e.NONE="NONE",e.VALIDATED="VALIDATED"})(DI||(DI={}));var OI;(function(e){e.BLOCK_LOW_AND_ABOVE="BLOCK_LOW_AND_ABOVE",e.BLOCK_MEDIUM_AND_ABOVE="BLOCK_MEDIUM_AND_ABOVE",e.BLOCK_ONLY_HIGH="BLOCK_ONLY_HIGH",e.BLOCK_NONE="BLOCK_NONE"})(OI||(OI={}));var RI;(function(e){e.DONT_ALLOW="DONT_ALLOW",e.ALLOW_ADULT="ALLOW_ADULT",e.ALLOW_ALL="ALLOW_ALL"})(RI||(RI={}));var NI;(function(e){e.auto="auto",e.en="en",e.ja="ja",e.ko="ko",e.hi="hi",e.zh="zh",e.pt="pt",e.es="es"})(NI||(NI={}));var LI;(function(e){e.MASK_MODE_DEFAULT="MASK_MODE_DEFAULT",e.MASK_MODE_USER_PROVIDED="MASK_MODE_USER_PROVIDED",e.MASK_MODE_BACKGROUND="MASK_MODE_BACKGROUND",e.MASK_MODE_FOREGROUND="MASK_MODE_FOREGROUND",e.MASK_MODE_SEMANTIC="MASK_MODE_SEMANTIC"})(LI||(LI={}));var zI;(function(e){e.CONTROL_TYPE_DEFAULT="CONTROL_TYPE_DEFAULT",e.CONTROL_TYPE_CANNY="CONTROL_TYPE_CANNY",e.CONTROL_TYPE_SCRIBBLE="CONTROL_TYPE_SCRIBBLE",e.CONTROL_TYPE_FACE_MESH="CONTROL_TYPE_FACE_MESH"})(zI||(zI={}));var FI;(function(e){e.SUBJECT_TYPE_DEFAULT="SUBJECT_TYPE_DEFAULT",e.SUBJECT_TYPE_PERSON="SUBJECT_TYPE_PERSON",e.SUBJECT_TYPE_ANIMAL="SUBJECT_TYPE_ANIMAL",e.SUBJECT_TYPE_PRODUCT="SUBJECT_TYPE_PRODUCT"})(FI||(FI={}));var BI;(function(e){e.EDIT_MODE_DEFAULT="EDIT_MODE_DEFAULT",e.EDIT_MODE_INPAINT_REMOVAL="EDIT_MODE_INPAINT_REMOVAL",e.EDIT_MODE_INPAINT_INSERTION="EDIT_MODE_INPAINT_INSERTION",e.EDIT_MODE_OUTPAINT="EDIT_MODE_OUTPAINT",e.EDIT_MODE_CONTROLLED_EDITING="EDIT_MODE_CONTROLLED_EDITING",e.EDIT_MODE_STYLE="EDIT_MODE_STYLE",e.EDIT_MODE_BGSWAP="EDIT_MODE_BGSWAP",e.EDIT_MODE_PRODUCT_IMAGE="EDIT_MODE_PRODUCT_IMAGE"})(BI||(BI={}));var UI;(function(e){e.FOREGROUND="FOREGROUND",e.BACKGROUND="BACKGROUND",e.PROMPT="PROMPT",e.SEMANTIC="SEMANTIC",e.INTERACTIVE="INTERACTIVE"})(UI||(UI={}));var VI;(function(e){e.ASSET="ASSET",e.STYLE="STYLE"})(VI||(VI={}));var GI;(function(e){e.INSERT="INSERT",e.REMOVE="REMOVE",e.REMOVE_STATIC="REMOVE_STATIC",e.OUTPAINT="OUTPAINT"})(GI||(GI={}));var jI;(function(e){e.OPTIMIZED="OPTIMIZED",e.LOSSLESS="LOSSLESS"})(jI||(jI={}));var WI;(function(e){e.SUPERVISED_FINE_TUNING="SUPERVISED_FINE_TUNING",e.PREFERENCE_TUNING="PREFERENCE_TUNING"})(WI||(WI={}));var HI;(function(e){e.STATE_UNSPECIFIED="STATE_UNSPECIFIED",e.STATE_PENDING="STATE_PENDING",e.STATE_ACTIVE="STATE_ACTIVE",e.STATE_FAILED="STATE_FAILED"})(HI||(HI={}));var qI;(function(e){e.STATE_UNSPECIFIED="STATE_UNSPECIFIED",e.PROCESSING="PROCESSING",e.ACTIVE="ACTIVE",e.FAILED="FAILED"})(qI||(qI={}));var KI;(function(e){e.SOURCE_UNSPECIFIED="SOURCE_UNSPECIFIED",e.UPLOADED="UPLOADED",e.GENERATED="GENERATED"})(KI||(KI={}));var JI;(function(e){e.TURN_COMPLETE_REASON_UNSPECIFIED="TURN_COMPLETE_REASON_UNSPECIFIED",e.MALFORMED_FUNCTION_CALL="MALFORMED_FUNCTION_CALL",e.RESPONSE_REJECTED="RESPONSE_REJECTED",e.NEED_MORE_INPUT="NEED_MORE_INPUT"})(JI||(JI={}));var YI;(function(e){e.MODALITY_UNSPECIFIED="MODALITY_UNSPECIFIED",e.TEXT="TEXT",e.IMAGE="IMAGE",e.VIDEO="VIDEO",e.AUDIO="AUDIO",e.DOCUMENT="DOCUMENT"})(YI||(YI={}));var XI;(function(e){e.VAD_SIGNAL_TYPE_UNSPECIFIED="VAD_SIGNAL_TYPE_UNSPECIFIED",e.VAD_SIGNAL_TYPE_SOS="VAD_SIGNAL_TYPE_SOS",e.VAD_SIGNAL_TYPE_EOS="VAD_SIGNAL_TYPE_EOS"})(XI||(XI={}));var QI;(function(e){e.START_SENSITIVITY_UNSPECIFIED="START_SENSITIVITY_UNSPECIFIED",e.START_SENSITIVITY_HIGH="START_SENSITIVITY_HIGH",e.START_SENSITIVITY_LOW="START_SENSITIVITY_LOW"})(QI||(QI={}));var ZI;(function(e){e.END_SENSITIVITY_UNSPECIFIED="END_SENSITIVITY_UNSPECIFIED",e.END_SENSITIVITY_HIGH="END_SENSITIVITY_HIGH",e.END_SENSITIVITY_LOW="END_SENSITIVITY_LOW"})(ZI||(ZI={}));var eP;(function(e){e.ACTIVITY_HANDLING_UNSPECIFIED="ACTIVITY_HANDLING_UNSPECIFIED",e.START_OF_ACTIVITY_INTERRUPTS="START_OF_ACTIVITY_INTERRUPTS",e.NO_INTERRUPTION="NO_INTERRUPTION"})(eP||(eP={}));var tP;(function(e){e.TURN_COVERAGE_UNSPECIFIED="TURN_COVERAGE_UNSPECIFIED",e.TURN_INCLUDES_ONLY_ACTIVITY="TURN_INCLUDES_ONLY_ACTIVITY",e.TURN_INCLUDES_ALL_INPUT="TURN_INCLUDES_ALL_INPUT"})(tP||(tP={}));var nP;(function(e){e.SCALE_UNSPECIFIED="SCALE_UNSPECIFIED",e.C_MAJOR_A_MINOR="C_MAJOR_A_MINOR",e.D_FLAT_MAJOR_B_FLAT_MINOR="D_FLAT_MAJOR_B_FLAT_MINOR",e.D_MAJOR_B_MINOR="D_MAJOR_B_MINOR",e.E_FLAT_MAJOR_C_MINOR="E_FLAT_MAJOR_C_MINOR",e.E_MAJOR_D_FLAT_MINOR="E_MAJOR_D_FLAT_MINOR",e.F_MAJOR_D_MINOR="F_MAJOR_D_MINOR",e.G_FLAT_MAJOR_E_FLAT_MINOR="G_FLAT_MAJOR_E_FLAT_MINOR",e.G_MAJOR_E_MINOR="G_MAJOR_E_MINOR",e.A_FLAT_MAJOR_F_MINOR="A_FLAT_MAJOR_F_MINOR",e.A_MAJOR_G_FLAT_MINOR="A_MAJOR_G_FLAT_MINOR",e.B_FLAT_MAJOR_G_MINOR="B_FLAT_MAJOR_G_MINOR",e.B_MAJOR_A_FLAT_MINOR="B_MAJOR_A_FLAT_MINOR"})(nP||(nP={}));var iP;(function(e){e.MUSIC_GENERATION_MODE_UNSPECIFIED="MUSIC_GENERATION_MODE_UNSPECIFIED",e.QUALITY="QUALITY",e.DIVERSITY="DIVERSITY",e.VOCALIZATION="VOCALIZATION"})(iP||(iP={}));var Zc;(function(e){e.PLAYBACK_CONTROL_UNSPECIFIED="PLAYBACK_CONTROL_UNSPECIFIED",e.PLAY="PLAY",e.PAUSE="PAUSE",e.STOP="STOP",e.RESET_CONTEXT="RESET_CONTEXT"})(Zc||(Zc={}));class Sb{constructor(t){const n={};for(const i of t.headers.entries())n[i[0]]=i[1];this.headers=n,this.responseInternal=t}json(){return this.responseInternal.json()}}class Qd{get text(){var t,n,i,r,s,a,o,l;if(((r=(i=(n=(t=this.candidates)===null||t===void 0?void 0:t[0])===null||n===void 0?void 0:n.content)===null||i===void 0?void 0:i.parts)===null||r===void 0?void 0:r.length)===0)return;this.candidates&&this.candidates.length>1&&console.warn("there are multiple candidates in the response, returning text from the first one.");let u="",c=!1;const f=[];for(const d of(l=(o=(a=(s=this.candidates)===null||s===void 0?void 0:s[0])===null||a===void 0?void 0:a.content)===null||o===void 0?void 0:o.parts)!==null&&l!==void 0?l:[]){for(const[h,m]of Object.entries(d))h!=="text"&&h!=="thought"&&h!=="thoughtSignature"&&(m!==null||m!==void 0)&&f.push(h);if(typeof d.text=="string"){if(typeof d.thought=="boolean"&&d.thought)continue;c=!0,u+=d.text}}return f.length>0&&console.warn(`there are non-text parts ${f} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`),c?u:void 0}get data(){var t,n,i,r,s,a,o,l;if(((r=(i=(n=(t=this.candidates)===null||t===void 0?void 0:t[0])===null||n===void 0?void 0:n.content)===null||i===void 0?void 0:i.parts)===null||r===void 0?void 0:r.length)===0)return;this.candidates&&this.candidates.length>1&&console.warn("there are multiple candidates in the response, returning data from the first one.");let u="";const c=[];for(const f of(l=(o=(a=(s=this.candidates)===null||s===void 0?void 0:s[0])===null||a===void 0?void 0:a.content)===null||o===void 0?void 0:o.parts)!==null&&l!==void 0?l:[]){for(const[d,h]of Object.entries(f))d!=="inlineData"&&(h!==null||h!==void 0)&&c.push(d);f.inlineData&&typeof f.inlineData.data=="string"&&(u+=atob(f.inlineData.data))}return c.length>0&&console.warn(`there are non-data parts ${c} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`),u.length>0?btoa(u):void 0}get functionCalls(){var t,n,i,r,s,a,o,l;if(((r=(i=(n=(t=this.candidates)===null||t===void 0?void 0:t[0])===null||n===void 0?void 0:n.content)===null||i===void 0?void 0:i.parts)===null||r===void 0?void 0:r.length)===0)return;this.candidates&&this.candidates.length>1&&console.warn("there are multiple candidates in the response, returning function calls from the first one.");const u=(l=(o=(a=(s=this.candidates)===null||s===void 0?void 0:s[0])===null||a===void 0?void 0:a.content)===null||o===void 0?void 0:o.parts)===null||l===void 0?void 0:l.filter(c=>c.functionCall).map(c=>c.functionCall).filter(c=>c!==void 0);if((u==null?void 0:u.length)!==0)return u}get executableCode(){var t,n,i,r,s,a,o,l,u;if(((r=(i=(n=(t=this.candidates)===null||t===void 0?void 0:t[0])===null||n===void 0?void 0:n.content)===null||i===void 0?void 0:i.parts)===null||r===void 0?void 0:r.length)===0)return;this.candidates&&this.candidates.length>1&&console.warn("there are multiple candidates in the response, returning executable code from the first one.");const c=(l=(o=(a=(s=this.candidates)===null||s===void 0?void 0:s[0])===null||a===void 0?void 0:a.content)===null||o===void 0?void 0:o.parts)===null||l===void 0?void 0:l.filter(f=>f.executableCode).map(f=>f.executableCode).filter(f=>f!==void 0);if((c==null?void 0:c.length)!==0)return(u=c==null?void 0:c[0])===null||u===void 0?void 0:u.code}get codeExecutionResult(){var t,n,i,r,s,a,o,l,u;if(((r=(i=(n=(t=this.candidates)===null||t===void 0?void 0:t[0])===null||n===void 0?void 0:n.content)===null||i===void 0?void 0:i.parts)===null||r===void 0?void 0:r.length)===0)return;this.candidates&&this.candidates.length>1&&console.warn("there are multiple candidates in the response, returning code execution result from the first one.");const c=(l=(o=(a=(s=this.candidates)===null||s===void 0?void 0:s[0])===null||a===void 0?void 0:a.content)===null||o===void 0?void 0:o.parts)===null||l===void 0?void 0:l.filter(f=>f.codeExecutionResult).map(f=>f.codeExecutionResult).filter(f=>f!==void 0);if((c==null?void 0:c.length)!==0)return(u=c==null?void 0:c[0])===null||u===void 0?void 0:u.output}}class rP{}class sP{}class L7{}class z7{}class F7{}class B7{}class aP{}class oP{}class lP{}class U7{}class lg{_fromAPIResponse({apiResponse:t,_isVertexAI:n}){const i=new lg;let r;const s=t;return n?r=E7(s):r=M7(s),Object.assign(i,r),i}}class uP{}class cP{}class dP{}class fP{}class V7{}class G7{}class j7{}class Cx{_fromAPIResponse({apiResponse:t,_isVertexAI:n}){const i=new Cx,s=k7(t);return Object.assign(i,s),i}}class W7{}class H7{}class q7{}class pP{}class K7{get text(){var t,n,i;let r="",s=!1;const a=[];for(const o of(i=(n=(t=this.serverContent)===null||t===void 0?void 0:t.modelTurn)===null||n===void 0?void 0:n.parts)!==null&&i!==void 0?i:[]){for(const[l,u]of Object.entries(o))l!=="text"&&l!=="thought"&&u!==null&&a.push(l);if(typeof o.text=="string"){if(typeof o.thought=="boolean"&&o.thought)continue;s=!0,r+=o.text}}return a.length>0&&console.warn(`there are non-text parts ${a} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`),s?r:void 0}get data(){var t,n,i;let r="";const s=[];for(const a of(i=(n=(t=this.serverContent)===null||t===void 0?void 0:t.modelTurn)===null||n===void 0?void 0:n.parts)!==null&&i!==void 0?i:[]){for(const[o,l]of Object.entries(a))o!=="inlineData"&&l!==null&&s.push(o);a.inlineData&&typeof a.inlineData.data=="string"&&(r+=atob(a.inlineData.data))}return s.length>0&&console.warn(`there are non-data parts ${s} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`),r.length>0?btoa(r):void 0}}class J7{get audioChunk(){if(this.serverContent&&this.serverContent.audioChunks&&this.serverContent.audioChunks.length>0)return this.serverContent.audioChunks[0]}}class $x{_fromAPIResponse({apiResponse:t,_isVertexAI:n}){const i=new $x,s=R4(t);return Object.assign(i,s),i}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function ti(e,t){if(!t||typeof t!="string")throw new Error("model is required and must be a string");if(t.includes("..")||t.includes("?")||t.includes("&"))throw new Error("invalid model parameter");if(e.isVertexAI()){if(t.startsWith("publishers/")||t.startsWith("projects/")||t.startsWith("models/"))return t;if(t.indexOf("/")>=0){const n=t.split("/",2);return`publishers/${n[0]}/models/${n[1]}`}else return`publishers/google/models/${t}`}else return t.startsWith("models/")||t.startsWith("tunedModels/")?t:`models/${t}`}function N4(e,t){const n=ti(e,t);return n?n.startsWith("publishers/")&&e.isVertexAI()?`projects/${e.getProject()}/locations/${e.getLocation()}/${n}`:n.startsWith("models/")&&e.isVertexAI()?`projects/${e.getProject()}/locations/${e.getLocation()}/publishers/google/${n}`:n:""}function L4(e){return Array.isArray(e)?e.map(t=>ug(t)):[ug(e)]}function ug(e){if(typeof e=="object"&&e!==null)return e;throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof e}`)}function z4(e){const t=ug(e);if(t.mimeType&&t.mimeType.startsWith("image/"))return t;throw new Error(`Unsupported mime type: ${t.mimeType}`)}function F4(e){const t=ug(e);if(t.mimeType&&t.mimeType.startsWith("audio/"))return t;throw new Error(`Unsupported mime type: ${t.mimeType}`)}function hP(e){if(e==null)throw new Error("PartUnion is required");if(typeof e=="object")return e;if(typeof e=="string")return{text:e};throw new Error(`Unsupported part type: ${typeof e}`)}function B4(e){if(e==null||Array.isArray(e)&&e.length===0)throw new Error("PartListUnion is required");return Array.isArray(e)?e.map(t=>hP(t)):[hP(e)]}function Cb(e){return e!=null&&typeof e=="object"&&"parts"in e&&Array.isArray(e.parts)}function mP(e){return e!=null&&typeof e=="object"&&"functionCall"in e}function gP(e){return e!=null&&typeof e=="object"&&"functionResponse"in e}function zr(e){if(e==null)throw new Error("ContentUnion is required");return Cb(e)?e:{role:"user",parts:B4(e)}}function Ax(e,t){if(!t)return[];if(e.isVertexAI()&&Array.isArray(t))return t.flatMap(n=>{const i=zr(n);return i.parts&&i.parts.length>0&&i.parts[0].text!==void 0?[i.parts[0].text]:[]});if(e.isVertexAI()){const n=zr(t);return n.parts&&n.parts.length>0&&n.parts[0].text!==void 0?[n.parts[0].text]:[]}return Array.isArray(t)?t.map(n=>zr(n)):[zr(t)]}function Xs(e){if(e==null||Array.isArray(e)&&e.length===0)throw new Error("contents are required");if(!Array.isArray(e)){if(mP(e)||gP(e))throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");return[zr(e)]}const t=[],n=[],i=Cb(e[0]);for(const r of e){const s=Cb(r);if(s!=i)throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");if(s)t.push(r);else{if(mP(r)||gP(r))throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");n.push(r)}}return i||t.push({role:"user",parts:B4(n)}),t}function Y7(e,t){e.includes("null")&&(t.nullable=!0);const n=e.filter(i=>i!=="null");if(n.length===1)t.type=Object.values(Sa).includes(n[0].toUpperCase())?n[0].toUpperCase():Sa.TYPE_UNSPECIFIED;else{t.anyOf=[];for(const i of n)t.anyOf.push({type:Object.values(Sa).includes(i.toUpperCase())?i.toUpperCase():Sa.TYPE_UNSPECIFIED})}}function fd(e){const t={},n=["items"],i=["anyOf"],r=["properties"];if(e.type&&e.anyOf)throw new Error("type and anyOf cannot be both populated.");const s=e.anyOf;s!=null&&s.length==2&&(s[0].type==="null"?(t.nullable=!0,e=s[1]):s[1].type==="null"&&(t.nullable=!0,e=s[0])),e.type instanceof Array&&Y7(e.type,t);for(const[a,o]of Object.entries(e))if(o!=null)if(a=="type"){if(o==="null")throw new Error("type: null can not be the only possible type for the field.");if(o instanceof Array)continue;t.type=Object.values(Sa).includes(o.toUpperCase())?o.toUpperCase():Sa.TYPE_UNSPECIFIED}else if(n.includes(a))t[a]=fd(o);else if(i.includes(a)){const l=[];for(const u of o){if(u.type=="null"){t.nullable=!0;continue}l.push(fd(u))}t[a]=l}else if(r.includes(a)){const l={};for(const[u,c]of Object.entries(o))l[u]=fd(c);t[a]=l}else{if(a==="additionalProperties")continue;t[a]=o}return t}function Ix(e){return fd(e)}function Px(e){if(typeof e=="object")return e;if(typeof e=="string")return{voiceConfig:{prebuiltVoiceConfig:{voiceName:e}}};throw new Error(`Unsupported speechConfig type: ${typeof e}`)}function kx(e){if("multiSpeakerVoiceConfig"in e)throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");return e}function zd(e){if(e.functionDeclarations)for(const t of e.functionDeclarations)t.parameters&&(Object.keys(t.parameters).includes("$schema")?t.parametersJsonSchema||(t.parametersJsonSchema=t.parameters,delete t.parameters):t.parameters=fd(t.parameters)),t.response&&(Object.keys(t.response).includes("$schema")?t.responseJsonSchema||(t.responseJsonSchema=t.response,delete t.response):t.response=fd(t.response));return e}function Fd(e){if(e==null)throw new Error("tools is required");if(!Array.isArray(e))throw new Error("tools is required and must be an array of Tools");const t=[];for(const n of e)t.push(n);return t}function X7(e,t,n,i=1){const r=!t.startsWith(`${n}/`)&&t.split("/").length===i;return e.isVertexAI()?t.startsWith("projects/")?t:t.startsWith("locations/")?`projects/${e.getProject()}/${t}`:t.startsWith(`${n}/`)?`projects/${e.getProject()}/locations/${e.getLocation()}/${t}`:r?`projects/${e.getProject()}/locations/${e.getLocation()}/${n}/${t}`:t:r?`${n}/${t}`:t}function Uo(e,t){if(typeof t!="string")throw new Error("name must be a string");return X7(e,t,"cachedContents")}function U4(e){switch(e){case"STATE_UNSPECIFIED":return"JOB_STATE_UNSPECIFIED";case"CREATING":return"JOB_STATE_RUNNING";case"ACTIVE":return"JOB_STATE_SUCCEEDED";case"FAILED":return"JOB_STATE_FAILED";default:return e}}function Kl(e){return Sx(e)}function Q7(e){return e!=null&&typeof e=="object"&&"name"in e}function Z7(e){return e!=null&&typeof e=="object"&&"video"in e}function eJ(e){return e!=null&&typeof e=="object"&&"uri"in e}function V4(e){var t;let n;if(Q7(e)&&(n=e.name),!(eJ(e)&&(n=e.uri,n===void 0))&&!(Z7(e)&&(n=(t=e.video)===null||t===void 0?void 0:t.uri,n===void 0))){if(typeof e=="string"&&(n=e),n===void 0)throw new Error("Could not extract file name from the provided input.");if(n.startsWith("https://")){const r=n.split("files/")[1].match(/[a-z0-9]+/);if(r===null)throw new Error(`Could not extract file name from URI ${n}`);n=r[0]}else n.startsWith("files/")&&(n=n.split("files/")[1]);return n}}function G4(e,t){let n;return e.isVertexAI()?n=t?"publishers/google/models":"models":n=t?"models":"tunedModels",n}function j4(e){for(const t of["models","tunedModels","publisherModels"])if(tJ(e,t))return e[t];return[]}function tJ(e,t){return e!==null&&typeof e=="object"&&t in e}function nJ(e,t={}){const n=e,i={name:n.name,description:n.description,parametersJsonSchema:n.inputSchema};return n.outputSchema&&(i.responseJsonSchema=n.outputSchema),t.behavior&&(i.behavior=t.behavior),{functionDeclarations:[i]}}function iJ(e,t={}){const n=[],i=new Set;for(const r of e){const s=r.name;if(i.has(s))throw new Error(`Duplicate function name ${s} found in MCP tools. Please ensure function names are unique.`);i.add(s);const a=nJ(r,t);a.functionDeclarations&&n.push(...a.functionDeclarations)}return{functionDeclarations:n}}function W4(e,t){let n;if(typeof t=="string")if(e.isVertexAI())if(t.startsWith("gs://"))n={format:"jsonl",gcsUri:[t]};else if(t.startsWith("bq://"))n={format:"bigquery",bigqueryUri:t};else throw new Error(`Unsupported string source for Vertex AI: ${t}`);else if(t.startsWith("files/"))n={fileName:t};else throw new Error(`Unsupported string source for Gemini API: ${t}`);else if(Array.isArray(t)){if(e.isVertexAI())throw new Error("InlinedRequest[] is not supported in Vertex AI.");n={inlinedRequests:t}}else n=t;const i=[n.gcsUri,n.bigqueryUri].filter(Boolean).length,r=[n.inlinedRequests,n.fileName].filter(Boolean).length;if(e.isVertexAI()){if(r>0||i!==1)throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.")}else if(i>0||r!==1)throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");return n}function rJ(e){if(typeof e!="string")return e;const t=e;if(t.startsWith("gs://"))return{format:"jsonl",gcsUri:t};if(t.startsWith("bq://"))return{format:"bigquery",bigqueryUri:t};throw new Error(`Unsupported destination: ${t}`)}function H4(e){if(typeof e!="object"||e===null)return{};const t=e,n=t.inlinedResponses;if(typeof n!="object"||n===null)return e;const r=n.inlinedResponses;if(!Array.isArray(r)||r.length===0)return e;let s=!1;for(const a of r){if(typeof a!="object"||a===null)continue;const l=a.response;if(typeof l!="object"||l===null)continue;if(l.embedding!==void 0){s=!0;break}}return s&&(t.inlinedEmbedContentResponses=t.inlinedResponses,delete t.inlinedResponses),e}function Bd(e,t){const n=t;if(!e.isVertexAI()){if(/batches\/[^/]+$/.test(n))return n.split("/").pop();throw new Error(`Invalid batch job name: ${n}.`)}if(/^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/.test(n))return n.split("/").pop();if(/^\d+$/.test(n))return n;throw new Error(`Invalid batch job name: ${n}.`)}function q4(e){const t=e;return t==="BATCH_STATE_UNSPECIFIED"?"JOB_STATE_UNSPECIFIED":t==="BATCH_STATE_PENDING"?"JOB_STATE_PENDING":t==="BATCH_STATE_RUNNING"?"JOB_STATE_RUNNING":t==="BATCH_STATE_SUCCEEDED"?"JOB_STATE_SUCCEEDED":t==="BATCH_STATE_FAILED"?"JOB_STATE_FAILED":t==="BATCH_STATE_CANCELLED"?"JOB_STATE_CANCELLED":t==="BATCH_STATE_EXPIRED"?"JOB_STATE_EXPIRED":t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function sJ(e){const t={},n=w(e,["responsesFile"]);n!=null&&b(t,["fileName"],n);const i=w(e,["inlinedResponses","inlinedResponses"]);if(i!=null){let s=i;Array.isArray(s)&&(s=s.map(a=>FJ(a))),b(t,["inlinedResponses"],s)}const r=w(e,["inlinedEmbedContentResponses","inlinedResponses"]);if(r!=null){let s=r;Array.isArray(s)&&(s=s.map(a=>a)),b(t,["inlinedEmbedContentResponses"],s)}return t}function aJ(e){const t={},n=w(e,["predictionsFormat"]);n!=null&&b(t,["format"],n);const i=w(e,["gcsDestination","outputUriPrefix"]);i!=null&&b(t,["gcsUri"],i);const r=w(e,["bigqueryDestination","outputUri"]);return r!=null&&b(t,["bigqueryUri"],r),t}function oJ(e){const t={},n=w(e,["format"]);n!=null&&b(t,["predictionsFormat"],n);const i=w(e,["gcsUri"]);i!=null&&b(t,["gcsDestination","outputUriPrefix"],i);const r=w(e,["bigqueryUri"]);if(r!=null&&b(t,["bigqueryDestination","outputUri"],r),w(e,["fileName"])!==void 0)throw new Error("fileName parameter is not supported in Vertex AI.");if(w(e,["inlinedResponses"])!==void 0)throw new Error("inlinedResponses parameter is not supported in Vertex AI.");if(w(e,["inlinedEmbedContentResponses"])!==void 0)throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");return t}function wm(e){const t={},n=w(e,["name"]);n!=null&&b(t,["name"],n);const i=w(e,["metadata","displayName"]);i!=null&&b(t,["displayName"],i);const r=w(e,["metadata","state"]);r!=null&&b(t,["state"],q4(r));const s=w(e,["metadata","createTime"]);s!=null&&b(t,["createTime"],s);const a=w(e,["metadata","endTime"]);a!=null&&b(t,["endTime"],a);const o=w(e,["metadata","updateTime"]);o!=null&&b(t,["updateTime"],o);const l=w(e,["metadata","model"]);l!=null&&b(t,["model"],l);const u=w(e,["metadata","output"]);return u!=null&&b(t,["dest"],sJ(H4(u))),t}function $b(e){const t={},n=w(e,["name"]);n!=null&&b(t,["name"],n);const i=w(e,["displayName"]);i!=null&&b(t,["displayName"],i);const r=w(e,["state"]);r!=null&&b(t,["state"],q4(r));const s=w(e,["error"]);s!=null&&b(t,["error"],s);const a=w(e,["createTime"]);a!=null&&b(t,["createTime"],a);const o=w(e,["startTime"]);o!=null&&b(t,["startTime"],o);const l=w(e,["endTime"]);l!=null&&b(t,["endTime"],l);const u=w(e,["updateTime"]);u!=null&&b(t,["updateTime"],u);const c=w(e,["model"]);c!=null&&b(t,["model"],c);const f=w(e,["inputConfig"]);f!=null&&b(t,["src"],lJ(f));const d=w(e,["outputConfig"]);d!=null&&b(t,["dest"],aJ(H4(d)));const h=w(e,["completionStats"]);return h!=null&&b(t,["completionStats"],h),t}function lJ(e){const t={},n=w(e,["instancesFormat"]);n!=null&&b(t,["format"],n);const i=w(e,["gcsSource","uris"]);i!=null&&b(t,["gcsUri"],i);const r=w(e,["bigquerySource","inputUri"]);return r!=null&&b(t,["bigqueryUri"],r),t}function uJ(e,t){const n={};if(w(t,["format"])!==void 0)throw new Error("format parameter is not supported in Gemini API.");if(w(t,["gcsUri"])!==void 0)throw new Error("gcsUri parameter is not supported in Gemini API.");if(w(t,["bigqueryUri"])!==void 0)throw new Error("bigqueryUri parameter is not supported in Gemini API.");const i=w(t,["fileName"]);i!=null&&b(n,["fileName"],i);const r=w(t,["inlinedRequests"]);if(r!=null){let s=r;Array.isArray(s)&&(s=s.map(a=>zJ(e,a))),b(n,["requests","requests"],s)}return n}function cJ(e){const t={},n=w(e,["format"]);n!=null&&b(t,["instancesFormat"],n);const i=w(e,["gcsUri"]);i!=null&&b(t,["gcsSource","uris"],i);const r=w(e,["bigqueryUri"]);if(r!=null&&b(t,["bigquerySource","inputUri"],r),w(e,["fileName"])!==void 0)throw new Error("fileName parameter is not supported in Vertex AI.");if(w(e,["inlinedRequests"])!==void 0)throw new Error("inlinedRequests parameter is not supported in Vertex AI.");return t}function dJ(e){const t={},n=w(e,["data"]);if(n!=null&&b(t,["data"],n),w(e,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function fJ(e,t){const n={},i=w(t,["name"]);return i!=null&&b(n,["_url","name"],Bd(e,i)),n}function pJ(e,t){const n={},i=w(t,["name"]);return i!=null&&b(n,["_url","name"],Bd(e,i)),n}function hJ(e){const t={},n=w(e,["content"]);n!=null&&b(t,["content"],n);const i=w(e,["citationMetadata"]);i!=null&&b(t,["citationMetadata"],mJ(i));const r=w(e,["tokenCount"]);r!=null&&b(t,["tokenCount"],r);const s=w(e,["finishReason"]);s!=null&&b(t,["finishReason"],s);const a=w(e,["avgLogprobs"]);a!=null&&b(t,["avgLogprobs"],a);const o=w(e,["groundingMetadata"]);o!=null&&b(t,["groundingMetadata"],o);const l=w(e,["index"]);l!=null&&b(t,["index"],l);const u=w(e,["logprobsResult"]);u!=null&&b(t,["logprobsResult"],u);const c=w(e,["safetyRatings"]);if(c!=null){let d=c;Array.isArray(d)&&(d=d.map(h=>h)),b(t,["safetyRatings"],d)}const f=w(e,["urlContextMetadata"]);return f!=null&&b(t,["urlContextMetadata"],f),t}function mJ(e){const t={},n=w(e,["citationSources"]);if(n!=null){let i=n;Array.isArray(i)&&(i=i.map(r=>r)),b(t,["citations"],i)}return t}function K4(e){const t={},n=w(e,["parts"]);if(n!=null){let r=n;Array.isArray(r)&&(r=r.map(s=>HJ(s))),b(t,["parts"],r)}const i=w(e,["role"]);return i!=null&&b(t,["role"],i),t}function gJ(e,t){const n={},i=w(e,["displayName"]);if(t!==void 0&&i!=null&&b(t,["batch","displayName"],i),w(e,["dest"])!==void 0)throw new Error("dest parameter is not supported in Gemini API.");return n}function _J(e,t){const n={},i=w(e,["displayName"]);t!==void 0&&i!=null&&b(t,["displayName"],i);const r=w(e,["dest"]);return t!==void 0&&r!=null&&b(t,["outputConfig"],oJ(rJ(r))),n}function _P(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["src"]);r!=null&&b(n,["batch","inputConfig"],uJ(e,W4(e,r)));const s=w(t,["config"]);return s!=null&&gJ(s,n),n}function yJ(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["model"],ti(e,i));const r=w(t,["src"]);r!=null&&b(n,["inputConfig"],cJ(W4(e,r)));const s=w(t,["config"]);return s!=null&&_J(s,n),n}function vJ(e,t){const n={},i=w(e,["displayName"]);return t!==void 0&&i!=null&&b(t,["batch","displayName"],i),n}function wJ(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["src"]);r!=null&&b(n,["batch","inputConfig"],CJ(e,r));const s=w(t,["config"]);return s!=null&&vJ(s,n),n}function bJ(e,t){const n={},i=w(t,["name"]);return i!=null&&b(n,["_url","name"],Bd(e,i)),n}function xJ(e,t){const n={},i=w(t,["name"]);return i!=null&&b(n,["_url","name"],Bd(e,i)),n}function TJ(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["name"]);i!=null&&b(t,["name"],i);const r=w(e,["done"]);r!=null&&b(t,["done"],r);const s=w(e,["error"]);return s!=null&&b(t,["error"],s),t}function MJ(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["name"]);i!=null&&b(t,["name"],i);const r=w(e,["done"]);r!=null&&b(t,["done"],r);const s=w(e,["error"]);return s!=null&&b(t,["error"],s),t}function EJ(e,t){const n={},i=w(t,["contents"]);if(i!=null){let s=Ax(e,i);Array.isArray(s)&&(s=s.map(a=>a)),b(n,["requests[]","request","content"],s)}const r=w(t,["config"]);return r!=null&&(b(n,["_self"],SJ(r,n)),x7(n,{"requests[].*":"requests[].request.*"})),n}function SJ(e,t){const n={},i=w(e,["taskType"]);t!==void 0&&i!=null&&b(t,["requests[]","taskType"],i);const r=w(e,["title"]);t!==void 0&&r!=null&&b(t,["requests[]","title"],r);const s=w(e,["outputDimensionality"]);if(t!==void 0&&s!=null&&b(t,["requests[]","outputDimensionality"],s),w(e,["mimeType"])!==void 0)throw new Error("mimeType parameter is not supported in Gemini API.");if(w(e,["autoTruncate"])!==void 0)throw new Error("autoTruncate parameter is not supported in Gemini API.");return n}function CJ(e,t){const n={},i=w(t,["fileName"]);i!=null&&b(n,["file_name"],i);const r=w(t,["inlinedRequests"]);return r!=null&&b(n,["requests"],EJ(e,r)),n}function $J(e){const t={};if(w(e,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const n=w(e,["fileUri"]);n!=null&&b(t,["fileUri"],n);const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function AJ(e){const t={},n=w(e,["id"]);n!=null&&b(t,["id"],n);const i=w(e,["args"]);i!=null&&b(t,["args"],i);const r=w(e,["name"]);if(r!=null&&b(t,["name"],r),w(e,["partialArgs"])!==void 0)throw new Error("partialArgs parameter is not supported in Gemini API.");if(w(e,["willContinue"])!==void 0)throw new Error("willContinue parameter is not supported in Gemini API.");return t}function IJ(e){const t={},n=w(e,["mode"]);n!=null&&b(t,["mode"],n);const i=w(e,["allowedFunctionNames"]);if(i!=null&&b(t,["allowedFunctionNames"],i),w(e,["streamFunctionCallArguments"])!==void 0)throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");return t}function PJ(e,t,n){const i={},r=w(t,["systemInstruction"]);n!==void 0&&r!=null&&b(n,["systemInstruction"],K4(zr(r)));const s=w(t,["temperature"]);s!=null&&b(i,["temperature"],s);const a=w(t,["topP"]);a!=null&&b(i,["topP"],a);const o=w(t,["topK"]);o!=null&&b(i,["topK"],o);const l=w(t,["candidateCount"]);l!=null&&b(i,["candidateCount"],l);const u=w(t,["maxOutputTokens"]);u!=null&&b(i,["maxOutputTokens"],u);const c=w(t,["stopSequences"]);c!=null&&b(i,["stopSequences"],c);const f=w(t,["responseLogprobs"]);f!=null&&b(i,["responseLogprobs"],f);const d=w(t,["logprobs"]);d!=null&&b(i,["logprobs"],d);const h=w(t,["presencePenalty"]);h!=null&&b(i,["presencePenalty"],h);const m=w(t,["frequencyPenalty"]);m!=null&&b(i,["frequencyPenalty"],m);const y=w(t,["seed"]);y!=null&&b(i,["seed"],y);const M=w(t,["responseMimeType"]);M!=null&&b(i,["responseMimeType"],M);const g=w(t,["responseSchema"]);g!=null&&b(i,["responseSchema"],Ix(g));const _=w(t,["responseJsonSchema"]);if(_!=null&&b(i,["responseJsonSchema"],_),w(t,["routingConfig"])!==void 0)throw new Error("routingConfig parameter is not supported in Gemini API.");if(w(t,["modelSelectionConfig"])!==void 0)throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");const T=w(t,["safetySettings"]);if(n!==void 0&&T!=null){let V=T;Array.isArray(V)&&(V=V.map(te=>qJ(te))),b(n,["safetySettings"],V)}const x=w(t,["tools"]);if(n!==void 0&&x!=null){let V=Fd(x);Array.isArray(V)&&(V=V.map(te=>JJ(zd(te)))),b(n,["tools"],V)}const S=w(t,["toolConfig"]);if(n!==void 0&&S!=null&&b(n,["toolConfig"],KJ(S)),w(t,["labels"])!==void 0)throw new Error("labels parameter is not supported in Gemini API.");const $=w(t,["cachedContent"]);n!==void 0&&$!=null&&b(n,["cachedContent"],Uo(e,$));const C=w(t,["responseModalities"]);C!=null&&b(i,["responseModalities"],C);const P=w(t,["mediaResolution"]);P!=null&&b(i,["mediaResolution"],P);const O=w(t,["speechConfig"]);if(O!=null&&b(i,["speechConfig"],Px(O)),w(t,["audioTimestamp"])!==void 0)throw new Error("audioTimestamp parameter is not supported in Gemini API.");const R=w(t,["thinkingConfig"]);R!=null&&b(i,["thinkingConfig"],R);const G=w(t,["imageConfig"]);G!=null&&b(i,["imageConfig"],LJ(G));const W=w(t,["enableEnhancedCivicAnswers"]);return W!=null&&b(i,["enableEnhancedCivicAnswers"],W),i}function kJ(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["candidates"]);if(i!=null){let l=i;Array.isArray(l)&&(l=l.map(u=>hJ(u))),b(t,["candidates"],l)}const r=w(e,["modelVersion"]);r!=null&&b(t,["modelVersion"],r);const s=w(e,["promptFeedback"]);s!=null&&b(t,["promptFeedback"],s);const a=w(e,["responseId"]);a!=null&&b(t,["responseId"],a);const o=w(e,["usageMetadata"]);return o!=null&&b(t,["usageMetadata"],o),t}function DJ(e,t){const n={},i=w(t,["name"]);return i!=null&&b(n,["_url","name"],Bd(e,i)),n}function OJ(e,t){const n={},i=w(t,["name"]);return i!=null&&b(n,["_url","name"],Bd(e,i)),n}function RJ(e){const t={};if(w(e,["authConfig"])!==void 0)throw new Error("authConfig parameter is not supported in Gemini API.");const n=w(e,["enableWidget"]);return n!=null&&b(t,["enableWidget"],n),t}function NJ(e){const t={};if(w(e,["excludeDomains"])!==void 0)throw new Error("excludeDomains parameter is not supported in Gemini API.");if(w(e,["blockingConfidence"])!==void 0)throw new Error("blockingConfidence parameter is not supported in Gemini API.");const n=w(e,["timeRangeFilter"]);return n!=null&&b(t,["timeRangeFilter"],n),t}function LJ(e){const t={},n=w(e,["aspectRatio"]);n!=null&&b(t,["aspectRatio"],n);const i=w(e,["imageSize"]);if(i!=null&&b(t,["imageSize"],i),w(e,["outputMimeType"])!==void 0)throw new Error("outputMimeType parameter is not supported in Gemini API.");if(w(e,["outputCompressionQuality"])!==void 0)throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");return t}function zJ(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["request","model"],ti(e,i));const r=w(t,["contents"]);if(r!=null){let o=Xs(r);Array.isArray(o)&&(o=o.map(l=>K4(l))),b(n,["request","contents"],o)}const s=w(t,["metadata"]);s!=null&&b(n,["metadata"],s);const a=w(t,["config"]);return a!=null&&b(n,["request","generationConfig"],PJ(e,a,w(n,["request"],{}))),n}function FJ(e){const t={},n=w(e,["response"]);n!=null&&b(t,["response"],kJ(n));const i=w(e,["error"]);return i!=null&&b(t,["error"],i),t}function BJ(e,t){const n={},i=w(e,["pageSize"]);t!==void 0&&i!=null&&b(t,["_query","pageSize"],i);const r=w(e,["pageToken"]);if(t!==void 0&&r!=null&&b(t,["_query","pageToken"],r),w(e,["filter"])!==void 0)throw new Error("filter parameter is not supported in Gemini API.");return n}function UJ(e,t){const n={},i=w(e,["pageSize"]);t!==void 0&&i!=null&&b(t,["_query","pageSize"],i);const r=w(e,["pageToken"]);t!==void 0&&r!=null&&b(t,["_query","pageToken"],r);const s=w(e,["filter"]);return t!==void 0&&s!=null&&b(t,["_query","filter"],s),n}function VJ(e){const t={},n=w(e,["config"]);return n!=null&&BJ(n,t),t}function GJ(e){const t={},n=w(e,["config"]);return n!=null&&UJ(n,t),t}function jJ(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["nextPageToken"]);i!=null&&b(t,["nextPageToken"],i);const r=w(e,["operations"]);if(r!=null){let s=r;Array.isArray(s)&&(s=s.map(a=>wm(a))),b(t,["batchJobs"],s)}return t}function WJ(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["nextPageToken"]);i!=null&&b(t,["nextPageToken"],i);const r=w(e,["batchPredictionJobs"]);if(r!=null){let s=r;Array.isArray(s)&&(s=s.map(a=>$b(a))),b(t,["batchJobs"],s)}return t}function HJ(e){const t={},n=w(e,["mediaResolution"]);n!=null&&b(t,["mediaResolution"],n);const i=w(e,["codeExecutionResult"]);i!=null&&b(t,["codeExecutionResult"],i);const r=w(e,["executableCode"]);r!=null&&b(t,["executableCode"],r);const s=w(e,["fileData"]);s!=null&&b(t,["fileData"],$J(s));const a=w(e,["functionCall"]);a!=null&&b(t,["functionCall"],AJ(a));const o=w(e,["functionResponse"]);o!=null&&b(t,["functionResponse"],o);const l=w(e,["inlineData"]);l!=null&&b(t,["inlineData"],dJ(l));const u=w(e,["text"]);u!=null&&b(t,["text"],u);const c=w(e,["thought"]);c!=null&&b(t,["thought"],c);const f=w(e,["thoughtSignature"]);f!=null&&b(t,["thoughtSignature"],f);const d=w(e,["videoMetadata"]);return d!=null&&b(t,["videoMetadata"],d),t}function qJ(e){const t={},n=w(e,["category"]);if(n!=null&&b(t,["category"],n),w(e,["method"])!==void 0)throw new Error("method parameter is not supported in Gemini API.");const i=w(e,["threshold"]);return i!=null&&b(t,["threshold"],i),t}function KJ(e){const t={},n=w(e,["functionCallingConfig"]);n!=null&&b(t,["functionCallingConfig"],IJ(n));const i=w(e,["retrievalConfig"]);return i!=null&&b(t,["retrievalConfig"],i),t}function JJ(e){const t={},n=w(e,["functionDeclarations"]);if(n!=null){let c=n;Array.isArray(c)&&(c=c.map(f=>f)),b(t,["functionDeclarations"],c)}if(w(e,["retrieval"])!==void 0)throw new Error("retrieval parameter is not supported in Gemini API.");const i=w(e,["googleSearchRetrieval"]);i!=null&&b(t,["googleSearchRetrieval"],i);const r=w(e,["computerUse"]);r!=null&&b(t,["computerUse"],r);const s=w(e,["fileSearch"]);s!=null&&b(t,["fileSearch"],s);const a=w(e,["codeExecution"]);if(a!=null&&b(t,["codeExecution"],a),w(e,["enterpriseWebSearch"])!==void 0)throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");const o=w(e,["googleMaps"]);o!=null&&b(t,["googleMaps"],RJ(o));const l=w(e,["googleSearch"]);l!=null&&b(t,["googleSearch"],NJ(l));const u=w(e,["urlContext"]);return u!=null&&b(t,["urlContext"],u),t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var zo;(function(e){e.PAGED_ITEM_BATCH_JOBS="batchJobs",e.PAGED_ITEM_MODELS="models",e.PAGED_ITEM_TUNING_JOBS="tuningJobs",e.PAGED_ITEM_FILES="files",e.PAGED_ITEM_CACHED_CONTENTS="cachedContents",e.PAGED_ITEM_FILE_SEARCH_STORES="fileSearchStores",e.PAGED_ITEM_DOCUMENTS="documents"})(zo||(zo={}));class cc{constructor(t,n,i,r){this.pageInternal=[],this.paramsInternal={},this.requestInternal=n,this.init(t,i,r)}init(t,n,i){var r,s;this.nameInternal=t,this.pageInternal=n[this.nameInternal]||[],this.sdkHttpResponseInternal=n==null?void 0:n.sdkHttpResponse,this.idxInternal=0;let a={config:{}};!i||Object.keys(i).length===0?a={config:{}}:typeof i=="object"?a=Object.assign({},i):a=i,a.config&&(a.config.pageToken=n.nextPageToken),this.paramsInternal=a,this.pageInternalSize=(s=(r=a.config)===null||r===void 0?void 0:r.pageSize)!==null&&s!==void 0?s:this.pageInternal.length}initNextPage(t){this.init(this.nameInternal,t,this.paramsInternal)}get page(){return this.pageInternal}get name(){return this.nameInternal}get pageSize(){return this.pageInternalSize}get sdkHttpResponse(){return this.sdkHttpResponseInternal}get params(){return this.paramsInternal}get pageLength(){return this.pageInternal.length}getItem(t){return this.pageInternal[t]}[Symbol.asyncIterator](){return{next:async()=>{if(this.idxInternal>=this.pageLength)if(this.hasNextPage())await this.nextPage();else return{value:void 0,done:!0};const t=this.getItem(this.idxInternal);return this.idxInternal+=1,{value:t,done:!1}},return:async()=>({value:void 0,done:!0})}}async nextPage(){if(!this.hasNextPage())throw new Error("No more pages to fetch.");const t=await this.requestInternal(this.params);return this.initNextPage(t),this.page}hasNextPage(){var t;return((t=this.params.config)===null||t===void 0?void 0:t.pageToken)!==void 0}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class YJ extends Bo{constructor(t){super(),this.apiClient=t,this.list=async(n={})=>new cc(zo.PAGED_ITEM_BATCH_JOBS,i=>this.listInternal(i),await this.listInternal(n),n),this.create=async n=>(this.apiClient.isVertexAI()&&(n.config=this.formatDestination(n.src,n.config)),this.createInternal(n)),this.createEmbeddings=async n=>{if(console.warn("batches.createEmbeddings() is experimental and may change without notice."),this.apiClient.isVertexAI())throw new Error("Vertex AI does not support batches.createEmbeddings.");return this.createEmbeddingsInternal(n)}}createInlinedGenerateContentRequest(t){const n=_P(this.apiClient,t),i=n._url,r=Dt("{model}:batchGenerateContent",i),o=n.batch.inputConfig.requests,l=o.requests,u=[];for(const c of l){const f=Object.assign({},c);if(f.systemInstruction){const d=f.systemInstruction;delete f.systemInstruction;const h=f.request;h.systemInstruction=d,f.request=h}u.push(f)}return o.requests=u,delete n.config,delete n._url,delete n._query,{path:r,body:n}}getGcsUri(t){if(typeof t=="string")return t.startsWith("gs://")?t:void 0;if(!Array.isArray(t)&&t.gcsUri&&t.gcsUri.length>0)return t.gcsUri[0]}getBigqueryUri(t){if(typeof t=="string")return t.startsWith("bq://")?t:void 0;if(!Array.isArray(t))return t.bigqueryUri}formatDestination(t,n){const i=n?Object.assign({},n):{},r=Date.now().toString();if(i.displayName||(i.displayName=`genaiBatchJob_${r}`),i.dest===void 0){const s=this.getGcsUri(t),a=this.getBigqueryUri(t);if(s)s.endsWith(".jsonl")?i.dest=`${s.slice(0,-6)}/dest`:i.dest=`${s}_dest_${r}`;else if(a)i.dest=`${a}_dest_${r}`;else throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.")}return i}async createInternal(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=yJ(this.apiClient,t);return o=Dt("batchPredictionJobs",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json()),a.then(c=>$b(c))}else{const u=_P(this.apiClient,t);return o=Dt("{model}:batchGenerateContent",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json()),a.then(c=>wm(c))}}async createEmbeddingsInternal(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=wJ(this.apiClient,t);return s=Dt("{model}:asyncBatchEmbedContent",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>wm(l))}}async get(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=OJ(this.apiClient,t);return o=Dt("batchPredictionJobs/{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json()),a.then(c=>$b(c))}else{const u=DJ(this.apiClient,t);return o=Dt("batches/{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json()),a.then(c=>wm(c))}}async cancel(t){var n,i,r,s;let a="",o={};if(this.apiClient.isVertexAI()){const l=pJ(this.apiClient,t);a=Dt("batchPredictionJobs/{name}:cancel",l._url),o=l._query,delete l._url,delete l._query,await this.apiClient.request({path:a,queryParams:o,body:JSON.stringify(l),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal})}else{const l=fJ(this.apiClient,t);a=Dt("batches/{name}:cancel",l._url),o=l._query,delete l._url,delete l._query,await this.apiClient.request({path:a,queryParams:o,body:JSON.stringify(l),httpMethod:"POST",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal})}}async listInternal(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=GJ(t);return o=Dt("batchPredictionJobs",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=WJ(c),d=new pP;return Object.assign(d,f),d})}else{const u=VJ(t);return o=Dt("batches",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=jJ(c),d=new pP;return Object.assign(d,f),d})}}async delete(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=xJ(this.apiClient,t);return o=Dt("batchPredictionJobs/{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"DELETE",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>MJ(c))}else{const u=bJ(this.apiClient,t);return o=Dt("batches/{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"DELETE",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>TJ(c))}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function XJ(e){const t={},n=w(e,["data"]);if(n!=null&&b(t,["data"],n),w(e,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function yP(e){const t={},n=w(e,["parts"]);if(n!=null){let r=n;Array.isArray(r)&&(r=r.map(s=>wY(s))),b(t,["parts"],r)}const i=w(e,["role"]);return i!=null&&b(t,["role"],i),t}function QJ(e,t){const n={},i=w(e,["ttl"]);t!==void 0&&i!=null&&b(t,["ttl"],i);const r=w(e,["expireTime"]);t!==void 0&&r!=null&&b(t,["expireTime"],r);const s=w(e,["displayName"]);t!==void 0&&s!=null&&b(t,["displayName"],s);const a=w(e,["contents"]);if(t!==void 0&&a!=null){let c=Xs(a);Array.isArray(c)&&(c=c.map(f=>yP(f))),b(t,["contents"],c)}const o=w(e,["systemInstruction"]);t!==void 0&&o!=null&&b(t,["systemInstruction"],yP(zr(o)));const l=w(e,["tools"]);if(t!==void 0&&l!=null){let c=l;Array.isArray(c)&&(c=c.map(f=>xY(f))),b(t,["tools"],c)}const u=w(e,["toolConfig"]);if(t!==void 0&&u!=null&&b(t,["toolConfig"],bY(u)),w(e,["kmsKeyName"])!==void 0)throw new Error("kmsKeyName parameter is not supported in Gemini API.");return n}function ZJ(e,t){const n={},i=w(e,["ttl"]);t!==void 0&&i!=null&&b(t,["ttl"],i);const r=w(e,["expireTime"]);t!==void 0&&r!=null&&b(t,["expireTime"],r);const s=w(e,["displayName"]);t!==void 0&&s!=null&&b(t,["displayName"],s);const a=w(e,["contents"]);if(t!==void 0&&a!=null){let f=Xs(a);Array.isArray(f)&&(f=f.map(d=>d)),b(t,["contents"],f)}const o=w(e,["systemInstruction"]);t!==void 0&&o!=null&&b(t,["systemInstruction"],zr(o));const l=w(e,["tools"]);if(t!==void 0&&l!=null){let f=l;Array.isArray(f)&&(f=f.map(d=>TY(d))),b(t,["tools"],f)}const u=w(e,["toolConfig"]);t!==void 0&&u!=null&&b(t,["toolConfig"],u);const c=w(e,["kmsKeyName"]);return t!==void 0&&c!=null&&b(t,["encryption_spec","kmsKeyName"],c),n}function eY(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["model"],N4(e,i));const r=w(t,["config"]);return r!=null&&QJ(r,n),n}function tY(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["model"],N4(e,i));const r=w(t,["config"]);return r!=null&&ZJ(r,n),n}function nY(e,t){const n={},i=w(t,["name"]);return i!=null&&b(n,["_url","name"],Uo(e,i)),n}function iY(e,t){const n={},i=w(t,["name"]);return i!=null&&b(n,["_url","name"],Uo(e,i)),n}function rY(e){const t={},n=w(e,["sdkHttpResponse"]);return n!=null&&b(t,["sdkHttpResponse"],n),t}function sY(e){const t={},n=w(e,["sdkHttpResponse"]);return n!=null&&b(t,["sdkHttpResponse"],n),t}function aY(e){const t={};if(w(e,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const n=w(e,["fileUri"]);n!=null&&b(t,["fileUri"],n);const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function oY(e){const t={},n=w(e,["id"]);n!=null&&b(t,["id"],n);const i=w(e,["args"]);i!=null&&b(t,["args"],i);const r=w(e,["name"]);if(r!=null&&b(t,["name"],r),w(e,["partialArgs"])!==void 0)throw new Error("partialArgs parameter is not supported in Gemini API.");if(w(e,["willContinue"])!==void 0)throw new Error("willContinue parameter is not supported in Gemini API.");return t}function lY(e){const t={},n=w(e,["mode"]);n!=null&&b(t,["mode"],n);const i=w(e,["allowedFunctionNames"]);if(i!=null&&b(t,["allowedFunctionNames"],i),w(e,["streamFunctionCallArguments"])!==void 0)throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");return t}function uY(e){const t={};if(w(e,["behavior"])!==void 0)throw new Error("behavior parameter is not supported in Vertex AI.");const n=w(e,["description"]);n!=null&&b(t,["description"],n);const i=w(e,["name"]);i!=null&&b(t,["name"],i);const r=w(e,["parameters"]);r!=null&&b(t,["parameters"],r);const s=w(e,["parametersJsonSchema"]);s!=null&&b(t,["parametersJsonSchema"],s);const a=w(e,["response"]);a!=null&&b(t,["response"],a);const o=w(e,["responseJsonSchema"]);return o!=null&&b(t,["responseJsonSchema"],o),t}function cY(e,t){const n={},i=w(t,["name"]);return i!=null&&b(n,["_url","name"],Uo(e,i)),n}function dY(e,t){const n={},i=w(t,["name"]);return i!=null&&b(n,["_url","name"],Uo(e,i)),n}function fY(e){const t={};if(w(e,["authConfig"])!==void 0)throw new Error("authConfig parameter is not supported in Gemini API.");const n=w(e,["enableWidget"]);return n!=null&&b(t,["enableWidget"],n),t}function pY(e){const t={};if(w(e,["excludeDomains"])!==void 0)throw new Error("excludeDomains parameter is not supported in Gemini API.");if(w(e,["blockingConfidence"])!==void 0)throw new Error("blockingConfidence parameter is not supported in Gemini API.");const n=w(e,["timeRangeFilter"]);return n!=null&&b(t,["timeRangeFilter"],n),t}function hY(e,t){const n={},i=w(e,["pageSize"]);t!==void 0&&i!=null&&b(t,["_query","pageSize"],i);const r=w(e,["pageToken"]);return t!==void 0&&r!=null&&b(t,["_query","pageToken"],r),n}function mY(e,t){const n={},i=w(e,["pageSize"]);t!==void 0&&i!=null&&b(t,["_query","pageSize"],i);const r=w(e,["pageToken"]);return t!==void 0&&r!=null&&b(t,["_query","pageToken"],r),n}function gY(e){const t={},n=w(e,["config"]);return n!=null&&hY(n,t),t}function _Y(e){const t={},n=w(e,["config"]);return n!=null&&mY(n,t),t}function yY(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["nextPageToken"]);i!=null&&b(t,["nextPageToken"],i);const r=w(e,["cachedContents"]);if(r!=null){let s=r;Array.isArray(s)&&(s=s.map(a=>a)),b(t,["cachedContents"],s)}return t}function vY(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["nextPageToken"]);i!=null&&b(t,["nextPageToken"],i);const r=w(e,["cachedContents"]);if(r!=null){let s=r;Array.isArray(s)&&(s=s.map(a=>a)),b(t,["cachedContents"],s)}return t}function wY(e){const t={},n=w(e,["mediaResolution"]);n!=null&&b(t,["mediaResolution"],n);const i=w(e,["codeExecutionResult"]);i!=null&&b(t,["codeExecutionResult"],i);const r=w(e,["executableCode"]);r!=null&&b(t,["executableCode"],r);const s=w(e,["fileData"]);s!=null&&b(t,["fileData"],aY(s));const a=w(e,["functionCall"]);a!=null&&b(t,["functionCall"],oY(a));const o=w(e,["functionResponse"]);o!=null&&b(t,["functionResponse"],o);const l=w(e,["inlineData"]);l!=null&&b(t,["inlineData"],XJ(l));const u=w(e,["text"]);u!=null&&b(t,["text"],u);const c=w(e,["thought"]);c!=null&&b(t,["thought"],c);const f=w(e,["thoughtSignature"]);f!=null&&b(t,["thoughtSignature"],f);const d=w(e,["videoMetadata"]);return d!=null&&b(t,["videoMetadata"],d),t}function bY(e){const t={},n=w(e,["functionCallingConfig"]);n!=null&&b(t,["functionCallingConfig"],lY(n));const i=w(e,["retrievalConfig"]);return i!=null&&b(t,["retrievalConfig"],i),t}function xY(e){const t={},n=w(e,["functionDeclarations"]);if(n!=null){let c=n;Array.isArray(c)&&(c=c.map(f=>f)),b(t,["functionDeclarations"],c)}if(w(e,["retrieval"])!==void 0)throw new Error("retrieval parameter is not supported in Gemini API.");const i=w(e,["googleSearchRetrieval"]);i!=null&&b(t,["googleSearchRetrieval"],i);const r=w(e,["computerUse"]);r!=null&&b(t,["computerUse"],r);const s=w(e,["fileSearch"]);s!=null&&b(t,["fileSearch"],s);const a=w(e,["codeExecution"]);if(a!=null&&b(t,["codeExecution"],a),w(e,["enterpriseWebSearch"])!==void 0)throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");const o=w(e,["googleMaps"]);o!=null&&b(t,["googleMaps"],fY(o));const l=w(e,["googleSearch"]);l!=null&&b(t,["googleSearch"],pY(l));const u=w(e,["urlContext"]);return u!=null&&b(t,["urlContext"],u),t}function TY(e){const t={},n=w(e,["functionDeclarations"]);if(n!=null){let f=n;Array.isArray(f)&&(f=f.map(d=>uY(d))),b(t,["functionDeclarations"],f)}const i=w(e,["retrieval"]);i!=null&&b(t,["retrieval"],i);const r=w(e,["googleSearchRetrieval"]);r!=null&&b(t,["googleSearchRetrieval"],r);const s=w(e,["computerUse"]);if(s!=null&&b(t,["computerUse"],s),w(e,["fileSearch"])!==void 0)throw new Error("fileSearch parameter is not supported in Vertex AI.");const a=w(e,["codeExecution"]);a!=null&&b(t,["codeExecution"],a);const o=w(e,["enterpriseWebSearch"]);o!=null&&b(t,["enterpriseWebSearch"],o);const l=w(e,["googleMaps"]);l!=null&&b(t,["googleMaps"],l);const u=w(e,["googleSearch"]);u!=null&&b(t,["googleSearch"],u);const c=w(e,["urlContext"]);return c!=null&&b(t,["urlContext"],c),t}function MY(e,t){const n={},i=w(e,["ttl"]);t!==void 0&&i!=null&&b(t,["ttl"],i);const r=w(e,["expireTime"]);return t!==void 0&&r!=null&&b(t,["expireTime"],r),n}function EY(e,t){const n={},i=w(e,["ttl"]);t!==void 0&&i!=null&&b(t,["ttl"],i);const r=w(e,["expireTime"]);return t!==void 0&&r!=null&&b(t,["expireTime"],r),n}function SY(e,t){const n={},i=w(t,["name"]);i!=null&&b(n,["_url","name"],Uo(e,i));const r=w(t,["config"]);return r!=null&&MY(r,n),n}function CY(e,t){const n={},i=w(t,["name"]);i!=null&&b(n,["_url","name"],Uo(e,i));const r=w(t,["config"]);return r!=null&&EY(r,n),n}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class $Y extends Bo{constructor(t){super(),this.apiClient=t,this.list=async(n={})=>new cc(zo.PAGED_ITEM_CACHED_CONTENTS,i=>this.listInternal(i),await this.listInternal(n),n)}async create(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=tY(this.apiClient,t);return o=Dt("cachedContents",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json()),a.then(c=>c)}else{const u=eY(this.apiClient,t);return o=Dt("cachedContents",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json()),a.then(c=>c)}}async get(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=dY(this.apiClient,t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json()),a.then(c=>c)}else{const u=cY(this.apiClient,t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json()),a.then(c=>c)}}async delete(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=iY(this.apiClient,t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"DELETE",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=sY(c),d=new dP;return Object.assign(d,f),d})}else{const u=nY(this.apiClient,t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"DELETE",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=rY(c),d=new dP;return Object.assign(d,f),d})}}async update(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=CY(this.apiClient,t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"PATCH",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json()),a.then(c=>c)}else{const u=SY(this.apiClient,t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"PATCH",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json()),a.then(c=>c)}}async listInternal(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=_Y(t);return o=Dt("cachedContents",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=vY(c),d=new fP;return Object.assign(d,f),d})}else{const u=gY(t);return o=Dt("cachedContents",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=yY(c),d=new fP;return Object.assign(d,f),d})}}}function cg(e,t){var n={};for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&t.indexOf(i)<0&&(n[i]=e[i]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,i=Object.getOwnPropertySymbols(e);r<i.length;r++)t.indexOf(i[r])<0&&Object.prototype.propertyIsEnumerable.call(e,i[r])&&(n[i[r]]=e[i[r]]);return n}function vP(e){var t=typeof Symbol=="function"&&Symbol.iterator,n=t&&e[t],i=0;if(n)return n.call(e);if(e&&typeof e.length=="number")return{next:function(){return e&&i>=e.length&&(e=void 0),{value:e&&e[i++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function fn(e){return this instanceof fn?(this.v=e,this):new fn(e)}function Ca(e,t,n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i=n.apply(e,t||[]),r,s=[];return r=Object.create((typeof AsyncIterator=="function"?AsyncIterator:Object).prototype),o("next"),o("throw"),o("return",a),r[Symbol.asyncIterator]=function(){return this},r;function a(h){return function(m){return Promise.resolve(m).then(h,f)}}function o(h,m){i[h]&&(r[h]=function(y){return new Promise(function(M,g){s.push([h,y,M,g])>1||l(h,y)})},m&&(r[h]=m(r[h])))}function l(h,m){try{u(i[h](m))}catch(y){d(s[0][3],y)}}function u(h){h.value instanceof fn?Promise.resolve(h.value.v).then(c,f):d(s[0][2],h)}function c(h){l("next",h)}function f(h){l("throw",h)}function d(h,m){h(m),s.shift(),s.length&&l(s[0][0],s[0][1])}}function $a(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t=e[Symbol.asyncIterator],n;return t?t.call(e):(e=typeof vP=="function"?vP(e):e[Symbol.iterator](),n={},i("next"),i("throw"),i("return"),n[Symbol.asyncIterator]=function(){return this},n);function i(s){n[s]=e[s]&&function(a){return new Promise(function(o,l){a=e[s](a),r(o,l,a.done,a.value)})}}function r(s,a,o,l){Promise.resolve(l).then(function(u){s({value:u,done:o})},a)}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function AY(e){var t;if(e.candidates==null||e.candidates.length===0)return!1;const n=(t=e.candidates[0])===null||t===void 0?void 0:t.content;return n===void 0?!1:J4(n)}function J4(e){if(e.parts===void 0||e.parts.length===0)return!1;for(const t of e.parts)if(t===void 0||Object.keys(t).length===0)return!1;return!0}function IY(e){if(e.length!==0){for(const t of e)if(t.role!=="user"&&t.role!=="model")throw new Error(`Role must be user or model, but got ${t.role}.`)}}function wP(e){if(e===void 0||e.length===0)return[];const t=[],n=e.length;let i=0;for(;i<n;)if(e[i].role==="user")t.push(e[i]),i++;else{const r=[];let s=!0;for(;i<n&&e[i].role==="model";)r.push(e[i]),s&&!J4(e[i])&&(s=!1),i++;s?t.push(...r):t.pop()}return t}class PY{constructor(t,n){this.modelsModule=t,this.apiClient=n}create(t){return new kY(this.apiClient,this.modelsModule,t.model,t.config,structuredClone(t.history))}}class kY{constructor(t,n,i,r={},s=[]){this.apiClient=t,this.modelsModule=n,this.model=i,this.config=r,this.history=s,this.sendPromise=Promise.resolve(),IY(s)}async sendMessage(t){var n;await this.sendPromise;const i=zr(t.message),r=this.modelsModule.generateContent({model:this.model,contents:this.getHistory(!0).concat(i),config:(n=t.config)!==null&&n!==void 0?n:this.config});return this.sendPromise=(async()=>{var s,a,o;const l=await r,u=(a=(s=l.candidates)===null||s===void 0?void 0:s[0])===null||a===void 0?void 0:a.content,c=l.automaticFunctionCallingHistory,f=this.getHistory(!0).length;let d=[];c!=null&&(d=(o=c.slice(f))!==null&&o!==void 0?o:[]);const h=u?[u]:[];this.recordHistory(i,h,d)})(),await this.sendPromise.catch(()=>{this.sendPromise=Promise.resolve()}),r}async sendMessageStream(t){var n;await this.sendPromise;const i=zr(t.message),r=this.modelsModule.generateContentStream({model:this.model,contents:this.getHistory(!0).concat(i),config:(n=t.config)!==null&&n!==void 0?n:this.config});this.sendPromise=r.then(()=>{}).catch(()=>{});const s=await r;return this.processStreamResponse(s,i)}getHistory(t=!1){const n=t?wP(this.history):this.history;return structuredClone(n)}processStreamResponse(t,n){return Ca(this,arguments,function*(){var r,s,a,o,l,u;const c=[];try{for(var f=!0,d=$a(t),h;h=yield fn(d.next()),r=h.done,!r;f=!0){o=h.value,f=!1;const m=o;if(AY(m)){const y=(u=(l=m.candidates)===null||l===void 0?void 0:l[0])===null||u===void 0?void 0:u.content;y!==void 0&&c.push(y)}yield yield fn(m)}}catch(m){s={error:m}}finally{try{!f&&!r&&(a=d.return)&&(yield fn(a.call(d)))}finally{if(s)throw s.error}}this.recordHistory(n,c)})}recordHistory(t,n,i){let r=[];n.length>0&&n.every(s=>s.role!==void 0)?r=n:r.push({role:"model",parts:[]}),i&&i.length>0?this.history.push(...wP(i)):this.history.push(t),this.history.push(...r)}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Xg extends Error{constructor(t){super(t.message),this.name="ApiError",this.status=t.status,Object.setPrototypeOf(this,Xg.prototype)}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function DY(e){const t={},n=w(e,["file"]);return n!=null&&b(t,["file"],n),t}function OY(e){const t={},n=w(e,["sdkHttpResponse"]);return n!=null&&b(t,["sdkHttpResponse"],n),t}function RY(e){const t={},n=w(e,["name"]);return n!=null&&b(t,["_url","file"],V4(n)),t}function NY(e){const t={},n=w(e,["sdkHttpResponse"]);return n!=null&&b(t,["sdkHttpResponse"],n),t}function LY(e){const t={},n=w(e,["name"]);return n!=null&&b(t,["_url","file"],V4(n)),t}function zY(e,t){const n={},i=w(e,["pageSize"]);t!==void 0&&i!=null&&b(t,["_query","pageSize"],i);const r=w(e,["pageToken"]);return t!==void 0&&r!=null&&b(t,["_query","pageToken"],r),n}function FY(e){const t={},n=w(e,["config"]);return n!=null&&zY(n,t),t}function BY(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["nextPageToken"]);i!=null&&b(t,["nextPageToken"],i);const r=w(e,["files"]);if(r!=null){let s=r;Array.isArray(s)&&(s=s.map(a=>a)),b(t,["files"],s)}return t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class UY extends Bo{constructor(t){super(),this.apiClient=t,this.list=async(n={})=>new cc(zo.PAGED_ITEM_FILES,i=>this.listInternal(i),await this.listInternal(n),n)}async upload(t){if(this.apiClient.isVertexAI())throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");return this.apiClient.uploadFile(t.file,t.config).then(n=>n)}async download(t){await this.apiClient.downloadFile(t)}async listInternal(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=FY(t);return s=Dt("files",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json().then(u=>{const c=u;return c.sdkHttpResponse={headers:l.headers},c})),r.then(l=>{const u=BY(l),c=new W7;return Object.assign(c,u),c})}}async createInternal(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=DY(t);return s=Dt("upload/v1beta/files",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>{const u=OY(l),c=new H7;return Object.assign(c,u),c})}}async get(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=LY(t);return s=Dt("files/{file}",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>l)}}async delete(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=RY(t);return s=Dt("files/{file}",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"DELETE",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json().then(u=>{const c=u;return c.sdkHttpResponse={headers:l.headers},c})),r.then(l=>{const u=NY(l),c=new q7;return Object.assign(c,u),c})}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function bm(e){const t={},n=w(e,["data"]);if(n!=null&&b(t,["data"],n),w(e,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function VY(e){const t={},n=w(e,["parts"]);if(n!=null){let r=n;Array.isArray(r)&&(r=r.map(s=>rX(s))),b(t,["parts"],r)}const i=w(e,["role"]);return i!=null&&b(t,["role"],i),t}function GY(e){const t={};if(w(e,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const n=w(e,["fileUri"]);n!=null&&b(t,["fileUri"],n);const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function jY(e){const t={},n=w(e,["id"]);n!=null&&b(t,["id"],n);const i=w(e,["args"]);i!=null&&b(t,["args"],i);const r=w(e,["name"]);if(r!=null&&b(t,["name"],r),w(e,["partialArgs"])!==void 0)throw new Error("partialArgs parameter is not supported in Gemini API.");if(w(e,["willContinue"])!==void 0)throw new Error("willContinue parameter is not supported in Gemini API.");return t}function WY(e){const t={};if(w(e,["behavior"])!==void 0)throw new Error("behavior parameter is not supported in Vertex AI.");const n=w(e,["description"]);n!=null&&b(t,["description"],n);const i=w(e,["name"]);i!=null&&b(t,["name"],i);const r=w(e,["parameters"]);r!=null&&b(t,["parameters"],r);const s=w(e,["parametersJsonSchema"]);s!=null&&b(t,["parametersJsonSchema"],s);const a=w(e,["response"]);a!=null&&b(t,["response"],a);const o=w(e,["responseJsonSchema"]);return o!=null&&b(t,["responseJsonSchema"],o),t}function HY(e){const t={},n=w(e,["modelSelectionConfig"]);n!=null&&b(t,["modelConfig"],n);const i=w(e,["responseJsonSchema"]);i!=null&&b(t,["responseJsonSchema"],i);const r=w(e,["audioTimestamp"]);r!=null&&b(t,["audioTimestamp"],r);const s=w(e,["candidateCount"]);s!=null&&b(t,["candidateCount"],s);const a=w(e,["enableAffectiveDialog"]);a!=null&&b(t,["enableAffectiveDialog"],a);const o=w(e,["frequencyPenalty"]);o!=null&&b(t,["frequencyPenalty"],o);const l=w(e,["logprobs"]);l!=null&&b(t,["logprobs"],l);const u=w(e,["maxOutputTokens"]);u!=null&&b(t,["maxOutputTokens"],u);const c=w(e,["mediaResolution"]);c!=null&&b(t,["mediaResolution"],c);const f=w(e,["presencePenalty"]);f!=null&&b(t,["presencePenalty"],f);const d=w(e,["responseLogprobs"]);d!=null&&b(t,["responseLogprobs"],d);const h=w(e,["responseMimeType"]);h!=null&&b(t,["responseMimeType"],h);const m=w(e,["responseModalities"]);m!=null&&b(t,["responseModalities"],m);const y=w(e,["responseSchema"]);y!=null&&b(t,["responseSchema"],y);const M=w(e,["routingConfig"]);M!=null&&b(t,["routingConfig"],M);const g=w(e,["seed"]);g!=null&&b(t,["seed"],g);const _=w(e,["speechConfig"]);_!=null&&b(t,["speechConfig"],_);const T=w(e,["stopSequences"]);T!=null&&b(t,["stopSequences"],T);const x=w(e,["temperature"]);x!=null&&b(t,["temperature"],x);const S=w(e,["thinkingConfig"]);S!=null&&b(t,["thinkingConfig"],S);const $=w(e,["topK"]);$!=null&&b(t,["topK"],$);const C=w(e,["topP"]);if(C!=null&&b(t,["topP"],C),w(e,["enableEnhancedCivicAnswers"])!==void 0)throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");return t}function qY(e){const t={};if(w(e,["authConfig"])!==void 0)throw new Error("authConfig parameter is not supported in Gemini API.");const n=w(e,["enableWidget"]);return n!=null&&b(t,["enableWidget"],n),t}function KY(e){const t={};if(w(e,["excludeDomains"])!==void 0)throw new Error("excludeDomains parameter is not supported in Gemini API.");if(w(e,["blockingConfidence"])!==void 0)throw new Error("blockingConfidence parameter is not supported in Gemini API.");const n=w(e,["timeRangeFilter"]);return n!=null&&b(t,["timeRangeFilter"],n),t}function JY(e,t){const n={},i=w(e,["generationConfig"]);t!==void 0&&i!=null&&b(t,["setup","generationConfig"],i);const r=w(e,["responseModalities"]);t!==void 0&&r!=null&&b(t,["setup","generationConfig","responseModalities"],r);const s=w(e,["temperature"]);t!==void 0&&s!=null&&b(t,["setup","generationConfig","temperature"],s);const a=w(e,["topP"]);t!==void 0&&a!=null&&b(t,["setup","generationConfig","topP"],a);const o=w(e,["topK"]);t!==void 0&&o!=null&&b(t,["setup","generationConfig","topK"],o);const l=w(e,["maxOutputTokens"]);t!==void 0&&l!=null&&b(t,["setup","generationConfig","maxOutputTokens"],l);const u=w(e,["mediaResolution"]);t!==void 0&&u!=null&&b(t,["setup","generationConfig","mediaResolution"],u);const c=w(e,["seed"]);t!==void 0&&c!=null&&b(t,["setup","generationConfig","seed"],c);const f=w(e,["speechConfig"]);t!==void 0&&f!=null&&b(t,["setup","generationConfig","speechConfig"],kx(f));const d=w(e,["thinkingConfig"]);t!==void 0&&d!=null&&b(t,["setup","generationConfig","thinkingConfig"],d);const h=w(e,["enableAffectiveDialog"]);t!==void 0&&h!=null&&b(t,["setup","generationConfig","enableAffectiveDialog"],h);const m=w(e,["systemInstruction"]);t!==void 0&&m!=null&&b(t,["setup","systemInstruction"],VY(zr(m)));const y=w(e,["tools"]);if(t!==void 0&&y!=null){let $=Fd(y);Array.isArray($)&&($=$.map(C=>aX(zd(C)))),b(t,["setup","tools"],$)}const M=w(e,["sessionResumption"]);t!==void 0&&M!=null&&b(t,["setup","sessionResumption"],sX(M));const g=w(e,["inputAudioTranscription"]);t!==void 0&&g!=null&&b(t,["setup","inputAudioTranscription"],g);const _=w(e,["outputAudioTranscription"]);t!==void 0&&_!=null&&b(t,["setup","outputAudioTranscription"],_);const T=w(e,["realtimeInputConfig"]);t!==void 0&&T!=null&&b(t,["setup","realtimeInputConfig"],T);const x=w(e,["contextWindowCompression"]);t!==void 0&&x!=null&&b(t,["setup","contextWindowCompression"],x);const S=w(e,["proactivity"]);if(t!==void 0&&S!=null&&b(t,["setup","proactivity"],S),w(e,["explicitVadSignal"])!==void 0)throw new Error("explicitVadSignal parameter is not supported in Gemini API.");return n}function YY(e,t){const n={},i=w(e,["generationConfig"]);t!==void 0&&i!=null&&b(t,["setup","generationConfig"],HY(i));const r=w(e,["responseModalities"]);t!==void 0&&r!=null&&b(t,["setup","generationConfig","responseModalities"],r);const s=w(e,["temperature"]);t!==void 0&&s!=null&&b(t,["setup","generationConfig","temperature"],s);const a=w(e,["topP"]);t!==void 0&&a!=null&&b(t,["setup","generationConfig","topP"],a);const o=w(e,["topK"]);t!==void 0&&o!=null&&b(t,["setup","generationConfig","topK"],o);const l=w(e,["maxOutputTokens"]);t!==void 0&&l!=null&&b(t,["setup","generationConfig","maxOutputTokens"],l);const u=w(e,["mediaResolution"]);t!==void 0&&u!=null&&b(t,["setup","generationConfig","mediaResolution"],u);const c=w(e,["seed"]);t!==void 0&&c!=null&&b(t,["setup","generationConfig","seed"],c);const f=w(e,["speechConfig"]);t!==void 0&&f!=null&&b(t,["setup","generationConfig","speechConfig"],kx(f));const d=w(e,["thinkingConfig"]);t!==void 0&&d!=null&&b(t,["setup","generationConfig","thinkingConfig"],d);const h=w(e,["enableAffectiveDialog"]);t!==void 0&&h!=null&&b(t,["setup","generationConfig","enableAffectiveDialog"],h);const m=w(e,["systemInstruction"]);t!==void 0&&m!=null&&b(t,["setup","systemInstruction"],zr(m));const y=w(e,["tools"]);if(t!==void 0&&y!=null){let C=Fd(y);Array.isArray(C)&&(C=C.map(P=>oX(zd(P)))),b(t,["setup","tools"],C)}const M=w(e,["sessionResumption"]);t!==void 0&&M!=null&&b(t,["setup","sessionResumption"],M);const g=w(e,["inputAudioTranscription"]);t!==void 0&&g!=null&&b(t,["setup","inputAudioTranscription"],g);const _=w(e,["outputAudioTranscription"]);t!==void 0&&_!=null&&b(t,["setup","outputAudioTranscription"],_);const T=w(e,["realtimeInputConfig"]);t!==void 0&&T!=null&&b(t,["setup","realtimeInputConfig"],T);const x=w(e,["contextWindowCompression"]);t!==void 0&&x!=null&&b(t,["setup","contextWindowCompression"],x);const S=w(e,["proactivity"]);t!==void 0&&S!=null&&b(t,["setup","proactivity"],S);const $=w(e,["explicitVadSignal"]);return t!==void 0&&$!=null&&b(t,["setup","explicitVadSignal"],$),n}function XY(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["setup","model"],ti(e,i));const r=w(t,["config"]);return r!=null&&b(n,["config"],JY(r,n)),n}function QY(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["setup","model"],ti(e,i));const r=w(t,["config"]);return r!=null&&b(n,["config"],YY(r,n)),n}function ZY(e){const t={},n=w(e,["musicGenerationConfig"]);return n!=null&&b(t,["musicGenerationConfig"],n),t}function eX(e){const t={},n=w(e,["weightedPrompts"]);if(n!=null){let i=n;Array.isArray(i)&&(i=i.map(r=>r)),b(t,["weightedPrompts"],i)}return t}function tX(e){const t={},n=w(e,["media"]);if(n!=null){let u=L4(n);Array.isArray(u)&&(u=u.map(c=>bm(c))),b(t,["mediaChunks"],u)}const i=w(e,["audio"]);i!=null&&b(t,["audio"],bm(F4(i)));const r=w(e,["audioStreamEnd"]);r!=null&&b(t,["audioStreamEnd"],r);const s=w(e,["video"]);s!=null&&b(t,["video"],bm(z4(s)));const a=w(e,["text"]);a!=null&&b(t,["text"],a);const o=w(e,["activityStart"]);o!=null&&b(t,["activityStart"],o);const l=w(e,["activityEnd"]);return l!=null&&b(t,["activityEnd"],l),t}function nX(e){const t={},n=w(e,["media"]);if(n!=null){let u=L4(n);Array.isArray(u)&&(u=u.map(c=>c)),b(t,["mediaChunks"],u)}const i=w(e,["audio"]);i!=null&&b(t,["audio"],F4(i));const r=w(e,["audioStreamEnd"]);r!=null&&b(t,["audioStreamEnd"],r);const s=w(e,["video"]);s!=null&&b(t,["video"],z4(s));const a=w(e,["text"]);a!=null&&b(t,["text"],a);const o=w(e,["activityStart"]);o!=null&&b(t,["activityStart"],o);const l=w(e,["activityEnd"]);return l!=null&&b(t,["activityEnd"],l),t}function iX(e){const t={},n=w(e,["setupComplete"]);n!=null&&b(t,["setupComplete"],n);const i=w(e,["serverContent"]);i!=null&&b(t,["serverContent"],i);const r=w(e,["toolCall"]);r!=null&&b(t,["toolCall"],r);const s=w(e,["toolCallCancellation"]);s!=null&&b(t,["toolCallCancellation"],s);const a=w(e,["usageMetadata"]);a!=null&&b(t,["usageMetadata"],lX(a));const o=w(e,["goAway"]);o!=null&&b(t,["goAway"],o);const l=w(e,["sessionResumptionUpdate"]);l!=null&&b(t,["sessionResumptionUpdate"],l);const u=w(e,["voiceActivityDetectionSignal"]);return u!=null&&b(t,["voiceActivityDetectionSignal"],u),t}function rX(e){const t={},n=w(e,["mediaResolution"]);n!=null&&b(t,["mediaResolution"],n);const i=w(e,["codeExecutionResult"]);i!=null&&b(t,["codeExecutionResult"],i);const r=w(e,["executableCode"]);r!=null&&b(t,["executableCode"],r);const s=w(e,["fileData"]);s!=null&&b(t,["fileData"],GY(s));const a=w(e,["functionCall"]);a!=null&&b(t,["functionCall"],jY(a));const o=w(e,["functionResponse"]);o!=null&&b(t,["functionResponse"],o);const l=w(e,["inlineData"]);l!=null&&b(t,["inlineData"],bm(l));const u=w(e,["text"]);u!=null&&b(t,["text"],u);const c=w(e,["thought"]);c!=null&&b(t,["thought"],c);const f=w(e,["thoughtSignature"]);f!=null&&b(t,["thoughtSignature"],f);const d=w(e,["videoMetadata"]);return d!=null&&b(t,["videoMetadata"],d),t}function sX(e){const t={},n=w(e,["handle"]);if(n!=null&&b(t,["handle"],n),w(e,["transparent"])!==void 0)throw new Error("transparent parameter is not supported in Gemini API.");return t}function aX(e){const t={},n=w(e,["functionDeclarations"]);if(n!=null){let c=n;Array.isArray(c)&&(c=c.map(f=>f)),b(t,["functionDeclarations"],c)}if(w(e,["retrieval"])!==void 0)throw new Error("retrieval parameter is not supported in Gemini API.");const i=w(e,["googleSearchRetrieval"]);i!=null&&b(t,["googleSearchRetrieval"],i);const r=w(e,["computerUse"]);r!=null&&b(t,["computerUse"],r);const s=w(e,["fileSearch"]);s!=null&&b(t,["fileSearch"],s);const a=w(e,["codeExecution"]);if(a!=null&&b(t,["codeExecution"],a),w(e,["enterpriseWebSearch"])!==void 0)throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");const o=w(e,["googleMaps"]);o!=null&&b(t,["googleMaps"],qY(o));const l=w(e,["googleSearch"]);l!=null&&b(t,["googleSearch"],KY(l));const u=w(e,["urlContext"]);return u!=null&&b(t,["urlContext"],u),t}function oX(e){const t={},n=w(e,["functionDeclarations"]);if(n!=null){let f=n;Array.isArray(f)&&(f=f.map(d=>WY(d))),b(t,["functionDeclarations"],f)}const i=w(e,["retrieval"]);i!=null&&b(t,["retrieval"],i);const r=w(e,["googleSearchRetrieval"]);r!=null&&b(t,["googleSearchRetrieval"],r);const s=w(e,["computerUse"]);if(s!=null&&b(t,["computerUse"],s),w(e,["fileSearch"])!==void 0)throw new Error("fileSearch parameter is not supported in Vertex AI.");const a=w(e,["codeExecution"]);a!=null&&b(t,["codeExecution"],a);const o=w(e,["enterpriseWebSearch"]);o!=null&&b(t,["enterpriseWebSearch"],o);const l=w(e,["googleMaps"]);l!=null&&b(t,["googleMaps"],l);const u=w(e,["googleSearch"]);u!=null&&b(t,["googleSearch"],u);const c=w(e,["urlContext"]);return c!=null&&b(t,["urlContext"],c),t}function lX(e){const t={},n=w(e,["promptTokenCount"]);n!=null&&b(t,["promptTokenCount"],n);const i=w(e,["cachedContentTokenCount"]);i!=null&&b(t,["cachedContentTokenCount"],i);const r=w(e,["candidatesTokenCount"]);r!=null&&b(t,["responseTokenCount"],r);const s=w(e,["toolUsePromptTokenCount"]);s!=null&&b(t,["toolUsePromptTokenCount"],s);const a=w(e,["thoughtsTokenCount"]);a!=null&&b(t,["thoughtsTokenCount"],a);const o=w(e,["totalTokenCount"]);o!=null&&b(t,["totalTokenCount"],o);const l=w(e,["promptTokensDetails"]);if(l!=null){let h=l;Array.isArray(h)&&(h=h.map(m=>m)),b(t,["promptTokensDetails"],h)}const u=w(e,["cacheTokensDetails"]);if(u!=null){let h=u;Array.isArray(h)&&(h=h.map(m=>m)),b(t,["cacheTokensDetails"],h)}const c=w(e,["candidatesTokensDetails"]);if(c!=null){let h=c;Array.isArray(h)&&(h=h.map(m=>m)),b(t,["responseTokensDetails"],h)}const f=w(e,["toolUsePromptTokensDetails"]);if(f!=null){let h=f;Array.isArray(h)&&(h=h.map(m=>m)),b(t,["toolUsePromptTokensDetails"],h)}const d=w(e,["trafficType"]);return d!=null&&b(t,["trafficType"],d),t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function uX(e){const t={},n=w(e,["data"]);if(n!=null&&b(t,["data"],n),w(e,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function cX(e){const t={},n=w(e,["content"]);n!=null&&b(t,["content"],n);const i=w(e,["citationMetadata"]);i!=null&&b(t,["citationMetadata"],dX(i));const r=w(e,["tokenCount"]);r!=null&&b(t,["tokenCount"],r);const s=w(e,["finishReason"]);s!=null&&b(t,["finishReason"],s);const a=w(e,["avgLogprobs"]);a!=null&&b(t,["avgLogprobs"],a);const o=w(e,["groundingMetadata"]);o!=null&&b(t,["groundingMetadata"],o);const l=w(e,["index"]);l!=null&&b(t,["index"],l);const u=w(e,["logprobsResult"]);u!=null&&b(t,["logprobsResult"],u);const c=w(e,["safetyRatings"]);if(c!=null){let d=c;Array.isArray(d)&&(d=d.map(h=>h)),b(t,["safetyRatings"],d)}const f=w(e,["urlContextMetadata"]);return f!=null&&b(t,["urlContextMetadata"],f),t}function dX(e){const t={},n=w(e,["citationSources"]);if(n!=null){let i=n;Array.isArray(i)&&(i=i.map(r=>r)),b(t,["citations"],i)}return t}function fX(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["contents"]);if(r!=null){let s=Xs(r);Array.isArray(s)&&(s=s.map(a=>a)),b(n,["contents"],s)}return n}function pX(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["tokensInfo"]);if(i!=null){let r=i;Array.isArray(r)&&(r=r.map(s=>s)),b(t,["tokensInfo"],r)}return t}function hX(e){const t={},n=w(e,["values"]);n!=null&&b(t,["values"],n);const i=w(e,["statistics"]);return i!=null&&b(t,["statistics"],mX(i)),t}function mX(e){const t={},n=w(e,["truncated"]);n!=null&&b(t,["truncated"],n);const i=w(e,["token_count"]);return i!=null&&b(t,["tokenCount"],i),t}function Qg(e){const t={},n=w(e,["parts"]);if(n!=null){let r=n;Array.isArray(r)&&(r=r.map(s=>MQ(s))),b(t,["parts"],r)}const i=w(e,["role"]);return i!=null&&b(t,["role"],i),t}function gX(e){const t={},n=w(e,["controlType"]);n!=null&&b(t,["controlType"],n);const i=w(e,["enableControlImageComputation"]);return i!=null&&b(t,["computeControl"],i),t}function _X(e){const t={};if(w(e,["systemInstruction"])!==void 0)throw new Error("systemInstruction parameter is not supported in Gemini API.");if(w(e,["tools"])!==void 0)throw new Error("tools parameter is not supported in Gemini API.");if(w(e,["generationConfig"])!==void 0)throw new Error("generationConfig parameter is not supported in Gemini API.");return t}function yX(e,t){const n={},i=w(e,["systemInstruction"]);t!==void 0&&i!=null&&b(t,["systemInstruction"],zr(i));const r=w(e,["tools"]);if(t!==void 0&&r!=null){let a=r;Array.isArray(a)&&(a=a.map(o=>Z4(o))),b(t,["tools"],a)}const s=w(e,["generationConfig"]);return t!==void 0&&s!=null&&b(t,["generationConfig"],uQ(s)),n}function vX(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["contents"]);if(r!=null){let a=Xs(r);Array.isArray(a)&&(a=a.map(o=>Qg(o))),b(n,["contents"],a)}const s=w(t,["config"]);return s!=null&&_X(s),n}function wX(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["contents"]);if(r!=null){let a=Xs(r);Array.isArray(a)&&(a=a.map(o=>o)),b(n,["contents"],a)}const s=w(t,["config"]);return s!=null&&yX(s,n),n}function bX(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["totalTokens"]);i!=null&&b(t,["totalTokens"],i);const r=w(e,["cachedContentTokenCount"]);return r!=null&&b(t,["cachedContentTokenCount"],r),t}function xX(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["totalTokens"]);return i!=null&&b(t,["totalTokens"],i),t}function TX(e,t){const n={},i=w(t,["model"]);return i!=null&&b(n,["_url","name"],ti(e,i)),n}function MX(e,t){const n={},i=w(t,["model"]);return i!=null&&b(n,["_url","name"],ti(e,i)),n}function EX(e){const t={},n=w(e,["sdkHttpResponse"]);return n!=null&&b(t,["sdkHttpResponse"],n),t}function SX(e){const t={},n=w(e,["sdkHttpResponse"]);return n!=null&&b(t,["sdkHttpResponse"],n),t}function CX(e,t){const n={},i=w(e,["outputGcsUri"]);t!==void 0&&i!=null&&b(t,["parameters","storageUri"],i);const r=w(e,["negativePrompt"]);t!==void 0&&r!=null&&b(t,["parameters","negativePrompt"],r);const s=w(e,["numberOfImages"]);t!==void 0&&s!=null&&b(t,["parameters","sampleCount"],s);const a=w(e,["aspectRatio"]);t!==void 0&&a!=null&&b(t,["parameters","aspectRatio"],a);const o=w(e,["guidanceScale"]);t!==void 0&&o!=null&&b(t,["parameters","guidanceScale"],o);const l=w(e,["seed"]);t!==void 0&&l!=null&&b(t,["parameters","seed"],l);const u=w(e,["safetyFilterLevel"]);t!==void 0&&u!=null&&b(t,["parameters","safetySetting"],u);const c=w(e,["personGeneration"]);t!==void 0&&c!=null&&b(t,["parameters","personGeneration"],c);const f=w(e,["includeSafetyAttributes"]);t!==void 0&&f!=null&&b(t,["parameters","includeSafetyAttributes"],f);const d=w(e,["includeRaiReason"]);t!==void 0&&d!=null&&b(t,["parameters","includeRaiReason"],d);const h=w(e,["language"]);t!==void 0&&h!=null&&b(t,["parameters","language"],h);const m=w(e,["outputMimeType"]);t!==void 0&&m!=null&&b(t,["parameters","outputOptions","mimeType"],m);const y=w(e,["outputCompressionQuality"]);t!==void 0&&y!=null&&b(t,["parameters","outputOptions","compressionQuality"],y);const M=w(e,["addWatermark"]);t!==void 0&&M!=null&&b(t,["parameters","addWatermark"],M);const g=w(e,["labels"]);t!==void 0&&g!=null&&b(t,["labels"],g);const _=w(e,["editMode"]);t!==void 0&&_!=null&&b(t,["parameters","editMode"],_);const T=w(e,["baseSteps"]);return t!==void 0&&T!=null&&b(t,["parameters","editConfig","baseSteps"],T),n}function $X(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["prompt"]);r!=null&&b(n,["instances[0]","prompt"],r);const s=w(t,["referenceImages"]);if(s!=null){let o=s;Array.isArray(o)&&(o=o.map(l=>IQ(l))),b(n,["instances[0]","referenceImages"],o)}const a=w(t,["config"]);return a!=null&&CX(a,n),n}function AX(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["predictions"]);if(i!=null){let r=i;Array.isArray(r)&&(r=r.map(s=>Zg(s))),b(t,["generatedImages"],r)}return t}function IX(e,t){const n={},i=w(e,["taskType"]);t!==void 0&&i!=null&&b(t,["requests[]","taskType"],i);const r=w(e,["title"]);t!==void 0&&r!=null&&b(t,["requests[]","title"],r);const s=w(e,["outputDimensionality"]);if(t!==void 0&&s!=null&&b(t,["requests[]","outputDimensionality"],s),w(e,["mimeType"])!==void 0)throw new Error("mimeType parameter is not supported in Gemini API.");if(w(e,["autoTruncate"])!==void 0)throw new Error("autoTruncate parameter is not supported in Gemini API.");return n}function PX(e,t){const n={},i=w(e,["taskType"]);t!==void 0&&i!=null&&b(t,["instances[]","task_type"],i);const r=w(e,["title"]);t!==void 0&&r!=null&&b(t,["instances[]","title"],r);const s=w(e,["outputDimensionality"]);t!==void 0&&s!=null&&b(t,["parameters","outputDimensionality"],s);const a=w(e,["mimeType"]);t!==void 0&&a!=null&&b(t,["instances[]","mimeType"],a);const o=w(e,["autoTruncate"]);return t!==void 0&&o!=null&&b(t,["parameters","autoTruncate"],o),n}function kX(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["contents"]);if(r!=null){let o=Ax(e,r);Array.isArray(o)&&(o=o.map(l=>l)),b(n,["requests[]","content"],o)}const s=w(t,["config"]);s!=null&&IX(s,n);const a=w(t,["model"]);return a!==void 0&&b(n,["requests[]","model"],ti(e,a)),n}function DX(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["contents"]);if(r!=null){let a=Ax(e,r);Array.isArray(a)&&(a=a.map(o=>o)),b(n,["instances[]","content"],a)}const s=w(t,["config"]);return s!=null&&PX(s,n),n}function OX(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["embeddings"]);if(i!=null){let s=i;Array.isArray(s)&&(s=s.map(a=>a)),b(t,["embeddings"],s)}const r=w(e,["metadata"]);return r!=null&&b(t,["metadata"],r),t}function RX(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["predictions[]","embeddings"]);if(i!=null){let s=i;Array.isArray(s)&&(s=s.map(a=>hX(a))),b(t,["embeddings"],s)}const r=w(e,["metadata"]);return r!=null&&b(t,["metadata"],r),t}function NX(e){const t={},n=w(e,["endpoint"]);n!=null&&b(t,["name"],n);const i=w(e,["deployedModelId"]);return i!=null&&b(t,["deployedModelId"],i),t}function LX(e){const t={};if(w(e,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const n=w(e,["fileUri"]);n!=null&&b(t,["fileUri"],n);const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function zX(e){const t={},n=w(e,["id"]);n!=null&&b(t,["id"],n);const i=w(e,["args"]);i!=null&&b(t,["args"],i);const r=w(e,["name"]);if(r!=null&&b(t,["name"],r),w(e,["partialArgs"])!==void 0)throw new Error("partialArgs parameter is not supported in Gemini API.");if(w(e,["willContinue"])!==void 0)throw new Error("willContinue parameter is not supported in Gemini API.");return t}function FX(e){const t={},n=w(e,["mode"]);n!=null&&b(t,["mode"],n);const i=w(e,["allowedFunctionNames"]);if(i!=null&&b(t,["allowedFunctionNames"],i),w(e,["streamFunctionCallArguments"])!==void 0)throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");return t}function BX(e){const t={};if(w(e,["behavior"])!==void 0)throw new Error("behavior parameter is not supported in Vertex AI.");const n=w(e,["description"]);n!=null&&b(t,["description"],n);const i=w(e,["name"]);i!=null&&b(t,["name"],i);const r=w(e,["parameters"]);r!=null&&b(t,["parameters"],r);const s=w(e,["parametersJsonSchema"]);s!=null&&b(t,["parametersJsonSchema"],s);const a=w(e,["response"]);a!=null&&b(t,["response"],a);const o=w(e,["responseJsonSchema"]);return o!=null&&b(t,["responseJsonSchema"],o),t}function UX(e,t,n){const i={},r=w(t,["systemInstruction"]);n!==void 0&&r!=null&&b(n,["systemInstruction"],Qg(zr(r)));const s=w(t,["temperature"]);s!=null&&b(i,["temperature"],s);const a=w(t,["topP"]);a!=null&&b(i,["topP"],a);const o=w(t,["topK"]);o!=null&&b(i,["topK"],o);const l=w(t,["candidateCount"]);l!=null&&b(i,["candidateCount"],l);const u=w(t,["maxOutputTokens"]);u!=null&&b(i,["maxOutputTokens"],u);const c=w(t,["stopSequences"]);c!=null&&b(i,["stopSequences"],c);const f=w(t,["responseLogprobs"]);f!=null&&b(i,["responseLogprobs"],f);const d=w(t,["logprobs"]);d!=null&&b(i,["logprobs"],d);const h=w(t,["presencePenalty"]);h!=null&&b(i,["presencePenalty"],h);const m=w(t,["frequencyPenalty"]);m!=null&&b(i,["frequencyPenalty"],m);const y=w(t,["seed"]);y!=null&&b(i,["seed"],y);const M=w(t,["responseMimeType"]);M!=null&&b(i,["responseMimeType"],M);const g=w(t,["responseSchema"]);g!=null&&b(i,["responseSchema"],Ix(g));const _=w(t,["responseJsonSchema"]);if(_!=null&&b(i,["responseJsonSchema"],_),w(t,["routingConfig"])!==void 0)throw new Error("routingConfig parameter is not supported in Gemini API.");if(w(t,["modelSelectionConfig"])!==void 0)throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");const T=w(t,["safetySettings"]);if(n!==void 0&&T!=null){let V=T;Array.isArray(V)&&(V=V.map(te=>PQ(te))),b(n,["safetySettings"],V)}const x=w(t,["tools"]);if(n!==void 0&&x!=null){let V=Fd(x);Array.isArray(V)&&(V=V.map(te=>zQ(zd(te)))),b(n,["tools"],V)}const S=w(t,["toolConfig"]);if(n!==void 0&&S!=null&&b(n,["toolConfig"],LQ(S)),w(t,["labels"])!==void 0)throw new Error("labels parameter is not supported in Gemini API.");const $=w(t,["cachedContent"]);n!==void 0&&$!=null&&b(n,["cachedContent"],Uo(e,$));const C=w(t,["responseModalities"]);C!=null&&b(i,["responseModalities"],C);const P=w(t,["mediaResolution"]);P!=null&&b(i,["mediaResolution"],P);const O=w(t,["speechConfig"]);if(O!=null&&b(i,["speechConfig"],Px(O)),w(t,["audioTimestamp"])!==void 0)throw new Error("audioTimestamp parameter is not supported in Gemini API.");const R=w(t,["thinkingConfig"]);R!=null&&b(i,["thinkingConfig"],R);const G=w(t,["imageConfig"]);G!=null&&b(i,["imageConfig"],hQ(G));const W=w(t,["enableEnhancedCivicAnswers"]);return W!=null&&b(i,["enableEnhancedCivicAnswers"],W),i}function VX(e,t,n){const i={},r=w(t,["systemInstruction"]);n!==void 0&&r!=null&&b(n,["systemInstruction"],zr(r));const s=w(t,["temperature"]);s!=null&&b(i,["temperature"],s);const a=w(t,["topP"]);a!=null&&b(i,["topP"],a);const o=w(t,["topK"]);o!=null&&b(i,["topK"],o);const l=w(t,["candidateCount"]);l!=null&&b(i,["candidateCount"],l);const u=w(t,["maxOutputTokens"]);u!=null&&b(i,["maxOutputTokens"],u);const c=w(t,["stopSequences"]);c!=null&&b(i,["stopSequences"],c);const f=w(t,["responseLogprobs"]);f!=null&&b(i,["responseLogprobs"],f);const d=w(t,["logprobs"]);d!=null&&b(i,["logprobs"],d);const h=w(t,["presencePenalty"]);h!=null&&b(i,["presencePenalty"],h);const m=w(t,["frequencyPenalty"]);m!=null&&b(i,["frequencyPenalty"],m);const y=w(t,["seed"]);y!=null&&b(i,["seed"],y);const M=w(t,["responseMimeType"]);M!=null&&b(i,["responseMimeType"],M);const g=w(t,["responseSchema"]);g!=null&&b(i,["responseSchema"],Ix(g));const _=w(t,["responseJsonSchema"]);_!=null&&b(i,["responseJsonSchema"],_);const T=w(t,["routingConfig"]);T!=null&&b(i,["routingConfig"],T);const x=w(t,["modelSelectionConfig"]);x!=null&&b(i,["modelConfig"],x);const S=w(t,["safetySettings"]);if(n!==void 0&&S!=null){let j=S;Array.isArray(j)&&(j=j.map(Y=>Y)),b(n,["safetySettings"],j)}const $=w(t,["tools"]);if(n!==void 0&&$!=null){let j=Fd($);Array.isArray(j)&&(j=j.map(Y=>Z4(zd(Y)))),b(n,["tools"],j)}const C=w(t,["toolConfig"]);n!==void 0&&C!=null&&b(n,["toolConfig"],C);const P=w(t,["labels"]);n!==void 0&&P!=null&&b(n,["labels"],P);const O=w(t,["cachedContent"]);n!==void 0&&O!=null&&b(n,["cachedContent"],Uo(e,O));const R=w(t,["responseModalities"]);R!=null&&b(i,["responseModalities"],R);const G=w(t,["mediaResolution"]);G!=null&&b(i,["mediaResolution"],G);const W=w(t,["speechConfig"]);W!=null&&b(i,["speechConfig"],Px(W));const V=w(t,["audioTimestamp"]);V!=null&&b(i,["audioTimestamp"],V);const te=w(t,["thinkingConfig"]);te!=null&&b(i,["thinkingConfig"],te);const J=w(t,["imageConfig"]);if(J!=null&&b(i,["imageConfig"],mQ(J)),w(t,["enableEnhancedCivicAnswers"])!==void 0)throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");return i}function bP(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["contents"]);if(r!=null){let a=Xs(r);Array.isArray(a)&&(a=a.map(o=>Qg(o))),b(n,["contents"],a)}const s=w(t,["config"]);return s!=null&&b(n,["generationConfig"],UX(e,s,n)),n}function xP(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["contents"]);if(r!=null){let a=Xs(r);Array.isArray(a)&&(a=a.map(o=>o)),b(n,["contents"],a)}const s=w(t,["config"]);return s!=null&&b(n,["generationConfig"],VX(e,s,n)),n}function TP(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["candidates"]);if(i!=null){let l=i;Array.isArray(l)&&(l=l.map(u=>cX(u))),b(t,["candidates"],l)}const r=w(e,["modelVersion"]);r!=null&&b(t,["modelVersion"],r);const s=w(e,["promptFeedback"]);s!=null&&b(t,["promptFeedback"],s);const a=w(e,["responseId"]);a!=null&&b(t,["responseId"],a);const o=w(e,["usageMetadata"]);return o!=null&&b(t,["usageMetadata"],o),t}function MP(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["candidates"]);if(i!=null){let u=i;Array.isArray(u)&&(u=u.map(c=>c)),b(t,["candidates"],u)}const r=w(e,["createTime"]);r!=null&&b(t,["createTime"],r);const s=w(e,["modelVersion"]);s!=null&&b(t,["modelVersion"],s);const a=w(e,["promptFeedback"]);a!=null&&b(t,["promptFeedback"],a);const o=w(e,["responseId"]);o!=null&&b(t,["responseId"],o);const l=w(e,["usageMetadata"]);return l!=null&&b(t,["usageMetadata"],l),t}function GX(e,t){const n={};if(w(e,["outputGcsUri"])!==void 0)throw new Error("outputGcsUri parameter is not supported in Gemini API.");if(w(e,["negativePrompt"])!==void 0)throw new Error("negativePrompt parameter is not supported in Gemini API.");const i=w(e,["numberOfImages"]);t!==void 0&&i!=null&&b(t,["parameters","sampleCount"],i);const r=w(e,["aspectRatio"]);t!==void 0&&r!=null&&b(t,["parameters","aspectRatio"],r);const s=w(e,["guidanceScale"]);if(t!==void 0&&s!=null&&b(t,["parameters","guidanceScale"],s),w(e,["seed"])!==void 0)throw new Error("seed parameter is not supported in Gemini API.");const a=w(e,["safetyFilterLevel"]);t!==void 0&&a!=null&&b(t,["parameters","safetySetting"],a);const o=w(e,["personGeneration"]);t!==void 0&&o!=null&&b(t,["parameters","personGeneration"],o);const l=w(e,["includeSafetyAttributes"]);t!==void 0&&l!=null&&b(t,["parameters","includeSafetyAttributes"],l);const u=w(e,["includeRaiReason"]);t!==void 0&&u!=null&&b(t,["parameters","includeRaiReason"],u);const c=w(e,["language"]);t!==void 0&&c!=null&&b(t,["parameters","language"],c);const f=w(e,["outputMimeType"]);t!==void 0&&f!=null&&b(t,["parameters","outputOptions","mimeType"],f);const d=w(e,["outputCompressionQuality"]);if(t!==void 0&&d!=null&&b(t,["parameters","outputOptions","compressionQuality"],d),w(e,["addWatermark"])!==void 0)throw new Error("addWatermark parameter is not supported in Gemini API.");if(w(e,["labels"])!==void 0)throw new Error("labels parameter is not supported in Gemini API.");const h=w(e,["imageSize"]);if(t!==void 0&&h!=null&&b(t,["parameters","sampleImageSize"],h),w(e,["enhancePrompt"])!==void 0)throw new Error("enhancePrompt parameter is not supported in Gemini API.");return n}function jX(e,t){const n={},i=w(e,["outputGcsUri"]);t!==void 0&&i!=null&&b(t,["parameters","storageUri"],i);const r=w(e,["negativePrompt"]);t!==void 0&&r!=null&&b(t,["parameters","negativePrompt"],r);const s=w(e,["numberOfImages"]);t!==void 0&&s!=null&&b(t,["parameters","sampleCount"],s);const a=w(e,["aspectRatio"]);t!==void 0&&a!=null&&b(t,["parameters","aspectRatio"],a);const o=w(e,["guidanceScale"]);t!==void 0&&o!=null&&b(t,["parameters","guidanceScale"],o);const l=w(e,["seed"]);t!==void 0&&l!=null&&b(t,["parameters","seed"],l);const u=w(e,["safetyFilterLevel"]);t!==void 0&&u!=null&&b(t,["parameters","safetySetting"],u);const c=w(e,["personGeneration"]);t!==void 0&&c!=null&&b(t,["parameters","personGeneration"],c);const f=w(e,["includeSafetyAttributes"]);t!==void 0&&f!=null&&b(t,["parameters","includeSafetyAttributes"],f);const d=w(e,["includeRaiReason"]);t!==void 0&&d!=null&&b(t,["parameters","includeRaiReason"],d);const h=w(e,["language"]);t!==void 0&&h!=null&&b(t,["parameters","language"],h);const m=w(e,["outputMimeType"]);t!==void 0&&m!=null&&b(t,["parameters","outputOptions","mimeType"],m);const y=w(e,["outputCompressionQuality"]);t!==void 0&&y!=null&&b(t,["parameters","outputOptions","compressionQuality"],y);const M=w(e,["addWatermark"]);t!==void 0&&M!=null&&b(t,["parameters","addWatermark"],M);const g=w(e,["labels"]);t!==void 0&&g!=null&&b(t,["labels"],g);const _=w(e,["imageSize"]);t!==void 0&&_!=null&&b(t,["parameters","sampleImageSize"],_);const T=w(e,["enhancePrompt"]);return t!==void 0&&T!=null&&b(t,["parameters","enhancePrompt"],T),n}function WX(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["prompt"]);r!=null&&b(n,["instances[0]","prompt"],r);const s=w(t,["config"]);return s!=null&&GX(s,n),n}function HX(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["prompt"]);r!=null&&b(n,["instances[0]","prompt"],r);const s=w(t,["config"]);return s!=null&&jX(s,n),n}function qX(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["predictions"]);if(i!=null){let s=i;Array.isArray(s)&&(s=s.map(a=>sQ(a))),b(t,["generatedImages"],s)}const r=w(e,["positivePromptSafetyAttributes"]);return r!=null&&b(t,["positivePromptSafetyAttributes"],X4(r)),t}function KX(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["predictions"]);if(i!=null){let s=i;Array.isArray(s)&&(s=s.map(a=>Zg(a))),b(t,["generatedImages"],s)}const r=w(e,["positivePromptSafetyAttributes"]);return r!=null&&b(t,["positivePromptSafetyAttributes"],Q4(r)),t}function JX(e,t){const n={},i=w(e,["numberOfVideos"]);if(t!==void 0&&i!=null&&b(t,["parameters","sampleCount"],i),w(e,["outputGcsUri"])!==void 0)throw new Error("outputGcsUri parameter is not supported in Gemini API.");if(w(e,["fps"])!==void 0)throw new Error("fps parameter is not supported in Gemini API.");const r=w(e,["durationSeconds"]);if(t!==void 0&&r!=null&&b(t,["parameters","durationSeconds"],r),w(e,["seed"])!==void 0)throw new Error("seed parameter is not supported in Gemini API.");const s=w(e,["aspectRatio"]);t!==void 0&&s!=null&&b(t,["parameters","aspectRatio"],s);const a=w(e,["resolution"]);t!==void 0&&a!=null&&b(t,["parameters","resolution"],a);const o=w(e,["personGeneration"]);if(t!==void 0&&o!=null&&b(t,["parameters","personGeneration"],o),w(e,["pubsubTopic"])!==void 0)throw new Error("pubsubTopic parameter is not supported in Gemini API.");const l=w(e,["negativePrompt"]);t!==void 0&&l!=null&&b(t,["parameters","negativePrompt"],l);const u=w(e,["enhancePrompt"]);if(t!==void 0&&u!=null&&b(t,["parameters","enhancePrompt"],u),w(e,["generateAudio"])!==void 0)throw new Error("generateAudio parameter is not supported in Gemini API.");const c=w(e,["lastFrame"]);t!==void 0&&c!=null&&b(t,["instances[0]","lastFrame"],e_(c));const f=w(e,["referenceImages"]);if(t!==void 0&&f!=null){let d=f;Array.isArray(d)&&(d=d.map(h=>XQ(h))),b(t,["instances[0]","referenceImages"],d)}if(w(e,["mask"])!==void 0)throw new Error("mask parameter is not supported in Gemini API.");if(w(e,["compressionQuality"])!==void 0)throw new Error("compressionQuality parameter is not supported in Gemini API.");return n}function YX(e,t){const n={},i=w(e,["numberOfVideos"]);t!==void 0&&i!=null&&b(t,["parameters","sampleCount"],i);const r=w(e,["outputGcsUri"]);t!==void 0&&r!=null&&b(t,["parameters","storageUri"],r);const s=w(e,["fps"]);t!==void 0&&s!=null&&b(t,["parameters","fps"],s);const a=w(e,["durationSeconds"]);t!==void 0&&a!=null&&b(t,["parameters","durationSeconds"],a);const o=w(e,["seed"]);t!==void 0&&o!=null&&b(t,["parameters","seed"],o);const l=w(e,["aspectRatio"]);t!==void 0&&l!=null&&b(t,["parameters","aspectRatio"],l);const u=w(e,["resolution"]);t!==void 0&&u!=null&&b(t,["parameters","resolution"],u);const c=w(e,["personGeneration"]);t!==void 0&&c!=null&&b(t,["parameters","personGeneration"],c);const f=w(e,["pubsubTopic"]);t!==void 0&&f!=null&&b(t,["parameters","pubsubTopic"],f);const d=w(e,["negativePrompt"]);t!==void 0&&d!=null&&b(t,["parameters","negativePrompt"],d);const h=w(e,["enhancePrompt"]);t!==void 0&&h!=null&&b(t,["parameters","enhancePrompt"],h);const m=w(e,["generateAudio"]);t!==void 0&&m!=null&&b(t,["parameters","generateAudio"],m);const y=w(e,["lastFrame"]);t!==void 0&&y!=null&&b(t,["instances[0]","lastFrame"],Da(y));const M=w(e,["referenceImages"]);if(t!==void 0&&M!=null){let T=M;Array.isArray(T)&&(T=T.map(x=>QQ(x))),b(t,["instances[0]","referenceImages"],T)}const g=w(e,["mask"]);t!==void 0&&g!=null&&b(t,["instances[0]","mask"],YQ(g));const _=w(e,["compressionQuality"]);return t!==void 0&&_!=null&&b(t,["parameters","compressionQuality"],_),n}function XX(e){const t={},n=w(e,["name"]);n!=null&&b(t,["name"],n);const i=w(e,["metadata"]);i!=null&&b(t,["metadata"],i);const r=w(e,["done"]);r!=null&&b(t,["done"],r);const s=w(e,["error"]);s!=null&&b(t,["error"],s);const a=w(e,["response","generateVideoResponse"]);return a!=null&&b(t,["response"],tQ(a)),t}function QX(e){const t={},n=w(e,["name"]);n!=null&&b(t,["name"],n);const i=w(e,["metadata"]);i!=null&&b(t,["metadata"],i);const r=w(e,["done"]);r!=null&&b(t,["done"],r);const s=w(e,["error"]);s!=null&&b(t,["error"],s);const a=w(e,["response"]);return a!=null&&b(t,["response"],nQ(a)),t}function ZX(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["prompt"]);r!=null&&b(n,["instances[0]","prompt"],r);const s=w(t,["image"]);s!=null&&b(n,["instances[0]","image"],e_(s));const a=w(t,["video"]);a!=null&&b(n,["instances[0]","video"],eU(a));const o=w(t,["source"]);o!=null&&iQ(o,n);const l=w(t,["config"]);return l!=null&&JX(l,n),n}function eQ(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["prompt"]);r!=null&&b(n,["instances[0]","prompt"],r);const s=w(t,["image"]);s!=null&&b(n,["instances[0]","image"],Da(s));const a=w(t,["video"]);a!=null&&b(n,["instances[0]","video"],tU(a));const o=w(t,["source"]);o!=null&&rQ(o,n);const l=w(t,["config"]);return l!=null&&YX(l,n),n}function tQ(e){const t={},n=w(e,["generatedSamples"]);if(n!=null){let s=n;Array.isArray(s)&&(s=s.map(a=>oQ(a))),b(t,["generatedVideos"],s)}const i=w(e,["raiMediaFilteredCount"]);i!=null&&b(t,["raiMediaFilteredCount"],i);const r=w(e,["raiMediaFilteredReasons"]);return r!=null&&b(t,["raiMediaFilteredReasons"],r),t}function nQ(e){const t={},n=w(e,["videos"]);if(n!=null){let s=n;Array.isArray(s)&&(s=s.map(a=>lQ(a))),b(t,["generatedVideos"],s)}const i=w(e,["raiMediaFilteredCount"]);i!=null&&b(t,["raiMediaFilteredCount"],i);const r=w(e,["raiMediaFilteredReasons"]);return r!=null&&b(t,["raiMediaFilteredReasons"],r),t}function iQ(e,t){const n={},i=w(e,["prompt"]);t!==void 0&&i!=null&&b(t,["instances[0]","prompt"],i);const r=w(e,["image"]);t!==void 0&&r!=null&&b(t,["instances[0]","image"],e_(r));const s=w(e,["video"]);return t!==void 0&&s!=null&&b(t,["instances[0]","video"],eU(s)),n}function rQ(e,t){const n={},i=w(e,["prompt"]);t!==void 0&&i!=null&&b(t,["instances[0]","prompt"],i);const r=w(e,["image"]);t!==void 0&&r!=null&&b(t,["instances[0]","image"],Da(r));const s=w(e,["video"]);return t!==void 0&&s!=null&&b(t,["instances[0]","video"],tU(s)),n}function sQ(e){const t={},n=w(e,["_self"]);n!=null&&b(t,["image"],gQ(n));const i=w(e,["raiFilteredReason"]);i!=null&&b(t,["raiFilteredReason"],i);const r=w(e,["_self"]);return r!=null&&b(t,["safetyAttributes"],X4(r)),t}function Zg(e){const t={},n=w(e,["_self"]);n!=null&&b(t,["image"],Y4(n));const i=w(e,["raiFilteredReason"]);i!=null&&b(t,["raiFilteredReason"],i);const r=w(e,["_self"]);r!=null&&b(t,["safetyAttributes"],Q4(r));const s=w(e,["prompt"]);return s!=null&&b(t,["enhancedPrompt"],s),t}function aQ(e){const t={},n=w(e,["_self"]);n!=null&&b(t,["mask"],Y4(n));const i=w(e,["labels"]);if(i!=null){let r=i;Array.isArray(r)&&(r=r.map(s=>s)),b(t,["labels"],r)}return t}function oQ(e){const t={},n=w(e,["video"]);return n!=null&&b(t,["video"],KQ(n)),t}function lQ(e){const t={},n=w(e,["_self"]);return n!=null&&b(t,["video"],JQ(n)),t}function uQ(e){const t={},n=w(e,["modelSelectionConfig"]);n!=null&&b(t,["modelConfig"],n);const i=w(e,["responseJsonSchema"]);i!=null&&b(t,["responseJsonSchema"],i);const r=w(e,["audioTimestamp"]);r!=null&&b(t,["audioTimestamp"],r);const s=w(e,["candidateCount"]);s!=null&&b(t,["candidateCount"],s);const a=w(e,["enableAffectiveDialog"]);a!=null&&b(t,["enableAffectiveDialog"],a);const o=w(e,["frequencyPenalty"]);o!=null&&b(t,["frequencyPenalty"],o);const l=w(e,["logprobs"]);l!=null&&b(t,["logprobs"],l);const u=w(e,["maxOutputTokens"]);u!=null&&b(t,["maxOutputTokens"],u);const c=w(e,["mediaResolution"]);c!=null&&b(t,["mediaResolution"],c);const f=w(e,["presencePenalty"]);f!=null&&b(t,["presencePenalty"],f);const d=w(e,["responseLogprobs"]);d!=null&&b(t,["responseLogprobs"],d);const h=w(e,["responseMimeType"]);h!=null&&b(t,["responseMimeType"],h);const m=w(e,["responseModalities"]);m!=null&&b(t,["responseModalities"],m);const y=w(e,["responseSchema"]);y!=null&&b(t,["responseSchema"],y);const M=w(e,["routingConfig"]);M!=null&&b(t,["routingConfig"],M);const g=w(e,["seed"]);g!=null&&b(t,["seed"],g);const _=w(e,["speechConfig"]);_!=null&&b(t,["speechConfig"],_);const T=w(e,["stopSequences"]);T!=null&&b(t,["stopSequences"],T);const x=w(e,["temperature"]);x!=null&&b(t,["temperature"],x);const S=w(e,["thinkingConfig"]);S!=null&&b(t,["thinkingConfig"],S);const $=w(e,["topK"]);$!=null&&b(t,["topK"],$);const C=w(e,["topP"]);if(C!=null&&b(t,["topP"],C),w(e,["enableEnhancedCivicAnswers"])!==void 0)throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");return t}function cQ(e,t){const n={},i=w(t,["model"]);return i!=null&&b(n,["_url","name"],ti(e,i)),n}function dQ(e,t){const n={},i=w(t,["model"]);return i!=null&&b(n,["_url","name"],ti(e,i)),n}function fQ(e){const t={};if(w(e,["authConfig"])!==void 0)throw new Error("authConfig parameter is not supported in Gemini API.");const n=w(e,["enableWidget"]);return n!=null&&b(t,["enableWidget"],n),t}function pQ(e){const t={};if(w(e,["excludeDomains"])!==void 0)throw new Error("excludeDomains parameter is not supported in Gemini API.");if(w(e,["blockingConfidence"])!==void 0)throw new Error("blockingConfidence parameter is not supported in Gemini API.");const n=w(e,["timeRangeFilter"]);return n!=null&&b(t,["timeRangeFilter"],n),t}function hQ(e){const t={},n=w(e,["aspectRatio"]);n!=null&&b(t,["aspectRatio"],n);const i=w(e,["imageSize"]);if(i!=null&&b(t,["imageSize"],i),w(e,["outputMimeType"])!==void 0)throw new Error("outputMimeType parameter is not supported in Gemini API.");if(w(e,["outputCompressionQuality"])!==void 0)throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");return t}function mQ(e){const t={},n=w(e,["aspectRatio"]);n!=null&&b(t,["aspectRatio"],n);const i=w(e,["imageSize"]);i!=null&&b(t,["imageSize"],i);const r=w(e,["outputMimeType"]);r!=null&&b(t,["imageOutputOptions","mimeType"],r);const s=w(e,["outputCompressionQuality"]);return s!=null&&b(t,["imageOutputOptions","compressionQuality"],s),t}function gQ(e){const t={},n=w(e,["bytesBase64Encoded"]);n!=null&&b(t,["imageBytes"],Kl(n));const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function Y4(e){const t={},n=w(e,["gcsUri"]);n!=null&&b(t,["gcsUri"],n);const i=w(e,["bytesBase64Encoded"]);i!=null&&b(t,["imageBytes"],Kl(i));const r=w(e,["mimeType"]);return r!=null&&b(t,["mimeType"],r),t}function e_(e){const t={};if(w(e,["gcsUri"])!==void 0)throw new Error("gcsUri parameter is not supported in Gemini API.");const n=w(e,["imageBytes"]);n!=null&&b(t,["bytesBase64Encoded"],Kl(n));const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function Da(e){const t={},n=w(e,["gcsUri"]);n!=null&&b(t,["gcsUri"],n);const i=w(e,["imageBytes"]);i!=null&&b(t,["bytesBase64Encoded"],Kl(i));const r=w(e,["mimeType"]);return r!=null&&b(t,["mimeType"],r),t}function _Q(e,t,n){const i={},r=w(t,["pageSize"]);n!==void 0&&r!=null&&b(n,["_query","pageSize"],r);const s=w(t,["pageToken"]);n!==void 0&&s!=null&&b(n,["_query","pageToken"],s);const a=w(t,["filter"]);n!==void 0&&a!=null&&b(n,["_query","filter"],a);const o=w(t,["queryBase"]);return n!==void 0&&o!=null&&b(n,["_url","models_url"],G4(e,o)),i}function yQ(e,t,n){const i={},r=w(t,["pageSize"]);n!==void 0&&r!=null&&b(n,["_query","pageSize"],r);const s=w(t,["pageToken"]);n!==void 0&&s!=null&&b(n,["_query","pageToken"],s);const a=w(t,["filter"]);n!==void 0&&a!=null&&b(n,["_query","filter"],a);const o=w(t,["queryBase"]);return n!==void 0&&o!=null&&b(n,["_url","models_url"],G4(e,o)),i}function vQ(e,t){const n={},i=w(t,["config"]);return i!=null&&_Q(e,i,n),n}function wQ(e,t){const n={},i=w(t,["config"]);return i!=null&&yQ(e,i,n),n}function bQ(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["nextPageToken"]);i!=null&&b(t,["nextPageToken"],i);const r=w(e,["_self"]);if(r!=null){let s=j4(r);Array.isArray(s)&&(s=s.map(a=>Ab(a))),b(t,["models"],s)}return t}function xQ(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["nextPageToken"]);i!=null&&b(t,["nextPageToken"],i);const r=w(e,["_self"]);if(r!=null){let s=j4(r);Array.isArray(s)&&(s=s.map(a=>Ib(a))),b(t,["models"],s)}return t}function TQ(e){const t={},n=w(e,["maskMode"]);n!=null&&b(t,["maskMode"],n);const i=w(e,["segmentationClasses"]);i!=null&&b(t,["maskClasses"],i);const r=w(e,["maskDilation"]);return r!=null&&b(t,["dilation"],r),t}function Ab(e){const t={},n=w(e,["name"]);n!=null&&b(t,["name"],n);const i=w(e,["displayName"]);i!=null&&b(t,["displayName"],i);const r=w(e,["description"]);r!=null&&b(t,["description"],r);const s=w(e,["version"]);s!=null&&b(t,["version"],s);const a=w(e,["_self"]);a!=null&&b(t,["tunedModelInfo"],FQ(a));const o=w(e,["inputTokenLimit"]);o!=null&&b(t,["inputTokenLimit"],o);const l=w(e,["outputTokenLimit"]);l!=null&&b(t,["outputTokenLimit"],l);const u=w(e,["supportedGenerationMethods"]);u!=null&&b(t,["supportedActions"],u);const c=w(e,["temperature"]);c!=null&&b(t,["temperature"],c);const f=w(e,["maxTemperature"]);f!=null&&b(t,["maxTemperature"],f);const d=w(e,["topP"]);d!=null&&b(t,["topP"],d);const h=w(e,["topK"]);h!=null&&b(t,["topK"],h);const m=w(e,["thinking"]);return m!=null&&b(t,["thinking"],m),t}function Ib(e){const t={},n=w(e,["name"]);n!=null&&b(t,["name"],n);const i=w(e,["displayName"]);i!=null&&b(t,["displayName"],i);const r=w(e,["description"]);r!=null&&b(t,["description"],r);const s=w(e,["versionId"]);s!=null&&b(t,["version"],s);const a=w(e,["deployedModels"]);if(a!=null){let f=a;Array.isArray(f)&&(f=f.map(d=>NX(d))),b(t,["endpoints"],f)}const o=w(e,["labels"]);o!=null&&b(t,["labels"],o);const l=w(e,["_self"]);l!=null&&b(t,["tunedModelInfo"],BQ(l));const u=w(e,["defaultCheckpointId"]);u!=null&&b(t,["defaultCheckpointId"],u);const c=w(e,["checkpoints"]);if(c!=null){let f=c;Array.isArray(f)&&(f=f.map(d=>d)),b(t,["checkpoints"],f)}return t}function MQ(e){const t={},n=w(e,["mediaResolution"]);n!=null&&b(t,["mediaResolution"],n);const i=w(e,["codeExecutionResult"]);i!=null&&b(t,["codeExecutionResult"],i);const r=w(e,["executableCode"]);r!=null&&b(t,["executableCode"],r);const s=w(e,["fileData"]);s!=null&&b(t,["fileData"],LX(s));const a=w(e,["functionCall"]);a!=null&&b(t,["functionCall"],zX(a));const o=w(e,["functionResponse"]);o!=null&&b(t,["functionResponse"],o);const l=w(e,["inlineData"]);l!=null&&b(t,["inlineData"],uX(l));const u=w(e,["text"]);u!=null&&b(t,["text"],u);const c=w(e,["thought"]);c!=null&&b(t,["thought"],c);const f=w(e,["thoughtSignature"]);f!=null&&b(t,["thoughtSignature"],f);const d=w(e,["videoMetadata"]);return d!=null&&b(t,["videoMetadata"],d),t}function EQ(e){const t={},n=w(e,["productImage"]);return n!=null&&b(t,["image"],Da(n)),t}function SQ(e,t){const n={},i=w(e,["numberOfImages"]);t!==void 0&&i!=null&&b(t,["parameters","sampleCount"],i);const r=w(e,["baseSteps"]);t!==void 0&&r!=null&&b(t,["parameters","baseSteps"],r);const s=w(e,["outputGcsUri"]);t!==void 0&&s!=null&&b(t,["parameters","storageUri"],s);const a=w(e,["seed"]);t!==void 0&&a!=null&&b(t,["parameters","seed"],a);const o=w(e,["safetyFilterLevel"]);t!==void 0&&o!=null&&b(t,["parameters","safetySetting"],o);const l=w(e,["personGeneration"]);t!==void 0&&l!=null&&b(t,["parameters","personGeneration"],l);const u=w(e,["addWatermark"]);t!==void 0&&u!=null&&b(t,["parameters","addWatermark"],u);const c=w(e,["outputMimeType"]);t!==void 0&&c!=null&&b(t,["parameters","outputOptions","mimeType"],c);const f=w(e,["outputCompressionQuality"]);t!==void 0&&f!=null&&b(t,["parameters","outputOptions","compressionQuality"],f);const d=w(e,["enhancePrompt"]);t!==void 0&&d!=null&&b(t,["parameters","enhancePrompt"],d);const h=w(e,["labels"]);return t!==void 0&&h!=null&&b(t,["labels"],h),n}function CQ(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["source"]);r!=null&&AQ(r,n);const s=w(t,["config"]);return s!=null&&SQ(s,n),n}function $Q(e){const t={},n=w(e,["predictions"]);if(n!=null){let i=n;Array.isArray(i)&&(i=i.map(r=>Zg(r))),b(t,["generatedImages"],i)}return t}function AQ(e,t){const n={},i=w(e,["prompt"]);t!==void 0&&i!=null&&b(t,["instances[0]","prompt"],i);const r=w(e,["personImage"]);t!==void 0&&r!=null&&b(t,["instances[0]","personImage","image"],Da(r));const s=w(e,["productImages"]);if(t!==void 0&&s!=null){let a=s;Array.isArray(a)&&(a=a.map(o=>EQ(o))),b(t,["instances[0]","productImages"],a)}return n}function IQ(e){const t={},n=w(e,["referenceImage"]);n!=null&&b(t,["referenceImage"],Da(n));const i=w(e,["referenceId"]);i!=null&&b(t,["referenceId"],i);const r=w(e,["referenceType"]);r!=null&&b(t,["referenceType"],r);const s=w(e,["maskImageConfig"]);s!=null&&b(t,["maskImageConfig"],TQ(s));const a=w(e,["controlImageConfig"]);a!=null&&b(t,["controlImageConfig"],gX(a));const o=w(e,["styleImageConfig"]);o!=null&&b(t,["styleImageConfig"],o);const l=w(e,["subjectImageConfig"]);return l!=null&&b(t,["subjectImageConfig"],l),t}function X4(e){const t={},n=w(e,["safetyAttributes","categories"]);n!=null&&b(t,["categories"],n);const i=w(e,["safetyAttributes","scores"]);i!=null&&b(t,["scores"],i);const r=w(e,["contentType"]);return r!=null&&b(t,["contentType"],r),t}function Q4(e){const t={},n=w(e,["safetyAttributes","categories"]);n!=null&&b(t,["categories"],n);const i=w(e,["safetyAttributes","scores"]);i!=null&&b(t,["scores"],i);const r=w(e,["contentType"]);return r!=null&&b(t,["contentType"],r),t}function PQ(e){const t={},n=w(e,["category"]);if(n!=null&&b(t,["category"],n),w(e,["method"])!==void 0)throw new Error("method parameter is not supported in Gemini API.");const i=w(e,["threshold"]);return i!=null&&b(t,["threshold"],i),t}function kQ(e){const t={},n=w(e,["image"]);return n!=null&&b(t,["image"],Da(n)),t}function DQ(e,t){const n={},i=w(e,["mode"]);t!==void 0&&i!=null&&b(t,["parameters","mode"],i);const r=w(e,["maxPredictions"]);t!==void 0&&r!=null&&b(t,["parameters","maxPredictions"],r);const s=w(e,["confidenceThreshold"]);t!==void 0&&s!=null&&b(t,["parameters","confidenceThreshold"],s);const a=w(e,["maskDilation"]);t!==void 0&&a!=null&&b(t,["parameters","maskDilation"],a);const o=w(e,["binaryColorThreshold"]);t!==void 0&&o!=null&&b(t,["parameters","binaryColorThreshold"],o);const l=w(e,["labels"]);return t!==void 0&&l!=null&&b(t,["labels"],l),n}function OQ(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["source"]);r!=null&&NQ(r,n);const s=w(t,["config"]);return s!=null&&DQ(s,n),n}function RQ(e){const t={},n=w(e,["predictions"]);if(n!=null){let i=n;Array.isArray(i)&&(i=i.map(r=>aQ(r))),b(t,["generatedMasks"],i)}return t}function NQ(e,t){const n={},i=w(e,["prompt"]);t!==void 0&&i!=null&&b(t,["instances[0]","prompt"],i);const r=w(e,["image"]);t!==void 0&&r!=null&&b(t,["instances[0]","image"],Da(r));const s=w(e,["scribbleImage"]);return t!==void 0&&s!=null&&b(t,["instances[0]","scribble"],kQ(s)),n}function LQ(e){const t={},n=w(e,["functionCallingConfig"]);n!=null&&b(t,["functionCallingConfig"],FX(n));const i=w(e,["retrievalConfig"]);return i!=null&&b(t,["retrievalConfig"],i),t}function zQ(e){const t={},n=w(e,["functionDeclarations"]);if(n!=null){let c=n;Array.isArray(c)&&(c=c.map(f=>f)),b(t,["functionDeclarations"],c)}if(w(e,["retrieval"])!==void 0)throw new Error("retrieval parameter is not supported in Gemini API.");const i=w(e,["googleSearchRetrieval"]);i!=null&&b(t,["googleSearchRetrieval"],i);const r=w(e,["computerUse"]);r!=null&&b(t,["computerUse"],r);const s=w(e,["fileSearch"]);s!=null&&b(t,["fileSearch"],s);const a=w(e,["codeExecution"]);if(a!=null&&b(t,["codeExecution"],a),w(e,["enterpriseWebSearch"])!==void 0)throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");const o=w(e,["googleMaps"]);o!=null&&b(t,["googleMaps"],fQ(o));const l=w(e,["googleSearch"]);l!=null&&b(t,["googleSearch"],pQ(l));const u=w(e,["urlContext"]);return u!=null&&b(t,["urlContext"],u),t}function Z4(e){const t={},n=w(e,["functionDeclarations"]);if(n!=null){let f=n;Array.isArray(f)&&(f=f.map(d=>BX(d))),b(t,["functionDeclarations"],f)}const i=w(e,["retrieval"]);i!=null&&b(t,["retrieval"],i);const r=w(e,["googleSearchRetrieval"]);r!=null&&b(t,["googleSearchRetrieval"],r);const s=w(e,["computerUse"]);if(s!=null&&b(t,["computerUse"],s),w(e,["fileSearch"])!==void 0)throw new Error("fileSearch parameter is not supported in Vertex AI.");const a=w(e,["codeExecution"]);a!=null&&b(t,["codeExecution"],a);const o=w(e,["enterpriseWebSearch"]);o!=null&&b(t,["enterpriseWebSearch"],o);const l=w(e,["googleMaps"]);l!=null&&b(t,["googleMaps"],l);const u=w(e,["googleSearch"]);u!=null&&b(t,["googleSearch"],u);const c=w(e,["urlContext"]);return c!=null&&b(t,["urlContext"],c),t}function FQ(e){const t={},n=w(e,["baseModel"]);n!=null&&b(t,["baseModel"],n);const i=w(e,["createTime"]);i!=null&&b(t,["createTime"],i);const r=w(e,["updateTime"]);return r!=null&&b(t,["updateTime"],r),t}function BQ(e){const t={},n=w(e,["labels","google-vertex-llm-tuning-base-model-id"]);n!=null&&b(t,["baseModel"],n);const i=w(e,["createTime"]);i!=null&&b(t,["createTime"],i);const r=w(e,["updateTime"]);return r!=null&&b(t,["updateTime"],r),t}function UQ(e,t){const n={},i=w(e,["displayName"]);t!==void 0&&i!=null&&b(t,["displayName"],i);const r=w(e,["description"]);t!==void 0&&r!=null&&b(t,["description"],r);const s=w(e,["defaultCheckpointId"]);return t!==void 0&&s!=null&&b(t,["defaultCheckpointId"],s),n}function VQ(e,t){const n={},i=w(e,["displayName"]);t!==void 0&&i!=null&&b(t,["displayName"],i);const r=w(e,["description"]);t!==void 0&&r!=null&&b(t,["description"],r);const s=w(e,["defaultCheckpointId"]);return t!==void 0&&s!=null&&b(t,["defaultCheckpointId"],s),n}function GQ(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","name"],ti(e,i));const r=w(t,["config"]);return r!=null&&UQ(r,n),n}function jQ(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["config"]);return r!=null&&VQ(r,n),n}function WQ(e,t){const n={},i=w(e,["outputGcsUri"]);t!==void 0&&i!=null&&b(t,["parameters","storageUri"],i);const r=w(e,["safetyFilterLevel"]);t!==void 0&&r!=null&&b(t,["parameters","safetySetting"],r);const s=w(e,["personGeneration"]);t!==void 0&&s!=null&&b(t,["parameters","personGeneration"],s);const a=w(e,["includeRaiReason"]);t!==void 0&&a!=null&&b(t,["parameters","includeRaiReason"],a);const o=w(e,["outputMimeType"]);t!==void 0&&o!=null&&b(t,["parameters","outputOptions","mimeType"],o);const l=w(e,["outputCompressionQuality"]);t!==void 0&&l!=null&&b(t,["parameters","outputOptions","compressionQuality"],l);const u=w(e,["enhanceInputImage"]);t!==void 0&&u!=null&&b(t,["parameters","upscaleConfig","enhanceInputImage"],u);const c=w(e,["imagePreservationFactor"]);t!==void 0&&c!=null&&b(t,["parameters","upscaleConfig","imagePreservationFactor"],c);const f=w(e,["labels"]);t!==void 0&&f!=null&&b(t,["labels"],f);const d=w(e,["numberOfImages"]);t!==void 0&&d!=null&&b(t,["parameters","sampleCount"],d);const h=w(e,["mode"]);return t!==void 0&&h!=null&&b(t,["parameters","mode"],h),n}function HQ(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["_url","model"],ti(e,i));const r=w(t,["image"]);r!=null&&b(n,["instances[0]","image"],Da(r));const s=w(t,["upscaleFactor"]);s!=null&&b(n,["parameters","upscaleConfig","upscaleFactor"],s);const a=w(t,["config"]);return a!=null&&WQ(a,n),n}function qQ(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["predictions"]);if(i!=null){let r=i;Array.isArray(r)&&(r=r.map(s=>Zg(s))),b(t,["generatedImages"],r)}return t}function KQ(e){const t={},n=w(e,["uri"]);n!=null&&b(t,["uri"],n);const i=w(e,["encodedVideo"]);i!=null&&b(t,["videoBytes"],Kl(i));const r=w(e,["encoding"]);return r!=null&&b(t,["mimeType"],r),t}function JQ(e){const t={},n=w(e,["gcsUri"]);n!=null&&b(t,["uri"],n);const i=w(e,["bytesBase64Encoded"]);i!=null&&b(t,["videoBytes"],Kl(i));const r=w(e,["mimeType"]);return r!=null&&b(t,["mimeType"],r),t}function YQ(e){const t={},n=w(e,["image"]);n!=null&&b(t,["_self"],Da(n));const i=w(e,["maskMode"]);return i!=null&&b(t,["maskMode"],i),t}function XQ(e){const t={},n=w(e,["image"]);n!=null&&b(t,["image"],e_(n));const i=w(e,["referenceType"]);return i!=null&&b(t,["referenceType"],i),t}function QQ(e){const t={},n=w(e,["image"]);n!=null&&b(t,["image"],Da(n));const i=w(e,["referenceType"]);return i!=null&&b(t,["referenceType"],i),t}function eU(e){const t={},n=w(e,["uri"]);n!=null&&b(t,["uri"],n);const i=w(e,["videoBytes"]);i!=null&&b(t,["encodedVideo"],Kl(i));const r=w(e,["mimeType"]);return r!=null&&b(t,["encoding"],r),t}function tU(e){const t={},n=w(e,["uri"]);n!=null&&b(t,["gcsUri"],n);const i=w(e,["videoBytes"]);i!=null&&b(t,["bytesBase64Encoded"],Kl(i));const r=w(e,["mimeType"]);return r!=null&&b(t,["mimeType"],r),t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function ZQ(e,t){const n={},i=w(e,["displayName"]);return t!==void 0&&i!=null&&b(t,["displayName"],i),n}function eZ(e){const t={},n=w(e,["config"]);return n!=null&&ZQ(n,t),t}function tZ(e,t){const n={},i=w(e,["force"]);return t!==void 0&&i!=null&&b(t,["_query","force"],i),n}function nZ(e){const t={},n=w(e,["name"]);n!=null&&b(t,["_url","name"],n);const i=w(e,["config"]);return i!=null&&tZ(i,t),t}function iZ(e){const t={},n=w(e,["name"]);return n!=null&&b(t,["_url","name"],n),t}function rZ(e,t){const n={},i=w(e,["customMetadata"]);if(t!==void 0&&i!=null){let s=i;Array.isArray(s)&&(s=s.map(a=>a)),b(t,["customMetadata"],s)}const r=w(e,["chunkingConfig"]);return t!==void 0&&r!=null&&b(t,["chunkingConfig"],r),n}function sZ(e){const t={},n=w(e,["name"]);n!=null&&b(t,["name"],n);const i=w(e,["metadata"]);i!=null&&b(t,["metadata"],i);const r=w(e,["done"]);r!=null&&b(t,["done"],r);const s=w(e,["error"]);s!=null&&b(t,["error"],s);const a=w(e,["response"]);return a!=null&&b(t,["response"],oZ(a)),t}function aZ(e){const t={},n=w(e,["fileSearchStoreName"]);n!=null&&b(t,["_url","file_search_store_name"],n);const i=w(e,["fileName"]);i!=null&&b(t,["fileName"],i);const r=w(e,["config"]);return r!=null&&rZ(r,t),t}function oZ(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["parent"]);i!=null&&b(t,["parent"],i);const r=w(e,["documentName"]);return r!=null&&b(t,["documentName"],r),t}function lZ(e,t){const n={},i=w(e,["pageSize"]);t!==void 0&&i!=null&&b(t,["_query","pageSize"],i);const r=w(e,["pageToken"]);return t!==void 0&&r!=null&&b(t,["_query","pageToken"],r),n}function uZ(e){const t={},n=w(e,["config"]);return n!=null&&lZ(n,t),t}function cZ(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["nextPageToken"]);i!=null&&b(t,["nextPageToken"],i);const r=w(e,["fileSearchStores"]);if(r!=null){let s=r;Array.isArray(s)&&(s=s.map(a=>a)),b(t,["fileSearchStores"],s)}return t}function nU(e,t){const n={},i=w(e,["mimeType"]);t!==void 0&&i!=null&&b(t,["mimeType"],i);const r=w(e,["displayName"]);t!==void 0&&r!=null&&b(t,["displayName"],r);const s=w(e,["customMetadata"]);if(t!==void 0&&s!=null){let o=s;Array.isArray(o)&&(o=o.map(l=>l)),b(t,["customMetadata"],o)}const a=w(e,["chunkingConfig"]);return t!==void 0&&a!=null&&b(t,["chunkingConfig"],a),n}function dZ(e){const t={},n=w(e,["fileSearchStoreName"]);n!=null&&b(t,["_url","file_search_store_name"],n);const i=w(e,["config"]);return i!=null&&nU(i,t),t}function fZ(e){const t={},n=w(e,["sdkHttpResponse"]);return n!=null&&b(t,["sdkHttpResponse"],n),t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const pZ="Content-Type",hZ="X-Server-Timeout",mZ="User-Agent",Pb="x-goog-api-client",gZ="1.34.0",_Z=`google-genai-sdk/${gZ}`,yZ="v1beta1",vZ="v1beta";class wZ{constructor(t){var n,i;this.clientOptions=Object.assign(Object.assign({},t),{project:t.project,location:t.location,apiKey:t.apiKey,vertexai:t.vertexai});const r={};this.clientOptions.vertexai?(r.apiVersion=(n=this.clientOptions.apiVersion)!==null&&n!==void 0?n:yZ,r.baseUrl=this.baseUrlFromProjectLocation(),this.normalizeAuthParameters()):(r.apiVersion=(i=this.clientOptions.apiVersion)!==null&&i!==void 0?i:vZ,r.baseUrl="https://generativelanguage.googleapis.com/"),r.headers=this.getDefaultHeaders(),this.clientOptions.httpOptions=r,t.httpOptions&&(this.clientOptions.httpOptions=this.patchHttpOptions(r,t.httpOptions))}baseUrlFromProjectLocation(){return this.clientOptions.project&&this.clientOptions.location&&this.clientOptions.location!=="global"?`https://${this.clientOptions.location}-aiplatform.googleapis.com/`:"https://aiplatform.googleapis.com/"}normalizeAuthParameters(){if(this.clientOptions.project&&this.clientOptions.location){this.clientOptions.apiKey=void 0;return}this.clientOptions.project=void 0,this.clientOptions.location=void 0}isVertexAI(){var t;return(t=this.clientOptions.vertexai)!==null&&t!==void 0?t:!1}getProject(){return this.clientOptions.project}getLocation(){return this.clientOptions.location}async getAuthHeaders(){const t=new Headers;return await this.clientOptions.auth.addAuthHeaders(t),t}getApiVersion(){if(this.clientOptions.httpOptions&&this.clientOptions.httpOptions.apiVersion!==void 0)return this.clientOptions.httpOptions.apiVersion;throw new Error("API version is not set.")}getBaseUrl(){if(this.clientOptions.httpOptions&&this.clientOptions.httpOptions.baseUrl!==void 0)return this.clientOptions.httpOptions.baseUrl;throw new Error("Base URL is not set.")}getRequestUrl(){return this.getRequestUrlInternal(this.clientOptions.httpOptions)}getHeaders(){if(this.clientOptions.httpOptions&&this.clientOptions.httpOptions.headers!==void 0)return this.clientOptions.httpOptions.headers;throw new Error("Headers are not set.")}getRequestUrlInternal(t){if(!t||t.baseUrl===void 0||t.apiVersion===void 0)throw new Error("HTTP options are not correctly set.");const i=[t.baseUrl.endsWith("/")?t.baseUrl.slice(0,-1):t.baseUrl];return t.apiVersion&&t.apiVersion!==""&&i.push(t.apiVersion),i.join("/")}getBaseResourcePath(){return`projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`}getApiKey(){return this.clientOptions.apiKey}getWebsocketBaseUrl(){const t=this.getBaseUrl(),n=new URL(t);return n.protocol=n.protocol=="http:"?"ws":"wss",n.toString()}setBaseUrl(t){if(this.clientOptions.httpOptions)this.clientOptions.httpOptions.baseUrl=t;else throw new Error("HTTP options are not correctly set.")}constructUrl(t,n,i){const r=[this.getRequestUrlInternal(n)];return i&&r.push(this.getBaseResourcePath()),t!==""&&r.push(t),new URL(`${r.join("/")}`)}shouldPrependVertexProjectPath(t){return!(this.clientOptions.apiKey||!this.clientOptions.vertexai||t.path.startsWith("projects/")||t.httpMethod==="GET"&&t.path.startsWith("publishers/google/models"))}async request(t){let n=this.clientOptions.httpOptions;t.httpOptions&&(n=this.patchHttpOptions(this.clientOptions.httpOptions,t.httpOptions));const i=this.shouldPrependVertexProjectPath(t),r=this.constructUrl(t.path,n,i);if(t.queryParams)for(const[a,o]of Object.entries(t.queryParams))r.searchParams.append(a,String(o));let s={};if(t.httpMethod==="GET"){if(t.body&&t.body!=="{}")throw new Error("Request body should be empty for GET request, but got non empty request body")}else s.body=t.body;return s=await this.includeExtraHttpOptionsToRequestInit(s,n,r.toString(),t.abortSignal),this.unaryApiCall(r,s,t.httpMethod)}patchHttpOptions(t,n){const i=JSON.parse(JSON.stringify(t));for(const[r,s]of Object.entries(n))typeof s=="object"?i[r]=Object.assign(Object.assign({},i[r]),s):s!==void 0&&(i[r]=s);return i}async requestStream(t){let n=this.clientOptions.httpOptions;t.httpOptions&&(n=this.patchHttpOptions(this.clientOptions.httpOptions,t.httpOptions));const i=this.shouldPrependVertexProjectPath(t),r=this.constructUrl(t.path,n,i);(!r.searchParams.has("alt")||r.searchParams.get("alt")!=="sse")&&r.searchParams.set("alt","sse");let s={};return s.body=t.body,s=await this.includeExtraHttpOptionsToRequestInit(s,n,r.toString(),t.abortSignal),this.streamApiCall(r,s,t.httpMethod)}async includeExtraHttpOptionsToRequestInit(t,n,i,r){if(n&&n.timeout||r){const s=new AbortController,a=s.signal;if(n.timeout&&(n==null?void 0:n.timeout)>0){const o=setTimeout(()=>s.abort(),n.timeout);o&&typeof o.unref=="function"&&o.unref()}r&&r.addEventListener("abort",()=>{s.abort()}),t.signal=a}return n&&n.extraBody!==null&&bZ(t,n.extraBody),t.headers=await this.getHeadersInternal(n,i),t}async unaryApiCall(t,n,i){return this.apiCall(t.toString(),Object.assign(Object.assign({},n),{method:i})).then(async r=>(await EP(r),new Sb(r))).catch(r=>{throw r instanceof Error?r:new Error(JSON.stringify(r))})}async streamApiCall(t,n,i){return this.apiCall(t.toString(),Object.assign(Object.assign({},n),{method:i})).then(async r=>(await EP(r),this.processStreamResponse(r))).catch(r=>{throw r instanceof Error?r:new Error(JSON.stringify(r))})}processStreamResponse(t){return Ca(this,arguments,function*(){var i;const r=(i=t==null?void 0:t.body)===null||i===void 0?void 0:i.getReader(),s=new TextDecoder("utf-8");if(!r)throw new Error("Response body is empty");try{let a="";const o="data:",l=[`

`,"\r\r",`\r
\r
`];for(;;){const{done:u,value:c}=yield fn(r.read());if(u){if(a.trim().length>0)throw new Error("Incomplete JSON segment at the end");break}const f=s.decode(c,{stream:!0});try{const m=JSON.parse(f);if("error"in m){const y=JSON.parse(JSON.stringify(m.error)),M=y.status,g=y.code,_=`got status: ${M}. ${JSON.stringify(m)}`;if(g>=400&&g<600)throw new Xg({message:_,status:g})}}catch(m){if(m.name==="ApiError")throw m}a+=f;let d=-1,h=0;for(;;){d=-1,h=0;for(const M of l){const g=a.indexOf(M);g!==-1&&(d===-1||g<d)&&(d=g,h=M.length)}if(d===-1)break;const m=a.substring(0,d);a=a.substring(d+h);const y=m.trim();if(y.startsWith(o)){const M=y.substring(o.length).trim();try{const g=new Response(M,{headers:t==null?void 0:t.headers,status:t==null?void 0:t.status,statusText:t==null?void 0:t.statusText});yield yield fn(new Sb(g))}catch(g){throw new Error(`exception parsing stream chunk ${M}. ${g}`)}}}}}finally{r.releaseLock()}})}async apiCall(t,n){return fetch(t,n).catch(i=>{throw new Error(`exception ${i} sending request`)})}getDefaultHeaders(){const t={},n=_Z+" "+this.clientOptions.userAgentExtra;return t[mZ]=n,t[Pb]=n,t[pZ]="application/json",t}async getHeadersInternal(t,n){const i=new Headers;if(t&&t.headers){for(const[r,s]of Object.entries(t.headers))i.append(r,s);t.timeout&&t.timeout>0&&i.append(hZ,String(Math.ceil(t.timeout/1e3)))}return await this.clientOptions.auth.addAuthHeaders(i,n),i}getFileName(t){var n;let i="";return typeof t=="string"&&(i=t.replace(/[/\\]+$/,""),i=(n=i.split(/[/\\]/).pop())!==null&&n!==void 0?n:""),i}async uploadFile(t,n){var i;const r={};n!=null&&(r.mimeType=n.mimeType,r.name=n.name,r.displayName=n.displayName),r.name&&!r.name.startsWith("files/")&&(r.name=`files/${r.name}`);const s=this.clientOptions.uploader,a=await s.stat(t);r.sizeBytes=String(a.size);const o=(i=n==null?void 0:n.mimeType)!==null&&i!==void 0?i:a.type;if(o===void 0||o==="")throw new Error("Can not determine mimeType. Please provide mimeType in the config.");r.mimeType=o;const l={file:r},u=this.getFileName(t),c=Dt("upload/v1beta/files",l._url),f=await this.fetchUploadUrl(c,r.sizeBytes,r.mimeType,u,l,n==null?void 0:n.httpOptions);return s.upload(t,f,this)}async uploadFileToFileSearchStore(t,n,i){var r;const s=this.clientOptions.uploader,a=await s.stat(n),o=String(a.size),l=(r=i==null?void 0:i.mimeType)!==null&&r!==void 0?r:a.type;if(l===void 0||l==="")throw new Error("Can not determine mimeType. Please provide mimeType in the config.");const u=`upload/v1beta/${t}:uploadToFileSearchStore`,c=this.getFileName(n),f={};i!=null&&nU(i,f);const d=await this.fetchUploadUrl(u,o,l,c,f,i==null?void 0:i.httpOptions);return s.uploadToFileSearchStore(n,d,this)}async downloadFile(t){await this.clientOptions.downloader.download(t,this)}async fetchUploadUrl(t,n,i,r,s,a){var o;let l={};a?l=a:l={apiVersion:"",headers:Object.assign({"Content-Type":"application/json","X-Goog-Upload-Protocol":"resumable","X-Goog-Upload-Command":"start","X-Goog-Upload-Header-Content-Length":`${n}`,"X-Goog-Upload-Header-Content-Type":`${i}`},r?{"X-Goog-Upload-File-Name":r}:{})};const u=await this.request({path:t,body:JSON.stringify(s),httpMethod:"POST",httpOptions:l});if(!u||!(u!=null&&u.headers))throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");const c=(o=u==null?void 0:u.headers)===null||o===void 0?void 0:o["x-goog-upload-url"];if(c===void 0)throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");return c}}async function EP(e){var t;if(e===void 0)throw new Error("response is undefined");if(!e.ok){const n=e.status;let i;!((t=e.headers.get("content-type"))===null||t===void 0)&&t.includes("application/json")?i=await e.json():i={error:{message:await e.text(),code:e.status,status:e.statusText}};const r=JSON.stringify(i);throw n>=400&&n<600?new Xg({message:r,status:n}):new Error(r)}}function bZ(e,t){if(!t||Object.keys(t).length===0)return;if(e.body instanceof Blob){console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");return}let n={};if(typeof e.body=="string"&&e.body.length>0)try{const s=JSON.parse(e.body);if(typeof s=="object"&&s!==null&&!Array.isArray(s))n=s;else{console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");return}}catch{console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");return}function i(s,a){const o=Object.assign({},s);for(const l in a)if(Object.prototype.hasOwnProperty.call(a,l)){const u=a[l],c=o[l];u&&typeof u=="object"&&!Array.isArray(u)&&c&&typeof c=="object"&&!Array.isArray(c)?o[l]=i(c,u):(c&&u&&typeof c!=typeof u&&console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${l}". Original type: ${typeof c}, New type: ${typeof u}. Overwriting.`),o[l]=u)}return o}const r=i(n,t);e.body=JSON.stringify(r)}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const xZ="mcp_used/unknown";let TZ=!1;function iU(e){for(const t of e)if(MZ(t)||typeof t=="object"&&"inputSchema"in t)return!0;return TZ}function rU(e){var t;const n=(t=e[Pb])!==null&&t!==void 0?t:"";e[Pb]=(n+` ${xZ}`).trimStart()}function MZ(e){return e!==null&&typeof e=="object"&&e instanceof Dx}function EZ(e){return Ca(this,arguments,function*(n,i=100){let r,s=0;for(;s<i;){const a=yield fn(n.listTools({cursor:r}));for(const o of a.tools)yield yield fn(o),s++;if(!a.nextCursor)break;r=a.nextCursor}})}class Dx{constructor(t=[],n){this.mcpTools=[],this.functionNameToMcpClient={},this.mcpClients=t,this.config=n}static create(t,n){return new Dx(t,n)}async initialize(){var t,n,i,r;if(this.mcpTools.length>0)return;const s={},a=[];for(const c of this.mcpClients)try{for(var o=!0,l=(n=void 0,$a(EZ(c))),u;u=await l.next(),t=u.done,!t;o=!0){r=u.value,o=!1;const f=r;a.push(f);const d=f.name;if(s[d])throw new Error(`Duplicate function name ${d} found in MCP tools. Please ensure function names are unique.`);s[d]=c}}catch(f){n={error:f}}finally{try{!o&&!t&&(i=l.return)&&await i.call(l)}finally{if(n)throw n.error}}this.mcpTools=a,this.functionNameToMcpClient=s}async tool(){return await this.initialize(),iJ(this.mcpTools,this.config)}async callTool(t){await this.initialize();const n=[];for(const i of t)if(i.name in this.functionNameToMcpClient){const r=this.functionNameToMcpClient[i.name];let s;this.config.timeout&&(s={timeout:this.config.timeout});const a=await r.callTool({name:i.name,arguments:i.args},void 0,s);n.push({functionResponse:{name:i.name,response:a.isError?{error:a}:a}})}return n}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */async function SZ(e,t,n){const i=new J7;let r;n.data instanceof Blob?r=JSON.parse(await n.data.text()):r=JSON.parse(n.data),Object.assign(i,r),t(i)}class CZ{constructor(t,n,i){this.apiClient=t,this.auth=n,this.webSocketFactory=i}async connect(t){var n,i;if(this.apiClient.isVertexAI())throw new Error("Live music is not supported for Vertex AI.");console.warn("Live music generation is experimental and may change in future versions.");const r=this.apiClient.getWebsocketBaseUrl(),s=this.apiClient.getApiVersion(),a=IZ(this.apiClient.getDefaultHeaders()),o=this.apiClient.getApiKey(),l=`${r}/ws/google.ai.generativelanguage.${s}.GenerativeService.BidiGenerateMusic?key=${o}`;let u=()=>{};const c=new Promise(T=>{u=T}),f=t.callbacks,d=function(){u({})},h=this.apiClient,m={onopen:d,onmessage:T=>{SZ(h,f.onmessage,T)},onerror:(n=f==null?void 0:f.onerror)!==null&&n!==void 0?n:function(T){},onclose:(i=f==null?void 0:f.onclose)!==null&&i!==void 0?i:function(T){}},y=this.webSocketFactory.create(l,AZ(a),m);y.connect(),await c;const _={setup:{model:ti(this.apiClient,t.model)}};return y.send(JSON.stringify(_)),new $Z(y,this.apiClient)}}class $Z{constructor(t,n){this.conn=t,this.apiClient=n}async setWeightedPrompts(t){if(!t.weightedPrompts||Object.keys(t.weightedPrompts).length===0)throw new Error("Weighted prompts must be set and contain at least one entry.");const n=eX(t);this.conn.send(JSON.stringify({clientContent:n}))}async setMusicGenerationConfig(t){t.musicGenerationConfig||(t.musicGenerationConfig={});const n=ZY(t);this.conn.send(JSON.stringify(n))}sendPlaybackControl(t){const n={playbackControl:t};this.conn.send(JSON.stringify(n))}play(){this.sendPlaybackControl(Zc.PLAY)}pause(){this.sendPlaybackControl(Zc.PAUSE)}stop(){this.sendPlaybackControl(Zc.STOP)}resetContext(){this.sendPlaybackControl(Zc.RESET_CONTEXT)}close(){this.conn.close()}}function AZ(e){const t={};return e.forEach((n,i)=>{t[i]=n}),t}function IZ(e){const t=new Headers;for(const[n,i]of Object.entries(e))t.append(n,i);return t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const PZ="FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";async function kZ(e,t,n){const i=new K7;let r;n.data instanceof Blob?r=await n.data.text():n.data instanceof ArrayBuffer?r=new TextDecoder().decode(n.data):r=n.data;const s=JSON.parse(r);if(e.isVertexAI()){const a=iX(s);Object.assign(i,a)}else Object.assign(i,s);t(i)}class DZ{constructor(t,n,i){this.apiClient=t,this.auth=n,this.webSocketFactory=i,this.music=new CZ(this.apiClient,this.auth,this.webSocketFactory)}async connect(t){var n,i,r,s,a,o;if(t.config&&t.config.httpOptions)throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");const l=this.apiClient.getWebsocketBaseUrl(),u=this.apiClient.getApiVersion();let c;const f=this.apiClient.getHeaders();t.config&&t.config.tools&&iU(t.config.tools)&&rU(f);const d=LZ(f);if(this.apiClient.isVertexAI())c=`${l}/ws/google.cloud.aiplatform.${u}.LlmBidiService/BidiGenerateContent`,await this.auth.addAuthHeaders(d,c);else{const O=this.apiClient.getApiKey();let R="BidiGenerateContent",G="key";O!=null&&O.startsWith("auth_tokens/")&&(console.warn("Warning: Ephemeral token support is experimental and may change in future versions."),u!=="v1alpha"&&console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection."),R="BidiGenerateContentConstrained",G="access_token"),c=`${l}/ws/google.ai.generativelanguage.${u}.GenerativeService.${R}?${G}=${O}`}let h=()=>{};const m=new Promise(O=>{h=O}),y=t.callbacks,M=function(){var O;(O=y==null?void 0:y.onopen)===null||O===void 0||O.call(y),h({})},g=this.apiClient,_={onopen:M,onmessage:O=>{kZ(g,y.onmessage,O)},onerror:(n=y==null?void 0:y.onerror)!==null&&n!==void 0?n:function(O){},onclose:(i=y==null?void 0:y.onclose)!==null&&i!==void 0?i:function(O){}},T=this.webSocketFactory.create(c,NZ(d),_);T.connect(),await m;let x=ti(this.apiClient,t.model);if(this.apiClient.isVertexAI()&&x.startsWith("publishers/")){const O=this.apiClient.getProject(),R=this.apiClient.getLocation();x=`projects/${O}/locations/${R}/`+x}let S={};this.apiClient.isVertexAI()&&((r=t.config)===null||r===void 0?void 0:r.responseModalities)===void 0&&(t.config===void 0?t.config={responseModalities:[og.AUDIO]}:t.config.responseModalities=[og.AUDIO]),!((s=t.config)===null||s===void 0)&&s.generationConfig&&console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");const $=(o=(a=t.config)===null||a===void 0?void 0:a.tools)!==null&&o!==void 0?o:[],C=[];for(const O of $)if(this.isCallableTool(O)){const R=O;C.push(await R.tool())}else C.push(O);C.length>0&&(t.config.tools=C);const P={model:x,config:t.config,callbacks:t.callbacks};return this.apiClient.isVertexAI()?S=QY(this.apiClient,P):S=XY(this.apiClient,P),delete S.config,T.send(JSON.stringify(S)),new RZ(T,this.apiClient)}isCallableTool(t){return"callTool"in t&&typeof t.callTool=="function"}}const OZ={turnComplete:!0};class RZ{constructor(t,n){this.conn=t,this.apiClient=n}tLiveClientContent(t,n){if(n.turns!==null&&n.turns!==void 0){let i=[];try{i=Xs(n.turns),t.isVertexAI()||(i=i.map(r=>Qg(r)))}catch{throw new Error(`Failed to parse client content "turns", type: '${typeof n.turns}'`)}return{clientContent:{turns:i,turnComplete:n.turnComplete}}}return{clientContent:{turnComplete:n.turnComplete}}}tLiveClienttToolResponse(t,n){let i=[];if(n.functionResponses==null)throw new Error("functionResponses is required.");if(Array.isArray(n.functionResponses)?i=n.functionResponses:i=[n.functionResponses],i.length===0)throw new Error("functionResponses is required.");for(const s of i){if(typeof s!="object"||s===null||!("name"in s)||!("response"in s))throw new Error(`Could not parse function response, type '${typeof s}'.`);if(!t.isVertexAI()&&!("id"in s))throw new Error(PZ)}return{toolResponse:{functionResponses:i}}}sendClientContent(t){t=Object.assign(Object.assign({},OZ),t);const n=this.tLiveClientContent(this.apiClient,t);this.conn.send(JSON.stringify(n))}sendRealtimeInput(t){let n={};this.apiClient.isVertexAI()?n={realtimeInput:nX(t)}:n={realtimeInput:tX(t)},this.conn.send(JSON.stringify(n))}sendToolResponse(t){if(t.functionResponses==null)throw new Error("Tool response parameters are required.");const n=this.tLiveClienttToolResponse(this.apiClient,t);this.conn.send(JSON.stringify(n))}close(){this.conn.close()}}function NZ(e){const t={};return e.forEach((n,i)=>{t[i]=n}),t}function LZ(e){const t=new Headers;for(const[n,i]of Object.entries(e))t.append(n,i);return t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const SP=10;function CP(e){var t,n,i;if(!((t=e==null?void 0:e.automaticFunctionCalling)===null||t===void 0)&&t.disable)return!0;let r=!1;for(const a of(n=e==null?void 0:e.tools)!==null&&n!==void 0?n:[])if(pd(a)){r=!0;break}if(!r)return!0;const s=(i=e==null?void 0:e.automaticFunctionCalling)===null||i===void 0?void 0:i.maximumRemoteCalls;return s&&(s<0||!Number.isInteger(s))||s==0?(console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:",s),!0):!1}function pd(e){return"callTool"in e&&typeof e.callTool=="function"}function zZ(e){var t,n,i;return(i=(n=(t=e.config)===null||t===void 0?void 0:t.tools)===null||n===void 0?void 0:n.some(r=>pd(r)))!==null&&i!==void 0?i:!1}function $P(e){var t;const n=[];return!((t=e==null?void 0:e.config)===null||t===void 0)&&t.tools&&e.config.tools.forEach((i,r)=>{if(pd(i))return;const s=i;s.functionDeclarations&&s.functionDeclarations.length>0&&n.push(r)}),n}function AP(e){var t;return!(!((t=e==null?void 0:e.automaticFunctionCalling)===null||t===void 0)&&t.ignoreCallHistory)}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class FZ extends Bo{constructor(t){super(),this.apiClient=t,this.generateContent=async n=>{var i,r,s,a,o;const l=await this.processParamsMaybeAddMcpUsage(n);if(this.maybeMoveToResponseJsonSchem(n),!zZ(n)||CP(n.config))return await this.generateContentInternal(l);const u=$P(n);if(u.length>0){const y=u.map(M=>`tools[${M}]`).join(", ");throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${y}.`)}let c,f;const d=Xs(l.contents),h=(s=(r=(i=l.config)===null||i===void 0?void 0:i.automaticFunctionCalling)===null||r===void 0?void 0:r.maximumRemoteCalls)!==null&&s!==void 0?s:SP;let m=0;for(;m<h&&(c=await this.generateContentInternal(l),!(!c.functionCalls||c.functionCalls.length===0));){const y=c.candidates[0].content,M=[];for(const g of(o=(a=n.config)===null||a===void 0?void 0:a.tools)!==null&&o!==void 0?o:[])if(pd(g)){const T=await g.callTool(c.functionCalls);M.push(...T)}m++,f={role:"user",parts:M},l.contents=Xs(l.contents),l.contents.push(y),l.contents.push(f),AP(l.config)&&(d.push(y),d.push(f))}return AP(l.config)&&(c.automaticFunctionCallingHistory=d),c},this.generateContentStream=async n=>{var i,r,s,a,o;if(this.maybeMoveToResponseJsonSchem(n),CP(n.config)){const f=await this.processParamsMaybeAddMcpUsage(n);return await this.generateContentStreamInternal(f)}const l=$P(n);if(l.length>0){const f=l.map(d=>`tools[${d}]`).join(", ");throw new Error(`Incompatible tools found at ${f}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`)}const u=(s=(r=(i=n==null?void 0:n.config)===null||i===void 0?void 0:i.toolConfig)===null||r===void 0?void 0:r.functionCallingConfig)===null||s===void 0?void 0:s.streamFunctionCallArguments,c=(o=(a=n==null?void 0:n.config)===null||a===void 0?void 0:a.automaticFunctionCalling)===null||o===void 0?void 0:o.disable;if(u&&!c)throw new Error("Running in streaming mode with 'streamFunctionCallArguments' enabled, this feature is not compatible with automatic function calling (AFC). Please set 'config.automaticFunctionCalling.disable' to true to disable AFC or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' to be undefined or set to false to disable streaming function call arguments feature.");return await this.processAfcStream(n)},this.generateImages=async n=>await this.generateImagesInternal(n).then(i=>{var r;let s;const a=[];if(i!=null&&i.generatedImages)for(const l of i.generatedImages)l&&(l!=null&&l.safetyAttributes)&&((r=l==null?void 0:l.safetyAttributes)===null||r===void 0?void 0:r.contentType)==="Positive Prompt"?s=l==null?void 0:l.safetyAttributes:a.push(l);let o;return s?o={generatedImages:a,positivePromptSafetyAttributes:s,sdkHttpResponse:i.sdkHttpResponse}:o={generatedImages:a,sdkHttpResponse:i.sdkHttpResponse},o}),this.list=async n=>{var i;const a={config:Object.assign(Object.assign({},{queryBase:!0}),n==null?void 0:n.config)};if(this.apiClient.isVertexAI()&&!a.config.queryBase){if(!((i=a.config)===null||i===void 0)&&i.filter)throw new Error("Filtering tuned models list for Vertex AI is not currently supported");a.config.filter="labels.tune-type:*"}return new cc(zo.PAGED_ITEM_MODELS,o=>this.listInternal(o),await this.listInternal(a),a)},this.editImage=async n=>{const i={model:n.model,prompt:n.prompt,referenceImages:[],config:n.config};return n.referenceImages&&n.referenceImages&&(i.referenceImages=n.referenceImages.map(r=>r.toReferenceImageAPI())),await this.editImageInternal(i)},this.upscaleImage=async n=>{let i={numberOfImages:1,mode:"upscale"};n.config&&(i=Object.assign(Object.assign({},i),n.config));const r={model:n.model,image:n.image,upscaleFactor:n.upscaleFactor,config:i};return await this.upscaleImageInternal(r)},this.generateVideos=async n=>{var i,r,s,a,o,l;if((n.prompt||n.image||n.video)&&n.source)throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");return this.apiClient.isVertexAI()||(!((i=n.video)===null||i===void 0)&&i.uri&&(!((r=n.video)===null||r===void 0)&&r.videoBytes)?n.video={uri:n.video.uri,mimeType:n.video.mimeType}:!((a=(s=n.source)===null||s===void 0?void 0:s.video)===null||a===void 0)&&a.uri&&(!((l=(o=n.source)===null||o===void 0?void 0:o.video)===null||l===void 0)&&l.videoBytes)&&(n.source.video={uri:n.source.video.uri,mimeType:n.source.video.mimeType})),await this.generateVideosInternal(n)}}maybeMoveToResponseJsonSchem(t){t.config&&t.config.responseSchema&&(t.config.responseJsonSchema||Object.keys(t.config.responseSchema).includes("$schema")&&(t.config.responseJsonSchema=t.config.responseSchema,delete t.config.responseSchema))}async processParamsMaybeAddMcpUsage(t){var n,i,r;const s=(n=t.config)===null||n===void 0?void 0:n.tools;if(!s)return t;const a=await Promise.all(s.map(async l=>pd(l)?await l.tool():l)),o={model:t.model,contents:t.contents,config:Object.assign(Object.assign({},t.config),{tools:a})};if(o.config.tools=a,t.config&&t.config.tools&&iU(t.config.tools)){const l=(r=(i=t.config.httpOptions)===null||i===void 0?void 0:i.headers)!==null&&r!==void 0?r:{};let u=Object.assign({},l);Object.keys(u).length===0&&(u=this.apiClient.getDefaultHeaders()),rU(u),o.config.httpOptions=Object.assign(Object.assign({},t.config.httpOptions),{headers:u})}return o}async initAfcToolsMap(t){var n,i,r;const s=new Map;for(const a of(i=(n=t.config)===null||n===void 0?void 0:n.tools)!==null&&i!==void 0?i:[])if(pd(a)){const o=a,l=await o.tool();for(const u of(r=l.functionDeclarations)!==null&&r!==void 0?r:[]){if(!u.name)throw new Error("Function declaration name is required.");if(s.has(u.name))throw new Error(`Duplicate tool declaration name: ${u.name}`);s.set(u.name,o)}}return s}async processAfcStream(t){var n,i,r;const s=(r=(i=(n=t.config)===null||n===void 0?void 0:n.automaticFunctionCalling)===null||i===void 0?void 0:i.maximumRemoteCalls)!==null&&r!==void 0?r:SP;let a=!1,o=0;const l=await this.initAfcToolsMap(t);return function(u,c,f){return Ca(this,arguments,function*(){for(var d,h,m,y,M,g;o<s;){a&&(o++,a=!1);const S=yield fn(u.processParamsMaybeAddMcpUsage(f)),$=yield fn(u.generateContentStreamInternal(S)),C=[],P=[];try{for(var _=!0,T=(h=void 0,$a($)),x;x=yield fn(T.next()),d=x.done,!d;_=!0){y=x.value,_=!1;const O=y;if(yield yield fn(O),O.candidates&&(!((M=O.candidates[0])===null||M===void 0)&&M.content)){P.push(O.candidates[0].content);for(const R of(g=O.candidates[0].content.parts)!==null&&g!==void 0?g:[])if(o<s&&R.functionCall){if(!R.functionCall.name)throw new Error("Function call name was not returned by the model.");if(c.has(R.functionCall.name)){const G=yield fn(c.get(R.functionCall.name).callTool([R.functionCall]));C.push(...G)}else throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${c.keys()}, mising tool: ${R.functionCall.name}`)}}}}catch(O){h={error:O}}finally{try{!_&&!d&&(m=T.return)&&(yield fn(m.call(T)))}finally{if(h)throw h.error}}if(C.length>0){a=!0;const O=new Qd;O.candidates=[{content:{role:"user",parts:C}}],yield yield fn(O);const R=[];R.push(...P),R.push({role:"user",parts:C});const G=Xs(f.contents).concat(R);f.contents=G}else break}})}(this,l,t)}async generateContentInternal(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=xP(this.apiClient,t);return o=Dt("{model}:generateContent",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=MP(c),d=new Qd;return Object.assign(d,f),d})}else{const u=bP(this.apiClient,t);return o=Dt("{model}:generateContent",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=TP(c),d=new Qd;return Object.assign(d,f),d})}}async generateContentStreamInternal(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=xP(this.apiClient,t);return o=Dt("{model}:streamGenerateContent?alt=sse",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.requestStream({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}),a.then(function(f){return Ca(this,arguments,function*(){var d,h,m,y;try{for(var M=!0,g=$a(f),_;_=yield fn(g.next()),d=_.done,!d;M=!0){y=_.value,M=!1;const T=y,x=MP(yield fn(T.json()));x.sdkHttpResponse={headers:T.headers};const S=new Qd;Object.assign(S,x),yield yield fn(S)}}catch(T){h={error:T}}finally{try{!M&&!d&&(m=g.return)&&(yield fn(m.call(g)))}finally{if(h)throw h.error}}})})}else{const u=bP(this.apiClient,t);return o=Dt("{model}:streamGenerateContent?alt=sse",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.requestStream({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}),a.then(function(f){return Ca(this,arguments,function*(){var d,h,m,y;try{for(var M=!0,g=$a(f),_;_=yield fn(g.next()),d=_.done,!d;M=!0){y=_.value,M=!1;const T=y,x=TP(yield fn(T.json()));x.sdkHttpResponse={headers:T.headers};const S=new Qd;Object.assign(S,x),yield yield fn(S)}}catch(T){h={error:T}}finally{try{!M&&!d&&(m=g.return)&&(yield fn(m.call(g)))}finally{if(h)throw h.error}}})})}}async embedContent(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=DX(this.apiClient,t);return o=Dt("{model}:predict",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=RX(c),d=new rP;return Object.assign(d,f),d})}else{const u=kX(this.apiClient,t);return o=Dt("{model}:batchEmbedContents",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=OX(c),d=new rP;return Object.assign(d,f),d})}}async generateImagesInternal(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=HX(this.apiClient,t);return o=Dt("{model}:predict",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=KX(c),d=new sP;return Object.assign(d,f),d})}else{const u=WX(this.apiClient,t);return o=Dt("{model}:predict",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=qX(c),d=new sP;return Object.assign(d,f),d})}}async editImageInternal(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI()){const o=$X(this.apiClient,t);return s=Dt("{model}:predict",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json().then(u=>{const c=u;return c.sdkHttpResponse={headers:l.headers},c})),r.then(l=>{const u=AX(l),c=new L7;return Object.assign(c,u),c})}else throw new Error("This method is only supported by the Vertex AI.")}async upscaleImageInternal(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI()){const o=HQ(this.apiClient,t);return s=Dt("{model}:predict",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json().then(u=>{const c=u;return c.sdkHttpResponse={headers:l.headers},c})),r.then(l=>{const u=qQ(l),c=new z7;return Object.assign(c,u),c})}else throw new Error("This method is only supported by the Vertex AI.")}async recontextImage(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI()){const o=CQ(this.apiClient,t);return s=Dt("{model}:predict",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>{const u=$Q(l),c=new F7;return Object.assign(c,u),c})}else throw new Error("This method is only supported by the Vertex AI.")}async segmentImage(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI()){const o=OQ(this.apiClient,t);return s=Dt("{model}:predict",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>{const u=RQ(l),c=new B7;return Object.assign(c,u),c})}else throw new Error("This method is only supported by the Vertex AI.")}async get(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=dQ(this.apiClient,t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json()),a.then(c=>Ib(c))}else{const u=cQ(this.apiClient,t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json()),a.then(c=>Ab(c))}}async listInternal(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=wQ(this.apiClient,t);return o=Dt("{models_url}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=xQ(c),d=new aP;return Object.assign(d,f),d})}else{const u=vQ(this.apiClient,t);return o=Dt("{models_url}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=bQ(c),d=new aP;return Object.assign(d,f),d})}}async update(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=jQ(this.apiClient,t);return o=Dt("{model}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"PATCH",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json()),a.then(c=>Ib(c))}else{const u=GQ(this.apiClient,t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"PATCH",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json()),a.then(c=>Ab(c))}}async delete(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=MX(this.apiClient,t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"DELETE",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=SX(c),d=new oP;return Object.assign(d,f),d})}else{const u=TX(this.apiClient,t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"DELETE",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=EX(c),d=new oP;return Object.assign(d,f),d})}}async countTokens(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=wX(this.apiClient,t);return o=Dt("{model}:countTokens",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=xX(c),d=new lP;return Object.assign(d,f),d})}else{const u=vX(this.apiClient,t);return o=Dt("{model}:countTokens",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=bX(c),d=new lP;return Object.assign(d,f),d})}}async computeTokens(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI()){const o=fX(this.apiClient,t);return s=Dt("{model}:computeTokens",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json().then(u=>{const c=u;return c.sdkHttpResponse={headers:l.headers},c})),r.then(l=>{const u=pX(l),c=new U7;return Object.assign(c,u),c})}else throw new Error("This method is only supported by the Vertex AI.")}async generateVideosInternal(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=eQ(this.apiClient,t);return o=Dt("{model}:predictLongRunning",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json()),a.then(c=>{const f=QX(c),d=new lg;return Object.assign(d,f),d})}else{const u=ZX(this.apiClient,t);return o=Dt("{model}:predictLongRunning",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json()),a.then(c=>{const f=XX(c),d=new lg;return Object.assign(d,f),d})}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class BZ extends Bo{constructor(t){super(),this.apiClient=t}async getVideosOperation(t){const n=t.operation,i=t.config;if(n.name===void 0||n.name==="")throw new Error("Operation name is required.");if(this.apiClient.isVertexAI()){const r=n.name.split("/operations/")[0];let s;i&&"httpOptions"in i&&(s=i.httpOptions);const a=await this.fetchPredictVideosOperationInternal({operationName:n.name,resourceName:r,config:{httpOptions:s}});return n._fromAPIResponse({apiResponse:a,_isVertexAI:!0})}else{const r=await this.getVideosOperationInternal({operationName:n.name,config:i});return n._fromAPIResponse({apiResponse:r,_isVertexAI:!1})}}async get(t){const n=t.operation,i=t.config;if(n.name===void 0||n.name==="")throw new Error("Operation name is required.");if(this.apiClient.isVertexAI()){const r=n.name.split("/operations/")[0];let s;i&&"httpOptions"in i&&(s=i.httpOptions);const a=await this.fetchPredictVideosOperationInternal({operationName:n.name,resourceName:r,config:{httpOptions:s}});return n._fromAPIResponse({apiResponse:a,_isVertexAI:!0})}else{const r=await this.getVideosOperationInternal({operationName:n.name,config:i});return n._fromAPIResponse({apiResponse:r,_isVertexAI:!1})}}async getVideosOperationInternal(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=P7(t);return o=Dt("{operationName}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json()),a}else{const u=I7(t);return o=Dt("{operationName}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json()),a}}async fetchPredictVideosOperationInternal(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI()){const o=T7(t);return s=Dt("{resourceName}:fetchPredictOperation",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r}else throw new Error("This method is only supported by the Vertex AI.")}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function UZ(e){const t={},n=w(e,["data"]);if(n!=null&&b(t,["data"],n),w(e,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function VZ(e){const t={},n=w(e,["parts"]);if(n!=null){let r=n;Array.isArray(r)&&(r=r.map(s=>XZ(s))),b(t,["parts"],r)}const i=w(e,["role"]);return i!=null&&b(t,["role"],i),t}function GZ(e,t,n){const i={},r=w(t,["expireTime"]);n!==void 0&&r!=null&&b(n,["expireTime"],r);const s=w(t,["newSessionExpireTime"]);n!==void 0&&s!=null&&b(n,["newSessionExpireTime"],s);const a=w(t,["uses"]);n!==void 0&&a!=null&&b(n,["uses"],a);const o=w(t,["liveConnectConstraints"]);n!==void 0&&o!=null&&b(n,["bidiGenerateContentSetup"],YZ(e,o));const l=w(t,["lockAdditionalFields"]);return n!==void 0&&l!=null&&b(n,["fieldMask"],l),i}function jZ(e,t){const n={},i=w(t,["config"]);return i!=null&&b(n,["config"],GZ(e,i,n)),n}function WZ(e){const t={};if(w(e,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const n=w(e,["fileUri"]);n!=null&&b(t,["fileUri"],n);const i=w(e,["mimeType"]);return i!=null&&b(t,["mimeType"],i),t}function HZ(e){const t={},n=w(e,["id"]);n!=null&&b(t,["id"],n);const i=w(e,["args"]);i!=null&&b(t,["args"],i);const r=w(e,["name"]);if(r!=null&&b(t,["name"],r),w(e,["partialArgs"])!==void 0)throw new Error("partialArgs parameter is not supported in Gemini API.");if(w(e,["willContinue"])!==void 0)throw new Error("willContinue parameter is not supported in Gemini API.");return t}function qZ(e){const t={};if(w(e,["authConfig"])!==void 0)throw new Error("authConfig parameter is not supported in Gemini API.");const n=w(e,["enableWidget"]);return n!=null&&b(t,["enableWidget"],n),t}function KZ(e){const t={};if(w(e,["excludeDomains"])!==void 0)throw new Error("excludeDomains parameter is not supported in Gemini API.");if(w(e,["blockingConfidence"])!==void 0)throw new Error("blockingConfidence parameter is not supported in Gemini API.");const n=w(e,["timeRangeFilter"]);return n!=null&&b(t,["timeRangeFilter"],n),t}function JZ(e,t){const n={},i=w(e,["generationConfig"]);t!==void 0&&i!=null&&b(t,["setup","generationConfig"],i);const r=w(e,["responseModalities"]);t!==void 0&&r!=null&&b(t,["setup","generationConfig","responseModalities"],r);const s=w(e,["temperature"]);t!==void 0&&s!=null&&b(t,["setup","generationConfig","temperature"],s);const a=w(e,["topP"]);t!==void 0&&a!=null&&b(t,["setup","generationConfig","topP"],a);const o=w(e,["topK"]);t!==void 0&&o!=null&&b(t,["setup","generationConfig","topK"],o);const l=w(e,["maxOutputTokens"]);t!==void 0&&l!=null&&b(t,["setup","generationConfig","maxOutputTokens"],l);const u=w(e,["mediaResolution"]);t!==void 0&&u!=null&&b(t,["setup","generationConfig","mediaResolution"],u);const c=w(e,["seed"]);t!==void 0&&c!=null&&b(t,["setup","generationConfig","seed"],c);const f=w(e,["speechConfig"]);t!==void 0&&f!=null&&b(t,["setup","generationConfig","speechConfig"],kx(f));const d=w(e,["thinkingConfig"]);t!==void 0&&d!=null&&b(t,["setup","generationConfig","thinkingConfig"],d);const h=w(e,["enableAffectiveDialog"]);t!==void 0&&h!=null&&b(t,["setup","generationConfig","enableAffectiveDialog"],h);const m=w(e,["systemInstruction"]);t!==void 0&&m!=null&&b(t,["setup","systemInstruction"],VZ(zr(m)));const y=w(e,["tools"]);if(t!==void 0&&y!=null){let $=Fd(y);Array.isArray($)&&($=$.map(C=>ZZ(zd(C)))),b(t,["setup","tools"],$)}const M=w(e,["sessionResumption"]);t!==void 0&&M!=null&&b(t,["setup","sessionResumption"],QZ(M));const g=w(e,["inputAudioTranscription"]);t!==void 0&&g!=null&&b(t,["setup","inputAudioTranscription"],g);const _=w(e,["outputAudioTranscription"]);t!==void 0&&_!=null&&b(t,["setup","outputAudioTranscription"],_);const T=w(e,["realtimeInputConfig"]);t!==void 0&&T!=null&&b(t,["setup","realtimeInputConfig"],T);const x=w(e,["contextWindowCompression"]);t!==void 0&&x!=null&&b(t,["setup","contextWindowCompression"],x);const S=w(e,["proactivity"]);if(t!==void 0&&S!=null&&b(t,["setup","proactivity"],S),w(e,["explicitVadSignal"])!==void 0)throw new Error("explicitVadSignal parameter is not supported in Gemini API.");return n}function YZ(e,t){const n={},i=w(t,["model"]);i!=null&&b(n,["setup","model"],ti(e,i));const r=w(t,["config"]);return r!=null&&b(n,["config"],JZ(r,n)),n}function XZ(e){const t={},n=w(e,["mediaResolution"]);n!=null&&b(t,["mediaResolution"],n);const i=w(e,["codeExecutionResult"]);i!=null&&b(t,["codeExecutionResult"],i);const r=w(e,["executableCode"]);r!=null&&b(t,["executableCode"],r);const s=w(e,["fileData"]);s!=null&&b(t,["fileData"],WZ(s));const a=w(e,["functionCall"]);a!=null&&b(t,["functionCall"],HZ(a));const o=w(e,["functionResponse"]);o!=null&&b(t,["functionResponse"],o);const l=w(e,["inlineData"]);l!=null&&b(t,["inlineData"],UZ(l));const u=w(e,["text"]);u!=null&&b(t,["text"],u);const c=w(e,["thought"]);c!=null&&b(t,["thought"],c);const f=w(e,["thoughtSignature"]);f!=null&&b(t,["thoughtSignature"],f);const d=w(e,["videoMetadata"]);return d!=null&&b(t,["videoMetadata"],d),t}function QZ(e){const t={},n=w(e,["handle"]);if(n!=null&&b(t,["handle"],n),w(e,["transparent"])!==void 0)throw new Error("transparent parameter is not supported in Gemini API.");return t}function ZZ(e){const t={},n=w(e,["functionDeclarations"]);if(n!=null){let c=n;Array.isArray(c)&&(c=c.map(f=>f)),b(t,["functionDeclarations"],c)}if(w(e,["retrieval"])!==void 0)throw new Error("retrieval parameter is not supported in Gemini API.");const i=w(e,["googleSearchRetrieval"]);i!=null&&b(t,["googleSearchRetrieval"],i);const r=w(e,["computerUse"]);r!=null&&b(t,["computerUse"],r);const s=w(e,["fileSearch"]);s!=null&&b(t,["fileSearch"],s);const a=w(e,["codeExecution"]);if(a!=null&&b(t,["codeExecution"],a),w(e,["enterpriseWebSearch"])!==void 0)throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");const o=w(e,["googleMaps"]);o!=null&&b(t,["googleMaps"],qZ(o));const l=w(e,["googleSearch"]);l!=null&&b(t,["googleSearch"],KZ(l));const u=w(e,["urlContext"]);return u!=null&&b(t,["urlContext"],u),t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function eee(e){const t=[];for(const n in e)if(Object.prototype.hasOwnProperty.call(e,n)){const i=e[n];if(typeof i=="object"&&i!=null&&Object.keys(i).length>0){const r=Object.keys(i).map(s=>`${n}.${s}`);t.push(...r)}else t.push(n)}return t.join(",")}function tee(e,t){let n=null;const i=e.bidiGenerateContentSetup;if(typeof i=="object"&&i!==null&&"setup"in i){const s=i.setup;typeof s=="object"&&s!==null?(e.bidiGenerateContentSetup=s,n=s):delete e.bidiGenerateContentSetup}else i!==void 0&&delete e.bidiGenerateContentSetup;const r=e.fieldMask;if(n){const s=eee(n);if(Array.isArray(t==null?void 0:t.lockAdditionalFields)&&(t==null?void 0:t.lockAdditionalFields.length)===0)s?e.fieldMask=s:delete e.fieldMask;else if(t!=null&&t.lockAdditionalFields&&t.lockAdditionalFields.length>0&&r!==null&&Array.isArray(r)&&r.length>0){const a=["temperature","topK","topP","maxOutputTokens","responseModalities","seed","speechConfig"];let o=[];r.length>0&&(o=r.map(u=>a.includes(u)?`generationConfig.${u}`:u));const l=[];s&&l.push(s),o.length>0&&l.push(...o),l.length>0?e.fieldMask=l.join(","):delete e.fieldMask}else delete e.fieldMask}else r!==null&&Array.isArray(r)&&r.length>0?e.fieldMask=r.join(","):delete e.fieldMask;return e}class nee extends Bo{constructor(t){super(),this.apiClient=t}async create(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");{const o=jZ(this.apiClient,t);s=Dt("auth_tokens",o._url),a=o._query,delete o.config,delete o._url,delete o._query;const l=tee(o,t.config);return r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(l),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(u=>u.json()),r.then(u=>u)}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function iee(e,t){const n={},i=w(e,["force"]);return t!==void 0&&i!=null&&b(t,["_query","force"],i),n}function ree(e){const t={},n=w(e,["name"]);n!=null&&b(t,["_url","name"],n);const i=w(e,["config"]);return i!=null&&iee(i,t),t}function see(e){const t={},n=w(e,["name"]);return n!=null&&b(t,["_url","name"],n),t}function aee(e,t){const n={},i=w(e,["pageSize"]);t!==void 0&&i!=null&&b(t,["_query","pageSize"],i);const r=w(e,["pageToken"]);return t!==void 0&&r!=null&&b(t,["_query","pageToken"],r),n}function oee(e){const t={},n=w(e,["parent"]);n!=null&&b(t,["_url","parent"],n);const i=w(e,["config"]);return i!=null&&aee(i,t),t}function lee(e){const t={},n=w(e,["sdkHttpResponse"]);n!=null&&b(t,["sdkHttpResponse"],n);const i=w(e,["nextPageToken"]);i!=null&&b(t,["nextPageToken"],i);const r=w(e,["documents"]);if(r!=null){let s=r;Array.isArray(s)&&(s=s.map(a=>a)),b(t,["documents"],s)}return t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class uee extends Bo{constructor(t){super(),this.apiClient=t,this.list=async n=>new cc(zo.PAGED_ITEM_DOCUMENTS,i=>this.listInternal({parent:n.parent,config:i.config}),await this.listInternal(n),n)}async get(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=see(t);return s=Dt("{name}",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>l)}}async delete(t){var n,i;let r="",s={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const a=ree(t);r=Dt("{name}",a._url),s=a._query,delete a._url,delete a._query,await this.apiClient.request({path:r,queryParams:s,body:JSON.stringify(a),httpMethod:"DELETE",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal})}}async listInternal(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=oee(t);return s=Dt("{parent}/documents",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>{const u=lee(l),c=new V7;return Object.assign(c,u),c})}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class cee extends Bo{constructor(t,n=new uee(t)){super(),this.apiClient=t,this.documents=n,this.list=async(i={})=>new cc(zo.PAGED_ITEM_FILE_SEARCH_STORES,r=>this.listInternal(r),await this.listInternal(i),i)}async uploadToFileSearchStore(t){if(this.apiClient.isVertexAI())throw new Error("Vertex AI does not support uploading files to a file search store.");return this.apiClient.uploadFileToFileSearchStore(t.fileSearchStoreName,t.file,t.config)}async create(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=eZ(t);return s=Dt("fileSearchStores",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>l)}}async get(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=iZ(t);return s=Dt("{name}",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>l)}}async delete(t){var n,i;let r="",s={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const a=nZ(t);r=Dt("{name}",a._url),s=a._query,delete a._url,delete a._query,await this.apiClient.request({path:r,queryParams:s,body:JSON.stringify(a),httpMethod:"DELETE",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal})}}async listInternal(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=uZ(t);return s=Dt("fileSearchStores",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>{const u=cZ(l),c=new G7;return Object.assign(c,u),c})}}async uploadToFileSearchStoreInternal(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=dZ(t);return s=Dt("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>{const u=fZ(l),c=new j7;return Object.assign(c,u),c})}}async importFile(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=aZ(t);return s=Dt("{file_search_store_name}:importFile",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json()),r.then(l=>{const u=sZ(l),c=new Cx;return Object.assign(c,u),c})}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */let sU=function(){const{crypto:e}=globalThis;if(e!=null&&e.randomUUID)return sU=e.randomUUID.bind(e),e.randomUUID();const t=new Uint8Array(1),n=e?()=>e.getRandomValues(t)[0]:()=>Math.random()*255&255;return"10000000-1000-4000-8000-100000000000".replace(/[018]/g,i=>(+i^n()&15>>+i/4).toString(16))};const dee=()=>sU();/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function kb(e){return typeof e=="object"&&e!==null&&("name"in e&&e.name==="AbortError"||"message"in e&&String(e.message).includes("FetchRequestCanceledException"))}const Db=e=>{if(e instanceof Error)return e;if(typeof e=="object"&&e!==null){try{if(Object.prototype.toString.call(e)==="[object Error]"){const t=new Error(e.message,e.cause?{cause:e.cause}:{});return e.stack&&(t.stack=e.stack),e.cause&&!t.cause&&(t.cause=e.cause),e.name&&(t.name=e.name),t}}catch{}try{return new Error(JSON.stringify(e))}catch{}}return new Error(e)};/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class ta extends Error{}class Kr extends ta{constructor(t,n,i,r){super(`${Kr.makeMessage(t,n,i)}`),this.status=t,this.headers=r,this.error=n}static makeMessage(t,n,i){const r=n!=null&&n.message?typeof n.message=="string"?n.message:JSON.stringify(n.message):n?JSON.stringify(n):i;return t&&r?`${t} ${r}`:t?`${t} status code (no body)`:r||"(no status code or body)"}static generate(t,n,i,r){if(!t||!r)return new t_({message:i,cause:Db(n)});const s=n;return t===400?new oU(t,s,i,r):t===401?new lU(t,s,i,r):t===403?new uU(t,s,i,r):t===404?new cU(t,s,i,r):t===409?new dU(t,s,i,r):t===422?new fU(t,s,i,r):t===429?new pU(t,s,i,r):t>=500?new hU(t,s,i,r):new Kr(t,s,i,r)}}class Ob extends Kr{constructor({message:t}={}){super(void 0,void 0,t||"Request was aborted.",void 0)}}class t_ extends Kr{constructor({message:t,cause:n}){super(void 0,void 0,t||"Connection error.",void 0),n&&(this.cause=n)}}class aU extends t_{constructor({message:t}={}){super({message:t??"Request timed out."})}}class oU extends Kr{}class lU extends Kr{}class uU extends Kr{}class cU extends Kr{}class dU extends Kr{}class fU extends Kr{}class pU extends Kr{}class hU extends Kr{}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const fee=/^[a-z][a-z0-9+.-]*:/i,pee=e=>fee.test(e);let Rb=e=>(Rb=Array.isArray,Rb(e));const hee=Rb;let mee=hee;const IP=mee;function gee(e){if(!e)return!0;for(const t in e)return!1;return!0}function _ee(e,t){return Object.prototype.hasOwnProperty.call(e,t)}const yee=(e,t)=>{if(typeof t!="number"||!Number.isInteger(t))throw new ta(`${e} must be an integer`);if(t<0)throw new ta(`${e} must be a positive integer`);return t},vee=e=>{try{return JSON.parse(e)}catch{return}};/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const wee=e=>new Promise(t=>setTimeout(t,e));/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const zc="0.0.1";/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function bee(){return typeof Deno<"u"&&Deno.build!=null?"deno":typeof EdgeRuntime<"u"?"edge":Object.prototype.toString.call(typeof globalThis.process<"u"?globalThis.process:0)==="[object process]"?"node":"unknown"}const xee=()=>{var e,t,n,i,r;const s=bee();if(s==="deno")return{"X-Stainless-Lang":"js","X-Stainless-Package-Version":zc,"X-Stainless-OS":kP(Deno.build.os),"X-Stainless-Arch":PP(Deno.build.arch),"X-Stainless-Runtime":"deno","X-Stainless-Runtime-Version":typeof Deno.version=="string"?Deno.version:(t=(e=Deno.version)===null||e===void 0?void 0:e.deno)!==null&&t!==void 0?t:"unknown"};if(typeof EdgeRuntime<"u")return{"X-Stainless-Lang":"js","X-Stainless-Package-Version":zc,"X-Stainless-OS":"Unknown","X-Stainless-Arch":`other:${EdgeRuntime}`,"X-Stainless-Runtime":"edge","X-Stainless-Runtime-Version":globalThis.process.version};if(s==="node")return{"X-Stainless-Lang":"js","X-Stainless-Package-Version":zc,"X-Stainless-OS":kP((n=globalThis.process.platform)!==null&&n!==void 0?n:"unknown"),"X-Stainless-Arch":PP((i=globalThis.process.arch)!==null&&i!==void 0?i:"unknown"),"X-Stainless-Runtime":"node","X-Stainless-Runtime-Version":(r=globalThis.process.version)!==null&&r!==void 0?r:"unknown"};const a=Tee();return a?{"X-Stainless-Lang":"js","X-Stainless-Package-Version":zc,"X-Stainless-OS":"Unknown","X-Stainless-Arch":"unknown","X-Stainless-Runtime":`browser:${a.browser}`,"X-Stainless-Runtime-Version":a.version}:{"X-Stainless-Lang":"js","X-Stainless-Package-Version":zc,"X-Stainless-OS":"Unknown","X-Stainless-Arch":"unknown","X-Stainless-Runtime":"unknown","X-Stainless-Runtime-Version":"unknown"}};function Tee(){if(typeof navigator>"u"||!navigator)return null;const e=[{key:"edge",pattern:/Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"ie",pattern:/MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"ie",pattern:/Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"chrome",pattern:/Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"firefox",pattern:/Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"safari",pattern:/(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/}];for(const{key:t,pattern:n}of e){const i=n.exec(navigator.userAgent);if(i){const r=i[1]||0,s=i[2]||0,a=i[3]||0;return{browser:t,version:`${r}.${s}.${a}`}}}return null}const PP=e=>e==="x32"?"x32":e==="x86_64"||e==="x64"?"x64":e==="arm"?"arm":e==="aarch64"||e==="arm64"?"arm64":e?`other:${e}`:"unknown",kP=e=>(e=e.toLowerCase(),e.includes("ios")?"iOS":e==="android"?"Android":e==="darwin"?"MacOS":e==="win32"?"Windows":e==="freebsd"?"FreeBSD":e==="openbsd"?"OpenBSD":e==="linux"?"Linux":e?`Other:${e}`:"Unknown");let xh;const Mee=()=>xh??(xh=xee());/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Eee(){if(typeof fetch<"u")return fetch;throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new GeminiNextGenAPIClient({ fetch })` or polyfill the global, `globalThis.fetch = fetch`")}function mU(...e){const t=globalThis.ReadableStream;if(typeof t>"u")throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");return new t(...e)}function See(e){let t=Symbol.asyncIterator in e?e[Symbol.asyncIterator]():e[Symbol.iterator]();return mU({start(){},async pull(n){const{done:i,value:r}=await t.next();i?n.close():n.enqueue(r)},async cancel(){var n;await((n=t.return)===null||n===void 0?void 0:n.call(t))}})}function gU(e){if(e[Symbol.asyncIterator])return e;const t=e.getReader();return{async next(){try{const n=await t.read();return n!=null&&n.done&&t.releaseLock(),n}catch(n){throw t.releaseLock(),n}},async return(){const n=t.cancel();return t.releaseLock(),await n,{done:!0,value:void 0}},[Symbol.asyncIterator](){return this}}}async function Cee(e){var t,n;if(e===null||typeof e!="object")return;if(e[Symbol.asyncIterator]){await((n=(t=e[Symbol.asyncIterator]()).return)===null||n===void 0?void 0:n.call(t));return}const i=e.getReader(),r=i.cancel();i.releaseLock(),await r}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const $ee=({headers:e,body:t})=>({bodyHeaders:{"content-type":"application/json"},body:JSON.stringify(t)});/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const _U=()=>{var e;if(typeof File>"u"){const{process:t}=globalThis,n=typeof((e=t==null?void 0:t.versions)===null||e===void 0?void 0:e.node)=="string"&&parseInt(t.versions.node.split("."))<20;throw new Error("`File` is not defined as a global, which is required for file uploads."+(n?" Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`.":""))}};function g0(e,t,n){return _U(),new File(e,t??"unknown_file",n)}function Aee(e){return(typeof e=="object"&&e!==null&&("name"in e&&e.name&&String(e.name)||"url"in e&&e.url&&String(e.url)||"filename"in e&&e.filename&&String(e.filename)||"path"in e&&e.path&&String(e.path))||"").split(/[\\/]/).pop()||void 0}const Iee=e=>e!=null&&typeof e=="object"&&typeof e[Symbol.asyncIterator]=="function";/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const yU=e=>e!=null&&typeof e=="object"&&typeof e.size=="number"&&typeof e.type=="string"&&typeof e.text=="function"&&typeof e.slice=="function"&&typeof e.arrayBuffer=="function",Pee=e=>e!=null&&typeof e=="object"&&typeof e.name=="string"&&typeof e.lastModified=="number"&&yU(e),kee=e=>e!=null&&typeof e=="object"&&typeof e.url=="string"&&typeof e.blob=="function";async function Dee(e,t,n){if(_U(),e=await e,Pee(e))return e instanceof File?e:g0([await e.arrayBuffer()],e.name);if(kee(e)){const r=await e.blob();return t||(t=new URL(e.url).pathname.split(/[\\/]/).pop()),g0(await Nb(r),t,n)}const i=await Nb(e);if(t||(t=Aee(e)),!(n!=null&&n.type)){const r=i.find(s=>typeof s=="object"&&"type"in s&&s.type);typeof r=="string"&&(n=Object.assign(Object.assign({},n),{type:r}))}return g0(i,t,n)}async function Nb(e){var t,n,i,r,s;let a=[];if(typeof e=="string"||ArrayBuffer.isView(e)||e instanceof ArrayBuffer)a.push(e);else if(yU(e))a.push(e instanceof Blob?e:await e.arrayBuffer());else if(Iee(e))try{for(var o=!0,l=$a(e),u;u=await l.next(),t=u.done,!t;o=!0){r=u.value,o=!1;const c=r;a.push(...await Nb(c))}}catch(c){n={error:c}}finally{try{!o&&!t&&(i=l.return)&&await i.call(l)}finally{if(n)throw n.error}}else{const c=(s=e==null?void 0:e.constructor)===null||s===void 0?void 0:s.name;throw new Error(`Unexpected data type: ${typeof e}${c?`; constructor: ${c}`:""}${Oee(e)}`)}return a}function Oee(e){return typeof e!="object"||e===null?"":`; props: [${Object.getOwnPropertyNames(e).map(n=>`"${n}"`).join(", ")}]`}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class vU{constructor(t){this._client=t}}vU._key=[];/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function wU(e){return e.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g,encodeURIComponent)}const DP=Object.freeze(Object.create(null)),Ree=(e=wU)=>function(n,...i){if(n.length===1)return n[0];let r=!1;const s=[],a=n.reduce((c,f,d)=>{var h,m,y;/[?#]/.test(f)&&(r=!0);const M=i[d];let g=(r?encodeURIComponent:e)(""+M);return d!==i.length&&(M==null||typeof M=="object"&&M.toString===((y=Object.getPrototypeOf((m=Object.getPrototypeOf((h=M.hasOwnProperty)!==null&&h!==void 0?h:DP))!==null&&m!==void 0?m:DP))===null||y===void 0?void 0:y.toString))&&(g=M+"",s.push({start:c.length+f.length,length:g.length,error:`Value of type ${Object.prototype.toString.call(M).slice(8,-1)} is not a valid path parameter`})),c+f+(d===i.length?"":g)},""),o=a.split(/[?#]/,1)[0],l=new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)","gi");let u;for(;(u=l.exec(o))!==null;)s.push({start:u.index,length:u[0].length,error:`Value "${u[0]}" can't be safely passed as a path parameter`});if(s.sort((c,f)=>c.start-f.start),s.length>0){let c=0;const f=s.reduce((d,h)=>{const m=" ".repeat(h.start-c),y="^".repeat(h.length);return c=h.start+h.length,d+m+y},"");throw new ta(`Path parameters result in path with invalid segments:
${s.map(d=>d.error).join(`
`)}
${a}
${f}`)}return a},Th=Ree(wU);/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class bU extends vU{create(t,n){var i;const{api_version:r=this._client.apiVersion}=t,s=cg(t,["api_version"]);if("model"in s&&"agent_config"in s)throw new ta("Invalid request: specified `model` and `agent_config`. If specifying `model`, use `generation_config`.");if("agent"in s&&"generation_config"in s)throw new ta("Invalid request: specified `agent` and `generation_config`. If specifying `agent`, use `agent_config`.");return this._client.post(Th`/${r}/interactions`,Object.assign(Object.assign({body:s},n),{stream:(i=t.stream)!==null&&i!==void 0?i:!1}))}delete(t,n={},i){const{api_version:r=this._client.apiVersion}=n??{};return this._client.delete(Th`/${r}/interactions/${t}`,i)}cancel(t,n={},i){const{api_version:r=this._client.apiVersion}=n??{};return this._client.post(Th`/${r}/interactions/${t}/cancel`,i)}get(t,n={},i){var r;const s=n??{},{api_version:a=this._client.apiVersion}=s,o=cg(s,["api_version"]);return this._client.get(Th`/${a}/interactions/${t}`,Object.assign(Object.assign({query:o},i),{stream:(r=n==null?void 0:n.stream)!==null&&r!==void 0?r:!1}))}}bU._key=Object.freeze(["interactions"]);class xU extends bU{}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Nee(e){let t=0;for(const r of e)t+=r.length;const n=new Uint8Array(t);let i=0;for(const r of e)n.set(r,i),i+=r.length;return n}let Mh;function Ox(e){let t;return(Mh??(t=new globalThis.TextEncoder,Mh=t.encode.bind(t)))(e)}let Eh;function OP(e){let t;return(Eh??(t=new globalThis.TextDecoder,Eh=t.decode.bind(t)))(e)}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class n_{constructor(){this.buffer=new Uint8Array,this.carriageReturnIndex=null}decode(t){if(t==null)return[];const n=t instanceof ArrayBuffer?new Uint8Array(t):typeof t=="string"?Ox(t):t;this.buffer=Nee([this.buffer,n]);const i=[];let r;for(;(r=Lee(this.buffer,this.carriageReturnIndex))!=null;){if(r.carriage&&this.carriageReturnIndex==null){this.carriageReturnIndex=r.index;continue}if(this.carriageReturnIndex!=null&&(r.index!==this.carriageReturnIndex+1||r.carriage)){i.push(OP(this.buffer.subarray(0,this.carriageReturnIndex-1))),this.buffer=this.buffer.subarray(this.carriageReturnIndex),this.carriageReturnIndex=null;continue}const s=this.carriageReturnIndex!==null?r.preceding-1:r.preceding,a=OP(this.buffer.subarray(0,s));i.push(a),this.buffer=this.buffer.subarray(r.index),this.carriageReturnIndex=null}return i}flush(){return this.buffer.length?this.decode(`
`):[]}}n_.NEWLINE_CHARS=new Set([`
`,"\r"]);n_.NEWLINE_REGEXP=/\r\n|[\n\r]/g;function Lee(e,t){for(let r=t??0;r<e.length;r++){if(e[r]===10)return{preceding:r,index:r+1,carriage:!1};if(e[r]===13)return{preceding:r,index:r+1,carriage:!0}}return null}function zee(e){for(let i=0;i<e.length-1;i++){if(e[i]===10&&e[i+1]===10||e[i]===13&&e[i+1]===13)return i+2;if(e[i]===13&&e[i+1]===10&&i+3<e.length&&e[i+2]===13&&e[i+3]===10)return i+4}return-1}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const dg={off:0,error:200,warn:300,info:400,debug:500},RP=(e,t,n)=>{if(e){if(_ee(dg,e))return e;Hr(n).warn(`${t} was set to ${JSON.stringify(e)}, expected one of ${JSON.stringify(Object.keys(dg))}`)}};function Af(){}function Sh(e,t,n){return!t||dg[e]>dg[n]?Af:t[e].bind(t)}const Fee={error:Af,warn:Af,info:Af,debug:Af};let NP=new WeakMap;function Hr(e){var t;const n=e.logger,i=(t=e.logLevel)!==null&&t!==void 0?t:"off";if(!n)return Fee;const r=NP.get(n);if(r&&r[0]===i)return r[1];const s={error:Sh("error",n,i),warn:Sh("warn",n,i),info:Sh("info",n,i),debug:Sh("debug",n,i)};return NP.set(n,[i,s]),s}const $u=e=>(e.options&&(e.options=Object.assign({},e.options),delete e.options.headers),e.headers&&(e.headers=Object.fromEntries((e.headers instanceof Headers?[...e.headers]:Object.entries(e.headers)).map(([t,n])=>[t,t.toLowerCase()==="x-goog-api-key"||t.toLowerCase()==="authorization"||t.toLowerCase()==="cookie"||t.toLowerCase()==="set-cookie"?"***":n]))),"retryOfRequestLogID"in e&&(e.retryOfRequestLogID&&(e.retryOf=e.retryOfRequestLogID),delete e.retryOfRequestLogID),e);/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class ed{constructor(t,n,i){this.iterator=t,this.controller=n,this.client=i}static fromSSEResponse(t,n,i){let r=!1;const s=i?Hr(i):console;function a(){return Ca(this,arguments,function*(){var l,u,c,f;if(r)throw new ta("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");r=!0;let d=!1;try{try{for(var h=!0,m=$a(Bee(t,n)),y;y=yield fn(m.next()),l=y.done,!l;h=!0){f=y.value,h=!1;const M=f;if(!d)if(M.data.startsWith("[DONE]")){d=!0;continue}else try{yield yield fn(JSON.parse(M.data))}catch(g){throw s.error("Could not parse message into JSON:",M.data),s.error("From chunk:",M.raw),g}}}catch(M){u={error:M}}finally{try{!h&&!l&&(c=m.return)&&(yield fn(c.call(m)))}finally{if(u)throw u.error}}d=!0}catch(M){if(kb(M))return yield fn(void 0);throw M}finally{d||n.abort()}})}return new ed(a,n,i)}static fromReadableStream(t,n,i){let r=!1;function s(){return Ca(this,arguments,function*(){var l,u,c,f;const d=new n_,h=gU(t);try{for(var m=!0,y=$a(h),M;M=yield fn(y.next()),l=M.done,!l;m=!0){f=M.value,m=!1;const g=f;for(const _ of d.decode(g))yield yield fn(_)}}catch(g){u={error:g}}finally{try{!m&&!l&&(c=y.return)&&(yield fn(c.call(y)))}finally{if(u)throw u.error}}for(const g of d.flush())yield yield fn(g)})}function a(){return Ca(this,arguments,function*(){var l,u,c,f;if(r)throw new ta("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");r=!0;let d=!1;try{try{for(var h=!0,m=$a(s()),y;y=yield fn(m.next()),l=y.done,!l;h=!0){f=y.value,h=!1;const M=f;d||M&&(yield yield fn(JSON.parse(M)))}}catch(M){u={error:M}}finally{try{!h&&!l&&(c=m.return)&&(yield fn(c.call(m)))}finally{if(u)throw u.error}}d=!0}catch(M){if(kb(M))return yield fn(void 0);throw M}finally{d||n.abort()}})}return new ed(a,n,i)}[Symbol.asyncIterator](){return this.iterator()}tee(){const t=[],n=[],i=this.iterator(),r=s=>({next:()=>{if(s.length===0){const a=i.next();t.push(a),n.push(a)}return s.shift()}});return[new ed(()=>r(t),this.controller,this.client),new ed(()=>r(n),this.controller,this.client)]}toReadableStream(){const t=this;let n;return mU({async start(){n=t[Symbol.asyncIterator]()},async pull(i){try{const{value:r,done:s}=await n.next();if(s)return i.close();const a=Ox(JSON.stringify(r)+`
`);i.enqueue(a)}catch(r){i.error(r)}},async cancel(){var i;await((i=n.return)===null||i===void 0?void 0:i.call(n))}})}}function Bee(e,t){return Ca(this,arguments,function*(){var i,r,s,a;if(!e.body)throw t.abort(),typeof globalThis.navigator<"u"&&globalThis.navigator.product==="ReactNative"?new ta("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api"):new ta("Attempted to iterate over a response with no body");const o=new Vee,l=new n_,u=gU(e.body);try{for(var c=!0,f=$a(Uee(u)),d;d=yield fn(f.next()),i=d.done,!i;c=!0){a=d.value,c=!1;const h=a;for(const m of l.decode(h)){const y=o.decode(m);y&&(yield yield fn(y))}}}catch(h){r={error:h}}finally{try{!c&&!i&&(s=f.return)&&(yield fn(s.call(f)))}finally{if(r)throw r.error}}for(const h of l.flush()){const m=o.decode(h);m&&(yield yield fn(m))}})}function Uee(e){return Ca(this,arguments,function*(){var n,i,r,s;let a=new Uint8Array;try{for(var o=!0,l=$a(e),u;u=yield fn(l.next()),n=u.done,!n;o=!0){s=u.value,o=!1;const c=s;if(c==null)continue;const f=c instanceof ArrayBuffer?new Uint8Array(c):typeof c=="string"?Ox(c):c;let d=new Uint8Array(a.length+f.length);d.set(a),d.set(f,a.length),a=d;let h;for(;(h=zee(a))!==-1;)yield yield fn(a.slice(0,h)),a=a.slice(h)}}catch(c){i={error:c}}finally{try{!o&&!n&&(r=l.return)&&(yield fn(r.call(l)))}finally{if(i)throw i.error}}a.length>0&&(yield yield fn(a))})}class Vee{constructor(){this.event=null,this.data=[],this.chunks=[]}decode(t){if(t.endsWith("\r")&&(t=t.substring(0,t.length-1)),!t){if(!this.event&&!this.data.length)return null;const s={event:this.event,data:this.data.join(`
`),raw:this.chunks};return this.event=null,this.data=[],this.chunks=[],s}if(this.chunks.push(t),t.startsWith(":"))return null;let[n,i,r]=Gee(t,":");return r.startsWith(" ")&&(r=r.substring(1)),n==="event"?this.event=r:n==="data"&&this.data.push(r),null}}function Gee(e,t){const n=e.indexOf(t);return n!==-1?[e.substring(0,n),t,e.substring(n+t.length)]:[e,"",""]}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */async function jee(e,t){const{response:n,requestLogID:i,retryOfRequestLogID:r,startTime:s}=t,a=await(async()=>{var o;if(t.options.stream)return Hr(e).debug("response",n.status,n.url,n.headers,n.body),t.options.__streamClass?t.options.__streamClass.fromSSEResponse(n,t.controller,e):ed.fromSSEResponse(n,t.controller,e);if(n.status===204)return null;if(t.options.__binaryResponse)return n;const l=n.headers.get("content-type"),u=(o=l==null?void 0:l.split(";")[0])===null||o===void 0?void 0:o.trim();return(u==null?void 0:u.includes("application/json"))||(u==null?void 0:u.endsWith("+json"))?await n.json():await n.text()})();return Hr(e).debug(`[${i}] response parsed`,$u({retryOfRequestLogID:r,url:n.url,status:n.status,body:a,durationMs:Date.now()-s})),a}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Rx extends Promise{constructor(t,n,i=jee){super(r=>{r(null)}),this.responsePromise=n,this.parseResponse=i,this.client=t}_thenUnwrap(t){return new Rx(this.client,this.responsePromise,async(n,i)=>t(await this.parseResponse(n,i),i))}asResponse(){return this.responsePromise.then(t=>t.response)}async withResponse(){const[t,n]=await Promise.all([this.parse(),this.asResponse()]);return{data:t,response:n}}parse(){return this.parsedPromise||(this.parsedPromise=this.responsePromise.then(t=>this.parseResponse(this.client,t))),this.parsedPromise}then(t,n){return this.parse().then(t,n)}catch(t){return this.parse().catch(t)}finally(t){return this.parse().finally(t)}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const TU=Symbol("brand.privateNullableHeaders");function*Wee(e){if(!e)return;if(TU in e){const{values:i,nulls:r}=e;yield*i.entries();for(const s of r)yield[s,null];return}let t=!1,n;e instanceof Headers?n=e.entries():IP(e)?n=e:(t=!0,n=Object.entries(e??{}));for(let i of n){const r=i[0];if(typeof r!="string")throw new TypeError("expected header name to be a string");const s=IP(i[1])?i[1]:[i[1]];let a=!1;for(const o of s)o!==void 0&&(t&&!a&&(a=!0,yield[r,null]),yield[r,o])}}const Zd=e=>{const t=new Headers,n=new Set;for(const i of e){const r=new Set;for(const[s,a]of Wee(i)){const o=s.toLowerCase();r.has(o)||(t.delete(s),r.add(o)),a===null?(t.delete(s),n.add(o)):(t.append(s,a),n.delete(o))}}return{[TU]:!0,values:t,nulls:n}};/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const _0=e=>{var t,n,i,r,s,a;if(typeof globalThis.process<"u")return(i=(n=(t=_7)===null||t===void 0?void 0:t[e])===null||n===void 0?void 0:n.trim())!==null&&i!==void 0?i:void 0;if(typeof globalThis.Deno<"u")return(a=(s=(r=globalThis.Deno.env)===null||r===void 0?void 0:r.get)===null||s===void 0?void 0:s.call(r,e))===null||a===void 0?void 0:a.trim()};/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var MU;class i_{constructor(t){var n,i,r,s,a,o,l,{baseURL:u=_0("GEMINI_NEXT_GEN_API_BASE_URL"),apiKey:c=(n=_0("GEMINI_API_KEY"))!==null&&n!==void 0?n:null,apiVersion:f="v1beta"}=t,d=cg(t,["baseURL","apiKey","apiVersion"]);const h=Object.assign(Object.assign({apiKey:c,apiVersion:f},d),{baseURL:u||"https://generativelanguage.googleapis.com"});this.baseURL=h.baseURL,this.timeout=(i=h.timeout)!==null&&i!==void 0?i:i_.DEFAULT_TIMEOUT,this.logger=(r=h.logger)!==null&&r!==void 0?r:console;const m="warn";this.logLevel=m,this.logLevel=(a=(s=RP(h.logLevel,"ClientOptions.logLevel",this))!==null&&s!==void 0?s:RP(_0("GEMINI_NEXT_GEN_API_LOG"),"process.env['GEMINI_NEXT_GEN_API_LOG']",this))!==null&&a!==void 0?a:m,this.fetchOptions=h.fetchOptions,this.maxRetries=(o=h.maxRetries)!==null&&o!==void 0?o:2,this.fetch=(l=h.fetch)!==null&&l!==void 0?l:Eee(),this.encoder=$ee,this._options=h,this.apiKey=c,this.apiVersion=f,this.clientAdapter=h.clientAdapter}withOptions(t){return new this.constructor(Object.assign(Object.assign(Object.assign({},this._options),{baseURL:this.baseURL,maxRetries:this.maxRetries,timeout:this.timeout,logger:this.logger,logLevel:this.logLevel,fetch:this.fetch,fetchOptions:this.fetchOptions,apiKey:this.apiKey,apiVersion:this.apiVersion}),t))}baseURLOverridden(){return this.baseURL!=="https://generativelanguage.googleapis.com"}defaultQuery(){return this._options.defaultQuery}validateHeaders({values:t,nulls:n}){if(!(t.has("authorization")||t.has("x-goog-api-key"))&&!(this.apiKey&&t.get("x-goog-api-key"))&&!n.has("x-goog-api-key"))throw new Error('Could not resolve authentication method. Expected the apiKey to be set. Or for the "x-goog-api-key" headers to be explicitly omitted')}async authHeaders(t){const n=Zd([t.headers]);if(!(n.values.has("authorization")||n.values.has("x-goog-api-key"))){if(this.apiKey)return Zd([{"x-goog-api-key":this.apiKey}]);if(this.clientAdapter.isVertexAI())return Zd([await this.clientAdapter.getAuthHeaders()])}}stringifyQuery(t){return Object.entries(t).filter(([n,i])=>typeof i<"u").map(([n,i])=>{if(typeof i=="string"||typeof i=="number"||typeof i=="boolean")return`${encodeURIComponent(n)}=${encodeURIComponent(i)}`;if(i===null)return`${encodeURIComponent(n)}=`;throw new ta(`Cannot stringify type ${typeof i}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`)}).join("&")}getUserAgent(){return`${this.constructor.name}/JS ${zc}`}defaultIdempotencyKey(){return`stainless-node-retry-${dee()}`}makeStatusError(t,n,i,r){return Kr.generate(t,n,i,r)}buildURL(t,n,i){const r=!this.baseURLOverridden()&&i||this.baseURL,s=pee(t)?new URL(t):new URL(r+(r.endsWith("/")&&t.startsWith("/")?t.slice(1):t)),a=this.defaultQuery();return gee(a)||(n=Object.assign(Object.assign({},a),n)),typeof n=="object"&&n&&!Array.isArray(n)&&(s.search=this.stringifyQuery(n)),s.toString()}async prepareOptions(t){if(this.clientAdapter&&this.clientAdapter.isVertexAI()&&!t.path.startsWith(`/${this.apiVersion}/projects/`)){const n=t.path.slice(this.apiVersion.length+1);t.path=`/${this.apiVersion}/projects/${this.clientAdapter.getProject()}/locations/${this.clientAdapter.getLocation()}${n}`}}async prepareRequest(t,{url:n,options:i}){}get(t,n){return this.methodRequest("get",t,n)}post(t,n){return this.methodRequest("post",t,n)}patch(t,n){return this.methodRequest("patch",t,n)}put(t,n){return this.methodRequest("put",t,n)}delete(t,n){return this.methodRequest("delete",t,n)}methodRequest(t,n,i){return this.request(Promise.resolve(i).then(r=>Object.assign({method:t,path:n},r)))}request(t,n=null){return new Rx(this,this.makeRequest(t,n,void 0))}async makeRequest(t,n,i){var r,s,a;const o=await t,l=(r=o.maxRetries)!==null&&r!==void 0?r:this.maxRetries;n==null&&(n=l),await this.prepareOptions(o);const{req:u,url:c,timeout:f}=await this.buildRequest(o,{retryCount:l-n});await this.prepareRequest(u,{url:c,options:o});const d="log_"+(Math.random()*(1<<24)|0).toString(16).padStart(6,"0"),h=i===void 0?"":`, retryOf: ${i}`,m=Date.now();if(Hr(this).debug(`[${d}] sending request`,$u({retryOfRequestLogID:i,method:o.method,url:c,options:o,headers:u.headers})),!((s=o.signal)===null||s===void 0)&&s.aborted)throw new Ob;const y=new AbortController,M=await this.fetchWithTimeout(c,u,f,y).catch(Db),g=Date.now();if(M instanceof globalThis.Error){const T=`retrying, ${n} attempts remaining`;if(!((a=o.signal)===null||a===void 0)&&a.aborted)throw new Ob;const x=kb(M)||/timed? ?out/i.test(String(M)+("cause"in M?String(M.cause):""));if(n)return Hr(this).info(`[${d}] connection ${x?"timed out":"failed"} - ${T}`),Hr(this).debug(`[${d}] connection ${x?"timed out":"failed"} (${T})`,$u({retryOfRequestLogID:i,url:c,durationMs:g-m,message:M.message})),this.retryRequest(o,n,i??d);throw Hr(this).info(`[${d}] connection ${x?"timed out":"failed"} - error; no more retries left`),Hr(this).debug(`[${d}] connection ${x?"timed out":"failed"} (error; no more retries left)`,$u({retryOfRequestLogID:i,url:c,durationMs:g-m,message:M.message})),x?new aU:new t_({cause:M})}const _=`[${d}${h}] ${u.method} ${c} ${M.ok?"succeeded":"failed"} with status ${M.status} in ${g-m}ms`;if(!M.ok){const T=await this.shouldRetry(M);if(n&&T){const O=`retrying, ${n} attempts remaining`;return await Cee(M.body),Hr(this).info(`${_} - ${O}`),Hr(this).debug(`[${d}] response error (${O})`,$u({retryOfRequestLogID:i,url:M.url,status:M.status,headers:M.headers,durationMs:g-m})),this.retryRequest(o,n,i??d,M.headers)}const x=T?"error; no more retries left":"error; not retryable";Hr(this).info(`${_} - ${x}`);const S=await M.text().catch(O=>Db(O).message),$=vee(S),C=$?void 0:S;throw Hr(this).debug(`[${d}] response error (${x})`,$u({retryOfRequestLogID:i,url:M.url,status:M.status,headers:M.headers,message:C,durationMs:Date.now()-m})),this.makeStatusError(M.status,$,C,M.headers)}return Hr(this).info(_),Hr(this).debug(`[${d}] response start`,$u({retryOfRequestLogID:i,url:M.url,status:M.status,headers:M.headers,durationMs:g-m})),{response:M,options:o,controller:y,requestLogID:d,retryOfRequestLogID:i,startTime:m}}async fetchWithTimeout(t,n,i,r){const s=n||{},{signal:a,method:o}=s,l=cg(s,["signal","method"]);a&&a.addEventListener("abort",()=>r.abort());const u=setTimeout(()=>r.abort(),i),c=globalThis.ReadableStream&&l.body instanceof globalThis.ReadableStream||typeof l.body=="object"&&l.body!==null&&Symbol.asyncIterator in l.body,f=Object.assign(Object.assign(Object.assign({signal:r.signal},c?{duplex:"half"}:{}),{method:"GET"}),l);o&&(f.method=o.toUpperCase());try{return await this.fetch.call(void 0,t,f)}finally{clearTimeout(u)}}async shouldRetry(t){const n=t.headers.get("x-should-retry");return n==="true"?!0:n==="false"?!1:t.status===408||t.status===409||t.status===429||t.status>=500}async retryRequest(t,n,i,r){var s;let a;const o=r==null?void 0:r.get("retry-after-ms");if(o){const u=parseFloat(o);Number.isNaN(u)||(a=u)}const l=r==null?void 0:r.get("retry-after");if(l&&!a){const u=parseFloat(l);Number.isNaN(u)?a=Date.parse(l)-Date.now():a=u*1e3}if(!(a&&0<=a&&a<60*1e3)){const u=(s=t.maxRetries)!==null&&s!==void 0?s:this.maxRetries;a=this.calculateDefaultRetryTimeoutMillis(n,u)}return await wee(a),this.makeRequest(t,n-1,i)}calculateDefaultRetryTimeoutMillis(t,n){const s=n-t,a=Math.min(.5*Math.pow(2,s),8),o=1-Math.random()*.25;return a*o*1e3}async buildRequest(t,{retryCount:n=0}={}){var i,r,s;const a=Object.assign({},t),{method:o,path:l,query:u,defaultBaseURL:c}=a,f=this.buildURL(l,u,c);"timeout"in a&&yee("timeout",a.timeout),a.timeout=(i=a.timeout)!==null&&i!==void 0?i:this.timeout;const{bodyHeaders:d,body:h}=this.buildBody({options:a}),m=await this.buildHeaders({options:t,method:o,bodyHeaders:d,retryCount:n});return{req:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({method:o,headers:m},a.signal&&{signal:a.signal}),globalThis.ReadableStream&&h instanceof globalThis.ReadableStream&&{duplex:"half"}),h&&{body:h}),(r=this.fetchOptions)!==null&&r!==void 0?r:{}),(s=a.fetchOptions)!==null&&s!==void 0?s:{}),url:f,timeout:a.timeout}}async buildHeaders({options:t,method:n,bodyHeaders:i,retryCount:r}){let s={};this.idempotencyHeader&&n!=="get"&&(t.idempotencyKey||(t.idempotencyKey=this.defaultIdempotencyKey()),s[this.idempotencyHeader]=t.idempotencyKey);const a=await this.authHeaders(t);let o=Zd([s,Object.assign(Object.assign({Accept:"application/json","User-Agent":this.getUserAgent(),"X-Stainless-Retry-Count":String(r)},t.timeout?{"X-Stainless-Timeout":String(Math.trunc(t.timeout/1e3))}:{}),Mee()),this._options.defaultHeaders,i,t.headers,a]);return this.validateHeaders(o),o.values}buildBody({options:{body:t,headers:n}}){if(!t)return{bodyHeaders:void 0,body:void 0};const i=Zd([n]);return ArrayBuffer.isView(t)||t instanceof ArrayBuffer||t instanceof DataView||typeof t=="string"&&i.values.has("content-type")||globalThis.Blob&&t instanceof globalThis.Blob||t instanceof FormData||t instanceof URLSearchParams||globalThis.ReadableStream&&t instanceof globalThis.ReadableStream?{bodyHeaders:void 0,body:t}:typeof t=="object"&&(Symbol.asyncIterator in t||Symbol.iterator in t&&"next"in t&&typeof t.next=="function")?{bodyHeaders:void 0,body:See(t)}:this.encoder({body:t,headers:i})}}i_.DEFAULT_TIMEOUT=6e4;class Sr extends i_{constructor(){super(...arguments),this.interactions=new xU(this)}}MU=Sr;Sr.GeminiNextGenAPIClient=MU;Sr.GeminiNextGenAPIClientError=ta;Sr.APIError=Kr;Sr.APIConnectionError=t_;Sr.APIConnectionTimeoutError=aU;Sr.APIUserAbortError=Ob;Sr.NotFoundError=cU;Sr.ConflictError=dU;Sr.RateLimitError=pU;Sr.BadRequestError=oU;Sr.AuthenticationError=lU;Sr.InternalServerError=hU;Sr.PermissionDeniedError=uU;Sr.UnprocessableEntityError=fU;Sr.toFile=Dee;Sr.Interactions=xU;/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Hee(e,t){const n={},i=w(e,["name"]);return i!=null&&b(n,["_url","name"],i),n}function qee(e,t){const n={},i=w(e,["name"]);return i!=null&&b(n,["_url","name"],i),n}function Kee(e,t){const n={},i=w(e,["sdkHttpResponse"]);return i!=null&&b(n,["sdkHttpResponse"],i),n}function Jee(e,t){const n={},i=w(e,["sdkHttpResponse"]);return i!=null&&b(n,["sdkHttpResponse"],i),n}function Yee(e,t,n){const i={};if(w(e,["validationDataset"])!==void 0)throw new Error("validationDataset parameter is not supported in Gemini API.");const r=w(e,["tunedModelDisplayName"]);if(t!==void 0&&r!=null&&b(t,["displayName"],r),w(e,["description"])!==void 0)throw new Error("description parameter is not supported in Gemini API.");const s=w(e,["epochCount"]);t!==void 0&&s!=null&&b(t,["tuningTask","hyperparameters","epochCount"],s);const a=w(e,["learningRateMultiplier"]);if(a!=null&&b(i,["tuningTask","hyperparameters","learningRateMultiplier"],a),w(e,["exportLastCheckpointOnly"])!==void 0)throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");if(w(e,["preTunedModelCheckpointId"])!==void 0)throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");if(w(e,["adapterSize"])!==void 0)throw new Error("adapterSize parameter is not supported in Gemini API.");const o=w(e,["batchSize"]);t!==void 0&&o!=null&&b(t,["tuningTask","hyperparameters","batchSize"],o);const l=w(e,["learningRate"]);if(t!==void 0&&l!=null&&b(t,["tuningTask","hyperparameters","learningRate"],l),w(e,["labels"])!==void 0)throw new Error("labels parameter is not supported in Gemini API.");if(w(e,["beta"])!==void 0)throw new Error("beta parameter is not supported in Gemini API.");return i}function Xee(e,t,n){const i={};let r=w(n,["config","method"]);if(r===void 0&&(r="SUPERVISED_FINE_TUNING"),r==="SUPERVISED_FINE_TUNING"){const h=w(e,["validationDataset"]);t!==void 0&&h!=null&&b(t,["supervisedTuningSpec"],LP(h))}else if(r==="PREFERENCE_TUNING"){const h=w(e,["validationDataset"]);t!==void 0&&h!=null&&b(t,["preferenceOptimizationSpec"],LP(h))}const s=w(e,["tunedModelDisplayName"]);t!==void 0&&s!=null&&b(t,["tunedModelDisplayName"],s);const a=w(e,["description"]);t!==void 0&&a!=null&&b(t,["description"],a);let o=w(n,["config","method"]);if(o===void 0&&(o="SUPERVISED_FINE_TUNING"),o==="SUPERVISED_FINE_TUNING"){const h=w(e,["epochCount"]);t!==void 0&&h!=null&&b(t,["supervisedTuningSpec","hyperParameters","epochCount"],h)}else if(o==="PREFERENCE_TUNING"){const h=w(e,["epochCount"]);t!==void 0&&h!=null&&b(t,["preferenceOptimizationSpec","hyperParameters","epochCount"],h)}let l=w(n,["config","method"]);if(l===void 0&&(l="SUPERVISED_FINE_TUNING"),l==="SUPERVISED_FINE_TUNING"){const h=w(e,["learningRateMultiplier"]);t!==void 0&&h!=null&&b(t,["supervisedTuningSpec","hyperParameters","learningRateMultiplier"],h)}else if(l==="PREFERENCE_TUNING"){const h=w(e,["learningRateMultiplier"]);t!==void 0&&h!=null&&b(t,["preferenceOptimizationSpec","hyperParameters","learningRateMultiplier"],h)}let u=w(n,["config","method"]);if(u===void 0&&(u="SUPERVISED_FINE_TUNING"),u==="SUPERVISED_FINE_TUNING"){const h=w(e,["exportLastCheckpointOnly"]);t!==void 0&&h!=null&&b(t,["supervisedTuningSpec","exportLastCheckpointOnly"],h)}else if(u==="PREFERENCE_TUNING"){const h=w(e,["exportLastCheckpointOnly"]);t!==void 0&&h!=null&&b(t,["preferenceOptimizationSpec","exportLastCheckpointOnly"],h)}let c=w(n,["config","method"]);if(c===void 0&&(c="SUPERVISED_FINE_TUNING"),c==="SUPERVISED_FINE_TUNING"){const h=w(e,["adapterSize"]);t!==void 0&&h!=null&&b(t,["supervisedTuningSpec","hyperParameters","adapterSize"],h)}else if(c==="PREFERENCE_TUNING"){const h=w(e,["adapterSize"]);t!==void 0&&h!=null&&b(t,["preferenceOptimizationSpec","hyperParameters","adapterSize"],h)}if(w(e,["batchSize"])!==void 0)throw new Error("batchSize parameter is not supported in Vertex AI.");if(w(e,["learningRate"])!==void 0)throw new Error("learningRate parameter is not supported in Vertex AI.");const f=w(e,["labels"]);t!==void 0&&f!=null&&b(t,["labels"],f);const d=w(e,["beta"]);return t!==void 0&&d!=null&&b(t,["preferenceOptimizationSpec","hyperParameters","beta"],d),i}function Qee(e,t){const n={},i=w(e,["baseModel"]);i!=null&&b(n,["baseModel"],i);const r=w(e,["preTunedModel"]);r!=null&&b(n,["preTunedModel"],r);const s=w(e,["trainingDataset"]);s!=null&&ute(s);const a=w(e,["config"]);return a!=null&&Yee(a,n),n}function Zee(e,t){const n={},i=w(e,["baseModel"]);i!=null&&b(n,["baseModel"],i);const r=w(e,["preTunedModel"]);r!=null&&b(n,["preTunedModel"],r);const s=w(e,["trainingDataset"]);s!=null&&cte(s,n,t);const a=w(e,["config"]);return a!=null&&Xee(a,n,t),n}function ete(e,t){const n={},i=w(e,["name"]);return i!=null&&b(n,["_url","name"],i),n}function tte(e,t){const n={},i=w(e,["name"]);return i!=null&&b(n,["_url","name"],i),n}function nte(e,t,n){const i={},r=w(e,["pageSize"]);t!==void 0&&r!=null&&b(t,["_query","pageSize"],r);const s=w(e,["pageToken"]);t!==void 0&&s!=null&&b(t,["_query","pageToken"],s);const a=w(e,["filter"]);return t!==void 0&&a!=null&&b(t,["_query","filter"],a),i}function ite(e,t,n){const i={},r=w(e,["pageSize"]);t!==void 0&&r!=null&&b(t,["_query","pageSize"],r);const s=w(e,["pageToken"]);t!==void 0&&s!=null&&b(t,["_query","pageToken"],s);const a=w(e,["filter"]);return t!==void 0&&a!=null&&b(t,["_query","filter"],a),i}function rte(e,t){const n={},i=w(e,["config"]);return i!=null&&nte(i,n),n}function ste(e,t){const n={},i=w(e,["config"]);return i!=null&&ite(i,n),n}function ate(e,t){const n={},i=w(e,["sdkHttpResponse"]);i!=null&&b(n,["sdkHttpResponse"],i);const r=w(e,["nextPageToken"]);r!=null&&b(n,["nextPageToken"],r);const s=w(e,["tunedModels"]);if(s!=null){let a=s;Array.isArray(a)&&(a=a.map(o=>EU(o))),b(n,["tuningJobs"],a)}return n}function ote(e,t){const n={},i=w(e,["sdkHttpResponse"]);i!=null&&b(n,["sdkHttpResponse"],i);const r=w(e,["nextPageToken"]);r!=null&&b(n,["nextPageToken"],r);const s=w(e,["tuningJobs"]);if(s!=null){let a=s;Array.isArray(a)&&(a=a.map(o=>Lb(o))),b(n,["tuningJobs"],a)}return n}function lte(e,t){const n={},i=w(e,["name"]);i!=null&&b(n,["model"],i);const r=w(e,["name"]);return r!=null&&b(n,["endpoint"],r),n}function ute(e,t){const n={};if(w(e,["gcsUri"])!==void 0)throw new Error("gcsUri parameter is not supported in Gemini API.");if(w(e,["vertexDatasetResource"])!==void 0)throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");const i=w(e,["examples"]);if(i!=null){let r=i;Array.isArray(r)&&(r=r.map(s=>s)),b(n,["examples","examples"],r)}return n}function cte(e,t,n){const i={};let r=w(n,["config","method"]);if(r===void 0&&(r="SUPERVISED_FINE_TUNING"),r==="SUPERVISED_FINE_TUNING"){const a=w(e,["gcsUri"]);t!==void 0&&a!=null&&b(t,["supervisedTuningSpec","trainingDatasetUri"],a)}else if(r==="PREFERENCE_TUNING"){const a=w(e,["gcsUri"]);t!==void 0&&a!=null&&b(t,["preferenceOptimizationSpec","trainingDatasetUri"],a)}let s=w(n,["config","method"]);if(s===void 0&&(s="SUPERVISED_FINE_TUNING"),s==="SUPERVISED_FINE_TUNING"){const a=w(e,["vertexDatasetResource"]);t!==void 0&&a!=null&&b(t,["supervisedTuningSpec","trainingDatasetUri"],a)}else if(s==="PREFERENCE_TUNING"){const a=w(e,["vertexDatasetResource"]);t!==void 0&&a!=null&&b(t,["preferenceOptimizationSpec","trainingDatasetUri"],a)}if(w(e,["examples"])!==void 0)throw new Error("examples parameter is not supported in Vertex AI.");return i}function EU(e,t){const n={},i=w(e,["sdkHttpResponse"]);i!=null&&b(n,["sdkHttpResponse"],i);const r=w(e,["name"]);r!=null&&b(n,["name"],r);const s=w(e,["state"]);s!=null&&b(n,["state"],U4(s));const a=w(e,["createTime"]);a!=null&&b(n,["createTime"],a);const o=w(e,["tuningTask","startTime"]);o!=null&&b(n,["startTime"],o);const l=w(e,["tuningTask","completeTime"]);l!=null&&b(n,["endTime"],l);const u=w(e,["updateTime"]);u!=null&&b(n,["updateTime"],u);const c=w(e,["description"]);c!=null&&b(n,["description"],c);const f=w(e,["baseModel"]);f!=null&&b(n,["baseModel"],f);const d=w(e,["_self"]);return d!=null&&b(n,["tunedModel"],lte(d)),n}function Lb(e,t){const n={},i=w(e,["sdkHttpResponse"]);i!=null&&b(n,["sdkHttpResponse"],i);const r=w(e,["name"]);r!=null&&b(n,["name"],r);const s=w(e,["state"]);s!=null&&b(n,["state"],U4(s));const a=w(e,["createTime"]);a!=null&&b(n,["createTime"],a);const o=w(e,["startTime"]);o!=null&&b(n,["startTime"],o);const l=w(e,["endTime"]);l!=null&&b(n,["endTime"],l);const u=w(e,["updateTime"]);u!=null&&b(n,["updateTime"],u);const c=w(e,["error"]);c!=null&&b(n,["error"],c);const f=w(e,["description"]);f!=null&&b(n,["description"],f);const d=w(e,["baseModel"]);d!=null&&b(n,["baseModel"],d);const h=w(e,["tunedModel"]);h!=null&&b(n,["tunedModel"],h);const m=w(e,["preTunedModel"]);m!=null&&b(n,["preTunedModel"],m);const y=w(e,["supervisedTuningSpec"]);y!=null&&b(n,["supervisedTuningSpec"],y);const M=w(e,["preferenceOptimizationSpec"]);M!=null&&b(n,["preferenceOptimizationSpec"],M);const g=w(e,["tuningDataStats"]);g!=null&&b(n,["tuningDataStats"],g);const _=w(e,["encryptionSpec"]);_!=null&&b(n,["encryptionSpec"],_);const T=w(e,["partnerModelTuningSpec"]);T!=null&&b(n,["partnerModelTuningSpec"],T);const x=w(e,["customBaseModel"]);x!=null&&b(n,["customBaseModel"],x);const S=w(e,["experiment"]);S!=null&&b(n,["experiment"],S);const $=w(e,["labels"]);$!=null&&b(n,["labels"],$);const C=w(e,["outputUri"]);C!=null&&b(n,["outputUri"],C);const P=w(e,["pipelineJob"]);P!=null&&b(n,["pipelineJob"],P);const O=w(e,["serviceAccount"]);O!=null&&b(n,["serviceAccount"],O);const R=w(e,["tunedModelDisplayName"]);R!=null&&b(n,["tunedModelDisplayName"],R);const G=w(e,["veoTuningSpec"]);return G!=null&&b(n,["veoTuningSpec"],G),n}function dte(e,t){const n={},i=w(e,["sdkHttpResponse"]);i!=null&&b(n,["sdkHttpResponse"],i);const r=w(e,["name"]);r!=null&&b(n,["name"],r);const s=w(e,["metadata"]);s!=null&&b(n,["metadata"],s);const a=w(e,["done"]);a!=null&&b(n,["done"],a);const o=w(e,["error"]);return o!=null&&b(n,["error"],o),n}function LP(e,t){const n={},i=w(e,["gcsUri"]);i!=null&&b(n,["validationDatasetUri"],i);const r=w(e,["vertexDatasetResource"]);return r!=null&&b(n,["validationDatasetUri"],r),n}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class fte extends Bo{constructor(t){super(),this.apiClient=t,this.list=async(n={})=>new cc(zo.PAGED_ITEM_TUNING_JOBS,i=>this.listInternal(i),await this.listInternal(n),n),this.get=async n=>await this.getInternal(n),this.tune=async n=>{var i;if(this.apiClient.isVertexAI())if(n.baseModel.startsWith("projects/")){const r={tunedModelName:n.baseModel};!((i=n.config)===null||i===void 0)&&i.preTunedModelCheckpointId&&(r.checkpointId=n.config.preTunedModelCheckpointId);const s=Object.assign(Object.assign({},n),{preTunedModel:r});return s.baseModel=void 0,await this.tuneInternal(s)}else{const r=Object.assign({},n);return await this.tuneInternal(r)}else{const r=Object.assign({},n),s=await this.tuneMldevInternal(r);let a="";return s.metadata!==void 0&&s.metadata.tunedModel!==void 0?a=s.metadata.tunedModel:s.name!==void 0&&s.name.includes("/operations/")&&(a=s.name.split("/operations/")[0]),{name:a,state:Eb.JOB_STATE_QUEUED}}}}async getInternal(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=tte(t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>Lb(c))}else{const u=ete(t);return o=Dt("{name}",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>EU(c))}}async listInternal(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=ste(t);return o=Dt("tuningJobs",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=ote(c),d=new uP;return Object.assign(d,f),d})}else{const u=rte(t);return o=Dt("tunedModels",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=ate(c),d=new uP;return Object.assign(d,f),d})}}async cancel(t){var n,i,r,s;let a,o="",l={};if(this.apiClient.isVertexAI()){const u=qee(t);return o=Dt("{name}:cancel",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=Jee(c),d=new cP;return Object.assign(d,f),d})}else{const u=Hee(t);return o=Dt("{name}:cancel",u._url),l=u._query,delete u._url,delete u._query,a=this.apiClient.request({path:o,queryParams:l,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(r=t.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(s=t.config)===null||s===void 0?void 0:s.abortSignal}).then(c=>c.json().then(f=>{const d=f;return d.sdkHttpResponse={headers:c.headers},d})),a.then(c=>{const f=Kee(c),d=new cP;return Object.assign(d,f),d})}}async tuneInternal(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI()){const o=Zee(t,t);return s=Dt("tuningJobs",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json().then(u=>{const c=u;return c.sdkHttpResponse={headers:l.headers},c})),r.then(l=>Lb(l))}else throw new Error("This method is only supported by the Vertex AI.")}async tuneMldevInternal(t){var n,i;let r,s="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const o=Qee(t);return s=Dt("tunedModels",o._url),a=o._query,delete o._url,delete o._query,r=this.apiClient.request({path:s,queryParams:a,body:JSON.stringify(o),httpMethod:"POST",httpOptions:(n=t.config)===null||n===void 0?void 0:n.httpOptions,abortSignal:(i=t.config)===null||i===void 0?void 0:i.abortSignal}).then(l=>l.json().then(u=>{const c=u;return c.sdkHttpResponse={headers:l.headers},c})),r.then(l=>dte(l))}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class pte{async download(t,n){throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.")}}const hte=1024*1024*8,mte=3,gte=1e3,_te=2,fg="x-goog-upload-status";async function yte(e,t,n){var i;const r=await SU(e,t,n),s=await(r==null?void 0:r.json());if(((i=r==null?void 0:r.headers)===null||i===void 0?void 0:i[fg])!=="final")throw new Error("Failed to upload file: Upload status is not finalized.");return s.file}async function vte(e,t,n){var i;const r=await SU(e,t,n),s=await(r==null?void 0:r.json());if(((i=r==null?void 0:r.headers)===null||i===void 0?void 0:i[fg])!=="final")throw new Error("Failed to upload file: Upload status is not finalized.");const a=R4(s),o=new $x;return Object.assign(o,a),o}async function SU(e,t,n){var i,r;let s=0,a=0,o=new Sb(new Response),l="upload";for(s=e.size;a<s;){const u=Math.min(hte,s-a),c=e.slice(a,a+u);a+u>=s&&(l+=", finalize");let f=0,d=gte;for(;f<mte&&(o=await n.request({path:"",body:c,httpMethod:"POST",httpOptions:{apiVersion:"",baseUrl:t,headers:{"X-Goog-Upload-Command":l,"X-Goog-Upload-Offset":String(a),"Content-Length":String(u)}}}),!(!((i=o==null?void 0:o.headers)===null||i===void 0)&&i[fg]));)f++,await bte(d),d=d*_te;if(a+=u,((r=o==null?void 0:o.headers)===null||r===void 0?void 0:r[fg])!=="active")break;if(s<=a)throw new Error("All content has been uploaded, but the upload status is not finalized.")}return o}async function wte(e){return{size:e.size,type:e.type}}function bte(e){return new Promise(t=>setTimeout(t,e))}class xte{async upload(t,n,i){if(typeof t=="string")throw new Error("File path is not supported in browser uploader.");return await yte(t,n,i)}async uploadToFileSearchStore(t,n,i){if(typeof t=="string")throw new Error("File path is not supported in browser uploader.");return await vte(t,n,i)}async stat(t){if(typeof t=="string")throw new Error("File path is not supported in browser uploader.");return await wte(t)}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Tte{create(t,n,i){return new Mte(t,n,i)}}class Mte{constructor(t,n,i){this.url=t,this.headers=n,this.callbacks=i}connect(){this.ws=new WebSocket(this.url),this.ws.onopen=this.callbacks.onopen,this.ws.onerror=this.callbacks.onerror,this.ws.onclose=this.callbacks.onclose,this.ws.onmessage=this.callbacks.onmessage}send(t){if(this.ws===void 0)throw new Error("WebSocket is not connected");this.ws.send(t)}close(){if(this.ws===void 0)throw new Error("WebSocket is not connected");this.ws.close()}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const zP="x-goog-api-key";class Ete{constructor(t){this.apiKey=t}async addAuthHeaders(t,n){if(t.get(zP)===null){if(this.apiKey.startsWith("auth_tokens/"))throw new Error("Ephemeral tokens are only supported by the live API.");if(!this.apiKey)throw new Error("API key is missing. Please provide a valid API key.");t.append(zP,this.apiKey)}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Ste="gl-node/";class Nx{get interactions(){if(this._interactions!==void 0)return this._interactions;console.warn("GoogleGenAI.interactions: Interactions usage is experimental and may change in future versions.");const t=this.httpOptions;t!=null&&t.extraBody&&console.warn("GoogleGenAI.interactions: Client level httpOptions.extraBody is not supported by the interactions client and will be ignored.");const n=new Sr({baseURL:this.apiClient.getBaseUrl(),apiKey:this.apiKey,apiVersion:this.apiClient.getApiVersion(),clientAdapter:this.apiClient,defaultHeaders:this.apiClient.getDefaultHeaders(),timeout:t==null?void 0:t.timeout});return this._interactions=n.interactions,this._interactions}constructor(t){var n;if(t.apiKey==null)throw new Error("An API Key must be set when running in a browser");if(t.project||t.location)throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");this.vertexai=(n=t.vertexai)!==null&&n!==void 0?n:!1,this.apiKey=t.apiKey;const i=b7(t.httpOptions,t.vertexai,void 0,void 0);i&&(t.httpOptions?t.httpOptions.baseUrl=i:t.httpOptions={baseUrl:i}),this.apiVersion=t.apiVersion,this.httpOptions=t.httpOptions;const r=new Ete(this.apiKey);this.apiClient=new wZ({auth:r,apiVersion:this.apiVersion,apiKey:this.apiKey,vertexai:this.vertexai,httpOptions:this.httpOptions,userAgentExtra:Ste+"web",uploader:new xte,downloader:new pte}),this.models=new FZ(this.apiClient),this.live=new DZ(this.apiClient,r,new Tte),this.batches=new YJ(this.apiClient),this.chats=new PY(this.models,this.apiClient),this.caches=new $Y(this.apiClient),this.files=new UY(this.apiClient),this.operations=new BZ(this.apiClient),this.authTokens=new nee(this.apiClient),this.tunings=new fte(this.apiClient),this.fileSearchStores=new cee(this.apiClient)}}const Cte=e=>new Promise((t,n)=>{const i=new FileReader;i.onloadend=()=>{const s=i.result.split(",")[1];t(s)},i.onerror=n,i.readAsDataURL(e)}),$te=async(e,t,n,i,r,s,a)=>{if(!i)throw new Error("Gemini API Key is not set. Please add it in the settings.");if(!r)throw new Error("Model Name is not configured. Please add it in the settings.");try{const o=new Nx({apiKey:i}),u=`${t==="Auto Detect"?"First, auto-detect the source language of the following text.":`The source language is ${t}.`} Then, translate the text to ${n}.
Do not add any extra explanations, comments, or annotations. Return only the translated text.`,c=await o.models.generateContentStream({model:r,contents:e,config:{systemInstruction:u,thinkingConfig:{thinkingBudget:0}}});let f="";for await(const d of c){if(a.aborted)throw new DOMException("Translation cancelled by user.","AbortError");const h=d.text;h&&(f+=h,s(h))}return f.trim()}catch(o){throw console.error("Error translating text:",o),o instanceof DOMException&&o.name==="AbortError"?o:new Error("Gemini API request failed.")}},Ate=async(e,t,n,i)=>{var c;if(!n)throw new Error("Gemini API Key is not set. Please add it in the settings.");const r=new Nx({apiKey:n}),s=e.match(/^data:(image\/\w+);base64,(.*)$/);if(!s)throw new Error("Invalid image data URL format.");const a=s[1],o=s[2],l={inlineData:{mimeType:a,data:o}},u={text:`1. First, accurately extract all text from the provided image.
2. Then, translate the extracted text into ${t}.
3. Finally, return a single JSON object with two keys: "sourceText" containing the exact extracted text, and "translatedText" containing the translation. Do not include any other explanations or markdown formatting.`};try{const d=((c=(await r.models.generateContent({model:i,contents:{parts:[u,l]},config:{responseMimeType:"application/json",responseSchema:{type:Sa.OBJECT,properties:{sourceText:{type:Sa.STRING,description:"The text extracted from the image."},translatedText:{type:Sa.STRING,description:"The translated text."}},required:["sourceText","translatedText"]}}})).text)==null?void 0:c.trim())||"{}",h=JSON.parse(d);if(typeof h.sourceText=="string"&&typeof h.translatedText=="string")return h;throw new Error("Invalid JSON structure in API response.")}catch(f){throw console.error("Error translating image:",f),f instanceof SyntaxError?new Error("Failed to parse the response from the Gemini API. The response was not valid JSON."):new Error("Gemini API request for image translation failed.")}},FP=async(e,t,n,i,r)=>{var c;if(!n)throw new Error("Gemini API Key is not set. Please add it in the settings.");const s=new Nx({apiKey:n}),a=await Cte(e);let o=e.type;o.includes(";")&&(o=o.split(";")[0]),o||(o="audio/wav");const l={inlineData:{mimeType:o,data:a}},u=`Transcribe the following audio. The language is ${t}. Return only the transcribed text.`;try{const f=await s.models.generateContent({model:i,contents:{parts:[l,{text:u}]}});if(r!=null&&r.aborted)throw new DOMException("Transcription cancelled by user.","AbortError");return((c=f.text)==null?void 0:c.trim())||""}catch(f){throw console.error("Error transcribing audio:",f),f instanceof DOMException&&f.name==="AbortError"?f:new Error("Gemini API transcription request failed.")}},Ite=async(e,t,n,i,r,s,a,o)=>{var c,f,d,h;if(!i)throw new Error("OpenAI API Key is not set.");if(!r)throw new Error("Model Name is not configured.");if(!s)throw new Error("OpenAI API URL is not set.");const u=`${t==="Auto Detect"?"First, auto-detect the source language of the following text.":`The source language is ${t}.`} Then, translate the text to ${n}. Do not add any extra explanations, comments, or annotations. Return only the translated text.`;try{const m=await fetch(`${s}/v1/chat/completions`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${i}`},body:JSON.stringify({model:r,messages:[{role:"system",content:u},{role:"user",content:e}],temperature:1,stream:!0}),signal:o});if(!m.ok){if(o.aborted)throw new DOMException("Request aborted by user","AbortError");const _=await m.json();throw new Error(((c=_.error)==null?void 0:c.message)||`OpenAI API request failed with status ${m.status}`)}if(!m.body)throw new Error("Response body is null, cannot stream.");const y=m.body.getReader(),M=new TextDecoder;let g="";for(;;){const{done:_,value:T}=await y.read();if(_)break;const S=M.decode(T,{stream:!0}).split(`
`).filter($=>$.trim().startsWith("data:"));for(const $ of S){const C=$.replace(/^data: /,"").trim();if(C==="[DONE]")break;try{const O=(h=(d=(f=JSON.parse(C).choices)==null?void 0:f[0])==null?void 0:d.delta)==null?void 0:h.content;O&&(g+=O,a(O))}catch{}}}return g.trim()}catch(m){throw console.error("Error translating text with OpenAI:",m),m instanceof Error&&m.name==="AbortError"?m:new Error("OpenAI API request failed.")}},Pte=async(e,t,n,i,r)=>{var a,o,l;if(!n)throw new Error("OpenAI API Key is not set.");if(!r)throw new Error("OpenAI API URL is not set.");if(!e.startsWith("data:image/")||!e.includes(";base64,"))throw new Error("Invalid image data URL format. It must be a base64 encoded image data URL.");const s=`1. First, accurately extract all text from the provided image.
2. Then, translate the extracted text into ${t}.
3. Finally, return a single JSON object with two keys: "sourceText" containing the exact extracted text, and "translatedText" containing the translation. Do not include any other explanations, markdown formatting, or code fences.`;try{const u=await fetch(`${r}/v1/chat/completions`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${n}`},body:JSON.stringify({model:i,messages:[{role:"user",content:[{type:"text",text:s},{type:"image_url",image_url:{url:e}}]}],max_tokens:2048,response_format:{type:"json_object"},stream:!1})});if(!u.ok){const h=await u.json();throw new Error(((a=h.error)==null?void 0:a.message)||`OpenAI API image request failed with status ${u.status}`)}const f=(l=(o=(await u.json()).choices[0])==null?void 0:o.message)==null?void 0:l.content;if(!f)throw new Error("No content in OpenAI API response.");const d=JSON.parse(f);if(typeof d.sourceText=="string"&&typeof d.translatedText=="string")return d;throw new Error("Invalid JSON structure in API response.")}catch(u){throw console.error("Error translating image with OpenAI:",u),u instanceof SyntaxError?new Error("Failed to parse the response from the OpenAI API. The response was not valid JSON."):u instanceof Error?u:new Error("OpenAI API request for image translation failed.")}},BP=async(e,t,n,i,r)=>{var o;if(!n)throw new Error("OpenAI API Key is not set.");if(!i)throw new Error("OpenAI API URL is not set.");const s=new FormData,a=e.type.includes("wav")?"wav":"webm";s.append("file",e,`recording.${a}`),s.append("model","whisper-1"),t&&t!=="auto"&&s.append("language",t);try{const l=await fetch(`${i}/v1/audio/transcriptions`,{method:"POST",headers:{Authorization:`Bearer ${n}`},body:s,signal:r});if(!l.ok){if(r!=null&&r.aborted)throw new DOMException("Request aborted by user","AbortError");const c=await l.json();throw new Error(((o=c.error)==null?void 0:o.message)||`OpenAI API audio request failed with status ${l.status}`)}return(await l.json()).text||""}catch(l){throw console.error("Error transcribing audio with OpenAI:",l),l instanceof Error&&l.name==="AbortError"?l:new Error("OpenAI API request for audio transcription failed.")}},zb=(e,t)=>t.some(n=>e instanceof n);let UP,VP;function kte(){return UP||(UP=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function Dte(){return VP||(VP=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const Fb=new WeakMap,y0=new WeakMap,r_=new WeakMap;function Ote(e){const t=new Promise((n,i)=>{const r=()=>{e.removeEventListener("success",s),e.removeEventListener("error",a)},s=()=>{n(ju(e.result)),r()},a=()=>{i(e.error),r()};e.addEventListener("success",s),e.addEventListener("error",a)});return r_.set(t,e),t}function Rte(e){if(Fb.has(e))return;const t=new Promise((n,i)=>{const r=()=>{e.removeEventListener("complete",s),e.removeEventListener("error",a),e.removeEventListener("abort",a)},s=()=>{n(),r()},a=()=>{i(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",s),e.addEventListener("error",a),e.addEventListener("abort",a)});Fb.set(e,t)}let Bb={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return Fb.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return ju(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function CU(e){Bb=e(Bb)}function Nte(e){return Dte().includes(e)?function(...t){return e.apply(Ub(this),t),ju(this.request)}:function(...t){return ju(e.apply(Ub(this),t))}}function Lte(e){return typeof e=="function"?Nte(e):(e instanceof IDBTransaction&&Rte(e),zb(e,kte())?new Proxy(e,Bb):e)}function ju(e){if(e instanceof IDBRequest)return Ote(e);if(y0.has(e))return y0.get(e);const t=Lte(e);return t!==e&&(y0.set(e,t),r_.set(t,e)),t}const Ub=e=>r_.get(e);function zte(e,t,{blocked:n,upgrade:i,blocking:r,terminated:s}={}){const a=indexedDB.open(e,t),o=ju(a);return i&&a.addEventListener("upgradeneeded",l=>{i(ju(a.result),l.oldVersion,l.newVersion,ju(a.transaction),l)}),n&&a.addEventListener("blocked",l=>n(l.oldVersion,l.newVersion,l)),o.then(l=>{s&&l.addEventListener("close",()=>s()),r&&l.addEventListener("versionchange",u=>r(u.oldVersion,u.newVersion,u))}).catch(()=>{}),o}const Fte=["get","getKey","getAll","getAllKeys","count"],Bte=["put","add","delete","clear"],v0=new Map;function GP(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(v0.get(t))return v0.get(t);const n=t.replace(/FromIndex$/,""),i=t!==n,r=Bte.includes(n);if(!(n in(i?IDBIndex:IDBObjectStore).prototype)||!(r||Fte.includes(n)))return;const s=async function(a,...o){const l=this.transaction(a,r?"readwrite":"readonly");let u=l.store;return i&&(u=u.index(o.shift())),(await Promise.all([u[n](...o),r&&l.done]))[0]};return v0.set(t,s),s}CU(e=>({...e,get:(t,n,i)=>GP(t,n)||e.get(t,n,i),has:(t,n)=>!!GP(t,n)||e.has(t,n)}));const Ute=["continue","continuePrimaryKey","advance"],jP={},Vb=new WeakMap,$U=new WeakMap,Vte={get(e,t){if(!Ute.includes(t))return e[t];let n=jP[t];return n||(n=jP[t]=function(...i){Vb.set(this,$U.get(this)[t](...i))}),n}};async function*Gte(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,Vte);for($U.set(n,t),r_.set(n,Ub(t));t;)yield n,t=await(Vb.get(n)||t.continue()),Vb.delete(n)}function WP(e,t){return t===Symbol.asyncIterator&&zb(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&zb(e,[IDBIndex,IDBObjectStore])}CU(e=>({...e,get(t,n,i){return WP(t,n)?Gte:e.get(t,n,i)},has(t,n){return WP(t,n)||e.has(t,n)}}));const jte="offline-model-db",Wa="model-chunks",Vr="model-meta",ef="consolidated-models",Wte=3;class Hte{constructor(){fe(this,"dbPromise");fe(this,"controllers",new Map);fe(this,"isOpfsSupported");fe(this,"opfsRootPromise");this.dbPromise=zte(jte,Wte,{upgrade(t){t.objectStoreNames.contains(Wa)||t.createObjectStore(Wa,{keyPath:["modelName","chunkIndex"]}).createIndex("modelName","modelName",{unique:!1}),t.objectStoreNames.contains(Vr)||t.createObjectStore(Vr,{keyPath:"modelName"}),t.objectStoreNames.contains(ef)||t.createObjectStore(ef,{keyPath:"modelName"})}}),this.isOpfsSupported="getDirectory"in navigator.storage,this.opfsRootPromise=this.isOpfsSupported?navigator.storage.getDirectory().catch(t=>(console.error("Failed to get OPFS root directory:",t),null)):Promise.resolve(null),this.isOpfsSupported?console.log("Origin Private File System is supported and will be used for model storage."):console.log("Origin Private File System not supported, falling back to IndexedDB.")}async getOpfsRoot(){return this.opfsRootPromise}async startDownload(t,n,i,r){if(this.controllers.has(t)){console.warn(`Download for ${t} is already in progress.`);return}this.isOpfsSupported?await this.runOpfsDownload(t,n,i,r,!1):await this.runIdbDownload(t,n,i,r,!1)}async resumeDownload(t,n,i,r){this.controllers.has(t)||(this.isOpfsSupported?await this.runOpfsDownload(t,n,i,r,!0):await this.runIdbDownload(t,n,i,r,!0))}async runOpfsDownload(t,n,i,r,s){const a=new AbortController;this.controllers.set(t,a);let o=0,l=0;try{const u=await this.getOpfsRoot();if(!u)throw new Error("Could not access OPFS.");const c=await u.getFileHandle(t,{create:!0}),f=await this.getDb(),d=await f.get(Vr,t);if(s&&d&&d.total>0&&(l=d.total,o=(await c.getFile()).size,o>=l&&(console.warn(`Resuming download for ${t}, but existing file is complete or corrupt. Restarting.`),o=0)),l===0){const m=await fetch(n,{method:"HEAD",signal:a.signal});if(!m.ok)throw new Error(`Failed to get model info. Status: ${m.status}`);if(l=Number(m.headers.get("Content-Length")),isNaN(l)||l===0)throw new Error("Could not determine file size.");o=0}if(await f.put(Vr,{modelName:t,total:l,status:"downloading"}),r({downloaded:o,total:l,percent:l>0?o/l*100:0,status:"downloading"}),o<l){const m=await fetch(n,{headers:{Range:`bytes=${o}-`},signal:a.signal});if(!m.ok||!m.body)throw new Error(`Download request failed. Status: ${m.status}`);const y=await c.createWritable({keepExistingData:!0});await y.seek(o);const M=m.body.getReader();for(;;){const{done:g,value:_}=await M.read();if(g)break;await y.write(_),o+=_.length,r({downloaded:o,total:l,percent:o/l*100,status:"downloading"})}await y.close()}const h=await c.getFile();if(h.size!==l)throw new Error(`Final file size ${h.size} does not match expected size ${l}`);await f.put(Vr,{modelName:t,total:l,status:"completed"}),r({downloaded:l,total:l,percent:100,status:"completed"}),console.log(`Model ${t} downloaded to OPFS successfully.`)}catch(u){this.handleDownloadError(u,t,o,l,r)}finally{this.controllers.delete(t)}}async runIdbDownload(t,n,i,r,s){const a=new AbortController;this.controllers.set(t,a);let o=0,l=0,u=0;const c=5*1024*1024;try{const f=await this.getDb();if(s){const d=await f.get(Vr,t);if(!d||!d.total)return this.runIdbDownload(t,n,i,r,!1);l=d.total;const h=await f.getAllFromIndex(Wa,"modelName",t);o=h.reduce((m,y)=>m+y.data.byteLength,0),u=h.length}else{await this.deleteModel(t);const d=await fetch(n,{method:"HEAD",signal:a.signal});if(!d.ok)throw new Error(`Failed to get model info. Status: ${d.status}`);if(l=Number(d.headers.get("Content-Length")),isNaN(l)||l===0)throw new Error("Could not determine file size.")}for(await f.put(Vr,{modelName:t,total:l,status:"downloading"});o<l;){const d=o,h=Math.min(o+c-1,l-1),m=await fetch(n,{headers:{Range:`bytes=${d}-${h}`},signal:a.signal});if(!m.ok)throw new Error(`Chunk download failed. Status: ${m.status}`);const y=await m.arrayBuffer();await f.put(Wa,{modelName:t,chunkIndex:u,data:y}),o+=y.byteLength,u++,r({downloaded:o,total:l,percent:o/l*100,status:"downloading"})}await this._consolidateModel(t,r)}catch(f){this.handleDownloadError(f,t,o,l,r)}finally{this.controllers.delete(t)}}handleDownloadError(t,n,i,r,s){if(t instanceof DOMException&&t.name==="AbortError")console.log(`Download for ${n} was paused.`),this.getDb().then(a=>a.put(Vr,{modelName:n,total:r,status:"paused",downloaded:i})),s({downloaded:i,total:r,percent:r>0?i/r*100:0,status:"paused"});else{const a=t instanceof Error?t.message:"Unknown download error";console.error(`Download error for ${n}:`,t),this.getDb().then(o=>o.put(Vr,{modelName:n,status:"error",error:a,total:r})),s({downloaded:i,total:r,percent:r>0?i/r*100:0,status:"error",error:a})}}async _consolidateModel(t,n){const i=await this.getDb(),r=await i.get(Vr,t);if(!r)return;const s=r.total||0,a=r.downloaded||s;try{n({downloaded:a,total:s,percent:100,status:"consolidating"});const o=await this.getModelFromChunksAsStream(t);if(!o)throw new Error("Failed to reconstruct model from chunks.");await i.put(ef,{modelName:t,blob:o}),await this._deleteChunks(t),await i.put(Vr,{modelName:t,total:s,status:"completed",downloaded:s}),n({downloaded:s,total:s,percent:100,status:"completed"}),console.log(`Model ${t} consolidated successfully.`)}catch(o){const l=o instanceof Error?o.message:"Unknown consolidation error";console.error(`Consolidation error for ${t}:`,o),await i.put(Vr,{modelName:t,status:"error",error:l,total:s}),n({downloaded:a,total:s,percent:a/s*100,status:"error",error:`Consolidation failed: ${l}`})}}async _deleteChunks(t){const i=(await this.getDb()).transaction(Wa,"readwrite");let s=await i.objectStore(Wa).index("modelName").openCursor(IDBKeyRange.only(t));for(;s;)s.delete(),s=await s.continue();await i.done}pauseDownload(t){const n=this.controllers.get(t);n&&(n.abort(),this.controllers.delete(t))}async deleteModel(t){if(this.pauseDownload(t),this.isOpfsSupported)try{const i=await this.getOpfsRoot();i&&await i.removeEntry(t)}catch(i){i instanceof DOMException&&i.name==="NotFoundError"||console.error(`Error deleting ${t} from OPFS:`,i)}const n=await this.getDb();await n.delete(Vr,t),await n.delete(ef,t),await this._deleteChunks(t)}async getStatus(t){const n=await this.getDb(),i=await n.get(Vr,t);if(!i)return{downloaded:0,total:0,percent:0,status:"not_started"};const r=i.total||0;if(i.status==="completed")return{downloaded:r,total:r,percent:100,status:"completed"};let s=0;if(this.isOpfsSupported)try{const a=await this.getOpfsRoot();a&&(s=(await(await a.getFileHandle(t)).getFile()).size)}catch{}else s=(await n.getAllFromIndex(Wa,"modelName",t)).reduce((o,l)=>o+l.data.byteLength,0);return{downloaded:s,total:r,percent:r>0?s/r*100:0,status:i.status,error:i.error}}async getModelAsBlob(t){const n=await this.getDb(),i=await n.get(Vr,t);if(!i||i.status!=="completed")return null;if(this.isOpfsSupported)try{const s=await this.getOpfsRoot();if(s){const o=await(await s.getFileHandle(t)).getFile();return o.size===i.total?o:(console.error(`OPFS file for ${t} is incomplete. Expected ${i.total}, found ${o.size}.`),null)}}catch(s){console.warn(`Could not get model ${t} from OPFS, will check IndexedDB.`,s)}const r=await n.get(ef,t);return r&&r.blob?r.blob:(console.warn(`Consolidated model for ${t} not found in store. Reconstructing from chunks as a fallback.`),this.getModelFromChunksAsStream(t))}async getModelFromChunksAsStream(t){const n=await this.getDb();if(!await n.getFromIndex(Wa,"modelName",t))return null;const r=new ReadableStream({async start(s){let l=await n.transaction(Wa,"readonly").objectStore(Wa).index("modelName").openCursor(IDBKeyRange.only(t));for(;l;)s.enqueue(new Uint8Array(l.value.data)),l=await l.continue();s.close()}});try{return await new Response(r).blob()}catch{return null}}getDb(){return this.dbPromise}}const $c=new Hte,xm=new Map,Au=[],qte=(e,t,n)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){const i=xm.get(e);if(i===void 0)xm.set(e,{backend:t,priority:n});else{if(i.priority>n)return;if(i.priority===n&&i.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){const r=Au.indexOf(e);r!==-1&&Au.splice(r,1);for(let s=0;s<Au.length;s++)if(xm.get(Au[s]).priority<=n){Au.splice(s,0,e);return}Au.push(e)}return}throw new TypeError("not a valid backend")},Kte=async e=>{const t=xm.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{const n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(i){return n||(t.error=`${i}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Jte=async e=>{const t=e.executionProviders||[],n=t.map(l=>typeof l=="string"?l:l.name),i=n.length===0?Au:n;let r;const s=[],a=new Set;for(const l of i){const u=await Kte(l);typeof u=="string"?s.push({name:l,err:u}):(r||(r=u),r===u&&a.add(l))}if(!r)throw new Error(`no available backend found. ERR: ${s.map(l=>`[${l.name}] ${l.err}`).join(", ")}`);for(const{name:l,err:u}of s)n.includes(l)&&console.warn(`removing requested execution provider "${l}" from session options because it is not available: ${u}`);const o=t.filter(l=>a.has(typeof l=="string"?l:l.name));return[r,new Proxy(e,{get:(l,u)=>u==="executionProviders"?o:Reflect.get(l,u)})]},Yte="1.22.0-dev.20250409-89f8206ba4";let HP="warning";const Aa={wasm:{},webgl:{},webgpu:{},versions:{common:Yte},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);HP=e}},get logLevel(){return HP}};Object.defineProperty(Aa,"logLevel",{enumerable:!0});const Xte=Aa,Qte=(e,t)=>{const n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];const i=n.getContext("2d");if(i!=null){let r,s;(t==null?void 0:t.tensorLayout)!==void 0&&t.tensorLayout==="NHWC"?(r=e.dims[2],s=e.dims[3]):(r=e.dims[3],s=e.dims[2]);const a=(t==null?void 0:t.format)!==void 0?t.format:"RGB",o=t==null?void 0:t.norm;let l,u;o===void 0||o.mean===void 0?l=[255,255,255,255]:typeof o.mean=="number"?l=[o.mean,o.mean,o.mean,o.mean]:(l=[o.mean[0],o.mean[1],o.mean[2],0],o.mean[3]!==void 0&&(l[3]=o.mean[3])),o===void 0||o.bias===void 0?u=[0,0,0,0]:typeof o.bias=="number"?u=[o.bias,o.bias,o.bias,o.bias]:(u=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(u[3]=o.bias[3]));const c=s*r;let f=0,d=c,h=c*2,m=-1;a==="RGBA"?(f=0,d=c,h=c*2,m=c*3):a==="RGB"?(f=0,d=c,h=c*2):a==="RBG"&&(f=0,h=c,d=c*2);for(let y=0;y<s;y++)for(let M=0;M<r;M++){const g=(e.data[f++]-u[0])*l[0],_=(e.data[d++]-u[1])*l[1],T=(e.data[h++]-u[2])*l[2],x=m===-1?255:(e.data[m++]-u[3])*l[3];i.fillStyle="rgba("+g+","+_+","+T+","+x+")",i.fillRect(M,y,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Zte=(e,t)=>{const n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let i;if(n!=null){let r,s,a;(t==null?void 0:t.tensorLayout)!==void 0&&t.tensorLayout==="NHWC"?(r=e.dims[2],s=e.dims[1],a=e.dims[3]):(r=e.dims[3],s=e.dims[2],a=e.dims[1]);const o=t!==void 0&&t.format!==void 0?t.format:"RGB",l=t==null?void 0:t.norm;let u,c;l===void 0||l.mean===void 0?u=[255,255,255,255]:typeof l.mean=="number"?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(u[3]=l.mean[3])),l===void 0||l.bias===void 0?c=[0,0,0,0]:typeof l.bias=="number"?c=[l.bias,l.bias,l.bias,l.bias]:(c=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(c[3]=l.bias[3]));const f=s*r;if(t!==void 0&&(t.format!==void 0&&a===4&&t.format!=="RGBA"||a===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const d=4;let h=0,m=1,y=2,M=3,g=0,_=f,T=f*2,x=-1;o==="RGBA"?(g=0,_=f,T=f*2,x=f*3):o==="RGB"?(g=0,_=f,T=f*2):o==="RBG"&&(g=0,T=f,_=f*2),i=n.createImageData(r,s);for(let S=0;S<s*r;h+=d,m+=d,y+=d,M+=d,S++)i.data[h]=(e.data[g++]-c[0])*u[0],i.data[m]=(e.data[_++]-c[1])*u[1],i.data[y]=(e.data[T++]-c[2])*u[2],i.data[M]=x===-1?255:(e.data[x++]-c[3])*u[3]}else throw new Error("Can not access image data");return i},w0=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:i}=t,r=t.norm??{mean:255,bias:0};let s,a;typeof r.mean=="number"?s=[r.mean,r.mean,r.mean,r.mean]:s=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?a=[r.bias,r.bias,r.bias,r.bias]:a=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];const o=t.format!==void 0?t.format:"RGBA",l=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",u=n*i,c=l==="RGBA"?new Float32Array(u*4):new Float32Array(u*3);let f=4,d=0,h=1,m=2,y=3,M=0,g=u,_=u*2,T=-1;o==="RGB"&&(f=3,d=0,h=1,m=2,y=-1),l==="RGBA"?T=u*3:l==="RBG"?(M=0,_=u,g=u*2):l==="BGR"&&(_=0,g=u,M=u*2);for(let S=0;S<u;S++,d+=f,m+=f,h+=f,y+=f)c[M++]=(e[d]+a[0])/s[0],c[g++]=(e[h]+a[1])/s[1],c[_++]=(e[m]+a[2])/s[2],T!==-1&&y!==-1&&(c[T++]=(e[y]+a[3])/s[3]);return l==="RGBA"?new Ks("float32",c,[1,4,n,i]):new Ks("float32",c,[1,3,n,i])},ene=async(e,t)=>{const n=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,i=typeof ImageData<"u"&&e instanceof ImageData,r=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,s=typeof e=="string";let a,o=t??{};const l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=c=>typeof HTMLCanvasElement<"u"&&c instanceof HTMLCanvasElement||c instanceof OffscreenCanvas?c.getContext("2d"):null;if(n){const c=l();c.width=e.width,c.height=e.height;const f=u(c);if(f!=null){let d=e.height,h=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(d=t.resizedHeight,h=t.resizedWidth),t!==void 0){if(o=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=d,o.width=h}else o.tensorFormat="RGBA",o.height=d,o.width=h;f.drawImage(e,0,0),a=f.getImageData(0,0,h,d).data}else throw new Error("Can not access image data")}else if(i){let c,f;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(c=t.resizedHeight,f=t.resizedWidth):(c=e.height,f=e.width),t!==void 0&&(o=t),o.format="RGBA",o.height=c,o.width=f,t!==void 0){const d=l();d.width=f,d.height=c;const h=u(d);if(h!=null)h.putImageData(e,0,0),a=h.getImageData(0,0,f,c).data;else throw new Error("Can not access image data")}else a=e.data}else if(r){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");const c=l();c.width=e.width,c.height=e.height;const f=u(c);if(f!=null){const d=e.height,h=e.width;return f.drawImage(e,0,0,h,d),a=f.getImageData(0,0,h,d).data,o.height=d,o.width=h,w0(a,o)}else throw new Error("Can not access image data")}else{if(s)return new Promise((c,f)=>{const d=l(),h=u(d);if(!e||!h)return f();const m=new Image;m.crossOrigin="Anonymous",m.src=e,m.onload=()=>{d.width=m.width,d.height=m.height,h.drawImage(m,0,0,d.width,d.height);const y=h.getImageData(0,0,d.width,d.height);o.height=d.height,o.width=d.width,c(w0(y.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(a!==void 0)return w0(a,o);throw new Error("Input data provided is not supported - aborted tensor creation")},tne=(e,t)=>{const{width:n,height:i,download:r,dispose:s}=t,a=[1,i,n,4];return new Ks({location:"texture",type:"float32",texture:e,dims:a,download:r,dispose:s})},nne=(e,t)=>{const{dataType:n,dims:i,download:r,dispose:s}=t;return new Ks({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:i,download:r,dispose:s})},ine=(e,t)=>{const{dataType:n,dims:i,download:r,dispose:s}=t;return new Ks({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:i,download:r,dispose:s})},rne=(e,t,n)=>new Ks({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]}),td=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Tm=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let qP=!1;const sne=()=>{if(!qP){qP=!0;const e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,i=typeof n<"u"&&n.from;e&&(td.set("int64",BigInt64Array),Tm.set(BigInt64Array,"int64")),t&&(td.set("uint64",BigUint64Array),Tm.set(BigUint64Array,"uint64")),i?(td.set("float16",n),Tm.set(n,"float16")):td.set("float16",Uint16Array)}},ane=e=>{let t=1;for(let n=0;n<e.length;n++){const i=e[n];if(typeof i!="number"||!Number.isSafeInteger(i))throw new TypeError(`dims[${n}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${i}`);t*=i}return t},one=(e,t)=>{switch(e.location){case"cpu":return new Ks(e.type,e.data,t);case"cpu-pinned":return new Ks({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Ks({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Ks({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new Ks({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}};let Ks=class{constructor(t,n,i){sne();let r,s;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,r=t.type,s=t.dims,t.location){case"cpu-pinned":{const o=td.get(r);if(!o)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(t.data instanceof o))throw new TypeError(`buffer should be of type ${o.name}`);this.cpuData=t.data;break}case"texture":{if(r!=="float32")throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint64"&&r!=="int8"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,l;if(typeof t=="string")if(r=t,l=i,t==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");o=n}else{const u=td.get(t);if(u===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(n)){if(t==="float16"&&u===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${u.name} as data.`);t==="uint64"||t==="int64"?o=u.from(n,BigInt):o=u.from(n)}else if(n instanceof u)o=n;else if(n instanceof Uint8ClampedArray)if(t==="uint8")o=Uint8Array.from(n);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(t==="float16"&&n instanceof Uint16Array&&u!==Uint16Array)o=new globalThis.Float16Array(n.buffer,n.byteOffset,n.length);else throw new TypeError(`A ${r} tensor's data must be type of ${u}`)}else if(l=n,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const u=typeof t[0];if(u==="string")r="string",o=t;else if(u==="boolean")r="bool",o=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${u}.`)}else if(t instanceof Uint8ClampedArray)r="uint8",o=Uint8Array.from(t);else{const u=Tm.get(t.constructor);if(u===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);r=u,o=t}if(l===void 0)l=[o.length];else if(!Array.isArray(l))throw new TypeError("A tensor's dims must be a number array");s=l,this.cpuData=o,this.dataLocation="cpu"}const a=ane(s);if(this.cpuData&&a!==this.cpuData.length&&!((r==="uint4"||r==="int4")&&Math.ceil(a/2)===this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=a}static async fromImage(t,n){return ene(t,n)}static fromTexture(t,n){return tne(t,n)}static fromGpuBuffer(t,n){return nne(t,n)}static fromMLTensor(t,n){return ine(t,n)}static fromPinnedBuffer(t,n,i){return rne(t,n,i)}toDataURL(t){return Qte(this,t)}toImageData(t){return Zte(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,t&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return one(this,t)}};const Fc=Ks,AU=(e,t)=>{(typeof Aa.trace>"u"?!Aa.wasm.trace:!Aa.trace)||console.timeStamp(`${e}::ORT::${t}`)},IU=(e,t)=>{var r;const n=((r=new Error().stack)==null?void 0:r.split(/\r\n|\r|\n/g))||[];let i=!1;for(let s=0;s<n.length;s++){if(i&&!n[s].includes("TRACE_FUNC")){let a=`FUNC_${e}::${n[s].trim().split(" ")[1]}`;t&&(a+=`::${t}`),AU("CPU",a);return}n[s].includes("TRACE_FUNC")&&(i=!0)}},Gb=e=>{(typeof Aa.trace>"u"?!Aa.wasm.trace:!Aa.trace)||IU("BEGIN",e)},jb=e=>{(typeof Aa.trace>"u"?!Aa.wasm.trace:!Aa.trace)||IU("END",e)};let lne=class PU{constructor(t){this.handler=t}async run(t,n,i){Gb();const r={};let s={};if(typeof t!="object"||t===null||t instanceof Fc||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof Fc)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(const u of n){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);r[u]=null}if(typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let u=!1;const c=Object.getOwnPropertyNames(n);for(const f of this.outputNames)if(c.indexOf(f)!==-1){const d=n[f];(d===null||d instanceof Fc)&&(u=!0,a=!1,r[f]=d)}if(u){if(typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else s=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const u of this.inputNames)if(typeof t[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(a)for(const u of this.outputNames)r[u]=null;const o=await this.handler.run(t,r,s),l={};for(const u in o)if(Object.hasOwnProperty.call(o,u)){const c=o[u];c instanceof Fc?l[u]=c:l[u]=new Fc(c.type,c.data,c.dims)}return jb(),l}async release(){return this.handler.dispose()}static async create(t,n,i,r){Gb();let s,a={};if(typeof t=="string"){if(s=t,typeof n=="object"&&n!==null)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(s=t,typeof n=="object"&&n!==null)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){const c=t;let f=0,d=t.byteLength;if(typeof n=="object"&&n!==null)a=n;else if(typeof n=="number"){if(f=n,!Number.isSafeInteger(f))throw new RangeError("'byteOffset' must be an integer.");if(f<0||f>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(d=t.byteLength-f,typeof i=="number"){if(d=i,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||f+d>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-f}].`);if(typeof r=="object"&&r!==null)a=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof i<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(c,f,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[o,l]=await Jte(a),u=await o.createInferenceSessionHandler(s,l);return jb(),new PU(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}};const une=lne,cne=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:une,TRACE:AU,TRACE_FUNC_BEGIN:Gb,TRACE_FUNC_END:jb,Tensor:Fc,env:Xte,registerBackend:qte},Symbol.toStringTag,{value:"Module"}));/*!
 * ONNX Runtime Web v1.22.0-dev.20250409-89f8206ba4
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var Lx=Object.defineProperty,dne=Object.getOwnPropertyDescriptor,fne=Object.getOwnPropertyNames,pne=Object.prototype.hasOwnProperty,hne=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),dt=(e,t)=>()=>(e&&(t=e(e=0)),t),Ud=(e,t)=>{for(var n in t)Lx(e,n,{get:t[n],enumerable:!0})},mne=(e,t,n,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of fne(t))!pne.call(e,r)&&r!==n&&Lx(e,r,{get:()=>t[r],enumerable:!(i=dne(t,r))||i.enumerable});return e},mp=e=>mne(Lx({},"__esModule",{value:!0}),e),tf,dl,Nu,KP,kU,DU=dt(()=>{tf=new Map,dl=[],Nu=(e,t,n)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let i=tf.get(e);if(i===void 0)tf.set(e,{backend:t,priority:n});else{if(i.priority>n)return;if(i.priority===n&&i.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let r=dl.indexOf(e);r!==-1&&dl.splice(r,1);for(let s=0;s<dl.length;s++)if(tf.get(dl[s]).priority<=n){dl.splice(s,0,e);return}dl.push(e)}return}throw new TypeError("not a valid backend")},KP=async e=>{let t=tf.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(i){return n||(t.error=`${i}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},kU=async e=>{let t=e.executionProviders||[],n=t.map(l=>typeof l=="string"?l:l.name),i=n.length===0?dl:n,r,s=[],a=new Set;for(let l of i){let u=await KP(l);typeof u=="string"?s.push({name:l,err:u}):(r||(r=u),r===u&&a.add(l))}if(!r)throw new Error(`no available backend found. ERR: ${s.map(l=>`[${l.name}] ${l.err}`).join(", ")}`);for(let{name:l,err:u}of s)n.includes(l)&&console.warn(`removing requested execution provider "${l}" from session options because it is not available: ${u}`);let o=t.filter(l=>a.has(typeof l=="string"?l:l.name));return[r,new Proxy(e,{get:(l,u)=>u==="executionProviders"?o:Reflect.get(l,u)})]}}),gne=dt(()=>{DU()}),OU,_ne=dt(()=>{OU="1.22.0-dev.20250409-89f8206ba4"}),b0,Fs,RU=dt(()=>{_ne(),b0="warning",Fs={wasm:{},webgl:{},webgpu:{},versions:{common:OU},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);b0=e}},get logLevel(){return b0}},Object.defineProperty(Fs,"logLevel",{enumerable:!0})}),wi,yne=dt(()=>{RU(),wi=Fs}),NU,LU,vne=dt(()=>{NU=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let i=n.getContext("2d");if(i!=null){let r,s;(t==null?void 0:t.tensorLayout)!==void 0&&t.tensorLayout==="NHWC"?(r=e.dims[2],s=e.dims[3]):(r=e.dims[3],s=e.dims[2]);let a=(t==null?void 0:t.format)!==void 0?t.format:"RGB",o=t==null?void 0:t.norm,l,u;o===void 0||o.mean===void 0?l=[255,255,255,255]:typeof o.mean=="number"?l=[o.mean,o.mean,o.mean,o.mean]:(l=[o.mean[0],o.mean[1],o.mean[2],0],o.mean[3]!==void 0&&(l[3]=o.mean[3])),o===void 0||o.bias===void 0?u=[0,0,0,0]:typeof o.bias=="number"?u=[o.bias,o.bias,o.bias,o.bias]:(u=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(u[3]=o.bias[3]));let c=s*r,f=0,d=c,h=c*2,m=-1;a==="RGBA"?(f=0,d=c,h=c*2,m=c*3):a==="RGB"?(f=0,d=c,h=c*2):a==="RBG"&&(f=0,h=c,d=c*2);for(let y=0;y<s;y++)for(let M=0;M<r;M++){let g=(e.data[f++]-u[0])*l[0],_=(e.data[d++]-u[1])*l[1],T=(e.data[h++]-u[2])*l[2],x=m===-1?255:(e.data[m++]-u[3])*l[3];i.fillStyle="rgba("+g+","+_+","+T+","+x+")",i.fillRect(M,y,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},LU=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),i;if(n!=null){let r,s,a;(t==null?void 0:t.tensorLayout)!==void 0&&t.tensorLayout==="NHWC"?(r=e.dims[2],s=e.dims[1],a=e.dims[3]):(r=e.dims[3],s=e.dims[2],a=e.dims[1]);let o=t!==void 0&&t.format!==void 0?t.format:"RGB",l=t==null?void 0:t.norm,u,c;l===void 0||l.mean===void 0?u=[255,255,255,255]:typeof l.mean=="number"?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(u[3]=l.mean[3])),l===void 0||l.bias===void 0?c=[0,0,0,0]:typeof l.bias=="number"?c=[l.bias,l.bias,l.bias,l.bias]:(c=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(c[3]=l.bias[3]));let f=s*r;if(t!==void 0&&(t.format!==void 0&&a===4&&t.format!=="RGBA"||a===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,h=0,m=1,y=2,M=3,g=0,_=f,T=f*2,x=-1;o==="RGBA"?(g=0,_=f,T=f*2,x=f*3):o==="RGB"?(g=0,_=f,T=f*2):o==="RBG"&&(g=0,T=f,_=f*2),i=n.createImageData(r,s);for(let S=0;S<s*r;h+=d,m+=d,y+=d,M+=d,S++)i.data[h]=(e.data[g++]-c[0])*u[0],i.data[m]=(e.data[_++]-c[1])*u[1],i.data[y]=(e.data[T++]-c[2])*u[2],i.data[M]=x===-1?255:(e.data[x++]-c[3])*u[3]}else throw new Error("Can not access image data");return i}}),Ch,zU,FU,BU,UU,VU,wne=dt(()=>{zx(),Ch=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:i}=t,r=t.norm??{mean:255,bias:0},s,a;typeof r.mean=="number"?s=[r.mean,r.mean,r.mean,r.mean]:s=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?a=[r.bias,r.bias,r.bias,r.bias]:a=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];let o=t.format!==void 0?t.format:"RGBA",l=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",u=n*i,c=l==="RGBA"?new Float32Array(u*4):new Float32Array(u*3),f=4,d=0,h=1,m=2,y=3,M=0,g=u,_=u*2,T=-1;o==="RGB"&&(f=3,d=0,h=1,m=2,y=-1),l==="RGBA"?T=u*3:l==="RBG"?(M=0,_=u,g=u*2):l==="BGR"&&(_=0,g=u,M=u*2);for(let x=0;x<u;x++,d+=f,m+=f,h+=f,y+=f)c[M++]=(e[d]+a[0])/s[0],c[g++]=(e[h]+a[1])/s[1],c[_++]=(e[m]+a[2])/s[2],T!==-1&&y!==-1&&(c[T++]=(e[y]+a[3])/s[3]);return l==="RGBA"?new gs("float32",c,[1,4,n,i]):new gs("float32",c,[1,3,n,i])},zU=async(e,t)=>{let n=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,i=typeof ImageData<"u"&&e instanceof ImageData,r=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,s=typeof e=="string",a,o=t??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=c=>typeof HTMLCanvasElement<"u"&&c instanceof HTMLCanvasElement||c instanceof OffscreenCanvas?c.getContext("2d"):null;if(n){let c=l();c.width=e.width,c.height=e.height;let f=u(c);if(f!=null){let d=e.height,h=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(d=t.resizedHeight,h=t.resizedWidth),t!==void 0){if(o=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=d,o.width=h}else o.tensorFormat="RGBA",o.height=d,o.width=h;f.drawImage(e,0,0),a=f.getImageData(0,0,h,d).data}else throw new Error("Can not access image data")}else if(i){let c,f;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(c=t.resizedHeight,f=t.resizedWidth):(c=e.height,f=e.width),t!==void 0&&(o=t),o.format="RGBA",o.height=c,o.width=f,t!==void 0){let d=l();d.width=f,d.height=c;let h=u(d);if(h!=null)h.putImageData(e,0,0),a=h.getImageData(0,0,f,c).data;else throw new Error("Can not access image data")}else a=e.data}else if(r){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let c=l();c.width=e.width,c.height=e.height;let f=u(c);if(f!=null){let d=e.height,h=e.width;return f.drawImage(e,0,0,h,d),a=f.getImageData(0,0,h,d).data,o.height=d,o.width=h,Ch(a,o)}else throw new Error("Can not access image data")}else{if(s)return new Promise((c,f)=>{let d=l(),h=u(d);if(!e||!h)return f();let m=new Image;m.crossOrigin="Anonymous",m.src=e,m.onload=()=>{d.width=m.width,d.height=m.height,h.drawImage(m,0,0,d.width,d.height);let y=h.getImageData(0,0,d.width,d.height);o.height=d.height,o.width=d.width,c(Ch(y.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(a!==void 0)return Ch(a,o);throw new Error("Input data provided is not supported - aborted tensor creation")},FU=(e,t)=>{let{width:n,height:i,download:r,dispose:s}=t,a=[1,i,n,4];return new gs({location:"texture",type:"float32",texture:e,dims:a,download:r,dispose:s})},BU=(e,t)=>{let{dataType:n,dims:i,download:r,dispose:s}=t;return new gs({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:i,download:r,dispose:s})},UU=(e,t)=>{let{dataType:n,dims:i,download:r,dispose:s}=t;return new gs({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:i,download:r,dispose:s})},VU=(e,t,n)=>new gs({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})}),Iu,If,x0,GU,bne=dt(()=>{Iu=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),If=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),x0=!1,GU=()=>{if(!x0){x0=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,i=typeof n<"u"&&n.from;e&&(Iu.set("int64",BigInt64Array),If.set(BigInt64Array,"int64")),t&&(Iu.set("uint64",BigUint64Array),If.set(BigUint64Array,"uint64")),i?(Iu.set("float16",n),If.set(n,"float16")):Iu.set("float16",Uint16Array)}}}),jU,WU,xne=dt(()=>{zx(),jU=e=>{let t=1;for(let n=0;n<e.length;n++){let i=e[n];if(typeof i!="number"||!Number.isSafeInteger(i))throw new TypeError(`dims[${n}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${i}`);t*=i}return t},WU=(e,t)=>{switch(e.location){case"cpu":return new gs(e.type,e.data,t);case"cpu-pinned":return new gs({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new gs({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new gs({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new gs({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),gs,zx=dt(()=>{vne(),wne(),bne(),xne(),gs=class{constructor(e,t,n){GU();let i,r;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,i=e.type,r=e.dims,e.location){case"cpu-pinned":{let a=Iu.get(i);if(!a)throw new TypeError(`unsupported type "${i}" to create tensor from pinned buffer`);if(!(e.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=e.data;break}case"texture":{if(i!=="float32")throw new TypeError(`unsupported type "${i}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint8"&&i!=="bool"&&i!=="uint4"&&i!=="int4")throw new TypeError(`unsupported type "${i}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint64"&&i!=="int8"&&i!=="uint8"&&i!=="bool"&&i!=="uint4"&&i!=="int4")throw new TypeError(`unsupported type "${i}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,o;if(typeof e=="string")if(i=e,o=n,e==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");a=t}else{let l=Iu.get(e);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if(e==="float16"&&l===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${l.name} as data.`);e==="uint64"||e==="int64"?a=l.from(t,BigInt):a=l.from(t)}else if(t instanceof l)a=t;else if(t instanceof Uint8ClampedArray)if(e==="uint8")a=Uint8Array.from(t);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(e==="float16"&&t instanceof Uint16Array&&l!==Uint16Array)a=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw new TypeError(`A ${i} tensor's data must be type of ${l}`)}else if(o=t,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof e[0];if(l==="string")i="string",a=e;else if(l==="boolean")i="bool",a=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else if(e instanceof Uint8ClampedArray)i="uint8",a=Uint8Array.from(e);else{let l=If.get(e.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);i=l,a=e}if(o===void 0)o=[a.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");r=o,this.cpuData=a,this.dataLocation="cpu"}let s=jU(r);if(this.cpuData&&s!==this.cpuData.length&&!((i==="uint4"||i==="int4")&&Math.ceil(s/2)===this.cpuData.length))throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=i,this.dims=r,this.size=s}static async fromImage(e,t){return zU(e,t)}static fromTexture(e,t){return FU(e,t)}static fromGpuBuffer(e,t){return BU(e,t)}static fromMLTensor(e,t){return UU(e,t)}static fromPinnedBuffer(e,t,n){return VU(e,t,n)}toDataURL(e){return NU(this,e)}toImageData(e){return LU(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return WU(this,e)}}}),Ma,HU=dt(()=>{zx(),Ma=gs}),gp,T0,Ia,Qs,qU=dt(()=>{RU(),gp=(e,t)=>{(typeof Fs.trace>"u"?!Fs.wasm.trace:!Fs.trace)||console.timeStamp(`${e}::ORT::${t}`)},T0=(e,t)=>{var r;let n=((r=new Error().stack)==null?void 0:r.split(/\r\n|\r|\n/g))||[],i=!1;for(let s=0;s<n.length;s++){if(i&&!n[s].includes("TRACE_FUNC")){let a=`FUNC_${e}::${n[s].trim().split(" ")[1]}`;t&&(a+=`::${t}`),gp("CPU",a);return}n[s].includes("TRACE_FUNC")&&(i=!0)}},Ia=e=>{(typeof Fs.trace>"u"?!Fs.wasm.trace:!Fs.trace)||T0("BEGIN",e)},Qs=e=>{(typeof Fs.trace>"u"?!Fs.wasm.trace:!Fs.trace)||T0("END",e)}}),KU,Tne=dt(()=>{DU(),HU(),qU(),KU=class JU{constructor(t){this.handler=t}async run(t,n,i){Ia();let r={},s={};if(typeof t!="object"||t===null||t instanceof Ma||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof Ma)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let u of n){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);r[u]=null}if(typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,c=Object.getOwnPropertyNames(n);for(let f of this.outputNames)if(c.indexOf(f)!==-1){let d=n[f];(d===null||d instanceof Ma)&&(u=!0,a=!1,r[f]=d)}if(u){if(typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else s=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of this.inputNames)if(typeof t[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(a)for(let u of this.outputNames)r[u]=null;let o=await this.handler.run(t,r,s),l={};for(let u in o)if(Object.hasOwnProperty.call(o,u)){let c=o[u];c instanceof Ma?l[u]=c:l[u]=new Ma(c.type,c.data,c.dims)}return Qs(),l}async release(){return this.handler.dispose()}static async create(t,n,i,r){Ia();let s,a={};if(typeof t=="string"){if(s=t,typeof n=="object"&&n!==null)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(s=t,typeof n=="object"&&n!==null)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let c=t,f=0,d=t.byteLength;if(typeof n=="object"&&n!==null)a=n;else if(typeof n=="number"){if(f=n,!Number.isSafeInteger(f))throw new RangeError("'byteOffset' must be an integer.");if(f<0||f>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(d=t.byteLength-f,typeof i=="number"){if(d=i,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||f+d>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-f}].`);if(typeof r=="object"&&r!==null)a=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof i<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(c,f,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[o,l]=await kU(a),u=await o.createInferenceSessionHandler(s,l);return Qs(),new JU(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),Fx,Mne=dt(()=>{Tne(),Fx=KU}),Ene=dt(()=>{}),Sne=dt(()=>{}),Cne=dt(()=>{}),$ne=dt(()=>{}),YU={};Ud(YU,{InferenceSession:()=>Fx,TRACE:()=>gp,TRACE_FUNC_BEGIN:()=>Ia,TRACE_FUNC_END:()=>Qs,Tensor:()=>Ma,env:()=>wi,registerBackend:()=>Nu});var Oa=dt(()=>{gne(),yne(),Mne(),HU(),Ene(),Sne(),qU(),Cne(),$ne()}),Bx=dt(()=>{}),XU={};Ud(XU,{default:()=>QU});var M0,E0,QU,Ane=dt(()=>{var e;i8(),dc(),Ux(),M0="ort-wasm-proxy-worker",E0=((e=globalThis.self)==null?void 0:e.name)===M0,E0&&(self.onmessage=t=>{let{type:n,in:i}=t.data;try{switch(n){case"init-wasm":Vx(i.wasm).then(()=>{aT(i).then(()=>{postMessage({type:n})},r=>{postMessage({type:n,err:r})})},r=>{postMessage({type:n,err:r})});break;case"init-ep":{let{epName:r,env:s}=i;oT(s,r).then(()=>{postMessage({type:n})},a=>{postMessage({type:n,err:a})});break}case"copy-from":{let{buffer:r}=i,s=vg(r);postMessage({type:n,out:s});break}case"create":{let{model:r,options:s}=i;lT(r,s).then(a=>{postMessage({type:n,out:a})},a=>{postMessage({type:n,err:a})});break}case"release":uT(i),postMessage({type:n});break;case"run":{let{sessionId:r,inputIndices:s,inputs:a,outputIndices:o,options:l}=i;cT(r,s,a,o,new Array(o.length).fill(null),l).then(u=>{u.some(c=>c[3]!=="cpu")?postMessage({type:n,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:n,out:u},fT([...a,...u]))},u=>{postMessage({type:n,err:u})});break}case"end-profiling":dT(i),postMessage({type:n});break;default:}}catch(r){postMessage({type:n,err:r})}}),QU=E0?null:t=>new Worker(t??fs,{type:"module",name:M0})}),ZU={};Ud(ZU,{default:()=>eV});var S0,C0,eV,JP,Ine=dt(()=>{var e,t;C0=(S0=import.meta.url,async function(n={}){var ho;var i,r,s=n,a=new Promise((p,v)=>{i=p,r=v}),o=typeof window=="object",l=typeof WorkerGlobalScope<"u",u=l&&((ho=self.name)==null?void 0:ho.startsWith("em-pthread"));s.mountExternalData=(p,v)=>{p.startsWith("./")&&(p=p.substring(2)),(s.Eb||(s.Eb=new Map)).set(p,v)},s.unmountExternalData=()=>{delete s.Eb};var c=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,pc:!0}).buffer.constructor;let f=p=>async(...v)=>{var E;try{if(s.Fb)throw Error("Session already started");let I=s.Fb={dc:v[0],errors:[]},k=await p(...v);if(s.Fb!==I)throw Error("Session mismatch");(E=s.Jb)==null||E.flush();let F=I.errors;if(0<F.length){let ie=await Promise.all(F);if(ie=ie.filter(ge=>ge),0<ie.length)throw Error(ie.join(`
`))}return k}finally{s.Fb=null}};s.jsepInit=(p,v)=>{if(p==="webgpu"){[s.Jb,s.Ub,s.Yb,s.Kb,s.Xb,s.jb,s.Zb,s.ac,s.Vb,s.Wb,s.$b]=v;let E=s.Jb;s.jsepRegisterBuffer=(I,k,F,ie)=>E.registerBuffer(I,k,F,ie),s.jsepGetBuffer=I=>E.getBuffer(I),s.jsepCreateDownloader=(I,k,F)=>E.createDownloader(I,k,F),s.jsepOnCreateSession=I=>{E.onCreateSession(I)},s.jsepOnReleaseSession=I=>{E.onReleaseSession(I)},s.jsepOnRunStart=I=>E.onRunStart(I),s.bc=(I,k)=>{E.upload(I,k)}}else if(p==="webnn"){let E=v[0];[s.nc,s.Nb,s.webnnEnsureTensor,s.Ob,s.webnnDownloadTensor]=v.slice(1),s.webnnReleaseTensorId=s.Nb,s.webnnUploadTensor=s.Ob,s.webnnOnRunStart=I=>E.onRunStart(I),s.webnnOnRunEnd=E.onRunEnd.bind(E),s.webnnRegisterMLContext=(I,k)=>{E.registerMLContext(I,k)},s.webnnOnReleaseSession=I=>{E.onReleaseSession(I)},s.webnnCreateMLTensorDownloader=(I,k)=>E.createMLTensorDownloader(I,k),s.webnnRegisterMLTensor=(I,k,F,ie)=>E.registerMLTensor(I,k,F,ie),s.webnnCreateMLContext=I=>E.createMLContext(I),s.webnnRegisterMLConstant=(I,k,F,ie,ge,Te)=>E.registerMLConstant(I,k,F,ie,ge,s.Eb,Te),s.webnnRegisterGraphInput=E.registerGraphInput.bind(E),s.webnnIsGraphInput=E.isGraphInput.bind(E),s.webnnCreateTemporaryTensor=E.createTemporaryTensor.bind(E),s.webnnIsInt64Supported=E.isInt64Supported.bind(E)}};let d=()=>{let p=(v,E,I)=>(...k)=>{let F=Si,ie=E==null?void 0:E();k=v(...k);let ge=E==null?void 0:E();return ie!==ge&&(v=ge,I(ie),E=I=null),Si!=F?new Promise((Te,Re)=>{vt={resolve:Te,reject:Re}}):k};(()=>{for(let v of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])s[v]=p(s[v],()=>s[v],E=>s[v]=E)})(),f!==void 0&&(s._OrtRun=f(s._OrtRun),s._OrtRunWithBinding=f(s._OrtRunWithBinding)),d=void 0};s.asyncInit=()=>{d==null||d()};var h,m,y=Object.assign({},s),M=(p,v)=>{throw v},g="";(o||l)&&(l?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),S0&&(g=S0),g=g.startsWith("blob:")?"":g.slice(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1),l&&(m=p=>{var v=new XMLHttpRequest;return v.open("GET",p,!1),v.responseType="arraybuffer",v.send(null),new Uint8Array(v.response)}),h=async p=>{if(Q(p))return new Promise((E,I)=>{var k=new XMLHttpRequest;k.open("GET",p,!0),k.responseType="arraybuffer",k.onload=()=>{k.status==200||k.status==0&&k.response?E(k.response):I(k.status)},k.onerror=I,k.send(null)});var v=await fetch(p,{credentials:"same-origin"});if(v.ok)return v.arrayBuffer();throw Error(v.status+" : "+v.url)});var _=console.log.bind(console),T=console.error.bind(console),x=_,S=T;Object.assign(s,y),y=null;var $,C,P,O,R,G,W,V,te,J,j,Y,X,ce=s.wasmBinary,me=!1,Q=p=>p.startsWith("file://");function H(){return $.buffer!=O.buffer&&U(),O}function B(){return $.buffer!=O.buffer&&U(),R}function ee(){return $.buffer!=O.buffer&&U(),G}function _e(){return $.buffer!=O.buffer&&U(),W}function le(){return $.buffer!=O.buffer&&U(),V}function ae(){return $.buffer!=O.buffer&&U(),te}function Ne(){return $.buffer!=O.buffer&&U(),J}function Ye(){return $.buffer!=O.buffer&&U(),X}if(u){let p=function(v){try{var E=v.data,I=E.Bb;if(I==="load"){let k=[];self.onmessage=F=>k.push(F),self.startWorker=()=>{postMessage({Bb:"loaded"});for(let F of k)p(F);self.onmessage=p};for(let F of E.Rb)s[F]&&!s[F].proxy||(s[F]=(...ie)=>{postMessage({Bb:"callHandler",Qb:F,args:ie})},F=="print"&&(x=s[F]),F=="printErr"&&(S=s[F]));$=E.kc,U(),ze(E.lc)}else if(I==="run"){Ti(E.Ab),Va(E.Ab,0,0,1,0,0),yi(),Me(E.Ab),ue||(Xo(),ue=!0);try{Yn(E.fc,E.Hb)}catch(k){if(k!="unwind")throw k}}else E.target!=="setimmediate"&&(I==="checkMailbox"?ue&&Fe():I&&(S(`worker: received unknown command ${I}`),S(E)))}catch(k){throw co(),k}};var ze,ue=!1;S=function(...v){v=v.join(" "),console.error(v)},self.alert=function(...v){postMessage({Bb:"alert",text:v.join(" "),ic:aa()})},self.onunhandledrejection=v=>{throw v.reason||v},self.onmessage=p}function U(){var p=$.buffer;s.HEAP8=O=new Int8Array(p),s.HEAP16=G=new Int16Array(p),s.HEAPU8=R=new Uint8Array(p),s.HEAPU16=W=new Uint16Array(p),s.HEAP32=V=new Int32Array(p),s.HEAPU32=te=new Uint32Array(p),s.HEAPF32=J=new Float32Array(p),s.HEAPF64=X=new Float64Array(p),s.HEAP64=j=new BigInt64Array(p),s.HEAPU64=Y=new BigUint64Array(p)}function we(){u?startWorker(s):Ft.Ca()}u||($=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),U());var Pe,ke=0,Le=null;function Ge(){if(--ke==0&&Le){var p=Le;Le=null,p()}}function $e(p){throw S(p="Aborted("+p+")"),me=!0,p=new WebAssembly.RuntimeError(p+". Build with -sASSERTIONS for more info."),r(p),p}function et(){return{a:{L:at,Aa:He,b:Yi,$:xt,A:Ii,pa:Xt,X:oe,Z:K,qa:re,na:de,ga:xe,ma:Ue,J:_t,Y:$t,V:mt,oa:Ht,W:It,va:tn,E:qt,Q:kt,O:ci,D:Cr,u:Hi,r:ot,P:lt,z,R:ne,ja:pe,T:ut,aa:gt,M:Mt,F:Wt,ia:Me,sa:Cn,t:wn,Ba:Hn,w:kn,o:Dn,l:Bi,c:ni,n:yr,j:Is,v:Ps,p:Rr,f:ks,s:Ds,m:Os,e:Rs,k:Ra,i:Br,g:Xl,d:Ql,da:Zl,ea:nu,fa:Na,ba:jo,ca:Wo,N:Ho,xa:iu,ua:su,h:gc,C:_c,G:yc,ta:ru,x:vc,ra:wc,U:bc,q:mc,y:La,K:za,S:au,za:so,ya:ou,ka:lu,la:Ko,_:bt,B:xc,I:Jo,ha:ao,H:uu,a:$,wa:Oe}}}var Ce={829644:(p,v,E,I,k)=>{if(s===void 0||!s.Eb)return 1;if((p=Sn(Number(p>>>0))).startsWith("./")&&(p=p.substring(2)),!(p=s.Eb.get(p)))return 2;if(v=Number(v>>>0),E=Number(E>>>0),I=Number(I>>>0),v+E>p.byteLength)return 3;try{let F=p.subarray(v,v+E);switch(k){case 0:B().set(F,I>>>0);break;case 1:s.mc?s.mc(I,F):s.bc(I,F);break;default:return 4}return 0}catch{return 4}},830468:(p,v,E)=>{s.Ob(p,B().subarray(v>>>0,v+E>>>0))},830532:()=>s.nc(),830574:p=>{s.Nb(p)},830611:()=>{s.Vb()},830642:()=>{s.Wb()},830671:()=>{s.$b()},830696:p=>s.Ub(p),830729:p=>s.Yb(p),830761:(p,v,E)=>{s.Kb(Number(p),Number(v),Number(E),!0)},830824:(p,v,E)=>{s.Kb(Number(p),Number(v),Number(E))},830881:()=>typeof wasmOffsetConverter<"u",830938:p=>{s.jb("Abs",p,void 0)},830989:p=>{s.jb("Neg",p,void 0)},831040:p=>{s.jb("Floor",p,void 0)},831093:p=>{s.jb("Ceil",p,void 0)},831145:p=>{s.jb("Reciprocal",p,void 0)},831203:p=>{s.jb("Sqrt",p,void 0)},831255:p=>{s.jb("Exp",p,void 0)},831306:p=>{s.jb("Erf",p,void 0)},831357:p=>{s.jb("Sigmoid",p,void 0)},831412:(p,v,E)=>{s.jb("HardSigmoid",p,{alpha:v,beta:E})},831491:p=>{s.jb("Log",p,void 0)},831542:p=>{s.jb("Sin",p,void 0)},831593:p=>{s.jb("Cos",p,void 0)},831644:p=>{s.jb("Tan",p,void 0)},831695:p=>{s.jb("Asin",p,void 0)},831747:p=>{s.jb("Acos",p,void 0)},831799:p=>{s.jb("Atan",p,void 0)},831851:p=>{s.jb("Sinh",p,void 0)},831903:p=>{s.jb("Cosh",p,void 0)},831955:p=>{s.jb("Asinh",p,void 0)},832008:p=>{s.jb("Acosh",p,void 0)},832061:p=>{s.jb("Atanh",p,void 0)},832114:p=>{s.jb("Tanh",p,void 0)},832166:p=>{s.jb("Not",p,void 0)},832217:(p,v,E)=>{s.jb("Clip",p,{min:v,max:E})},832286:p=>{s.jb("Clip",p,void 0)},832338:(p,v)=>{s.jb("Elu",p,{alpha:v})},832396:p=>{s.jb("Gelu",p,void 0)},832448:p=>{s.jb("Relu",p,void 0)},832500:(p,v)=>{s.jb("LeakyRelu",p,{alpha:v})},832564:(p,v)=>{s.jb("ThresholdedRelu",p,{alpha:v})},832634:(p,v)=>{s.jb("Cast",p,{to:v})},832692:p=>{s.jb("Add",p,void 0)},832743:p=>{s.jb("Sub",p,void 0)},832794:p=>{s.jb("Mul",p,void 0)},832845:p=>{s.jb("Div",p,void 0)},832896:p=>{s.jb("Pow",p,void 0)},832947:p=>{s.jb("Equal",p,void 0)},833e3:p=>{s.jb("Greater",p,void 0)},833055:p=>{s.jb("GreaterOrEqual",p,void 0)},833117:p=>{s.jb("Less",p,void 0)},833169:p=>{s.jb("LessOrEqual",p,void 0)},833228:(p,v,E,I,k)=>{s.jb("ReduceMean",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},833403:(p,v,E,I,k)=>{s.jb("ReduceMax",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},833577:(p,v,E,I,k)=>{s.jb("ReduceMin",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},833751:(p,v,E,I,k)=>{s.jb("ReduceProd",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},833926:(p,v,E,I,k)=>{s.jb("ReduceSum",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},834100:(p,v,E,I,k)=>{s.jb("ReduceL1",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},834273:(p,v,E,I,k)=>{s.jb("ReduceL2",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},834446:(p,v,E,I,k)=>{s.jb("ReduceLogSum",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},834623:(p,v,E,I,k)=>{s.jb("ReduceSumSquare",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},834803:(p,v,E,I,k)=>{s.jb("ReduceLogSumExp",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},834983:p=>{s.jb("Where",p,void 0)},835036:(p,v,E)=>{s.jb("Transpose",p,{perm:v?Array.from(le().subarray(Number(v)>>>0,Number(E)>>>0)):[]})},835160:(p,v,E,I)=>{s.jb("DepthToSpace",p,{blocksize:v,mode:Sn(E),format:I?"NHWC":"NCHW"})},835293:(p,v,E,I)=>{s.jb("DepthToSpace",p,{blocksize:v,mode:Sn(E),format:I?"NHWC":"NCHW"})},835426:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui)=>{s.jb("ConvTranspose",p,{format:Te?"NHWC":"NCHW",autoPad:v,dilations:[E],group:I,kernelShape:[k],pads:[F,ie],strides:[ge],wIsConst:()=>!!H()[Re>>>0],outputPadding:nt?Array.from(le().subarray(Number(nt)>>>0,Number(ht)>>>0)):[],outputShape:At?Array.from(le().subarray(Number(At)>>>0,Number(Jt)>>>0)):[],activation:Sn(ui)})},835859:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.jb("ConvTranspose",p,{format:ge?"NHWC":"NCHW",autoPad:v,dilations:Array.from(le().subarray(Number(E)>>>0,2+(Number(E)>>>0)>>>0)),group:I,kernelShape:Array.from(le().subarray(Number(k)>>>0,2+(Number(k)>>>0)>>>0)),pads:Array.from(le().subarray(Number(F)>>>0,4+(Number(F)>>>0)>>>0)),strides:Array.from(le().subarray(Number(ie)>>>0,2+(Number(ie)>>>0)>>>0)),wIsConst:()=>!!H()[Te>>>0],outputPadding:Re?Array.from(le().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],outputShape:ht?Array.from(le().subarray(Number(ht)>>>0,Number(At)>>>0)):[],activation:Sn(Jt)})},836520:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui)=>{s.jb("ConvTranspose",p,{format:Te?"NHWC":"NCHW",autoPad:v,dilations:[E],group:I,kernelShape:[k],pads:[F,ie],strides:[ge],wIsConst:()=>!!H()[Re>>>0],outputPadding:nt?Array.from(le().subarray(Number(nt)>>>0,Number(ht)>>>0)):[],outputShape:At?Array.from(le().subarray(Number(At)>>>0,Number(Jt)>>>0)):[],activation:Sn(ui)})},836953:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.jb("ConvTranspose",p,{format:ge?"NHWC":"NCHW",autoPad:v,dilations:Array.from(le().subarray(Number(E)>>>0,2+(Number(E)>>>0)>>>0)),group:I,kernelShape:Array.from(le().subarray(Number(k)>>>0,2+(Number(k)>>>0)>>>0)),pads:Array.from(le().subarray(Number(F)>>>0,4+(Number(F)>>>0)>>>0)),strides:Array.from(le().subarray(Number(ie)>>>0,2+(Number(ie)>>>0)>>>0)),wIsConst:()=>!!H()[Te>>>0],outputPadding:Re?Array.from(le().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],outputShape:ht?Array.from(le().subarray(Number(ht)>>>0,Number(At)>>>0)):[],activation:Sn(Jt)})},837614:(p,v)=>{s.jb("GlobalAveragePool",p,{format:v?"NHWC":"NCHW"})},837705:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.jb("AveragePool",p,{format:Jt?"NHWC":"NCHW",auto_pad:v,ceil_mode:E,count_include_pad:I,storage_order:k,dilations:F?Array.from(le().subarray(Number(F)>>>0,Number(ie)>>>0)):[],kernel_shape:ge?Array.from(le().subarray(Number(ge)>>>0,Number(Te)>>>0)):[],pads:Re?Array.from(le().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],strides:ht?Array.from(le().subarray(Number(ht)>>>0,Number(At)>>>0)):[]})},838184:(p,v)=>{s.jb("GlobalAveragePool",p,{format:v?"NHWC":"NCHW"})},838275:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.jb("AveragePool",p,{format:Jt?"NHWC":"NCHW",auto_pad:v,ceil_mode:E,count_include_pad:I,storage_order:k,dilations:F?Array.from(le().subarray(Number(F)>>>0,Number(ie)>>>0)):[],kernel_shape:ge?Array.from(le().subarray(Number(ge)>>>0,Number(Te)>>>0)):[],pads:Re?Array.from(le().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],strides:ht?Array.from(le().subarray(Number(ht)>>>0,Number(At)>>>0)):[]})},838754:(p,v)=>{s.jb("GlobalMaxPool",p,{format:v?"NHWC":"NCHW"})},838841:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.jb("MaxPool",p,{format:Jt?"NHWC":"NCHW",auto_pad:v,ceil_mode:E,count_include_pad:I,storage_order:k,dilations:F?Array.from(le().subarray(Number(F)>>>0,Number(ie)>>>0)):[],kernel_shape:ge?Array.from(le().subarray(Number(ge)>>>0,Number(Te)>>>0)):[],pads:Re?Array.from(le().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],strides:ht?Array.from(le().subarray(Number(ht)>>>0,Number(At)>>>0)):[]})},839316:(p,v)=>{s.jb("GlobalMaxPool",p,{format:v?"NHWC":"NCHW"})},839403:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.jb("MaxPool",p,{format:Jt?"NHWC":"NCHW",auto_pad:v,ceil_mode:E,count_include_pad:I,storage_order:k,dilations:F?Array.from(le().subarray(Number(F)>>>0,Number(ie)>>>0)):[],kernel_shape:ge?Array.from(le().subarray(Number(ge)>>>0,Number(Te)>>>0)):[],pads:Re?Array.from(le().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],strides:ht?Array.from(le().subarray(Number(ht)>>>0,Number(At)>>>0)):[]})},839878:(p,v,E,I,k)=>{s.jb("Gemm",p,{alpha:v,beta:E,transA:I,transB:k})},839982:p=>{s.jb("MatMul",p,void 0)},840036:(p,v,E,I)=>{s.jb("ArgMax",p,{keepDims:!!v,selectLastIndex:!!E,axis:I})},840144:(p,v,E,I)=>{s.jb("ArgMin",p,{keepDims:!!v,selectLastIndex:!!E,axis:I})},840252:(p,v)=>{s.jb("Softmax",p,{axis:v})},840315:(p,v)=>{s.jb("Concat",p,{axis:v})},840375:(p,v,E,I,k)=>{s.jb("Split",p,{axis:v,numOutputs:E,splitSizes:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},840531:p=>{s.jb("Expand",p,void 0)},840585:(p,v)=>{s.jb("Gather",p,{axis:Number(v)})},840656:(p,v)=>{s.jb("GatherElements",p,{axis:Number(v)})},840735:(p,v)=>{s.jb("GatherND",p,{batch_dims:Number(v)})},840814:(p,v,E,I,k,F,ie,ge,Te,Re,nt)=>{s.jb("Resize",p,{antialias:v,axes:E?Array.from(le().subarray(Number(E)>>>0,Number(I)>>>0)):[],coordinateTransformMode:Sn(k),cubicCoeffA:F,excludeOutside:ie,extrapolationValue:ge,keepAspectRatioPolicy:Sn(Te),mode:Sn(Re),nearestMode:Sn(nt)})},841176:(p,v,E,I,k,F,ie)=>{s.jb("Slice",p,{starts:v?Array.from(le().subarray(Number(v)>>>0,Number(E)>>>0)):[],ends:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[],axes:F?Array.from(le().subarray(Number(F)>>>0,Number(ie)>>>0)):[]})},841440:p=>{s.jb("Tile",p,void 0)},841492:(p,v,E)=>{s.jb("InstanceNormalization",p,{epsilon:v,format:E?"NHWC":"NCHW"})},841606:(p,v,E)=>{s.jb("InstanceNormalization",p,{epsilon:v,format:E?"NHWC":"NCHW"})},841720:p=>{s.jb("Range",p,void 0)},841773:(p,v)=>{s.jb("Einsum",p,{equation:Sn(v)})},841854:(p,v,E,I,k)=>{s.jb("Pad",p,{mode:v,value:E,pads:I?Array.from(le().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},841997:(p,v,E,I,k,F)=>{s.jb("BatchNormalization",p,{epsilon:v,momentum:E,spatial:!!k,trainingMode:!!I,format:F?"NHWC":"NCHW"})},842166:(p,v,E,I,k,F)=>{s.jb("BatchNormalization",p,{epsilon:v,momentum:E,spatial:!!k,trainingMode:!!I,format:F?"NHWC":"NCHW"})},842335:(p,v,E)=>{s.jb("CumSum",p,{exclusive:Number(v),reverse:Number(E)})},842432:(p,v,E)=>{s.jb("DequantizeLinear",p,{axis:v,blockSize:E})},842522:(p,v,E,I,k)=>{s.jb("GridSample",p,{align_corners:v,mode:Sn(E),padding_mode:Sn(I),format:k?"NHWC":"NCHW"})},842692:(p,v,E,I,k)=>{s.jb("GridSample",p,{align_corners:v,mode:Sn(E),padding_mode:Sn(I),format:k?"NHWC":"NCHW"})},842862:(p,v)=>{s.jb("ScatterND",p,{reduction:Sn(v)})},842947:(p,v,E,I,k,F,ie,ge,Te)=>{s.jb("Attention",p,{numHeads:v,isUnidirectional:E,maskFilterValue:I,scale:k,doRotary:F,qkvHiddenSizes:ie?Array.from(le().subarray(Number(ge)>>>0,Number(ge)+ie>>>0)):[],pastPresentShareBuffer:!!Te})},843219:p=>{s.jb("BiasAdd",p,void 0)},843274:p=>{s.jb("BiasSplitGelu",p,void 0)},843335:p=>{s.jb("FastGelu",p,void 0)},843391:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr)=>{s.jb("Conv",p,{format:ht?"NHWC":"NCHW",auto_pad:v,dilations:E?Array.from(le().subarray(Number(E)>>>0,Number(I)>>>0)):[],group:k,kernel_shape:F?Array.from(le().subarray(Number(F)>>>0,Number(ie)>>>0)):[],pads:ge?Array.from(le().subarray(Number(ge)>>>0,Number(Te)>>>0)):[],strides:Re?Array.from(le().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],w_is_const:()=>!!H()[Number(At)>>>0],activation:Sn(Jt),activation_params:ui?Array.from(Ne().subarray(Number(ui)>>>0,Number(vr)>>>0)):[]})},843975:p=>{s.jb("Gelu",p,void 0)},844027:(p,v,E,I,k,F,ie,ge,Te)=>{s.jb("GroupQueryAttention",p,{numHeads:v,kvNumHeads:E,scale:I,softcap:k,doRotary:F,rotaryInterleaved:ie,smoothSoftmax:ge,localWindowSize:Te})},844244:(p,v,E,I)=>{s.jb("LayerNormalization",p,{axis:v,epsilon:E,simplified:!!I})},844355:(p,v,E,I)=>{s.jb("LayerNormalization",p,{axis:v,epsilon:E,simplified:!!I})},844466:(p,v,E,I,k,F)=>{s.jb("MatMulNBits",p,{k:v,n:E,accuracyLevel:I,bits:k,blockSize:F})},844593:(p,v,E,I,k,F)=>{s.jb("MultiHeadAttention",p,{numHeads:v,isUnidirectional:E,maskFilterValue:I,scale:k,doRotary:F})},844752:(p,v)=>{s.jb("QuickGelu",p,{alpha:v})},844816:(p,v,E,I,k)=>{s.jb("RotaryEmbedding",p,{interleaved:!!v,numHeads:E,rotaryEmbeddingDim:I,scale:k})},844955:(p,v,E)=>{s.jb("SkipLayerNormalization",p,{epsilon:v,simplified:!!E})},845057:(p,v,E)=>{s.jb("SkipLayerNormalization",p,{epsilon:v,simplified:!!E})},845159:(p,v,E,I)=>{s.jb("GatherBlockQuantized",p,{gatherAxis:v,quantizeAxis:E,blockSize:I})},845280:p=>{s.Zb(p)},845314:(p,v)=>s.ac(Number(p),Number(v),s.Fb.dc,s.Fb.errors)};function He(p,v,E){return rn(async()=>{await s.Xb(Number(p),Number(v),Number(E))})}function at(){return typeof wasmOffsetConverter<"u"}class Z{constructor(v){fe(this,"name","ExitStatus");this.message=`Program terminated with exit(${v})`,this.status=v}}var he=p=>{p.terminate(),p.onmessage=()=>{}},ye=[],Ke=p=>{Ct.length==0&&(tr(),Ji(Ct[0]));var v=Ct.pop();if(!v)return 6;Et.push(v),En[p.Ab]=v,v.Ab=p.Ab;var E={Bb:"run",fc:p.ec,Hb:p.Hb,Ab:p.Ab};return v.postMessage(E,p.Mb),0},Be=0,Se=(p,v,...E)=>{for(var I=2*E.length,k=la(),F=Ga(8*I),ie=F>>>3,ge=0;ge<E.length;ge++){var Te=E[ge];typeof Te=="bigint"?(j[ie+2*ge]=1n,j[ie+2*ge+1]=Te):(j[ie+2*ge]=0n,Ye()[ie+2*ge+1>>>0]=Te)}return p=Qo(p,0,I,F,v),Ls(k),p};function Oe(p){if(u)return Se(0,1,p);if(P=p,!(0<Be)){for(var v of Et)he(v);for(v of Ct)he(v);Ct=[],Et=[],En={},me=!0}M(0,new Z(p))}function ct(p){if(u)return Se(1,0,p);bt(p)}var bt=p=>{if(P=p,u)throw ct(p),"unwind";Oe(p)},Ct=[],Et=[],hn=[],En={},Kt=p=>{var v=p.Ab;delete En[v],Ct.push(p),Et.splice(Et.indexOf(p),1),p.Ab=0,Zo(v)};function yi(){hn.forEach(p=>p())}var Ji=p=>new Promise(v=>{p.onmessage=k=>{var F=(k=k.data).Bb;if(k.Gb&&k.Gb!=aa()){var ie=En[k.Gb];ie?ie.postMessage(k,k.Mb):S(`Internal error! Worker sent a message "${F}" to target pthread ${k.Gb}, but that thread no longer exists!`)}else F==="checkMailbox"?Fe():F==="spawnThread"?Ke(k):F==="cleanupThread"?Kt(En[k.hc]):F==="loaded"?(p.loaded=!0,v(p)):F==="alert"?alert(`Thread ${k.ic}: ${k.text}`):k.target==="setimmediate"?p.postMessage(k):F==="callHandler"?s[k.Qb](...k.args):F&&S(`worker sent an unknown command ${F}`)},p.onerror=k=>{throw S(`worker sent an error! ${k.filename}:${k.lineno}: ${k.message}`),k};var E,I=[];for(E of[])s.propertyIsEnumerable(E)&&I.push(E);p.postMessage({Bb:"load",Rb:I,kc:$,lc:C})});function tr(){var p=new Worker((()=>{let v=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new v("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});Ct.push(p)}var Ti=p=>{U();var v=ae()[p+52>>>2>>>0];p=ae()[p+56>>>2>>>0],fo(v,v-p),Ls(v)},Yn=(p,v)=>{Be=0,p=nl(p,v),0<Be?P=p:oa(p)};class $n{constructor(v){this.Ib=v-24}}function Yi(p,v,E){var I=new $n(p>>>=0);throw v>>>=0,E>>>=0,ae()[I.Ib+16>>>2>>>0]=0,ae()[I.Ib+4>>>2>>>0]=v,ae()[I.Ib+8>>>2>>>0]=E,p}function Gi(p,v,E,I){return u?Se(2,1,p,v,E,I):xt(p,v,E,I)}function xt(p,v,E,I){if(p>>>=0,E>>>=0,I>>>=0,c===void 0)return 6;var k=[];return u&&k.length===0?Gi(p,v>>>=0,E,I):(p={ec:E,Ab:p,Hb:I,Mb:k},u?(p.Bb="spawnThread",postMessage(p,k),0):Ke(p))}var ji=typeof TextDecoder<"u"?new TextDecoder:void 0,Wi=(p,v=0,E=NaN)=>{var I=(v>>>=0)+E;for(E=v;p[E]&&!(E>=I);)++E;if(16<E-v&&p.buffer&&ji)return ji.decode(p.buffer instanceof ArrayBuffer?p.subarray(v,E):p.slice(v,E));for(I="";v<E;){var k=p[v++];if(128&k){var F=63&p[v++];if((224&k)==192)I+=String.fromCharCode((31&k)<<6|F);else{var ie=63&p[v++];65536>(k=(240&k)==224?(15&k)<<12|F<<6|ie:(7&k)<<18|F<<12|ie<<6|63&p[v++])?I+=String.fromCharCode(k):(k-=65536,I+=String.fromCharCode(55296|k>>10,56320|1023&k))}}else I+=String.fromCharCode(k)}return I},Sn=(p,v)=>(p>>>=0)?Wi(B(),p,v):"";function Ii(p,v,E){return u?Se(3,1,p,v,E):0}function Xt(p,v){if(u)return Se(4,1,p,v)}var nr=p=>{for(var v=0,E=0;E<p.length;++E){var I=p.charCodeAt(E);127>=I?v++:2047>=I?v+=2:55296<=I&&57343>=I?(v+=4,++E):v+=3}return v},L=(p,v,E)=>{var I=B();if(v>>>=0,0<E){var k=v;E=v+E-1;for(var F=0;F<p.length;++F){var ie=p.charCodeAt(F);if(55296<=ie&&57343>=ie&&(ie=65536+((1023&ie)<<10)|1023&p.charCodeAt(++F)),127>=ie){if(v>=E)break;I[v++>>>0]=ie}else{if(2047>=ie){if(v+1>=E)break;I[v++>>>0]=192|ie>>6}else{if(65535>=ie){if(v+2>=E)break;I[v++>>>0]=224|ie>>12}else{if(v+3>=E)break;I[v++>>>0]=240|ie>>18,I[v++>>>0]=128|ie>>12&63}I[v++>>>0]=128|ie>>6&63}I[v++>>>0]=128|63&ie}}I[v>>>0]=0,p=v-k}else p=0;return p};function oe(p,v){if(u)return Se(5,1,p,v)}function K(p,v,E){if(u)return Se(6,1,p,v,E)}function re(p,v,E){return u?Se(7,1,p,v,E):0}function de(p,v){if(u)return Se(8,1,p,v)}function xe(p,v,E){if(u)return Se(9,1,p,v,E)}function Ue(p,v,E,I){if(u)return Se(10,1,p,v,E,I)}function _t(p,v,E,I){if(u)return Se(11,1,p,v,E,I)}function $t(p,v,E,I){if(u)return Se(12,1,p,v,E,I)}function mt(p){if(u)return Se(13,1,p)}function Ht(p,v){if(u)return Se(14,1,p,v)}function It(p,v,E){if(u)return Se(15,1,p,v,E)}var Zt,St,tn=()=>$e(""),vn=p=>{for(var v="";B()[p>>>0];)v+=Zt[B()[p++>>>0]];return v},Wn={},ei={};function Bn(p,v,E={}){return function(I,k,F={}){var ie=k.name;if(!I)throw new St(`type "${ie}" must have a positive integer typeid pointer`);if(ei.hasOwnProperty(I)){if(F.Sb)return;throw new St(`Cannot register type '${ie}' twice`)}ei[I]=k,Wn.hasOwnProperty(I)&&(k=Wn[I],delete Wn[I],k.forEach(ge=>ge()))}(p,v,E)}var Je=(p,v,E)=>{switch(v){case 1:return E?I=>H()[I>>>0]:I=>B()[I>>>0];case 2:return E?I=>ee()[I>>>1>>>0]:I=>_e()[I>>>1>>>0];case 4:return E?I=>le()[I>>>2>>>0]:I=>ae()[I>>>2>>>0];case 8:return E?I=>j[I>>>3]:I=>Y[I>>>3];default:throw new TypeError(`invalid integer width (${v}): ${p}`)}};function qt(p,v,E){E>>>=0,Bn(p>>>=0,{name:v=vn(v>>>0),fromWireType:I=>I,toWireType:function(I,k){if(typeof k!="bigint"&&typeof k!="number")throw k=k===null?"null":(I=typeof k)=="object"||I==="array"||I==="function"?k.toString():""+k,new TypeError(`Cannot convert "${k}" to ${this.name}`);return typeof k=="number"&&(k=BigInt(k)),k},Cb:Pt,readValueFromPointer:Je(v,E,v.indexOf("u")==-1),Db:null})}var Pt=8;function kt(p,v,E,I){Bn(p>>>=0,{name:v=vn(v>>>0),fromWireType:function(k){return!!k},toWireType:function(k,F){return F?E:I},Cb:Pt,readValueFromPointer:function(k){return this.fromWireType(B()[k>>>0])},Db:null})}var An=[],zn=[];function ni(p){9<(p>>>=0)&&--zn[p+1]==0&&(zn[p]=void 0,An.push(p))}var Un=p=>{if(!p)throw new St("Cannot use deleted val. handle = "+p);return zn[p]},In=p=>{switch(p){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let v=An.pop()||zn.length;return zn[v]=p,zn[v+1]=1,v}};function ir(p){return this.fromWireType(ae()[p>>>2>>>0])}var Mi={name:"emscripten::val",fromWireType:p=>{var v=Un(p);return ni(p),v},toWireType:(p,v)=>In(v),Cb:Pt,readValueFromPointer:ir,Db:null};function ci(p){return Bn(p>>>0,Mi)}var Xi=(p,v)=>{switch(v){case 4:return function(E){return this.fromWireType(Ne()[E>>>2>>>0])};case 8:return function(E){return this.fromWireType(Ye()[E>>>3>>>0])};default:throw new TypeError(`invalid float width (${v}): ${p}`)}};function Cr(p,v,E){E>>>=0,Bn(p>>>=0,{name:v=vn(v>>>0),fromWireType:I=>I,toWireType:(I,k)=>k,Cb:Pt,readValueFromPointer:Xi(v,E),Db:null})}function Hi(p,v,E,I,k){if(p>>>=0,E>>>=0,v=vn(v>>>0),k===-1&&(k=4294967295),k=ge=>ge,I===0){var F=32-8*E;k=ge=>ge<<F>>>F}var ie=v.includes("unsigned")?function(ge,Te){return Te>>>0}:function(ge,Te){return Te};Bn(p,{name:v,fromWireType:k,toWireType:ie,Cb:Pt,readValueFromPointer:Je(v,E,I!==0),Db:null})}function ot(p,v,E){function I(F){var ie=ae()[F>>>2>>>0];return F=ae()[F+4>>>2>>>0],new k(H().buffer,F,ie)}var k=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][v];Bn(p>>>=0,{name:E=vn(E>>>0),fromWireType:I,Cb:Pt,readValueFromPointer:I},{Sb:!0})}function lt(p,v){Bn(p>>>=0,{name:v=vn(v>>>0),fromWireType:function(E){for(var I,k=ae()[E>>>2>>>0],F=E+4,ie=F,ge=0;ge<=k;++ge){var Te=F+ge;ge!=k&&B()[Te>>>0]!=0||(ie=Sn(ie,Te-ie),I===void 0?I=ie:(I+="\0",I+=ie),ie=Te+1)}return Ni(E),I},toWireType:function(E,I){I instanceof ArrayBuffer&&(I=new Uint8Array(I));var k=typeof I=="string";if(!(k||I instanceof Uint8Array||I instanceof Uint8ClampedArray||I instanceof Int8Array))throw new St("Cannot pass non-string to std::string");var F=k?nr(I):I.length,ie=Ns(4+F+1),ge=ie+4;if(ae()[ie>>>2>>>0]=F,k)L(I,ge,F+1);else if(k)for(k=0;k<F;++k){var Te=I.charCodeAt(k);if(255<Te)throw Ni(ie),new St("String has UTF-16 code units that do not fit in 8 bits");B()[ge+k>>>0]=Te}else for(k=0;k<F;++k)B()[ge+k>>>0]=I[k];return E!==null&&E.push(Ni,ie),ie},Cb:Pt,readValueFromPointer:ir,Db(E){Ni(E)}})}var wt=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,mn=(p,v)=>{for(var E=p>>1,I=E+v/2;!(E>=I)&&_e()[E>>>0];)++E;if(32<(E<<=1)-p&&wt)return wt.decode(B().slice(p,E));for(E="",I=0;!(I>=v/2);++I){var k=ee()[p+2*I>>>1>>>0];if(k==0)break;E+=String.fromCharCode(k)}return E},os=(p,v,E)=>{if(E??(E=2147483647),2>E)return 0;var I=v;E=(E-=2)<2*p.length?E/2:p.length;for(var k=0;k<E;++k){var F=p.charCodeAt(k);ee()[v>>>1>>>0]=F,v+=2}return ee()[v>>>1>>>0]=0,v-I},Yr=p=>2*p.length,ls=(p,v)=>{for(var E=0,I="";!(E>=v/4);){var k=le()[p+4*E>>>2>>>0];if(k==0)break;++E,65536<=k?(k-=65536,I+=String.fromCharCode(55296|k>>10,56320|1023&k)):I+=String.fromCharCode(k)}return I},ia=(p,v,E)=>{if(v>>>=0,E??(E=2147483647),4>E)return 0;var I=v;E=I+E-4;for(var k=0;k<p.length;++k){var F=p.charCodeAt(k);if(55296<=F&&57343>=F&&(F=65536+((1023&F)<<10)|1023&p.charCodeAt(++k)),le()[v>>>2>>>0]=F,(v+=4)+4>E)break}return le()[v>>>2>>>0]=0,v-I},Ee=p=>{for(var v=0,E=0;E<p.length;++E){var I=p.charCodeAt(E);55296<=I&&57343>=I&&++E,v+=4}return v};function z(p,v,E){if(p>>>=0,v>>>=0,E=vn(E>>>=0),v===2)var I=mn,k=os,F=Yr,ie=ge=>_e()[ge>>>1>>>0];else v===4&&(I=ls,k=ia,F=Ee,ie=ge=>ae()[ge>>>2>>>0]);Bn(p,{name:E,fromWireType:ge=>{for(var Te,Re=ae()[ge>>>2>>>0],nt=ge+4,ht=0;ht<=Re;++ht){var At=ge+4+ht*v;ht!=Re&&ie(At)!=0||(nt=I(nt,At-nt),Te===void 0?Te=nt:(Te+="\0",Te+=nt),nt=At+v)}return Ni(ge),Te},toWireType:(ge,Te)=>{if(typeof Te!="string")throw new St(`Cannot pass non-string to C++ string type ${E}`);var Re=F(Te),nt=Ns(4+Re+v);return ae()[nt>>>2>>>0]=Re/v,k(Te,nt+4,Re+v),ge!==null&&ge.push(Ni,nt),nt},Cb:Pt,readValueFromPointer:ir,Db(ge){Ni(ge)}})}function ne(p,v){Bn(p>>>=0,{Tb:!0,name:v=vn(v>>>0),Cb:0,fromWireType:()=>{},toWireType:()=>{}})}function pe(p){Va(p>>>0,!l,1,!o,131072,!1),yi()}var be=p=>{if(!me)try{if(p(),!(0<Be))try{u?oa(P):bt(P)}catch(v){v instanceof Z||v=="unwind"||M(0,v)}}catch(v){v instanceof Z||v=="unwind"||M(0,v)}};function Me(p){p>>>=0,typeof Atomics.jc=="function"&&(Atomics.jc(le(),p>>>2,p).value.then(Fe),p+=128,Atomics.store(le(),p>>>2,1))}var Fe=()=>{var p=aa();p&&(Me(p),be(tl))};function ut(p,v){(p>>>=0)==v>>>0?setTimeout(Fe):u?postMessage({Gb:p,Bb:"checkMailbox"}):(p=En[p])&&p.postMessage({Bb:"checkMailbox"})}var yt=[];function gt(p,v,E,I,k){for(v>>>=0,I/=2,yt.length=I,E=k>>>0>>>3,k=0;k<I;k++)yt[k]=j[E+2*k]?j[E+2*k+1]:Ye()[E+2*k+1>>>0];return(v?Ce[v]:Xe[p])(...yt)}var Mt=()=>{Be=0};function Wt(p){p>>>=0,u?postMessage({Bb:"cleanupThread",hc:p}):Kt(En[p])}function Cn(p){}var Tn=(p,v)=>{var E=ei[p];if(E===void 0)throw p=Yo(p),E=vn(p),Ni(p),new St(`${v} has unknown type ${E}`);return E},Pn=(p,v,E)=>{var I=[];return p=p.toWireType(I,E),I.length&&(ae()[v>>>2>>>0]=In(I)),p};function wn(p,v,E){return v>>>=0,E>>>=0,p=Un(p>>>0),v=Tn(v,"emval::as"),Pn(v,E,p)}function Hn(p,v){return v>>>=0,p=Un(p>>>0),(v=Tn(v,"emval::as")).toWireType(null,p)}var Ei=p=>{try{p()}catch(v){$e(v)}},oi=0,Si=null,Pi=0,_r=[],tt={},it={},Ve=0,vt=null,Gt=[];function rn(p){return function(v){if(!me){if(oi===0){var E=!1,I=!1;v((k=0)=>{if(!me&&(Pi=k,E=!0,I)){oi=2,Ei(()=>rl(Si)),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.resume(),k=!1;try{var F=function(){var Te=le()[Si+8>>>2>>>0];return Te=Ft[it[Te]],--Be,Te()}()}catch(Te){F=Te,k=!0}var ie=!1;if(!Si){var ge=vt;ge&&(vt=null,(k?ge.reject:ge.resolve)(F),ie=!0)}if(k&&!ie)throw F}}),I=!0,E||(oi=1,Si=function(){var k=Ns(65548),F=k+12;ae()[k>>>2>>>0]=F,ae()[k+4>>>2>>>0]=F+65536,F=_r[0];var ie=tt[F];return ie===void 0&&(ie=Ve++,tt[F]=ie,it[ie]=F),F=ie,le()[k+8>>>2>>>0]=F,k}(),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.pause(),Ei(()=>il(Si)))}else oi===2?(oi=0,Ei(sl),Ni(Si),Si=null,Gt.forEach(be)):$e(`invalid state: ${oi}`);return Pi}}(v=>{p().then(v)})}function kn(p){return p>>>=0,rn(async()=>{var v=await Un(p);return In(v)})}var Mn=[];function Dn(p,v,E,I){return E>>>=0,I>>>=0,(p=Mn[p>>>0])(null,v=Un(v>>>0),E,I)}var li={},Vn=p=>{var v=li[p];return v===void 0?vn(p):v};function Bi(p,v,E,I,k){return E>>>=0,I>>>=0,k>>>=0,(p=Mn[p>>>0])(v=Un(v>>>0),v[E=Vn(E)],I,k)}var $r=()=>typeof globalThis=="object"?globalThis:Function("return this")();function yr(p){return(p>>>=0)==0?In($r()):(p=Vn(p),In($r()[p]))}var $s=p=>{var v=Mn.length;return Mn.push(p),v},As=(p,v)=>{for(var E=Array(p),I=0;I<p;++I)E[I]=Tn(ae()[v+4*I>>>2>>>0],"parameter "+I);return E},us=(p,v)=>Object.defineProperty(v,"name",{value:p});function Is(p,v,E){var I=(v=As(p,v>>>0)).shift();p--;var k=`return function (obj, func, destructorsRef, args) {
`,F=0,ie=[];E===0&&ie.push("obj");for(var ge=["retType"],Te=[I],Re=0;Re<p;++Re)ie.push("arg"+Re),ge.push("argType"+Re),Te.push(v[Re]),k+=`  var arg${Re} = argType${Re}.readValueFromPointer(args${F?"+"+F:""});
`,F+=v[Re].Cb;return k+=`  var rv = ${E===1?"new func":"func.call"}(${ie.join(", ")});
`,I.Tb||(ge.push("emval_returnValue"),Te.push(Pn),k+=`  return emval_returnValue(retType, destructorsRef, rv);
`),ge.push(k+`};
`),p=function(nt){var ht=Function;if(!(ht instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof ht} which is not a function`);var At=us(ht.name||"unknownFunctionName",function(){});return At.prototype=ht.prototype,At=new At,(nt=ht.apply(At,nt))instanceof Object?nt:At}(ge)(...Te),E=`methodCaller<(${v.map(nt=>nt.name).join(", ")}) => ${I.name}>`,$s(us(E,p))}function Ps(p){return p=Vn(p>>>0),In(s[p])}function Rr(p,v){return v>>>=0,p=Un(p>>>0),v=Un(v),In(p[v])}function ks(p){9<(p>>>=0)&&(zn[p+1]+=1)}function Ds(){return In([])}function Os(p){p=Un(p>>>0);for(var v=Array(p.length),E=0;E<p.length;E++)v[E]=p[E];return In(v)}function Rs(p){return In(Vn(p>>>0))}function Ra(){return In({})}function Br(p){for(var v=Un(p>>>=0);v.length;){var E=v.pop();v.pop()(E)}ni(p)}function Xl(p,v,E){v>>>=0,E>>>=0,p=Un(p>>>0),v=Un(v),E=Un(E),p[v]=E}function Ql(p,v){return v>>>=0,p=(p=Tn(p>>>0,"_emval_take_value")).readValueFromPointer(v),In(p)}function Zl(p,v){p=-9007199254740992>p||9007199254740992<p?NaN:Number(p),v>>>=0,p=new Date(1e3*p),le()[v>>>2>>>0]=p.getUTCSeconds(),le()[v+4>>>2>>>0]=p.getUTCMinutes(),le()[v+8>>>2>>>0]=p.getUTCHours(),le()[v+12>>>2>>>0]=p.getUTCDate(),le()[v+16>>>2>>>0]=p.getUTCMonth(),le()[v+20>>>2>>>0]=p.getUTCFullYear()-1900,le()[v+24>>>2>>>0]=p.getUTCDay(),p=(p.getTime()-Date.UTC(p.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,le()[v+28>>>2>>>0]=p}var eu=p=>p%4==0&&(p%100!=0||p%400==0),tu=[0,31,60,91,121,152,182,213,244,274,305,335],no=[0,31,59,90,120,151,181,212,243,273,304,334];function nu(p,v){p=-9007199254740992>p||9007199254740992<p?NaN:Number(p),v>>>=0,p=new Date(1e3*p),le()[v>>>2>>>0]=p.getSeconds(),le()[v+4>>>2>>>0]=p.getMinutes(),le()[v+8>>>2>>>0]=p.getHours(),le()[v+12>>>2>>>0]=p.getDate(),le()[v+16>>>2>>>0]=p.getMonth(),le()[v+20>>>2>>>0]=p.getFullYear()-1900,le()[v+24>>>2>>>0]=p.getDay();var E=(eu(p.getFullYear())?tu:no)[p.getMonth()]+p.getDate()-1|0;le()[v+28>>>2>>>0]=E,le()[v+36>>>2>>>0]=-60*p.getTimezoneOffset(),E=new Date(p.getFullYear(),6,1).getTimezoneOffset();var I=new Date(p.getFullYear(),0,1).getTimezoneOffset();p=0|(E!=I&&p.getTimezoneOffset()==Math.min(I,E)),le()[v+32>>>2>>>0]=p}function Na(p){p>>>=0;var v=new Date(le()[p+20>>>2>>>0]+1900,le()[p+16>>>2>>>0],le()[p+12>>>2>>>0],le()[p+8>>>2>>>0],le()[p+4>>>2>>>0],le()[p>>>2>>>0],0),E=le()[p+32>>>2>>>0],I=v.getTimezoneOffset(),k=new Date(v.getFullYear(),6,1).getTimezoneOffset(),F=new Date(v.getFullYear(),0,1).getTimezoneOffset(),ie=Math.min(F,k);return 0>E?le()[p+32>>>2>>>0]=+(k!=F&&ie==I):0<E!=(ie==I)&&(k=Math.max(F,k),v.setTime(v.getTime()+6e4*((0<E?ie:k)-I))),le()[p+24>>>2>>>0]=v.getDay(),E=(eu(v.getFullYear())?tu:no)[v.getMonth()]+v.getDate()-1|0,le()[p+28>>>2>>>0]=E,le()[p>>>2>>>0]=v.getSeconds(),le()[p+4>>>2>>>0]=v.getMinutes(),le()[p+8>>>2>>>0]=v.getHours(),le()[p+12>>>2>>>0]=v.getDate(),le()[p+16>>>2>>>0]=v.getMonth(),le()[p+20>>>2>>>0]=v.getYear(),p=v.getTime(),BigInt(isNaN(p)?-1:p/1e3)}function jo(p,v,E,I,k,F,ie){return u?Se(16,1,p,v,E,I,k,F,ie):-52}function Wo(p,v,E,I,k,F){if(u)return Se(17,1,p,v,E,I,k,F)}var ra={},mc=()=>performance.timeOrigin+performance.now();function Ho(p,v){if(u)return Se(18,1,p,v);if(ra[p]&&(clearTimeout(ra[p].id),delete ra[p]),!v)return 0;var E=setTimeout(()=>{delete ra[p],be(()=>el(p,performance.timeOrigin+performance.now()))},v);return ra[p]={id:E,qc:v},0}function iu(p,v,E,I){p>>>=0,v>>>=0,E>>>=0,I>>>=0;var k=new Date().getFullYear(),F=new Date(k,0,1).getTimezoneOffset();k=new Date(k,6,1).getTimezoneOffset();var ie=Math.max(F,k);ae()[p>>>2>>>0]=60*ie,le()[v>>>2>>>0]=+(F!=k),p=(v=ge=>{var Te=Math.abs(ge);return`UTC${0<=ge?"-":"+"}${String(Math.floor(Te/60)).padStart(2,"0")}${String(Te%60).padStart(2,"0")}`})(F),v=v(k),k<F?(L(p,E,17),L(v,I,17)):(L(p,I,17),L(v,E,17))}var ru=()=>Date.now();function su(p,v,E){return 0<=p&&3>=p?(p===0?p=Date.now():p=performance.timeOrigin+performance.now(),j[E>>>0>>>3]=BigInt(Math.round(1e6*p)),0):28}var io=[],ro=(p,v)=>{io.length=0;for(var E;E=B()[p++>>>0];){var I=E!=105;v+=(I&=E!=112)&&v%8?4:0,io.push(E==112?ae()[v>>>2>>>0]:E==106?j[v>>>3]:E==105?le()[v>>>2>>>0]:Ye()[v>>>3>>>0]),v+=I?8:4}return io};function gc(p,v,E){return p>>>=0,v=ro(v>>>0,E>>>0),Ce[p](...v)}function _c(p,v,E){return p>>>=0,v=ro(v>>>0,E>>>0),Ce[p](...v)}var yc=()=>{};function vc(p,v){return S(Sn(p>>>0,v>>>0))}var wc=()=>{throw Be+=1,"unwind"};function bc(){return 4294901760}var La=()=>navigator.hardwareConcurrency;function za(){return $e("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function au(p){p>>>=0;var v=B().length;if(p<=v||4294901760<p)return!1;for(var E=1;4>=E;E*=2){var I=v*(1+.2/E);I=Math.min(I,p+100663296);e:{I=(Math.min(4294901760,65536*Math.ceil(Math.max(p,I)/65536))-$.buffer.byteLength+65535)/65536|0;try{$.grow(I),U();var k=1;break e}catch{}k=void 0}if(k)return!0}return!1}var Fa=()=>($e("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Ba={},sa=p=>{p.forEach(v=>{Fa()})};function so(){var p=Error().stack.toString().split(`
`);return p[0]=="Error"&&p.shift(),sa(p),Ba.Lb=Fa(),Ba.cc=p,Ba.Lb}function ou(p,v,E){if(p>>>=0,v>>>=0,Ba.Lb==p)var I=Ba.cc;else(I=Error().stack.toString().split(`
`))[0]=="Error"&&I.shift(),sa(I);for(var k=3;I[k]&&Fa()!=p;)++k;for(p=0;p<E&&I[p+k];++p)le()[v+4*p>>>2>>>0]=Fa();return p}var Ua,Xr={},qo=()=>{if(!Ua){var p,v={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(p in Xr)Xr[p]===void 0?delete v[p]:v[p]=Xr[p];var E=[];for(p in v)E.push(`${p}=${v[p]}`);Ua=E}return Ua};function lu(p,v){if(u)return Se(19,1,p,v);p>>>=0,v>>>=0;var E=0;return qo().forEach((I,k)=>{var F=v+E;for(k=ae()[p+4*k>>>2>>>0]=F,F=0;F<I.length;++F)H()[k++>>>0]=I.charCodeAt(F);H()[k>>>0]=0,E+=I.length+1}),0}function Ko(p,v){if(u)return Se(20,1,p,v);p>>>=0,v>>>=0;var E=qo();ae()[p>>>2>>>0]=E.length;var I=0;return E.forEach(k=>I+=k.length+1),ae()[v>>>2>>>0]=I,0}function xc(p){return u?Se(21,1,p):52}function Jo(p,v,E,I){return u?Se(22,1,p,v,E,I):52}function ao(p,v,E,I){return u?Se(23,1,p,v,E,I):70}var oo=[null,[],[]];function uu(p,v,E,I){if(u)return Se(24,1,p,v,E,I);v>>>=0,E>>>=0,I>>>=0;for(var k=0,F=0;F<E;F++){var ie=ae()[v>>>2>>>0],ge=ae()[v+4>>>2>>>0];v+=8;for(var Te=0;Te<ge;Te++){var Re=B()[ie+Te>>>0],nt=oo[p];Re===0||Re===10?((p===1?x:S)(Wi(nt)),nt.length=0):nt.push(Re)}k+=ge}return ae()[I>>>2>>>0]=k,0}u||function(){for(var p=s.numThreads-1;p--;)tr();ye.unshift(()=>{ke++,function(v){u?v():Promise.all(Ct.map(Ji)).then(v)}(()=>Ge())})}();for(var lo=Array(256),uo=0;256>uo;++uo)lo[uo]=String.fromCharCode(uo);Zt=lo,St=s.BindingError=class extends Error{constructor(p){super(p),this.name="BindingError"}},s.InternalError=class extends Error{constructor(p){super(p),this.name="InternalError"}},zn.push(0,1,void 0,1,null,1,!0,1,!1,1),s.count_emval_handles=()=>zn.length/2-5-An.length;var Ft,Xe=[Oe,ct,Gi,Ii,Xt,oe,K,re,de,xe,Ue,_t,$t,mt,Ht,It,jo,Wo,Ho,lu,Ko,xc,Jo,ao,uu];(async function(){function p(I,k){return Ft=I.exports,Ft=function(){var F=Ft,ie={};for(let[ge,Te]of Object.entries(F))ie[ge]=typeof Te=="function"?(...Re)=>{_r.push(ge);try{return Te(...Re)}finally{me||(_r.pop(),Si&&oi===1&&_r.length===0&&(oi=0,Be+=1,Ei(po),typeof Fibers<"u"&&Fibers.rc()))}}:Te;return ie}(),Ft=function(){var F=Ft,ie=Te=>Re=>Te(Re)>>>0,ge=Te=>()=>Te()>>>0;return(F=Object.assign({},F)).Da=ie(F.Da),F.fb=ge(F.fb),F.hb=ie(F.hb),F.tb=ie(F.tb),F.ub=ge(F.ub),F.__cxa_get_exception_ptr=ie(F.__cxa_get_exception_ptr),F}(),hn.push(Ft.ib),C=k,Ge(),Ft}ke++;var v=et();if(s.instantiateWasm)return new Promise(I=>{s.instantiateWasm(v,(k,F)=>{p(k,F),I(k.exports)})});if(u)return new Promise(I=>{ze=k=>{var F=new WebAssembly.Instance(k,et());I(p(F,k))}});Pe??(Pe=s.locateFile?s.locateFile?s.locateFile("ort-wasm-simd-threaded.jsep.wasm",g):g+"ort-wasm-simd-threaded.jsep.wasm":new URL("/Gemini-AI-Translator/assets/ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href);try{var E=await async function(I){var k=Pe;if(!ce&&typeof WebAssembly.instantiateStreaming=="function"&&!Q(k))try{var F=fetch(k,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(F,I)}catch(ie){S(`wasm streaming compile failed: ${ie}`),S("falling back to ArrayBuffer instantiation")}return async function(ie,ge){try{var Te=await async function(Re){if(!ce)try{var nt=await h(Re);return new Uint8Array(nt)}catch{}if(Re==Pe&&ce)Re=new Uint8Array(ce);else{if(!m)throw"both async and sync fetching of the wasm failed";Re=m(Re)}return Re}(ie);return await WebAssembly.instantiate(Te,ge)}catch(Re){S(`failed to asynchronously prepare wasm: ${Re}`),$e(Re)}}(k,I)}(v);return p(E.instance,E.module)}catch(I){return r(I),Promise.reject(I)}})();var Yo=p=>(Yo=Ft.Da)(p),Xo=()=>(Xo=Ft.Ea)();s._OrtInit=(p,v)=>(s._OrtInit=Ft.Fa)(p,v),s._OrtGetLastError=(p,v)=>(s._OrtGetLastError=Ft.Ga)(p,v),s._OrtCreateSessionOptions=(p,v,E,I,k,F,ie,ge,Te,Re)=>(s._OrtCreateSessionOptions=Ft.Ha)(p,v,E,I,k,F,ie,ge,Te,Re),s._OrtAppendExecutionProvider=(p,v,E,I,k)=>(s._OrtAppendExecutionProvider=Ft.Ia)(p,v,E,I,k),s._OrtAddFreeDimensionOverride=(p,v,E)=>(s._OrtAddFreeDimensionOverride=Ft.Ja)(p,v,E),s._OrtAddSessionConfigEntry=(p,v,E)=>(s._OrtAddSessionConfigEntry=Ft.Ka)(p,v,E),s._OrtReleaseSessionOptions=p=>(s._OrtReleaseSessionOptions=Ft.La)(p),s._OrtCreateSession=(p,v,E)=>(s._OrtCreateSession=Ft.Ma)(p,v,E),s._OrtReleaseSession=p=>(s._OrtReleaseSession=Ft.Na)(p),s._OrtGetInputOutputCount=(p,v,E)=>(s._OrtGetInputOutputCount=Ft.Oa)(p,v,E),s._OrtGetInputOutputMetadata=(p,v,E,I)=>(s._OrtGetInputOutputMetadata=Ft.Pa)(p,v,E,I),s._OrtFree=p=>(s._OrtFree=Ft.Qa)(p),s._OrtCreateTensor=(p,v,E,I,k,F)=>(s._OrtCreateTensor=Ft.Ra)(p,v,E,I,k,F),s._OrtGetTensorData=(p,v,E,I,k)=>(s._OrtGetTensorData=Ft.Sa)(p,v,E,I,k),s._OrtReleaseTensor=p=>(s._OrtReleaseTensor=Ft.Ta)(p),s._OrtCreateRunOptions=(p,v,E,I)=>(s._OrtCreateRunOptions=Ft.Ua)(p,v,E,I),s._OrtAddRunConfigEntry=(p,v,E)=>(s._OrtAddRunConfigEntry=Ft.Va)(p,v,E),s._OrtReleaseRunOptions=p=>(s._OrtReleaseRunOptions=Ft.Wa)(p),s._OrtCreateBinding=p=>(s._OrtCreateBinding=Ft.Xa)(p),s._OrtBindInput=(p,v,E)=>(s._OrtBindInput=Ft.Ya)(p,v,E),s._OrtBindOutput=(p,v,E,I)=>(s._OrtBindOutput=Ft.Za)(p,v,E,I),s._OrtClearBoundOutputs=p=>(s._OrtClearBoundOutputs=Ft._a)(p),s._OrtReleaseBinding=p=>(s._OrtReleaseBinding=Ft.$a)(p),s._OrtRunWithBinding=(p,v,E,I,k)=>(s._OrtRunWithBinding=Ft.ab)(p,v,E,I,k),s._OrtRun=(p,v,E,I,k,F,ie,ge)=>(s._OrtRun=Ft.bb)(p,v,E,I,k,F,ie,ge),s._OrtEndProfiling=p=>(s._OrtEndProfiling=Ft.cb)(p),s._JsepOutput=(p,v,E)=>(s._JsepOutput=Ft.db)(p,v,E),s._JsepGetNodeName=p=>(s._JsepGetNodeName=Ft.eb)(p);var aa=()=>(aa=Ft.fb)(),Ni=s._free=p=>(Ni=s._free=Ft.gb)(p),Ns=s._malloc=p=>(Ns=s._malloc=Ft.hb)(p),Va=(p,v,E,I,k,F)=>(Va=Ft.kb)(p,v,E,I,k,F),co=()=>(co=Ft.lb)(),Qo=(p,v,E,I,k)=>(Qo=Ft.mb)(p,v,E,I,k),Zo=p=>(Zo=Ft.nb)(p),oa=p=>(oa=Ft.ob)(p),el=(p,v)=>(el=Ft.pb)(p,v),tl=()=>(tl=Ft.qb)(),fo=(p,v)=>(fo=Ft.rb)(p,v),Ls=p=>(Ls=Ft.sb)(p),Ga=p=>(Ga=Ft.tb)(p),la=()=>(la=Ft.ub)(),nl=s.dynCall_ii=(p,v)=>(nl=s.dynCall_ii=Ft.vb)(p,v),il=p=>(il=Ft.wb)(p),po=()=>(po=Ft.xb)(),rl=p=>(rl=Ft.yb)(p),sl=()=>(sl=Ft.zb)();return s.stackSave=()=>la(),s.stackRestore=p=>Ls(p),s.stackAlloc=p=>Ga(p),s.setValue=function(p,v,E="i8"){switch(E.endsWith("*")&&(E="*"),E){case"i1":case"i8":H()[p>>>0]=v;break;case"i16":ee()[p>>>1>>>0]=v;break;case"i32":le()[p>>>2>>>0]=v;break;case"i64":j[p>>>3]=BigInt(v);break;case"float":Ne()[p>>>2>>>0]=v;break;case"double":Ye()[p>>>3>>>0]=v;break;case"*":ae()[p>>>2>>>0]=v;break;default:$e(`invalid type for setValue: ${E}`)}},s.getValue=function(p,v="i8"){switch(v.endsWith("*")&&(v="*"),v){case"i1":case"i8":return H()[p>>>0];case"i16":return ee()[p>>>1>>>0];case"i32":return le()[p>>>2>>>0];case"i64":return j[p>>>3];case"float":return Ne()[p>>>2>>>0];case"double":return Ye()[p>>>3>>>0];case"*":return ae()[p>>>2>>>0];default:$e(`invalid type for getValue: ${v}`)}},s.UTF8ToString=Sn,s.stringToUTF8=L,s.lengthBytesUTF8=nr,function p(){if(0<ke)Le=p;else if(u)i(s),we();else{for(;0<ye.length;)ye.shift()(s);0<ke?Le=p:(s.calledRun=!0,me||(we(),i(s)))}}(),s.PTR_SIZE=4,a}),eV=C0,JP=(t=(e=globalThis.self)==null?void 0:e.name)==null?void 0:t.startsWith("em-pthread"),JP&&C0()}),$0,Wb,YP,fs,tV,$h,XP,QP,A0,ZP,I0,nV,P0,iV,Ux=dt(()=>{Bx(),$0=typeof location>"u"?void 0:location.origin,Wb=import.meta.url>"file:"&&import.meta.url<"file;",YP=()=>{{if(Wb){let e=URL;return new URL(new e("ort.bundle.min.mjs",import.meta.url).href,$0).href}return import.meta.url}},fs=YP(),tV=()=>{if(fs&&!fs.startsWith("blob:"))return fs.substring(0,fs.lastIndexOf("/")+1)},$h=(e,t)=>{try{let n=t??fs;return(n?new URL(e,n):new URL(e)).origin===$0}catch{return!1}},XP=(e,t)=>{let n=t??fs;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},QP=(e,t)=>`${t??"./"}${e}`,A0=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},ZP=async e=>(await import(e)).default,I0=(Ane(),mp(XU)).default,nV=async()=>{if(!fs)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if($h(fs))return[void 0,I0()];let e=await A0(fs);return[e,I0(e)]},P0=(Ine(),mp(ZU)).default,iV=async(e,t,n)=>{if(!e&&!t&&P0&&fs&&$h(fs))return[void 0,P0];{let i="ort-wasm-simd-threaded.jsep.mjs",r=e??XP(i,t),s=n&&r&&!$h(r,t),a=s?await A0(r):r??QP(i,t);return[s?a:void 0,await ZP(a)]}}}),k0,Ah,nf,D0,ek,tk,nk,Vx,mi,dc=dt(()=>{Ux(),Ah=!1,nf=!1,D0=!1,ek=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},tk=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},nk=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},Vx=async e=>{if(Ah)return Promise.resolve();if(nf)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(D0)throw new Error("previous call to 'initializeWebAssembly()' failed.");nf=!0;let t=e.initTimeout,n=e.numThreads;if(e.simd!==!1){if(e.simd==="relaxed"){if(!nk())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!tk())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let i=ek();n>1&&!i&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let r=e.wasmPaths,s=typeof r=="string"?r:void 0,a=r==null?void 0:r.mjs,o=(a==null?void 0:a.href)??a,l=r==null?void 0:r.wasm,u=(l==null?void 0:l.href)??l,c=e.wasmBinary,[f,d]=await iV(o,s,n>1),h=!1,m=[];if(t>0&&m.push(new Promise(y=>{setTimeout(()=>{h=!0,y()},t)})),m.push(new Promise((y,M)=>{let g={numThreads:n};if(c)g.wasmBinary=c;else if(u||s)g.locateFile=_=>u??s+_;else if(o&&o.indexOf("blob:")!==0)g.locateFile=_=>new URL(_,o).href;else if(f){let _=tV();_&&(g.locateFile=T=>_+T)}d(g).then(_=>{nf=!1,Ah=!0,k0=_,y(),f&&URL.revokeObjectURL(f)},_=>{nf=!1,D0=!0,M(_)})})),await Promise.race(m),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},mi=()=>{if(Ah&&k0)return k0;throw new Error("WebAssembly is not initialized yet.")}}),xa,pg,ii,Gx=dt(()=>{dc(),xa=(e,t)=>{let n=mi(),i=n.lengthBytesUTF8(e)+1,r=n._malloc(i);return n.stringToUTF8(e,r,i),t.push(r),r},pg=(e,t,n,i)=>{if(typeof e=="object"&&e!==null){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([r,s])=>{let a=t?t+r:r;if(typeof s=="object")pg(s,a+".",n,i);else if(typeof s=="string"||typeof s=="number")i(a,s.toString());else if(typeof s=="boolean")i(a,s?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof s}`)})},ii=e=>{let t=mi(),n=t.stackSave();try{let i=t.PTR_SIZE,r=t.stackAlloc(2*i);t._OrtGetLastError(r,r+i);let s=Number(t.getValue(r,i===4?"i32":"i64")),a=t.getValue(r+i,"*"),o=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${s}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(n)}}}),rV,Pne=dt(()=>{dc(),Gx(),rV=e=>{let t=mi(),n=0,i=[],r=e||{};try{if((e==null?void 0:e.logSeverityLevel)===void 0)r.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if((e==null?void 0:e.logVerbosityLevel)===void 0)r.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);(e==null?void 0:e.terminate)===void 0&&(r.terminate=!1);let s=0;return(e==null?void 0:e.tag)!==void 0&&(s=xa(e.tag,i)),n=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,s),n===0&&ii("Can't create run options."),(e==null?void 0:e.extra)!==void 0&&pg(e.extra,"",new WeakSet,(a,o)=>{let l=xa(a,i),u=xa(o,i);t._OrtAddRunConfigEntry(n,l,u)!==0&&ii(`Can't set a run config entry: ${a} - ${o}.`)}),[n,i]}catch(s){throw n!==0&&t._OrtReleaseRunOptions(n),i.forEach(a=>t._free(a)),s}}}),ik,rk,sk,rf,ak,sV,kne=dt(()=>{dc(),Gx(),ik=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},rk=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},sk=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(e.enableMemPattern=!1)},rf=(e,t,n,i)=>{let r=xa(t,i),s=xa(n,i);mi()._OrtAddSessionConfigEntry(e,r,s)!==0&&ii(`Can't set a session config entry: ${t} - ${n}.`)},ak=async(e,t,n)=>{for(let i of t){let r=typeof i=="string"?i:i.name,s=[];switch(r){case"webnn":if(r="WEBNN",typeof i!="string"){let c=i==null?void 0:i.deviceType;c&&rf(e,"deviceType",c,n)}break;case"webgpu":if(r="JS",typeof i!="string"){let c=i;if(c!=null&&c.preferredLayout){if(c.preferredLayout!=="NCHW"&&c.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${c.preferredLayout}`);rf(e,"preferredLayout",c.preferredLayout,n)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let a=xa(r,n),o=s.length,l=0,u=0;if(o>0){l=mi()._malloc(o*mi().PTR_SIZE),n.push(l),u=mi()._malloc(o*mi().PTR_SIZE),n.push(u);for(let c=0;c<o;c++)mi().setValue(l+c*mi().PTR_SIZE,s[c][0],"*"),mi().setValue(u+c*mi().PTR_SIZE,s[c][1],"*")}await mi()._OrtAppendExecutionProvider(e,a,l,u,o)!==0&&ii(`Can't append execution provider: ${r}.`)}},sV=async e=>{let t=mi(),n=0,i=[],r=e||{};sk(r);try{let s=ik(r.graphOptimizationLevel??"all"),a=rk(r.executionMode??"sequential"),o=typeof r.logId=="string"?xa(r.logId,i):0,l=r.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let u=r.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let c=typeof r.optimizedModelFilePath=="string"?xa(r.optimizedModelFilePath,i):0;if(n=t._OrtCreateSessionOptions(s,!!r.enableCpuMemArena,!!r.enableMemPattern,a,!!r.enableProfiling,0,o,l,u,c),n===0&&ii("Can't create session options."),r.executionProviders&&await ak(n,r.executionProviders,i),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);rf(n,"enableGraphCapture",r.enableGraphCapture.toString(),i)}if(r.freeDimensionOverrides)for(let[f,d]of Object.entries(r.freeDimensionOverrides)){if(typeof f!="string")throw new Error(`free dimension override name must be a string: ${f}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let h=xa(f,i);t._OrtAddFreeDimensionOverride(n,h,d)!==0&&ii(`Can't set a free dimension override: ${f} - ${d}.`)}return r.extra!==void 0&&pg(r.extra,"",new WeakSet,(f,d)=>{rf(n,f,d,i)}),[n,i]}catch(s){throw n!==0&&t._OrtReleaseSessionOptions(n)!==0&&ii("Can't release session options."),i.forEach(a=>t._free(a)),s}}}),Bc,Eo,Pu,jx,hg,Wx,Hx,Hb,en=dt(()=>{Bc=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},Eo=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},Pu=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],i=typeof t=="number"?t:t.reduce((r,s)=>r*s,1);return n>0?Math.ceil(i*n):void 0},jx=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},hg=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Wx=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Hx=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Hb=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),qx,aV=dt(()=>{Bx(),qx=async e=>{if(typeof e=="string"){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),i=n?parseInt(n,10):0;if(i<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),s;try{s=new ArrayBuffer(i)}catch(o){if(o instanceof RangeError){let l=Math.ceil(i/65536);s=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw o}let a=0;for(;;){let{done:o,value:l}=await r.read();if(o)break;let u=l.byteLength;new Uint8Array(s,a,u).set(l),a+=u}return new Uint8Array(s,0,i)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),ok,lk,uk,ck,Kx,dk,Nn,Vo=dt(()=>{en(),ok=["V","I","W","E","F"],lk=(e,t)=>{console.log(`[${ok[e]},${new Date().toISOString()}]${t}`)},Kx=(e,t)=>{uk=e,ck=t},dk=(e,t)=>{let n=hg(e),i=hg(uk);n>=i&&lk(n,typeof t=="function"?t():t)},Nn=(...e)=>{ck&&dk(...e)}}),fk,Ed,We,mg,oV,lV,uV,ln=dt(()=>{fk=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},Ed=class{static calcShape(e,t,n=!1){let i=e.length,r=t.length;if(i===0)return t;if(r===0)return e;let s=Math.max(e.length,t.length),a=new Array(s);if(n){if(i<2||r<2)return;let o=fk.calcMatMulShape([e[i-2],e[i-1]],[t[r-2],t[r-1]]);if(o===void 0)return;[a[s-2],a[s-1]]=o}for(let o=n?3:1;o<=s;o++){let l=i-o<0?1:e[i-o],u=r-o<0?1:t[r-o];if(l!==u&&l>1&&u>1)return;let c=Math.max(l,u);if(l&&u)a[s-o]=Math.max(l,u);else{if(c>1)return;a[s-o]=0}}return a}static isValidBroadcast(e,t){let n=e.length,i=t.length;if(n>i)return!1;for(let r=1;r<=n;r++)if(e[n-r]!==1&&e[n-r]!==t[i-r])return!1;return!0}},We=class Mm{static size(t){return Mm.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,n=4){let i=t.length;if(i===0)return[];let r=new Array(i),s=i-1;for(;s>=0;){if(t[s]%n===0){r[s]=t[s]/n;break}if(n%t[s]!==0)throw new Error("cannot convert shape");r[s]=1,n/=t[s],s--}for(s--;s>=0;s--)r[s]=t[s];return r}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return Mm.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return Mm.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(t,n,i){let r=1;for(let s=n;s<i;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=Number(t[s])}return r}static computeStrides(t){let n=t.length;if(n===0)return[];if(n===1)return[1];let i=new Array(n);i[n-1]=1,i[n-2]=t[n-1];for(let r=n-3;r>=0;--r)i[r]=i[r+1]*t[r+1];return i}static normalizeAxis(t,n){if(t<-n&&t>=n)throw new Error("unsupported axis for this operation.");return t<0?t+n:t}static normalizeAxes(t,n){return t.map(i=>this.normalizeAxis(i,n??t.length))}static sortBasedOnPerm(t,n){return n?n.map(i=>t[i]):t.slice().reverse()}static padShape(t,n){let i=t.length;return t.map((r,s)=>r+n[s]+n[s+i])}static areEqual(t,n){return t.length!==n.length?!1:t.every((i,r)=>i===n[r])}},mg=class Pf{static adjustPoolAttributes(t,n,i,r,s,a){if(!t&&i.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let o=0;o<n.length-2;o++)o>=i.length?i.push(n[o+2]):i[o]=n[o+2];for(let o=0;o<i.length;o++)if(o<r.length){if(r[o]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let o=0;o<i.length;o++)if(o<s.length){if(s[o]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let o=0;o<i.length*2;o++)if(o<a.length){if(a[o]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let o=0;o<i.length;o++){if(i[o]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[o]>=i[o]||a[o+i.length]>=i[o])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,i,r,s,a,o){if(o){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<t.length-2;l++)Pf.adjustPadAndReturnShape(t[l+(a?1:2)],n[l],i[l],r[l],s,l,l+t.length-2,o)}}static computePoolOutputShape(t,n,i,r,s,a,o){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let l=[n[0],n[1]];return Pf.computeShapeHelper(t,n,l,i,r,s,a,o),l}static computeConvOutputShape(t,n,i,r,s,a,o){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[t[0],n[0]];return Pf.computeShapeHelper(!1,t,l,i,r,s,a,o),l}static computeShapeHelper(t,n,i,r,s,a,o,l){if(t)for(let u=0;u<n.length-2;u++)i.push(1);else for(let u=0;u<n.length-2;u++)i.push(Pf.adjustPadAndReturnShape(n[u+2],r[u],s[u],a[u],o,u,u+n.length-2,l))}static adjustPadAndReturnShape(t,n,i,r,s,a,o,l){let u=i*(r-1)+1;if(l&&l!=="NOTSET")switch(l){case"VALID":return s[a]=0,s[o]=0,Math.floor((t-u)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(i!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let c=((t+n-1)/n-1)*n+r-t;return s[a]=Math.floor(l==="SAME_LOWER"?(c+1)/2:c/2),s[o]=c-s[a],Math.floor((t+c-r)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[a]+s[o]-u)/n+1)}},oV=class{static getShapeOfGemmResult(e,t,n,i,r){if(e.length!==2||n.length!==2)throw new Error("shape need to be of size 2");let s,a,o;t?(s=e[1],a=e[0]):(s=e[0],a=e[1]);let l=-1;if(i?(o=n[0],l=1):(o=n[1],l=0),n[l]!==a)throw new Error("dimension mismatch");if(s<=0||o<=0||a<=0)throw new Error("invalid shape specified");if(r&&!Ed.isValidBroadcast(r,[s,o]))throw new Error("gemm: invalid bias shape for broadcast");return[s,o,a]}},lV=-34028234663852886e22,uV=34028234663852886e22}),Jx,cV=dt(()=>{en(),Jx=(e,t)=>new(jx(t))(e)}),qb,O0,pk,R0,hk,N0,L0,z0,mk,dV,Dne=dt(()=>{Vo(),qb=(e,t=!0)=>{if(e.byteLength%8!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 8 (BigInt).");let n=e.byteLength/8,i=new BigInt64Array(e.buffer,e.byteOffset,n),r=new Int32Array(n);for(let s=0;s<n;s++){let a=i[s];if(a>2147483647n||a<-2147483648n)throw new Error(`Overflow occurred when converting BigInt to Int32 at index ${s}: ${a}`);r[s]=Number(a)}return t?new Uint8Array(r.buffer):r},O0=(e,t=!0)=>{if(e.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (Int32).");let n=e.byteLength/4,i=new Int32Array(e.buffer,e.byteOffset,n),r=BigInt64Array.from(i,BigInt);return t?new Uint8Array(r.buffer):r},pk=1,R0=()=>pk++,hk=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),N0=(e,t)=>{let n=hk.get(e);if(!n)throw new Error("Unsupported data type.");return t.length>0?Math.ceil(t.reduce((i,r)=>i*r)*n/8):0},L0=class{constructor(e){this.shouldConvertInt64toInt32=!1,this.isInt64ToInt32Converted=!1;let{sessionId:t,context:n,tensor:i,dataType:r,shape:s,shouldConvertInt64toInt32:a=!1}=e;this.sessionId=t,this.mlContext=n,this.mlTensor=i,this.dataType=r,this.tensorShape=s,this.shouldConvertInt64toInt32=a}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return N0(this.dataType,this.tensorShape)}destroy(){Nn("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e,t){if(e){let n=await this.mlContext.readTensor(this.mlTensor),i=O0(new Uint8Array(n));if(t){(t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength)).set(i);return}else return i.buffer}else return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,t,n){return this.mlContext===e&&this.dataType===t&&this.tensorShape.length===n.length&&this.tensorShape.every((i,r)=>i===n[r])}setIsInt64ToInt32Converted(e){this.isInt64ToInt32Converted=e}},z0=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,n,i){let r=t,s=this.tensorManager.getMLContext(e),a=r==="int64"&&!s.opSupportLimits().input.dataTypes.includes("int64");if(a&&(r="int32",Nn("verbose",()=>"[WebNN] TensorIdTracker.ensureTensor: convert dataType from int64 to int32")),this.wrapper){if(this.wrapper.canReuseTensor(s,r,n))return this.wrapper.tensor;if(i){if(this.wrapper.byteLength!==N0(r,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let o=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,r,n,o,!0,!0,a),i&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let t=e;if(this.wrapper)if(this.wrapper.shouldConvertInt64toInt32&&(t=qb(e,!0),this.wrapper.setIsInt64ToInt32Converted(!0)),t.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else Nn("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor();this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(e){var t,n,i;if(this.activeUpload){let r=(t=this.wrapper)!=null&&t.isInt64ToInt32Converted?O0(this.activeUpload):this.activeUpload;if(e){e instanceof ArrayBuffer?new Uint8Array(e).set(r):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(r);return}else return r.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read((n=this.wrapper)==null?void 0:n.shouldConvertInt64toInt32,e):this.wrapper.read((i=this.wrapper)==null?void 0:i.shouldConvertInt64toInt32)}},mk=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let t=this.backend.getMLContext(e);if(!t)throw new Error("MLContext not found for session.");return t}reserveTensorId(){let e=R0();return this.tensorTrackersById.set(e,new z0(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,n,i,r){Nn("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${n}, shape: ${i}, copyOld: ${r}}`);let s=this.tensorTrackersById.get(t);if(!s)throw new Error("Tensor not found.");return s.ensureTensor(e,n,i,r)}upload(e,t){let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");n.upload(t)}async download(e,t){Nn("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t==null?void 0:t.byteLength}}`);let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter(t=>t.sessionId!==e)}registerTensor(e,t,n,i){let r=this.getMLContext(e),s=R0(),a=new L0({sessionId:e,context:r,tensor:t,dataType:n,shape:i});return this.tensorTrackersById.set(s,new z0(this,a)),this.externalTensors.add(a),s}async getCachedTensor(e,t,n,i,r,s,a=!1){let o=this.getMLContext(e);for(let[u,c]of this.freeTensors.entries())if(c.canReuseTensor(o,t,n)){Nn("verbose",()=>`[WebNN] Reusing tensor {dataType: ${t}, shape: ${n}}`);let f=this.freeTensors.splice(u,1)[0];return f.sessionId=e,f}Nn("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, shape: ${n}}`);let l=await o.createTensor({dataType:t,shape:n,dimensions:n,usage:i,writable:r,readable:s});return new L0({sessionId:e,context:o,tensor:l,dataType:t,shape:n,shouldConvertInt64toInt32:a})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},dV=(...e)=>new mk(...e)}),Ih,gk,fV,One=dt(()=>{en(),dc(),cV(),Dne(),Vo(),Ih=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),gk=(e,t)=>{if(e===t)return!0;if(e===void 0||t===void 0)return!1;let n=Object.keys(e).sort(),i=Object.keys(t).sort();return n.length===i.length&&n.every((r,s)=>r===i[s]&&e[r]===t[r])},fV=class{constructor(e){this.tensorManager=dV(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,Kx(e.logLevel,!!e.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(e){Nn("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){Nn("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let t=this.temporarySessionTensorIds.get(e);if(t){for(let n of t)Nn("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${n}}`),this.tensorManager.releaseTensorId(n);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let n=this.mlContextCache.findIndex(i=>i.gpuDevice===e);if(n!==-1)return this.mlContextCache[n].mlContext;{let i=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:i}),i}}else if(e===void 0){let n=this.mlContextCache.findIndex(i=>i.options===void 0&&i.gpuDevice===void 0);if(n!==-1)return this.mlContextCache[n].mlContext;{let i=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:i}),i}}let t=this.mlContextCache.findIndex(n=>gk(n.options,e));if(t!==-1)return this.mlContextCache[t].mlContext;{let n=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:n}),n}}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let n=this.sessionIdsByMLContext.get(t);n||(n=new Set,this.sessionIdsByMLContext.set(t,n)),n.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e);let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(t);if(n.delete(e),n.size===0){this.sessionIdsByMLContext.delete(t);let i=this.mlContextCache.findIndex(r=>r.mlContext===t);i!==-1&&this.mlContextCache.splice(i,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){Nn("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,n,i,r){let s=Ih.get(n);if(!s)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,t,s,i,r)}async createTemporaryTensor(e,t,n){Nn("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${t}, shape: ${n}}`);let i=Ih.get(t);if(!i)throw new Error(`Unsupported ONNX data type: ${t}`);let r=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,r,i,n,!1);let s=this.temporarySessionTensorIds.get(e);return s?s.push(r):this.temporarySessionTensorIds.set(e,[r]),r}uploadTensor(e,t){if(!mi().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");Nn("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let n=await this.tensorManager.download(e);return Jx(n,t)}}registerMLTensor(e,t,n,i){let r=Ih.get(n);if(!r)throw new Error(`Unsupported ONNX data type: ${n}`);let s=this.tensorManager.registerTensor(e,t,r,i);return Nn("verbose",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${r}, dimensions: ${i}} -> {tensorId: ${s}}`),s}registerMLConstant(e,t,n,i,r,s,a=!1){if(!s)throw new Error("External mounted files are not available.");let o=e;e.startsWith("./")&&(o=e.substring(2));let l=s.get(o);if(!l)throw new Error(`File with name ${o} not found in preloaded files.`);if(t+n>l.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let u=l.slice(t,t+n).buffer,c;switch(r.dataType){case"float32":c=new Float32Array(u);break;case"float16":c=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(u):new Uint16Array(u);break;case"int32":c=new Int32Array(u);break;case"uint32":c=new Uint32Array(u);break;case"int64":a?(c=qb(new Uint8Array(u),!1),r.dataType="int32"):c=new BigInt64Array(u);break;case"uint64":c=new BigUint64Array(u);break;case"int8":c=new Int8Array(u);break;case"int4":case"uint4":case"uint8":c=new Uint8Array(u);break;default:throw new Error(`Unsupported data type: ${r.dataType} in creating WebNN Constant from external data.`)}return Nn("verbose",()=>`[WebNN] registerMLConstant {dataType: ${r.dataType}, shape: ${r.shape}}} ${a?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),i.constant(r,c)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}isGraphInput(e,t){let n=this.sessionGraphInputs.get(e);return n?n.includes(t):!1}isInt64Supported(e){var t;return!!((t=this.mlContextBySessionId.get(e))!=null&&t.opSupportLimits().input.dataTypes.includes("int64"))}flush(){}}}),Yx=dt(()=>{}),F0,Ph,kh,_k,yk,B0,Kb,vk,pV,Rne=dt(()=>{Vo(),Yx(),F0=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Ph=[],kh=e=>Math.ceil(Number(e)/16)*16,_k=e=>{for(let t=0;t<Ph.length;t++){let n=Ph[t];if(e<=n)return n}return Math.ceil(e/16)*16},yk=1,B0=()=>yk++,Kb=async(e,t,n,i)=>{let r=kh(n),s=e.device.createBuffer({size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,s,0,r),e.flush(),await s.mapAsync(GPUMapMode.READ);let o=s.getMappedRange();if(i){let l=i();return l.set(new Uint8Array(o,0,n)),l}else return new Uint8Array(o.slice(0,n))}finally{s.destroy()}},vk=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[t]of F0)Ph.push(t),this.freeBuffers.set(t,[]),this.freeUniformBuffers.set(t,[]);this.sessionCount=0}upload(e,t){let n=t.buffer,i=t.byteOffset,r=t.byteLength,s=kh(r),a=this.storageCache.get(e);if(!a)throw new Error("gpu data for uploading does not exist");if(Number(a.originalSize)!==r)throw new Error(`inconsistent data size. gpu data size=${a.originalSize}, data size=${r}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=o.getMappedRange();new Uint8Array(l).set(new Uint8Array(n,i,r)),o.unmap();let u=this.backend.device.createCommandEncoder();u.copyBufferToBuffer(o,0,a.gpuData.buffer,0,s),this.backend.device.queue.submit([u.finish()]),o.destroy(),Nn("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`)}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(t);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let r=kh(n.originalSize),s=this.backend.getCommandEncoder();this.backend.endComputePass(),s.copyBufferToBuffer(n.gpuData.buffer,0,i.gpuData.buffer,0,r)}registerExternalBuffer(e,t,n){let i;if(n){if(i=n[0],e===n[1])return Nn("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${i}, buffer is the same, skip.`),i;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else i=B0();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:e},originalSize:t}),Nn("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${i}, registered.`),i}unregisterExternalBuffer(e){e!==void 0&&(this.storageCache.delete(e),Nn("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=_k(e),i,r=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,s=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(r||s){let o=(r?this.freeBuffers:this.freeUniformBuffers).get(n);o?o.length>0?i=o.pop():i=this.backend.device.createBuffer({size:n,usage:t}):i=this.backend.device.createBuffer({size:n,usage:t})}else i=this.backend.device.createBuffer({size:n,usage:t});let a={id:B0(),type:0,buffer:i};return this.storageCache.set(a.id,{gpuData:a,originalSize:Number(e)}),Nn("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${a.id}`),a}get(e){var t;return(t=this.storageCache.get(e))==null?void 0:t.gpuData}release(e){let t=typeof e=="bigint"?Number(e):e,n=this.storageCache.get(t);if(!n){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return Nn("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,t){let n=this.storageCache.get(Number(e));if(!n)throw new Error("data does not exist");await Kb(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let e of this.buffersPending){let t=F0.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(e.size)||[];t===void 0||n.length>=t?e.destroy():n.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(e.size)||[];t===void 0||n.length>=t?e.destroy():n.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,this.sessionCount===0&&(Nn("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.storageCache=new Map)}},pV=(...e)=>new vk(...e)}),wk,Qn,Ui=dt(()=>{wk=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},Qn=e=>new wk(e)}),Sd,Dh,hr,Nr,Bt,zi,Jb,nd,jl,Lt,sf,Qe,Ot,hV,Xx,bk,mV,cn=dt(()=>{en(),ln(),Sd=64,Dh=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},hr=(e,t=1)=>{let n=Dh(e,t);return typeof n=="string"?n:n[0]},Nr=(e,t=1)=>{let n=Dh(e,t);return typeof n=="string"?n:n[1]},Bt=(...e)=>{let t=[];return e.forEach(n=>{n.length!==0&&t.push({type:12,data:n},{type:12,data:We.computeStrides(n)})}),t},zi=e=>e%4===0?4:e%2===0?2:1,Jb=(e="f32",t,n="0")=>!t||t===1?`${e}(${n})`:`vec${t}<${e}>(${n})`,nd=(e,t,n)=>e==="f32"?n:t===1?`f32(${n})`:`vec${t}<f32>(${n})`,jl=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Lt=(e,t,n,i)=>e.startsWith("uniforms.")&&n>4?typeof t=="string"?i==="f16"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:i==="f16"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,sf=(e,t,n,i,r)=>{let s=typeof n=="number",a=s?n:n.length,o=[...new Array(a).keys()],l=a<2?"u32":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,u=Dh(t,r),c=typeof u=="string"?u:u[1],f=typeof u=="string"?u:u[0],d={indices:l,value:c,storage:f,tensor:t},h=Q=>typeof Q=="string"?Q:`${Q}u`,m={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},y=s?"uniforms.":"",M=`${y}${e}_shape`,g=`${y}${e}_strides`,_="";for(let Q=0;Q<a-1;Q++)_+=`
    let dim${Q} = current / ${Lt(g,Q,a)};
    let rest${Q} = current % ${Lt(g,Q,a)};
    indices[${Q}] = dim${Q};
    current = rest${Q};
    `;_+=`indices[${a-1}] = current;`;let T=a<2?"":`
  fn o2i_${e}(offset: u32) -> ${d.indices} {
    var indices: ${d.indices};
    var current = offset;
    ${_}
    return indices;
  }`,x=Q=>(m.offsetToIndices=!0,a<2?Q:`o2i_${e}(${Q})`),S=[];if(a>=2)for(let Q=a-1;Q>=0;Q--)S.push(`${Lt(g,Q,a)} * (indices[${Q}])`);let $=a<2?"":`
  fn i2o_${e}(indices: ${d.indices}) -> u32 {
    return ${S.join("+")};
  }`,C=Q=>(m.indicesToOffset=!0,a<2?Q:`i2o_${e}(${Q})`),P=(...Q)=>a===0?"0u":`${d.indices}(${Q.map(h).join(",")})`,O=(Q,H)=>a<2?`${Q}`:`${Lt(Q,H,a)}`,R=(Q,H,B)=>a<2?`${Q}=${B};`:`${Lt(Q,H,a)}=${B};`,G={},W=(Q,H)=>{m.broadcastedIndicesToOffset=!0;let B=`${H.name}broadcastedIndicesTo${e}Offset`;if(B in G)return`${B}(${Q})`;let ee=[];for(let _e=a-1;_e>=0;_e--){let le=H.indicesGet("outputIndices",_e+H.rank-a);ee.push(`${O(g,_e)} * (${le} % ${O(M,_e)})`)}return G[B]=`fn ${B}(outputIndices: ${H.type.indices}) -> u32 {
             return ${ee.length>0?ee.join("+"):"0u"};
           }`,`${B}(${Q})`},V=(Q,H)=>(()=>{if(d.storage===d.value)return`${e}[${Q}]=${H};`;if(d.storage==="vec2<u32>"&&d.value==="i32")return`${e}[${Q}]=vec2<u32>(u32(${H}), select(0u, 0xFFFFFFFFu, ${H} < 0));`;if(d.storage==="vec2<u32>"&&d.value==="u32")return`${e}[${Q}]=vec2<u32>(u32(${H}), 0u);`;if(d.storage==="u32"&&d.value==="vec4<bool>")return`${e}[${Q}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${H}));`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),te=Q=>(()=>{if(d.storage===d.value)return`${e}[${Q}]`;if(d.storage==="vec2<u32>"&&d.value==="i32")return`i32(${e}[${Q}].x)`;if(d.storage==="vec2<u32>"&&d.value==="u32")return`u32(${e}[${Q}].x)`;if(d.storage==="u32"&&d.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${Q}] & 0xFFu), bool(${e}[${Q}] & 0xFF00u), bool(${e}[${Q}] & 0xFF0000u), bool(${e}[${Q}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),J=a<2?"":`
  fn get_${e}ByIndices(indices: ${d.indices}) -> ${c} {
    return ${te(`i2o_${e}(indices)`)};
  }`,j=a<2?"":(()=>{let Q=o.map(B=>`d${B}: u32`).join(", "),H=o.map(B=>`d${B}`).join(", ");return`
  fn get_${e}(${Q}) -> ${c} {
    return get_${e}ByIndices(${P(H)});
  }`})(),Y=(...Q)=>{if(Q.length!==a)throw new Error(`indices length must be ${a}`);let H=Q.map(h).join(",");return a===0?te("0u"):a===1?te(H[0]):(m.get=!0,m.getByIndices=!0,m.indicesToOffset=!0,`get_${e}(${H})`)},X=Q=>a<2?te(Q):(m.getByIndices=!0,m.indicesToOffset=!0,`get_${e}ByIndices(${Q})`),ce=a<2?"":`
  fn set_${e}ByIndices(indices: ${d.indices}, value: ${c}) {
    ${V(`i2o_${e}(indices)`,"value")}
  }`,me=a<2?"":(()=>{let Q=o.map(B=>`d${B}: u32`).join(", "),H=o.map(B=>`d${B}`).join(", ");return`
  fn set_${e}(${Q}, value: ${c}) {
    set_${e}ByIndices(${P(H)}, value);
  }`})();return{impl:()=>{let Q=[],H=!1;return m.offsetToIndices&&(Q.push(T),H=!0),m.indicesToOffset&&(Q.push($),H=!0),m.broadcastedIndicesToOffset&&(Object.values(G).forEach(B=>Q.push(B)),H=!0),m.set&&(Q.push(me),H=!0),m.setByIndices&&(Q.push(ce),H=!0),m.get&&(Q.push(j),H=!0),m.getByIndices&&(Q.push(J),H=!0),!s&&H&&Q.unshift(`const ${M} = ${d.indices}(${n.join(",")});`,`const ${g} = ${d.indices}(${We.computeStrides(n).join(",")});`),Q.join(`
`)},type:d,offsetToIndices:x,indicesToOffset:C,broadcastedIndicesToOffset:W,indices:P,indicesGet:O,indicesSet:R,set:(...Q)=>{if(Q.length!==a+1)throw new Error(`indices length must be ${a}`);let H=Q[a];if(typeof H!="string")throw new Error("value must be string");let B=Q.slice(0,a).map(h).join(",");return a===0?V("0u",H):a===1?V(B[0],H):(m.set=!0,m.setByIndices=!0,m.indicesToOffset=!0,`set_${e}(${B}, ${H})`)},setByOffset:V,setByIndices:(Q,H)=>a<2?V(Q,H):(m.setByIndices=!0,m.indicesToOffset=!0,`set_${e}ByIndices(${Q}, ${H});`),get:Y,getByOffset:te,getByIndices:X,usage:i,name:e,strides:g,shape:M,rank:a}},Qe=(e,t,n,i=1)=>sf(e,t,n,"input",i),Ot=(e,t,n,i=1)=>sf(e,t,n,"output",i),hV=(e,t,n)=>sf(e,t,n,"atomicOutput",1),Xx=(e,t,n,i=1)=>sf(e,t,n,"internal",i),bk=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${typeof e=="number"?`${e}u`:e}) { return; }`}mainStart(e=Sd){let t=typeof e=="number"?e:e[0],n=typeof e=="number"?1:e[1],i=typeof e=="number"?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||i>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${n}, ${i}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*n*i>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${n}, ${i}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let r=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,s=r?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,a=r?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${t*n*i}u + local_idx;`;return`@compute @workgroup_size(${t}, ${n}, ${i})
  fn main(${s}) {
    ${a}
  `}appendVariableUniforms(e){e.rank!==0&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if(e.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n=e.usage==="input"?"read":"read_write",i=e.usage==="atomicOutput"?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${i}>;`}declareVariables(...e){return e.map(t=>this.declareVariable(t,this.variableIndex++)).join(`
`)}registerInternalVariable(e){if(e.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach(t=>this.registerInternalVariable(t)),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let e=[];for(let{name:t,type:n,length:i}of this.uniforms)if(i&&i>4)n==="f16"?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(i/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(i/4)}>`);else{let r=i==null||i===1?n:`vec${i}<${n}>`;e.push(`${t}:${r}`)}return`
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(e=>e.impl()).join(`
`)+this.internalVariables.map(e=>e.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let e=t=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(t)];return this.uniforms.map(t=>[e(t.type),t.length??1])}},mV=(e,t)=>new bk(e,t)}),xk,U0,Tk,Mk,Ek,Sk,Ms,gV,_V,Jl=dt(()=>{en(),ln(),Ui(),cn(),xk=(e,t)=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(t.length!==0&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},U0=(e,t)=>t.length!==0?t:[...new Array(e).keys()].reverse(),Tk=(e,t)=>We.sortBasedOnPerm(e,U0(e.length,t)),Mk=(e,t,n,i)=>{let r=`fn perm(i: ${i.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`;for(let s=0;s<t;++s)r+=`a[${e[s]}]=i[${s}];`;return r+="return a;}"},Ek=(e,t)=>{let n=[],i=[];for(let r=0;r<e.length;++r)e[r]!==1&&n.push(e[r]),e[t[r]]!==1&&i.push(t[r]);return{newShape:n,newPerm:i}},Sk=(e,t)=>{let n=0;for(let i=0;i<e.length;++i)if(t[e[i]]!==1){if(e[i]<n)return!1;n=e[i]}return!0},Ms=(e,t)=>{let n=e.dataType,i=e.dims.length,r=U0(i,t),s=Tk(e.dims,r),a=e.dims,o=s,l=i<2||Sk(r,e.dims),u;if(l)return u=m=>{let y=Qe("input",n,a,4),M=Ot("output",n,o,4);return`
  ${m.registerUniform("output_size","u32").declareVariables(y,M)}
  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let m=We.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(m/64/4)},programUniforms:[{type:12,data:Math.ceil(m/4)}]}},getShaderSource:u};let{newShape:c,newPerm:f}=Ek(e.dims,r),d=We.areEqual(f,[2,3,1]),h=We.areEqual(f,[3,1,2]);if(c.length===2||d||h){a=d?[c[0],c[1]*c[2]]:h?[c[0]*c[1],c[2]]:c,o=[a[1],a[0]];let m=16;return u=y=>{let M=Qe("a",n,a.length),g=Ot("output",n,o.length);return`
  ${y.registerUniform("output_size","u32").declareVariables(M,g)}
  var<workgroup> tile : array<array<${g.type.value}, ${m+1}>, ${m}>;
  ${y.mainStart([m,m,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${m} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${m}u + local_id.x;
    let input_row = workgroup_id_x * ${m}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${M.getByIndices(`${M.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${m}u + local_id.x;
    let output_row = workgroup_id_y * ${m}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${g.setByIndices(`${g.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let y=We.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(o[1]/m),y:Math.ceil(o[0]/m)},programUniforms:[{type:12,data:y},...Bt(a,o)]}},getShaderSource:u}}return u=m=>{let y=Qe("a",n,a.length),M=Ot("output",n,o.length);return`
  ${m.registerUniform("output_size","u32").declareVariables(y,M)}

  ${Mk(r,i,y,M)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${M.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${M.setByOffset("global_idx",y.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let m=We.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},...Bt(a,o)]}},getShaderSource:u}},gV=(e,t)=>{xk(e.inputs,t.perm),e.compute(Ms(e.inputs[0],t.perm))},_V=e=>Qn({perm:e.perm})}),Ck,$k,Ak,Ik,Pk,kk,Dk,Ok,Rk,Nk,da,yV,vV,wV,bV,xV,TV,MV,EV,SV,CV,Nne=dt(()=>{en(),ln(),cn(),Qx(),Jl(),Ck={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},$k={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Ak={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Ik={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Pk=(e,t)=>{let n=[];for(let i=t-e;i<t;++i)n.push(i);return n},kk=(e,t)=>{let n=[],i=e.length;for(let s=0;s<i;s++)t.indexOf(s)===-1&&n.push(e[s]);let r=t.map(s=>e[s]);return[n,r]},Dk=(e,t)=>{let n=e.length+t.length,i=[],r=0;for(let s=0;s<n;s++)t.indexOf(s)===-1?i.push(e[r++]):i.push(1);return i},Ok=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},Rk=(e,t)=>{let n=[];if(!Ok(e,t)){for(let i=0;i<t;++i)e.indexOf(i)===-1&&n.push(i);e.forEach(i=>n.push(i))}return n},Nk=(e,t,n,i,r,s,a)=>{let o=n[0].dims,l=We.size(s),u=We.size(a),c=Qe("_A",n[0].dataType,o),f=Ot("output",r,s),d=64;l===1&&(d=256);let h=`
          var<workgroup> aBestValues : array<f32, ${d}>;
       `,m=y=>`
        ${y.registerUniform("reduceSize","u32").declareVariables(c,f)}
        ${h}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${y.mainStart(d)}

          let outputIndex = global_idx / ${d};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${Ak[i]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${d}) {
           let candidate = f32(${c.getByOffset("offset + k")});
           bestValue = ${Ck[i]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${d}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${$k[i]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${f.setByOffset("outputIndex",`${i==="mean"?`${f.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${f.type.storage}(${Ik[i]})`}`)};
         }
        }`;return{name:e,shaderCache:{hint:`${t};${d}`,inputDependencies:["type"]},getShaderSource:m,getRunData:()=>({outputs:[{dims:s,dataType:r}],dispatchGroup:{x:l},programUniforms:[{type:12,data:u}]})}},da=(e,t,n,i)=>{let r=e.inputs.length===1?n:Yb(e.inputs,n),s=r.axes;s.length===0&&!r.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((h,m)=>m));let a=We.normalizeAxes(s,e.inputs[0].dims.length),o=a,l=e.inputs[0],u=Rk(o,e.inputs[0].dims.length);u.length>0&&(l=e.compute(Ms(e.inputs[0],u),{inputs:[0],outputs:[-1]})[0],o=Pk(o.length,l.dims.length));let[c,f]=kk(l.dims,o),d=c;r.keepDims&&(d=Dk(c,a)),e.compute(Nk(t,r.cacheKey,[l],i,e.inputs[0].dataType,d,f),{inputs:[l]})},yV=(e,t)=>{da(e,"ReduceMeanShared",t,"mean")},vV=(e,t)=>{da(e,"ReduceL1Shared",t,"l1")},wV=(e,t)=>{da(e,"ReduceL2Shared",t,"l2")},bV=(e,t)=>{da(e,"ReduceLogSumExpShared",t,"logSumExp")},xV=(e,t)=>{da(e,"ReduceMaxShared",t,"max")},TV=(e,t)=>{da(e,"ReduceMinShared",t,"min")},MV=(e,t)=>{da(e,"ReduceProdShared",t,"prod")},EV=(e,t)=>{da(e,"ReduceSumShared",t,"sum")},SV=(e,t)=>{da(e,"ReduceSumSquareShared",t,"sumSquare")},CV=(e,t)=>{da(e,"ReduceLogSumShared",t,"logSum")}}),fa,Lk,gg,Yb,pa,zk,Fk,Bk,Uk,Vk,Gk,jk,Wk,Hk,qk,ha,$V,AV,IV,PV,kV,DV,OV,RV,NV,LV,Qx=dt(()=>{en(),ln(),Ui(),cn(),Nne(),fa=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Lk=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],gg=(e,t,n,i,r,s,a=!1,o=!1)=>{let l=[],u=n[0].dims,c=u.length,f=We.normalizeAxes(r,c),d=!o&&f.length===0;u.forEach((y,M)=>{d||f.indexOf(M)>=0?a&&l.push(1):l.push(y)});let h=l.length,m=We.size(l);return{name:e,shaderCache:t,getShaderSource:y=>{let M=[],g=Qe("_A",n[0].dataType,c),_=Ot("output",s,h),T=i(g,_,f),x=T[2];for(let S=0,$=0;S<c;S++)d||f.indexOf(S)>=0?(a&&$++,x=`for(var j${S}: u32 = 0; j${S} < ${u[S]}; j${S}++) {
                  ${T[2].includes("last_index")?`let last_index = j${S};`:""}
                  ${g.indicesSet("input_indices",S,`j${S}`)}
                  ${x}
                }`):(M.push(`${g.indicesSet("input_indices",S,_.indicesGet("output_indices",$))};`),$++);return`

        ${y.registerUniform("output_size","u32").declareVariables(g,_)}

        ${y.mainStart()}
          ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${g.type.indices};
          let output_indices = ${_.offsetToIndices("global_idx")};

          ${M.join(`
`)}
          ${T[0]}       // init ops for reduce max/min
          ${T[1]}
          ${x}
          ${T[3]}
          ${T.length===4?_.setByOffset("global_idx","value"):T.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:l,dataType:s}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},...Bt(u,l)]})}},Yb=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(i=>n.push(Number(i))),Qn({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},pa=(e,t,n,i)=>{let r=e.inputs,s=r.length===1?n:Yb(r,n);e.compute(gg(t,{hint:s.cacheKey,inputDependencies:["rank"]},[r[0]],s.noopWithEmptyAxes&&s.axes.length===0?Lk:i,s.axes,r[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},zk=(e,t)=>{fa(e.inputs),pa(e,"ReduceLogSum",t,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,"value = log(value);"])},Fk=(e,t)=>{fa(e.inputs),pa(e,"ReduceL1",t,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += abs(${n.getByIndices("input_indices")});`,""])},Bk=(e,t)=>{fa(e.inputs),pa(e,"ReduceL2",t,(n,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Uk=(e,t)=>{fa(e.inputs),pa(e,"ReduceLogSumExp",t,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += exp(${n.getByIndices("input_indices")});`,"value = log(value);"])},Vk=(e,t)=>{fa(e.inputs),pa(e,"ReduceMax",t,(n,i,r)=>{let s=[];for(let a=0;a<n.rank;a++)(r.indexOf(a)>=0||r.length===0)&&s.push(n.indicesSet("input_indices",a,0));return[`${s.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = max(value, ${n.getByIndices("input_indices")});`,""]})},Gk=(e,t)=>{fa(e.inputs),pa(e,"ReduceMean",t,(n,i,r)=>{let s=1;for(let a=0;a<n.rank;a++)(r.indexOf(a)>=0||r.length===0)&&(s*=e.inputs[0].dims[a]);return["var sum = f32(0);","",`sum += f32(${n.getByIndices("input_indices")});`,`let value = ${i.type.value}(sum / ${s});`]})},jk=(e,t)=>{fa(e.inputs),pa(e,"ReduceMin",t,(n,i,r)=>{let s=[];for(let a=0;a<n.rank;a++)(r.indexOf(a)>=0||r.length===0)&&s.push(`input_indices[${a}] = 0;`);return[`${s.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = min(value, ${n.getByIndices("input_indices")});`,""]})},Wk=(e,t)=>{fa(e.inputs),pa(e,"ReduceProd",t,(n,i)=>[`var value = ${i.type.storage}(1);`,"",`value *= ${n.getByIndices("input_indices")};`,""])},Hk=(e,t)=>{fa(e.inputs),pa(e,"ReduceSum",t,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,""])},qk=(e,t)=>{fa(e.inputs),pa(e,"ReduceSumSquare",t,(n,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += t * t;`,""])},ha=(e,t,n)=>{if(t.length===0)return n;let i=1,r=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?i*=e[s]:r*=e[s];return r<32&&i>1024},$V=(e,t)=>{ha(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Gk(e,t):yV(e,t)},AV=(e,t)=>{ha(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Fk(e,t):vV(e,t)},IV=(e,t)=>{ha(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Bk(e,t):wV(e,t)},PV=(e,t)=>{ha(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Uk(e,t):bV(e,t)},kV=(e,t)=>{ha(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Vk(e,t):xV(e,t)},DV=(e,t)=>{ha(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?jk(e,t):TV(e,t)},OV=(e,t)=>{ha(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Wk(e,t):MV(e,t)},RV=(e,t)=>{ha(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Hk(e,t):EV(e,t)},NV=(e,t)=>{ha(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?qk(e,t):SV(e,t)},LV=(e,t)=>{ha(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?zk(e,t):CV(e,t)}}),V0,zV,FV,Xb,Lne=dt(()=>{en(),Ui(),Qx(),V0=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},zV=(e,t)=>{V0(e.inputs);let n=(i,r,s)=>{let a=[];for(let o=0;o<i.rank;o++)(s.indexOf(o)>=0||s.length===0)&&a.push(`input_indices[${o}] = 0;`);return[`${a.join(`
`)}`,`var value = ${i.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${i.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${i.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",r.setByOffset("global_idx","best_index")]};e.compute(gg("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},FV=(e,t)=>{V0(e.inputs);let n=(i,r,s)=>{let a=[];for(let o=0;o<i.rank;o++)(s.indexOf(o)>=0||s.length===0)&&a.push(`input_indices[${o}] = 0;`);return[`${a.join(`
`)}`,`var value = ${i.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${i.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${i.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",r.setByOffset("global_idx","best_index")]};e.compute(gg("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},Xb=e=>Qn(e)}),Kk,Oh,Jk,Yk,Xk,_p,Qk,BV,Zx=dt(()=>{en(),ln(),Yx(),cn(),Kk=(e,t)=>{let n=e[0],i=e[1],r=e[2],s=e[3],a=e[4],o=e[5];if(a&&o)throw new Error("Attention cannot have both past and attention_bias");if(n.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let l=n.dims[0],u=n.dims[1],c=n.dims[2];if(r.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(i.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(i.dims[0]!==c)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(r.dims[0]!==i.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let f=r.dims[0]/3,d=f,h=d;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let T of t.qkvHiddenSizes)if(T%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");f=t.qkvHiddenSizes[0],d=t.qkvHiddenSizes[1],h=t.qkvHiddenSizes[2]}let m=u;if(f!==d)throw new Error("qkv_hidden_sizes first element should be same as the second");if(r.dims[0]!==f+d+h)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let y=0;if(a){if(d!==h)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(a.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(a.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(a.dims[1]!==l)throw new Error('Input "past" second dimension must be batch_size');if(a.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(a.dims[4]!==d/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(y=a.dims[3])}let M=m+y,g=-1,_=0;if(s)throw new Error("Mask not supported");if(a)throw new Error("past is not supported");if(o){if(o.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(o.dims[0]!==l||o.dims[1]!==t.numHeads||o.dims[2]!==u||o.dims[3]!==M)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:u,pastSequenceLength:y,kvSequenceLength:m,totalSequenceLength:M,maxSequenceLength:g,inputHiddenSize:c,hiddenSize:f,vHiddenSize:h,headSize:Math.floor(f/t.numHeads),vHeadSize:Math.floor(h/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:_,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Oh=(e,t,n)=>t&&e?`
      let total_sequence_length_input = u32(${t.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${e==null?void 0:e.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,Jk=(e,t,n,i,r,s,a,o)=>{let l=zi(a?1:s),u=64,c=s/l;c<u&&(u=32);let f=Math.ceil(s/l/u),d=[{type:12,data:t},{type:12,data:n},{type:12,data:i},{type:12,data:r},{type:12,data:c},{type:12,data:f}],h=hr(e.dataType,l),m=Nr(1,l),y=["type"];a&&y.push("type"),o&&y.push("type");let M=g=>{let _=Ot("x",e.dataType,e.dims,l),T=[_],x=a?Qe("seq_lens",a.dataType,a.dims):void 0;x&&T.push(x);let S=o?Qe("total_sequence_length_input",o.dataType,o.dims):void 0;S&&T.push(S);let $=Nr(e.dataType),C=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${u}>;
  var<workgroup> thread_sum: array<f32, ${u}>;
  ${g.registerUniforms(C).declareVariables(...T)}
  ${g.mainStart([u,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${Oh(x,S,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${u}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${a?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${m}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${m}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(l){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${u}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${m}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${m}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${u}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${_.type.value}(${$}(1.0) / ${$}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${m}(x[offset + i]);
        x[offset + i] = ${_.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${a?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${_.type.value}(${$}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${h};${l}`,inputDependencies:y},getShaderSource:M,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:r,z:t*n},programUniforms:d})}},Yk=(e,t,n,i,r,s,a,o,l)=>{let u=a+s.kvSequenceLength,c=[s.batchSize,s.numHeads,s.sequenceLength,u],f=e>1&&i,d=s.kvNumHeads?s.kvNumHeads:s.numHeads,h=f?[s.batchSize,d,u,s.headSize]:void 0,m=s.nReps?s.nReps:1,y=s.scale===0?1/Math.sqrt(s.headSize):s.scale,M=zi(s.headSize),g=s.headSize/M,_=12,T={x:Math.ceil(u/_),y:Math.ceil(s.sequenceLength/_),z:s.batchSize*s.numHeads},x=[{type:12,data:s.sequenceLength},{type:12,data:g},{type:12,data:u},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:1,data:y},{type:12,data:a},{type:12,data:s.kvSequenceLength},{type:12,data:m}],S=f&&i&&We.size(i.dims)>0,$=["type","type"];S&&$.push("type"),r&&$.push("type"),o&&$.push("type"),l&&$.push("type");let C=[{dims:c,dataType:t.dataType,gpuDataType:0}];f&&C.push({dims:h,dataType:t.dataType,gpuDataType:0});let P=O=>{let R=Qe("q",t.dataType,t.dims,M),G=Qe("key",n.dataType,n.dims,M),W=[R,G];if(S){let ce=Qe("past_key",i.dataType,i.dims,M);W.push(ce)}r&&W.push(Qe("attention_bias",r.dataType,r.dims));let V=o?Qe("seq_lens",o.dataType,o.dims):void 0;V&&W.push(V);let te=l?Qe("total_sequence_length_input",l.dataType,l.dims):void 0;te&&W.push(te);let J=Ot("output",t.dataType,c),j=[J];f&&j.push(Ot("present_key",t.dataType,h,M));let Y=Nr(1,M),X=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${_}u;

  var<workgroup> tileQ: array<${R.type.storage}, ${_*_}>;
  var<workgroup> tileK: array<${R.type.storage}, ${_*_}>;
  ${O.registerUniforms(X).declareVariables(...W,...j)}
  ${O.mainStart([_,_,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${m===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${m===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${Oh(V,te,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${S&&f?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${f?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${Y}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${S&&f?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${f?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${Y}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(M){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${M}`)}})()};
        output[outputIdx] = ${J.type.value} (sum * uniforms.alpha) + ${r?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${M};${r!==void 0};${i!==void 0};${e}`,inputDependencies:$},getRunData:()=>({outputs:C,dispatchGroup:T,programUniforms:x}),getShaderSource:P}},Xk=(e,t,n,i,r,s,a=void 0,o=void 0)=>{let l=s+r.kvSequenceLength,u=r.nReps?r.nReps:1,c=r.vHiddenSize*u,f=e>1&&i,d=r.kvNumHeads?r.kvNumHeads:r.numHeads,h=f?[r.batchSize,d,l,r.headSize]:void 0,m=[r.batchSize,r.sequenceLength,c],y=12,M={x:Math.ceil(r.vHeadSize/y),y:Math.ceil(r.sequenceLength/y),z:r.batchSize*r.numHeads},g=[{type:12,data:r.sequenceLength},{type:12,data:l},{type:12,data:r.vHeadSize},{type:12,data:r.numHeads},{type:12,data:r.headSize},{type:12,data:c},{type:12,data:s},{type:12,data:r.kvSequenceLength},{type:12,data:u}],_=f&&i&&We.size(i.dims)>0,T=["type","type"];_&&T.push("type"),a&&T.push("type"),o&&T.push("type");let x=[{dims:m,dataType:t.dataType,gpuDataType:0}];f&&x.push({dims:h,dataType:t.dataType,gpuDataType:0});let S=$=>{let C=Qe("probs",t.dataType,t.dims),P=Qe("v",n.dataType,n.dims),O=[C,P];_&&O.push(Qe("past_value",i.dataType,i.dims));let R=a?Qe("seq_lens",a.dataType,a.dims):void 0;a&&O.push(R);let G=o?Qe("total_sequence_length_input",o.dataType,o.dims):void 0;o&&O.push(G);let W=[Ot("output",t.dataType,m)];f&&W.push(Ot("present_value",t.dataType,h));let V=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${y}u;
  var<workgroup> tileQ: array<${C.type.value}, ${y*y}>;
  var<workgroup> tileV: array<${C.type.value}, ${y*y}>;
  ${$.registerUniforms(V).declareVariables(...O,...W)}
  ${$.mainStart([y,y,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${u===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${u===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${Oh(R,G,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${_&&f?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${f?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${C.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${_&&f?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${f?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${i!==void 0};${e}`,inputDependencies:T},getRunData:()=>({outputs:x,dispatchGroup:M,programUniforms:g}),getShaderSource:S}},_p=(e,t,n,i,r,s,a,o,l,u,c=void 0,f=void 0)=>{let d=Math.min(e.outputCount,1+(a?1:0)+(o?1:0)),h=d>1?u.pastSequenceLength:0,m=h+u.kvSequenceLength,y=l&&We.size(l.dims)>0?l:void 0,M=[t,n];d>1&&a&&We.size(a.dims)>0&&M.push(a),y&&M.push(y),c&&M.push(c),f&&M.push(f);let g=e.compute(Yk(d,t,n,a,y,u,h,c,f),{inputs:M,outputs:d>1?[-1,1]:[-1]})[0];e.compute(Jk(g,u.batchSize,u.numHeads,h,u.sequenceLength,m,c,f),{inputs:c&&f?[g,c,f]:[g],outputs:[]});let _=[g,i];d>1&&o&&We.size(o.dims)>0&&_.push(o),c&&_.push(c),f&&_.push(f),e.compute(Xk(d,g,i,o,u,h,c,f),{inputs:_,outputs:d>1?[0,2]:[0]})},Qk=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],i=t.sequenceLength,r=t.inputHiddenSize,s=t.headSize,a=12,o={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],u=[{type:12,data:i},{type:12,data:r},{type:12,data:s},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],c=f=>{let d=Ot("output_q",l[0].dataType,n),h=Ot("output_k",l[0].dataType,n),m=Ot("output_v",l[0].dataType,n),y=Qe("input",l[0].dataType,l[0].dims),M=Qe("weight",l[1].dataType,l[1].dims),g=Qe("bias",l[2].dataType,l[2].dims),_=y.type.storage,T=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${a}u;
  var<workgroup> tileInput: array<${_}, ${a*a}>;
  var<workgroup> tileWeightQ: array<${_}, ${a*a}>;
  var<workgroup> tileWeightK: array<${_}, ${a*a}>;
  var<workgroup> tileWeightV: array<${_}, ${a*a}>;
  ${f.registerUniforms(T).declareVariables(y,M,g,d,h,m)}
  ${f.mainStart([a,a,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${_}(0);
    var valueK = ${_}(0);
    var valueV = ${_}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:o,programUniforms:u}),getShaderSource:c},{inputs:l,outputs:[-1,-1,-1]})},BV=(e,t)=>{let n=Kk(e.inputs,t),[i,r,s]=Qk(e,n);return _p(e,i,r,s,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}}),Zk,e3,t3,UV,zne=dt(()=>{Oa(),en(),ln(),Ui(),cn(),Zk=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let n=(i,r,s)=>{let a=r.length;if(a!==i.length)throw new Error(`${s}: num dimensions != ${a}`);r.forEach((o,l)=>{if(o!==i[l])throw new Error(`${s}: dim[${l}] do not match`)})};if(e[0].dims.length>1){let i=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,i,"Invalid input scale"),n(e[2].dims,i,"Invalid input B"),n(e[3].dims,i,"Invalid input mean"),n(e[4].dims,i,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},e3=(e,t)=>{let{epsilon:n,spatial:i,format:r}=t,s=e[0].dims,a=i?zi(s[s.length-1]):1,o=r==="NHWC"&&s.length>1?a:1,l=We.size(s)/a,u=i,c=u?s.length:s,f=Qe("x",e[0].dataType,e[0].dims,a),d=Qe("scale",e[1].dataType,e[1].dims,o),h=Qe("bias",e[2].dataType,e[2].dims,o),m=Qe("inputMean",e[3].dataType,e[3].dims,o),y=Qe("inputVar",e[4].dataType,e[4].dims,o),M=Ot("y",e[0].dataType,c,a),g=()=>{let T="";if(i)T=`let cOffset = ${s.length===1?"0u":r==="NHWC"?`outputIndices[${s.length-1}] / ${a}`:"outputIndices[1]"};`;else if(r==="NCHW")T=`
            ${M.indicesSet("outputIndices","0","0")}
            let cOffset = ${M.indicesToOffset("outputIndices")};`;else{T=`var cIndices = ${d.type.indices}(0);
                       cIndices[0] = outputIndices[${s.length-1}];`;for(let x=1;x<d.rank;x++)T+=`cIndices[${x}] = outputIndices[${x}];`;T+=`let cOffset = ${d.indicesToOffset("cIndices")};`}return T},_=T=>`
  const epsilon = ${n};
  ${T.registerUniform("outputSize","u32").declareVariables(f,d,h,m,y,M)}
  ${T.mainStart()}
  ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${M.offsetToIndices(`global_idx * ${a}`)};
    ${g()}
    let scale = ${d.getByOffset("cOffset")};
    let bias = ${h.getByOffset("cOffset")};
    let inputMean = ${m.getByOffset("cOffset")};
    let inputVar = ${y.getByOffset("cOffset")};
    let x = ${f.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${M.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${i}_${a}`,inputDependencies:u?["rank","type","type","type","type"]:void 0},getShaderSource:_,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u?[{type:12,data:l},...Bt(s)]:[{type:12,data:l}]})}},t3=e=>Qn(e),UV=(e,t)=>{let{inputs:n,outputCount:i}=e,r=t3({...t,outputCount:i});if(wi.webgpu.validateInputContent&&Zk(n,r),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(e3(n,r))}}),n3,i3,VV,Fne=dt(()=>{ln(),cn(),n3=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},i3=e=>{let t=e[0].dims,n=e[0].dims[2],i=We.size(t)/4,r=e[0].dataType,s=Qe("input",r,t,4),a=Qe("bias",r,[n],4),o=Qe("residual",r,t,4),l=Ot("output",r,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:u=>`
  const channels = ${n}u / 4;
  ${u.declareVariables(s,a,o,l)}

  ${u.mainStart()}
    ${u.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let value = ${s.getByOffset("global_idx")}
      + ${a.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};
    ${l.setByOffset("global_idx","value")}
  }`}},VV=e=>{n3(e.inputs),e.compute(i3(e.inputs))}}),r3,Kn,GV,jV,WV,HV,qV,KV,JV,YV,XV,s3,QV,ZV,eG,tG,kf,nG,Em,iG,rG,sG,aG,oG,lG,uG,cG,dG,fG,pG,hG,mG,gG,_G,yG,G0,vG,Qb,Zb,wG,bG,xG,a3,o3,TG,eT=dt(()=>{en(),ln(),Ui(),cn(),r3=(e,t,n,i,r,s,a)=>{let o=Math.ceil(t/4),l="";typeof r=="string"?l=`${r}(a)`:l=r("a");let u=Qe("inputData",n,[o],4),c=Ot("outputData",i,[o],4),f=[{name:"vec_size",type:"u32"}];return a&&f.push(...a),`
      ${e.registerUniforms(f).declareVariables(u,c)}

  ${s??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${u.getByOffset("global_idx")};
    ${c.setByOffset("global_idx",l)}
  }`},Kn=(e,t,n,i,r,s=e.dataType,a,o)=>{let l=[{type:12,data:Math.ceil(We.size(e.dims)/4)}];return a&&l.push(...a),{name:t,shaderCache:{hint:r,inputDependencies:["type"]},getShaderSource:u=>r3(u,We.size(e.dims),e.dataType,s,n,i,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(We.size(u[0].dims)/64/4)},programUniforms:l})}},GV=e=>{e.compute(Kn(e.inputs[0],"Abs","abs"))},jV=e=>{e.compute(Kn(e.inputs[0],"Acos","acos"))},WV=e=>{e.compute(Kn(e.inputs[0],"Acosh","acosh"))},HV=e=>{e.compute(Kn(e.inputs[0],"Asin","asin"))},qV=e=>{e.compute(Kn(e.inputs[0],"Asinh","asinh"))},KV=e=>{e.compute(Kn(e.inputs[0],"Atan","atan"))},JV=e=>{e.compute(Kn(e.inputs[0],"Atanh","atanh"))},YV=e=>Qn(e),XV=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Kn(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},s3=e=>{let t,n,i=e.length>=2&&e[1].data!==0,r=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:t=i?e[1].getFloat32Array()[0]:-34028234663852886e22,n=r?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=i?e[1].getUint16Array()[0]:64511,n=r?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return Qn({min:t,max:n})},QV=(e,t)=>{let n=t||s3(e.inputs),i=Nr(e.inputs[0].dataType);e.compute(Kn(e.inputs[0],"Clip",r=>`clamp(${r}, vec4<${i}>(uniforms.min), vec4<${i}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:"min",type:i},{name:"max",type:i}]),{inputs:[0]})},ZV=e=>{e.compute(Kn(e.inputs[0],"Ceil","ceil"))},eG=e=>{e.compute(Kn(e.inputs[0],"Cos","cos"))},tG=e=>{e.compute(Kn(e.inputs[0],"Cosh","cosh"))},kf=e=>Qn(e),nG=(e,t)=>{let n=Nr(e.inputs[0].dataType);e.compute(Kn(e.inputs[0],"Elu",i=>`elu_vf32(${i})`,`
  const elu_alpha_ = ${n}(${t.alpha});

  fn elu_f32(a: ${n}) -> ${n} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},Em=(e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,iG=e=>{let t=Nr(e.inputs[0].dataType);e.compute(Kn(e.inputs[0],"Erf",n=>`erf_vf32(${n})`,Em(t)))},rG=e=>{e.compute(Kn(e.inputs[0],"Exp","exp"))},sG=e=>{e.compute(Kn(e.inputs[0],"Floor","floor"))},aG=e=>{let t=Nr(e.inputs[0].dataType);e.compute(Kn(e.inputs[0],"Gelu",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,Em(t)))},oG=(e,t)=>{let n=Nr(e.inputs[0].dataType);e.compute(Kn(e.inputs[0],"LeakyRelu",i=>`select(leaky_relu_alpha_ * ${i}, ${i}, ${i} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},lG=e=>{e.compute(Kn(e.inputs[0],"Not",t=>`!${t}`))},uG=e=>{e.compute(Kn(e.inputs[0],"Neg",t=>`-${t}`))},cG=e=>{e.compute(Kn(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},dG=e=>{let t=Nr(e.inputs[0].dataType);e.compute(Kn(e.inputs[0],"Relu",n=>`select(vec4<${t}>(0.0), ${n}, ${n} > vec4<${t}>(0.0))`))},fG=e=>{e.compute(Kn(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},pG=e=>Qn(e),hG=(e,t)=>{let n=Nr(e.inputs[0].dataType);e.compute(Kn(e.inputs[0],"HardSigmoid",i=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${i} + vec4<${n}>(${t.beta})))`,void 0,t.cacheKey))},mG=e=>{e.compute(Kn(e.inputs[0],"Sin","sin"))},gG=e=>{e.compute(Kn(e.inputs[0],"Sinh","sinh"))},_G=e=>{e.compute(Kn(e.inputs[0],"Sqrt","sqrt"))},yG=e=>{e.compute(Kn(e.inputs[0],"Tan","tan"))},G0=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,vG=e=>{e.compute(Kn(e.inputs[0],"Tanh",G0))},Qb=(e="f32")=>`
const fast_gelu_a: ${e} = 0.5;
const fast_gelu_b: ${e} = 0.7978845608028654;
const fast_gelu_c: ${e} = 0.035677408136300125;

fn tanh_v(v: vec4<${e}>) -> vec4<${e}> {
  return ${G0("v")};
}
`,Zb=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,wG=e=>{let t=Nr(e.inputs[0].dataType);e.compute(Kn(e.inputs[0],"FastGelu",Zb,Qb(t),void 0,e.inputs[0].dataType))},bG=(e,t)=>{let n=Nr(e.inputs[0].dataType);return e.compute(Kn(e.inputs[0],"ThresholdedRelu",i=>`select(vec4<${n}>(0.0), ${i}, ${i} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},xG=e=>{e.compute(Kn(e.inputs[0],"Log","log"))},a3=(e,t)=>`
const alpha = vec4<${e}>(${t});
const one = ${e}(1.0);
const zero = ${e}(0.0);

fn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {
  let v = x *alpha;
  var x1 : vec4<${e}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,o3=e=>`quick_gelu_impl(${e})`,TG=(e,t)=>{let n=Nr(e.inputs[0].dataType);e.compute(Kn(e.inputs[0],"QuickGelu",o3,a3(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}}),l3,u3,MG,Bne=dt(()=>{ln(),cn(),eT(),l3=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},u3=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=Qe("input",e[0].dataType,e[0].dims,4),i=Qe("bias",e[0].dataType,[e[0].dims[2]],4),r=Ot("output",e[0].dataType,t,4),s=We.size(t)/4,a=hr(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:o=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${o.declareVariables(n,i,r)}

  ${Em(a)}

  ${o.mainStart()}
    ${o.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${r.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},MG=e=>{l3(e.inputs),e.compute(u3(e.inputs))}}),c3,d3,ma,EG,SG,CG,$G,AG,IG,PG,kG,DG,OG,Une=dt(()=>{en(),ln(),cn(),c3=(e,t,n,i,r,s,a,o,l,u,c,f)=>{let d,h;typeof o=="string"?d=h=(_,T)=>`${o}((${_}),(${T}))`:typeof o=="function"?d=h=o:(d=o.scalar,h=o.vector);let m=Ot("outputData",c,i.length,4),y=Qe("aData",l,t.length,4),M=Qe("bData",u,n.length,4),g;if(r)if(s){let _=We.size(t)===1,T=We.size(n)===1,x=t.length>0&&t[t.length-1]%4===0,S=n.length>0&&n[n.length-1]%4===0;_||T?g=m.setByOffset("global_idx",h(_?`${y.type.value}(${y.getByOffset("0")}.x)`:y.getByOffset("global_idx"),T?`${M.type.value}(${M.getByOffset("0")}.x)`:M.getByOffset("global_idx"))):g=`
            let outputIndices = ${m.offsetToIndices("global_idx * 4u")};
            let offsetA = ${y.broadcastedIndicesToOffset("outputIndices",m)};
            let offsetB = ${M.broadcastedIndicesToOffset("outputIndices",m)};
            ${m.setByOffset("global_idx",h(a||x?y.getByOffset("offsetA / 4u"):`${y.type.value}(${y.getByOffset("offsetA / 4u")}[offsetA % 4u])`,a||S?M.getByOffset("offsetB / 4u"):`${M.type.value}(${M.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else g=m.setByOffset("global_idx",h(y.getByOffset("global_idx"),M.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let _=(T,x,S="")=>{let $=`aData[indexA${x}][componentA${x}]`,C=`bData[indexB${x}][componentB${x}]`;return`
            let outputIndices${x} = ${m.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offsetA${x} = ${y.broadcastedIndicesToOffset(`outputIndices${x}`,m)};
            let offsetB${x} = ${M.broadcastedIndicesToOffset(`outputIndices${x}`,m)};
            let indexA${x} = offsetA${x} / 4u;
            let indexB${x} = offsetB${x} / 4u;
            let componentA${x} = offsetA${x} % 4u;
            let componentB${x} = offsetB${x} % 4u;
            ${T}[${x}] = ${S}(${d($,C)});
          `};c===9?g=`
            var data = vec4<u32>(0);
            ${_("data",0,"u32")}
            ${_("data",1,"u32")}
            ${_("data",2,"u32")}
            ${_("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:g=`
            ${_("outputData[global_idx]",0)}
            ${_("outputData[global_idx]",1)}
            ${_("outputData[global_idx]",2)}
            ${_("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(y,M,m)}

        ${f??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${g}
      }`},d3=(e,t,n,i,r,s,a=n.dataType)=>{let o=n.dims.map(y=>Number(y)??1),l=i.dims.map(y=>Number(y)??1),u=!We.areEqual(o,l),c=o,f=We.size(o),d=!1,h=!1,m=[u];if(u){let y=Ed.calcShape(o,l,!1);if(!y)throw new Error("Can't perform binary op on the given tensors");c=y.slice(),f=We.size(c);let M=We.size(o)===1,g=We.size(l)===1,_=o.length>0&&o[o.length-1]%4===0,T=l.length>0&&l[l.length-1]%4===0;m.push(M),m.push(g),m.push(_),m.push(T);let x=1;for(let S=1;S<c.length;S++){let $=o[o.length-S],C=l[l.length-S];if($===C)x*=$;else break}x%4===0?(h=!0,d=!0):(M||g||_||T)&&(d=!0)}else d=!0;return m.push(d),{name:e,shaderCache:{hint:t+m.map(y=>y.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:y=>c3(y,o,l,c,d,u,h,r,n.dataType,i.dataType,a,s),getRunData:()=>({outputs:[{dims:c,dataType:a}],dispatchGroup:{x:Math.ceil(f/64/4)},programUniforms:[{type:12,data:Math.ceil(We.size(c)/4)},...Bt(o,l,c)]})}},ma=(e,t,n,i,r,s)=>{e.compute(d3(t,r??"",e.inputs[0],e.inputs[1],n,i,s))},EG=e=>{ma(e,"Add",(t,n)=>`${t}+${n}`)},SG=e=>{ma(e,"Div",(t,n)=>`${t}/${n}`)},CG=e=>{ma(e,"Equal",{scalar:(t,n)=>`u32(${t}==${n})`,vector:(t,n)=>`vec4<u32>(${t}==${n})`},void 0,void 0,9)},$G=e=>{ma(e,"Mul",(t,n)=>`${t}*${n}`)},AG=e=>{let t=Qe("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;ma(e,"Pow",{scalar:(n,i)=>`pow_custom(${n},${i})`,vector:(n,i)=>`pow_vector_custom(${n},${i})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},IG=e=>{ma(e,"Sub",(t,n)=>`${t}-${n}`)},PG=e=>{ma(e,"Greater",{scalar:(t,n)=>`u32(${t}>${n})`,vector:(t,n)=>`vec4<u32>(${t}>${n})`},void 0,void 0,9)},kG=e=>{ma(e,"Less",{scalar:(t,n)=>`u32(${t}<${n})`,vector:(t,n)=>`vec4<u32>(${t}<${n})`},void 0,void 0,9)},DG=e=>{ma(e,"GreaterOrEqual",{scalar:(t,n)=>`u32(${t}>=${n})`,vector:(t,n)=>`vec4<u32>(${t}>=${n})`},void 0,void 0,9)},OG=e=>{ma(e,"LessOrEqual",{scalar:(t,n)=>`u32(${t}<=${n})`,vector:(t,n)=>`vec4<u32>(${t}<=${n})`},void 0,void 0,9)}}),f3,p3,h3,m3,RG,NG,Vne=dt(()=>{en(),ln(),Ui(),cn(),f3=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let n=0,i=e[n],r=i.dataType,s=i.dims.length;e.forEach((a,o)=>{if(o!==n){if(a.dataType!==r)throw new Error("input tensors should be one type");if(a.dims.length!==s)throw new Error("input tensors should have the same shape");a.dims.forEach((l,u)=>{if(u!==t&&l!==i.dims[u])throw new Error("non concat dimensions must match")})}})},p3=(e,t)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${e}u>(${t});
    for (var i: u32 = 0u; i < ${e}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,h3=(e,t)=>{let n=e.length,i=[];for(let r=0;r<n;++r){let s=t.setByOffset("global_idx",e[r].getByIndices("indices"));n===1?i.push(s):r===0?i.push(`if (inputIndex == ${r}u) { ${s} }`):r===n-1?i.push(`else { ${s} }`):i.push(`else if (inputIndex == ${r}) { ${s} }`)}return i.join(`
`)},m3=(e,t,n,i)=>{let r=We.size(n),s=new Array(e.length),a=new Array(e.length),o=0,l=[],u=[],c=[{type:12,data:r}];for(let y=0;y<e.length;++y)o+=e[y].dims[t],s[y]=o,u.push(e[y].dims.length),a[y]=Qe(`input${y}`,i,u[y]),l.push("rank"),c.push({type:12,data:s[y]});for(let y=0;y<e.length;++y)c.push(...Bt(e[y].dims));c.push(...Bt(n));let f=Ot("output",i,n.length),d=f.indicesGet("indices",t),h=Array.from(Array(s.length).keys()).map(y=>`uniforms.sizeInConcatAxis${y}`).join(","),m=y=>`

  ${(()=>{y.registerUniform("outputSize","u32");for(let M=0;M<e.length;M++)y.registerUniform(`sizeInConcatAxis${M}`,"u32");return y.declareVariables(...a,f)})()}

  ${p3(s.length,h)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${f.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${d});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${s.length}u>(${h});
      ${d} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${h3(a,f)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:i}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:c}),getShaderSource:m}},RG=(e,t)=>{let n=e.inputs,i=n[0].dims,r=We.normalizeAxis(t.axis,i.length);f3(n,r);let s=i.slice();s[r]=n.reduce((o,l)=>o+(l.dims.length>r?l.dims[r]:0),0);let a=n.filter(o=>We.size(o.dims)>0);e.compute(m3(a,r,s,n[0].dataType),{inputs:a})},NG=e=>Qn({axis:e.axis})}),Xu,Qu,Zu,tT,fc=dt(()=>{en(),ln(),Xu=(e,t,n="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},Qu=(e,t)=>{e.activation==="Clip"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation==="HardSigmoid"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation==="LeakyRelu"&&t.push({type:1,data:e.alpha})},Zu=(e,t)=>{e.activation==="Clip"?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):e.activation==="HardSigmoid"?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):e.activation==="LeakyRelu"&&t.push({name:"alpha",type:"f32"})},tT=e=>{let t=(e==null?void 0:e.activation)||"";if(t==="HardSigmoid"){let[n,i]=(e==null?void 0:e.activation_params)||[.2,.5];return{activation:t,alpha:n,beta:i}}else if(t==="Clip"){let[n,i]=(e==null?void 0:e.activation_params)||[lV,uV];return{activation:t,clipMax:i,clipMin:n}}else if(t==="LeakyRelu"){let[n]=(e==null?void 0:e.activation_params)||[.01];return{activation:t,alpha:n}}return{activation:t}}}),br,LG,nT=dt(()=>{br=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},LG=e=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      `}),zG,Gne=dt(()=>{zG=e=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));
}
`}),Qf,iT,rT=dt(()=>{en(),ln(),cn(),fc(),Qf=(e,t,n,i,r)=>{let s=i-n;return`
      ${Array.from({length:n}).map((a,o)=>`
      if (${Lt(t.shape,o,t.rank)} != 1) {
        ${t.indicesSet(e,o,Lt(r,o+s,i))}
      } else {
        ${t.indicesSet(e,o,0)}
      }`).join("")}
`},iT=(e,t,n,i,r=!1,s)=>{let a=e[0].dims,o=e[1].dims,l=a[a.length-2],u=o[o.length-1],c=a[a.length-1],f=zi(u),d=zi(c),h=zi(l),m=We.size(n)/f/h,y=e.length>2,M=i?i.slice(0,-2):n.slice(0,-2),g=[We.size(M),l,u],_=[{type:12,data:m},{type:12,data:l},{type:12,data:u},{type:12,data:c}];Qu(t,_),_.push(...Bt(M,a,o)),y&&_.push(...Bt(e[2].dims)),_.push(...Bt(g));let T=x=>{let S=Xx("batch_dims",e[0].dataType,M.length),$=Qe("a",e[0].dataType,a.length,d),C=Qe("b",e[1].dataType,o.length,f),P=Ot("output",e[0].dataType,g.length,f),O=hr(P.type.tensor),R=Xu(t,P.type.value,O),G=[$,C],W="";if(y){let J=r?f:1;G.push(Qe("bias",e[2].dataType,e[2].dims.length,J)),W=`${r?`value += bias[col / ${J}];`:`value += ${P.type.value}(bias[row + i]);`}`}let V=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Zu(t,V);let te=()=>{let J=`var a_data: ${$.type.value};`;for(let j=0;j<d;j++)J+=`
              let b_data${j} = b[(b_offset + (k + ${j}) * uniforms.N + col) / ${f}];`;for(let j=0;j<h;j++){J+=`a_data = a[(a_offset + (row + ${j}) * uniforms.K + k) / ${d}];`;for(let Y=0;Y<d;Y++)J+=`
            values[${j}] = fma(${C.type.value}(a_data${d===1?"":`[${Y}]`}), b_data${Y}, values[${j}]);
`}return J};return`
  ${x.registerUniforms(V).registerInternalVariables(S).declareVariables(...G,P)}
  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${f})) * ${f};
    var index1 = global_idx / (uniforms.N / ${f});
    let stride1 = uniforms.M / ${h};
    let row = (index1 % stride1) * ${h};
    let batch = index1 / stride1;

    ${n.length===2?"":`let batch_indices = ${S.offsetToIndices("batch")};`}

    var a_indices: ${$.type.indices};
    ${Qf("a_indices",$,$.rank-2,S.rank,"batch_indices")}
    ${$.indicesSet("a_indices",$.rank-2,0)}
    ${$.indicesSet("a_indices",$.rank-1,0)}
    let a_offset = ${$.indicesToOffset("a_indices")};

    var b_indices: ${C.type.indices};
    ${Qf("b_indices",C,C.rank-2,S.rank,"batch_indices")}
    ${C.indicesSet("b_indices",C.rank-2,0)}
    ${C.indicesSet("b_indices",C.rank-1,0)}
    let b_offset = ${C.indicesToOffset("b_indices")};
    var values: array<${P.type.value}, ${h}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${d}) {
      ${te()}
    }
    for (var i = 0u; i < ${h}u; i++) {
      var value = values[i];
      ${W}
      ${R}
      let cur_indices = ${P.type.indices}(batch, row + i, col);
      let offset = ${P.indicesToOffset("cur_indices")};
      ${P.setByOffset(`offset / ${f}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${f};${d};${h};${r}`,inputDependencies:y?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:s?s(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:_}),getShaderSource:T}}}),g3,_3,e1,j0,y3,t1,v3,_g,sT=dt(()=>{en(),ln(),cn(),fc(),rT(),nT(),g3=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,_3=(e,t)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,e1=(e,t,n="f32",i,r=!1,s=32,a=!1,o=32)=>{let l=t[1]*e[1],u=t[0]*e[0],c=r?l:s,f=r?s:l,d=c/t[0],h=s/t[1];if(!((r&&d===4&&e[1]===4||!r&&(d===3||d===4))&&c%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${r} is true, innerElementSize ${d} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${d} must be 3 or 4.
  tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${d}<${n}>, ${c/d}>, ${f}>;
var<workgroup> mm_Bsub: array<array<vec4<${n}>, ${u/e[0]}>, ${s}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${d};
const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${a?"0":"i32(globalId.z)"};
  ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${l};

  let num_tiles = ${a?`${Math.ceil(o/s)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${a?`i32(globalId.z) * ${o}`:"0"};

  var acc: array<vec4<${n}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${h};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${g3(r,i)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${i?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${d===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${_3(r,d)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},j0=(e,t)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,y3=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",t1=(e,t,n="f32",i,r=!1,s=32,a=!1,o=32,l=!1)=>{let u=e[1]*t[1],c=e[0]*t[0],f=r?u:s,d=r?s:u;if(!(d%t[1]===0&&f%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${d} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${f} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let h=d/t[1],m=f/t[0],y=s/t[1],M=l?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${u};
    let globalColStart = i32(workgroupId.x) * ${c};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${f}; inputCol = inputCol + ${t[0]}) {
          ${j0(r,i)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${i?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${n}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${u};

let tileRowA = i32(localId.y) * ${h};
let tileColA = i32(localId.x) * ${m};
let tileRowB = i32(localId.y) * ${y};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${m}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${j0(r,i)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${i?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${n}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${y3(r)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${n}, ${f}>, ${d}>;
  var<workgroup> mm_Bsub : array<array<${n}, ${c}>, ${s}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${a?"0":"i32(globalId.z)"};
    ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${a?`${Math.ceil(o/s)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${a?`i32(globalId.z) * ${o}`:"0"};

    var acc : array<array<${n}, colPerThread>, rowPerThread>;
    ${M}
  }
`},v3=(e,t,n,i,r=!1)=>{let[s,a,o,l]=i,u=hr(i[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${s.type.indices}) -> ${br(e,u)} {
      var value = ${br(e,u)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${a.type.indices};
        ${Qf("aIndices",a,a.rank-2,s.rank,"batchIndices")}
        ${a.indicesSet("aIndices",a.rank-2,"u32(row)")}
        ${a.indicesSet("aIndices",a.rank-1,"u32(colIn)")}
        value = ${a.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${s.type.indices}) -> ${br(e,u)} {
      var value = ${br(e,u)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${o.type.indices};
        ${Qf("bIndices",o,o.rank-2,s.rank,"batchIndices")}
        ${o.indicesSet("bIndices",o.rank-2,"u32(row)")}
        ${o.indicesSet("bIndices",o.rank-1,"u32(colIn)")}
        value = ${o.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${br(e,u)}) {
      let col = colIn * ${e};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${r?"bias[colIn]":`${br(e,u)}(bias[row])`};`:""}
        ${n}
        ${l.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},_g=(e,t,n,i,r=!1,s)=>{let a=e[0].dims,o=e[1].dims,l=a.slice(0,-2),u=o.slice(0,-2),c=i?i.slice(0,-2):n.slice(0,-2),f=We.size(c),d=a[a.length-2],h=a[a.length-1],m=o[o.length-1],y=h%4===0&&m%4===0,M=d<=8?[4,1,1]:[4,4,1],g=[8,8,1],_=[Math.ceil(m/g[0]/M[0]),Math.ceil(d/g[1]/M[1]),Math.ceil(f/g[2]/M[2])],T=y?4:1,x=[...l,d,h/T],S=x.length,$=[...u,h,m/T],C=$.length,P=[f,d,m/T],O=[{type:6,data:d},{type:6,data:m},{type:6,data:h}];Qu(t,O),O.push(...Bt(c,x,$));let R=["rank","rank"],G=e.length>2;G&&(O.push(...Bt(e[2].dims)),R.push("rank")),O.push(...Bt(P));let W=V=>{let te=c.length,J=Xx("batchDims",e[0].dataType,te,1),j=hr(e[0].dataType),Y=Qe("a",e[0].dataType,S,T),X=Qe("b",e[1].dataType,C,T),ce=Ot("result",e[0].dataType,P.length,T),me=[Y,X];if(G){let _e=r?T:1;me.push(Qe("bias",e[2].dataType,e[2].dims.length,_e))}let Q=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Zu(t,Q);let H=hr(ce.type.tensor),B=Xu(t,ce.type.value,H),ee=v3(T,G,B,[J,Y,X,ce],r);return`
  ${V.registerUniforms(Q).registerInternalVariables(J).declareVariables(...me,ce)}
  ${ee}
  ${y?e1(M,g,j,J):t1(M,g,j,J)}
                   `};return{name:"MatMul",shaderCache:{hint:`${M};${t.activation};${y};${r}`,inputDependencies:R},getRunData:()=>({outputs:[{dims:s?s(n):n,dataType:e[0].dataType}],dispatchGroup:{x:_[0],y:_[1],z:_[2]},programUniforms:O}),getShaderSource:W}}}),w3,FG,jne=dt(()=>{en(),Vo(),cn(),fc(),nT(),Gne(),sT(),w3=(e,t,n,i,r=!1,s,a=4,o=4,l=4,u="f32")=>{let c=O=>{switch(O){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${u}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${O} is not supported.`)}},f=O=>{switch(O){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${O} is not supported.`)}},d=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,h=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,m=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",y=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",M=e?"row":"col",g=e?"col":"row",_=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${M} / outWidth;
    let outCol = ${M} % outWidth;

    let WRow = ${g} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${g} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${g} % inChannels;
    var resData = ${br(a,u)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${m} && xCol >= 0 && xCol < ${y}) {
      ${d}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${c(a)}
    }
    return resData;`,T=e?t&&i?`
    let col = colIn * ${a};
    ${_}`:`
    let col = colIn * ${a};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${_}
    }
    return ${br(a,u)}(0.0);`:i&&n?`
    let col = colIn * ${a};
    ${_}`:`
    let col = colIn * ${a};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${_}
    }
    return ${br(a,u)}(0.0);`,x=e?i&&n?f(o):`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${f(o)}
    }
    return ${br(o,u)}(0.0);`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${f(o)}
    }
    return ${br(o,u)}(0.0);`,S=br(l,u),$=br(e?a:o,u),C=br(e?o:a,u),P=Xu(s,S,u);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${$} {
      ${e?T:x}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${C} {
      ${e?x:T}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${S}) {
      let col = colIn * ${l};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${h}
      ${LG(r)}
      ${P}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},FG=(e,t,n,i,r,s,a,o,l)=>{let u=t.format==="NHWC",c=u?e[0].dims[3]:e[0].dims[1],f=n[0],d=u?n[2]:n[3],h=u?n[1]:n[2],m=u?n[3]:n[1],y=u&&(c%4===0||c%3===0)&&m%4===0,M=u?m:d*h,g=u?d*h:m,_=[8,8,1],T=i<=8?[4,1,1]:[4,4,1],x=[Math.ceil(M/_[0]/T[0]),Math.ceil(g/_[1]/T[1]),Math.ceil(f/_[2]/T[2])];Nn("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${x}`);let S=y?u&&c%4!==0?3:4:1,$=_[1]*T[1],C=_[0]*T[0],P=Math.max(_[0]*S,_[1]),O=i%$===0,R=r%C===0,G=s%P===0,W=y?[S,4,4]:[1,1,1],V=[{type:6,data:i},{type:6,data:r},{type:6,data:s},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Qu(t,V),V.push(...Bt(e[0].dims,e[1].dims));let te=["rank","rank"];a&&(V.push(...Bt(e[2].dims)),te.push("rank")),V.push(...Bt(n));let J=j=>{let Y=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Zu(t,Y);let X=y?4:1,ce=hr(e[0].dataType),me=`
      fn setOutputAtIndex(flatIndex : i32, value : ${y?`vec4<${ce}>`:ce}) {
        result[flatIndex] = ${y?`vec4<${ce}>`:ce}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${y?`vec4<${ce}>`:ce}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${y?"/ 4":""}, value);
      }`,Q=Qe("x",e[0].dataType,e[0].dims.length,S===3?1:S),H=Qe("w",e[1].dataType,e[1].dims.length,X),B=[Q,H],ee=Ot("result",e[0].dataType,n.length,X);if(a){let _e=Qe("bias",e[2].dataType,e[2].dims.length,X);B.push(_e),me+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?`vec4<${ce}>`:ce} {
          return bias[coords.${u?"w":"y"}${y?"/ 4":""}];
        }`}return`
        ${zG("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${j.registerUniforms(Y).declareVariables(...B,ee)}
        ${me}
        ${w3(u,O,R,G,a,t,W[0],W[1],W[2],ce)}
        ${y?e1(T,_,ce,void 0,!u,P):t1(T,_,ce,void 0,!u,P,!1,void 0,o)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${S};${y};${O};${R};${G};${$};${C};${P}`,inputDependencies:te},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:e[0].dataType}],dispatchGroup:{x:x[0],y:x[1],z:x[2]},programUniforms:V}),getShaderSource:J}}}),b3,W0,af,x3,H0,T3,BG,UG,Wne=dt(()=>{en(),Vo(),ln(),cn(),fc(),nT(),b3=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},W0=e=>typeof e=="number"?[e,e,e]:e,af=(e,t)=>t<=1?e:e+(e-1)*(t-1),x3=(e,t,n,i=1)=>{let r=af(t,i);return Math.floor((e[0]*(n-1)-n+r)/2)},H0=(e,t,n,i,r)=>{r==null&&(r=x3(e,t[0],i[0]));let s=[0,0,0,n];for(let a=0;a<3;a++)e[a]+2*r>=t[a]&&(s[a]=Math.trunc((e[a]-t[a]+2*r)/i[a]+1));return s},T3=(e,t,n,i,r,s,a,o,l,u)=>{let c,f,d,h;if(e==="VALID"&&(e=0),typeof e=="number"){c={top:e,bottom:e,left:e,right:e,front:e,back:e};let m=H0([t,n,i,1],[o,l,u],1,[r,s,a],e);f=m[0],d=m[1],h=m[2]}else if(Array.isArray(e)){if(!e.every((y,M,g)=>y===g[0]))throw Error(`Unsupported padding parameter: ${e}`);c={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let m=H0([t,n,i,1],[o,l,u],1,[r,s,a],e[0]);f=m[0],d=m[1],h=m[2]}else if(e==="SAME_UPPER"){f=Math.ceil(t/r),d=Math.ceil(n/s),h=Math.ceil(i/a);let m=(f-1)*r+o-t,y=(d-1)*s+l-n,M=(h-1)*a+u-i,g=Math.floor(m/2),_=m-g,T=Math.floor(y/2),x=y-T,S=Math.floor(M/2),$=M-S;c={top:T,bottom:x,left:S,right:$,front:g,back:_}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outDepth:f,outHeight:d,outWidth:h}},BG=(e,t,n,i,r,s=!1,a="channelsLast")=>{let o,l,u,c,f;if(a==="channelsLast")[o,l,u,c,f]=e;else if(a==="channelsFirst")[o,f,l,u,c]=e;else throw new Error(`Unknown dataFormat ${a}`);let[d,,h,m,y]=t,[M,g,_]=W0(n),[T,x,S]=W0(i),$=af(h,T),C=af(m,x),P=af(y,S),{padInfo:O,outDepth:R,outHeight:G,outWidth:W}=T3(r,l,u,c,M,g,_,$,C,P),V=s?d*f:d,te=[0,0,0,0,0];return a==="channelsFirst"?te=[o,V,R,G,W]:a==="channelsLast"&&(te=[o,R,G,W,V]),{batchSize:o,dataFormat:a,inDepth:l,inHeight:u,inWidth:c,inChannels:f,outDepth:R,outHeight:G,outWidth:W,outChannels:V,padInfo:O,strideDepth:M,strideHeight:g,strideWidth:_,filterDepth:h,filterHeight:m,filterWidth:y,effectiveFilterDepth:$,effectiveFilterHeight:C,effectiveFilterWidth:P,dilationDepth:T,dilationHeight:x,dilationWidth:S,inShape:e,outShape:te,filterShape:t}},UG=(e,t,n,i,r,s)=>{let a=s==="channelsLast";a?e[0].dims[3]:e[0].dims[1];let o=[64,1,1],l={x:n.map((M,g)=>g)},u=[Math.ceil(b3(l.x.map(M=>n[M]))/o[0]),1,1];Nn("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${u}`);let c=1,f=We.size(n),d=[{type:12,data:f},{type:12,data:i},{type:12,data:r},{type:12,data:t.strides},{type:12,data:t.dilations}];Qu(t,d),d.push(...Bt(e[0].dims,e[1].dims));let h=["rank","rank"],m=e.length===3;m&&(d.push(...Bt(e[2].dims)),h.push("rank")),d.push(...Bt(n));let y=M=>{let g=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:i.length},{name:"pads",type:"u32",length:r.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];Zu(t,g);let _=1,T=hr(e[0].dataType),x=Qe("x",e[0].dataType,e[0].dims.length,c),S=Qe("W",e[1].dataType,e[1].dims.length,_),$=[x,S],C=Ot("result",e[0].dataType,n.length,_),P="";if(m){let G=Qe("bias",e[2].dataType,e[2].dims.length,_);$.push(G),P+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${T} {
          return bias[${a?Lt("coords",4,5):Lt("coords",1,5)}];
        }`}let O=br(c,T),R=Xu(t,O,T);return`
            ${P}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${S.getByIndices("aIndices")};
            }
          ${M.registerUniforms(g).declareVariables(...$,C)}
          ${M.mainStart()}
          ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${C.offsetToIndices("global_idx")};
              let batch = ${Lt("coords",0,x.rank)};
              let d2 = ${a?Lt("coords",x.rank-1,x.rank):Lt("coords",1,x.rank)};
              let xFRCCorner = vec3<u32>(${a?Lt("coords",1,x.rank):Lt("coords",2,x.rank)},
              ${a?Lt("coords",2,x.rank):Lt("coords",3,x.rank)},
              ${a?Lt("coords",3,x.rank):Lt("coords",4,x.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${a?Lt("uniforms.x_shape",1,x.rank):Lt("uniforms.x_shape",2,x.rank)};
              let xShapeZ = ${a?Lt("uniforms.x_shape",2,x.rank):Lt("uniforms.x_shape",3,x.rank)};
              let xShapeW = ${a?Lt("uniforms.x_shape",3,x.rank):Lt("uniforms.x_shape",4,x.rank)};
              let xShapeU = ${a?Lt("uniforms.x_shape",4,x.rank):Lt("uniforms.x_shape",1,x.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${a?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${a?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${a?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${a?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${m?"value = value + getBiasByOutputCoords(coords)":""};
              ${R}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${a};${c};${m}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:u[0],y:u[1],z:u[2]},programUniforms:d}),getShaderSource:y}}}),VG,GG,Hne=dt(()=>{en(),ln(),cn(),fc(),VG=(e,t,n,i)=>{let r=e.length>2,s=r?"value += b[output_channel];":"",a=e[0].dims,o=e[1].dims,l=t.format==="NHWC",u=l?n[3]:n[1],c=u/t.group,f=l&&c>=4?zi(u):1,d=We.size(n)/f,h=[{type:12,data:d},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:c}];Qu(t,h),h.push(...Bt(a,[o[0],o[1],o[2],o[3]/f]));let m=r?["rank","rank","rank"]:["rank","rank"];h.push(...Bt([n[0],n[1],n[2],n[3]/f]));let y=M=>{let g=Ot("output",e[0].dataType,n.length,f),_=hr(g.type.tensor),T=Xu(t,g.type.value,_),x=Qe("x",e[0].dataType,a.length),S=Qe("w",e[1].dataType,o.length,f),$=[x,S];r&&$.push(Qe("b",e[2].dataType,e[2].dims,f));let C=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];Zu(t,C);let P=l?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${x.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${S.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${x.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${S.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${M.registerUniforms(C).declareVariables(...$,g)}

  ${M.mainStart()}
    ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${g.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${l?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${f} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];

    var value: ${g.type.value} = ${g.type.value}(0);
    ${P}
    ${s}
    ${T}
    ${g.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${f}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:y}},GG=(e,t,n,i)=>{let r=e.length>2,s=zi(n[3]),a=zi(n[2]),o=We.size(n)/s/a,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/s],u=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/s],c=[n[0],n[1],n[2],n[3]/s],f=[{type:12,data:o},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Qu(t,f),f.push(...Bt(l,u,c));let d=(a-1)*t.strides[1]+u[1],h=m=>{let y=Ot("output",e[0].dataType,c.length,s),M=hr(y.type.tensor),g=Xu(t,y.type.value,M),_=Qe("x",e[0].dataType,l.length,s),T=Qe("w",e[1].dataType,u.length,s),x=[_,T];r&&x.push(Qe("b",e[2].dataType,e[2].dims,s));let S=r?"value += b[output_channel];":"",$=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Zu(t,$),`
  ${m.registerUniforms($).declareVariables(...x,y)}
  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${a}u;
    let col = (index1 % width1) * ${a}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${_.type.value}, ${d}>;
    var values: array<${y.type.value}, ${a}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${u[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${d}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${_.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${_.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${u[1]}; w_width++) {
          let w_val = ${T.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${a}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${a}u; i++) {
      var value = values[i];
      ${S}
      ${g}
      ${y.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${s};${a};${d};${u[0]};${u[1]}`,inputDependencies:r?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:f}),getShaderSource:h}}}),M3,Rh,E3,Nh,n1,q0,S3,C3,i1,qne=dt(()=>{ln(),jne(),Wne(),sT(),Hne(),fc(),rT(),Jl(),M3=(e,t,n,i,r,s)=>{let a=e[0],o=e.slice(s?1:2,s?3:4),l=o.length,u=t[0],c=t.slice(2).map((d,h)=>d+(d-1)*(n[h]-1)),f=o.map((d,h)=>d+i[h]+i[h+l]).map((d,h)=>Math.floor((d-c[h]+r[h])/r[h]));return f.splice(0,0,a),f.splice(s?3:1,0,u),f},Rh=[2,3,1,0],E3=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let n=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[1]*t.group;if(n!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.length!==r*2)throw new Error(`pads should be ${r*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Nh=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let s=2;s<t[1].dims.length;++s)n[s-2]===0&&(n[s-2]=t[1].dims[s]);let i=e.pads.slice();mg.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,i,e.format==="NHWC",e.autoPad);let r=Object.assign({},e);return Object.assign(r,{kernelShape:n,pads:i}),r},n1=e=>{let t=tT(e),n=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],r=e.dilations,s=e.group,a=e.kernel_shape,o=e.pads,l=e.strides,u=e.w_is_const();return{autoPad:i,format:n,dilations:r,group:s,kernelShape:a,pads:o,strides:l,wIsConst:u,...t,cacheKey:`${e.format};${t.activation};`}},q0=(e,t,n,i)=>{let r=n.format==="NHWC",s=M3(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,r);if(n.group!==1){let $=[t[0]];if(r){let C=e.kernelCustomData.wT??e.compute(Ms(t[1],Rh),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=C),$.push(C)}else $.push(t[1]);t.length===3&&$.push(t[2]),!e.adapterInfo.isArchitecture("ampere")&&r&&t[1].dims[0]===n.group&&t[1].dims[1]===1&&n.dilations[0]===1&&n.dilations[1]===1?e.compute(GG($,n,s,i),{inputs:$}):e.compute(VG($,n,s,i),{inputs:$});return}let a=t.length===3,o=t[0].dims[r?1:2],l=t[0].dims[r?2:3],u=t[0].dims[r?3:1],c=t[1].dims[2],f=t[1].dims[3],d=s[r?1:2],h=s[r?2:3],m=s[r?3:1],y=r&&c===o&&f===l&&n.pads[0]===0&&n.pads[1]===0;if(y||c===1&&f===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let $=s[0],C,P,O,R=[];if(r){let V=e.kernelCustomData.wT??e.compute(Ms(t[1],Rh),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=V),y){let te=o*l*u;C=t[0].reshape([1,$,te]),P=V.reshape([1,te,m]),O=[1,$,m]}else C=t[0].reshape([$,o*l,u]),P=V.reshape([1,u,m]),O=[$,d*h,m];R.push(C),R.push(P)}else C=t[0].reshape([$,u,o*l]),P=t[1].reshape([1,m,u]),O=[$,m,d*h],R.push(P),R.push(C);a&&R.push(t[2]);let G=O[2],W=R[0].dims[R[0].dims.length-1];G<8&&W<8?e.compute(iT(R,n,s,O,r,i),{inputs:R}):e.compute(_g(R,n,s,O,r,i),{inputs:R});return}let M=!0,g=e.kernelCustomData.wT??e.compute(Ms(t[1],Rh),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=g);let _=[t[0],g];a&&_.push(t[2]);let T=r?d*h:m,x=r?m:d*h,S=c*f*u;e.compute(FG(_,n,s,T,x,S,a,M,i),{inputs:_})},S3=(e,t)=>{let n=t.format==="NHWC",i=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&i.push(e.inputs[2]);let r=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),a=[1].concat(t.dilations),o=[1].concat(t.kernelShape),l=Nh({...t,pads:r,strides:s,dilations:a,kernelShape:o},i);q0(e,i,l,u=>n?[u[0],u[2],u[3]]:[u[0],u[1],u[3]])},C3=(e,t,n)=>{let i=n.format==="NHWC"?"channelsLast":"channelsFirst",r=Nh(n,t),s=n.autoPad==="NOTSET"?n.pads:n.autoPad,a=BG(t[0].dims,t[1].dims,n.strides,n.dilations,s,!1,i);e.compute(UG(t,r,a.outShape,[a.filterDepth,a.filterHeight,a.filterWidth],[a.padInfo.front,a.padInfo.top,a.padInfo.left],i))},i1=(e,t)=>{if(E3(e.inputs,t),e.inputs[0].dims.length===3)S3(e,t);else if(e.inputs[0].dims.length===5)C3(e,e.inputs,t);else{let n=Nh(t,e.inputs);q0(e,e.inputs,n)}}}),jG,Kne=dt(()=>{en(),Vo(),ln(),cn(),jG=(e,t,n)=>{let i=e.length>2,r=t.outputShape,s=t.format==="NHWC",a=t.group,o=e[1].dims,l=o[2]/a,u=o[3],c=s?zi(l):1,f=s&&u===1&&l>=4,d=f?Math.floor(l/4)*4:Math.floor(l/c)*c,h=l-d,m=s?zi(u):1,y=s?u===1?c:m:1,M=We.size(r)/m,g=[Math.ceil(M/64),1,1];Nn("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${g}`);let _=["rank","rank"],T=[t.strides[0],t.strides[1]],x=[t.kernelShape[s?1:2],t.kernelShape[s?2:3]],S=[t.dilations[0],t.dilations[1]],$=[x[0]+(t.dilations[0]<=1?0:(t.kernelShape[s?1:2]-1)*(t.dilations[0]-1)),x[1]+(t.dilations[1]<=1?0:(t.kernelShape[s?2:3]-1)*(t.dilations[1]-1))],C=[$[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),$[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],P=[{type:12,data:M},{type:12,data:T},{type:12,data:x},{type:12,data:S},{type:12,data:$},{type:6,data:C},{type:12,data:d},{type:12,data:l},{type:12,data:u},...Bt(e[0].dims,e[1].dims)];i&&(P.push(...Bt(e[2].dims)),_.push("rank")),P.push(...Bt(r));let O=R=>{let G=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:T.length},{name:"filter_dims",type:"u32",length:x.length},{name:"dilations",type:"u32",length:x.length},{name:"effective_filter_dims",type:"u32",length:$.length},{name:"pads",type:"i32",length:C.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],W=hr(e[0].dataType),V=s?1:2,te=s?2:3,J=s?3:1,j=Qe("W",e[1].dataType,e[1].dims.length,y),Y=Qe("Dy",e[0].dataType,e[0].dims.length,c),X=[Y,j];i&&X.push(Qe("bias",e[2].dataType,[r[J]].length,m));let ce=Ot("result",e[0].dataType,r.length,m),me=()=>{let B="";if(f)c===4?B+=`
        let xValue = ${Y.getByOffset("x_offset")};
        let wValue = ${j.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:c===2?B+=`
          dotProd = dotProd + dot(vec4<${W}>(${Y.getByOffset("x_offset")}, ${Y.getByOffset("x_offset + 1u")}), vec4<${W}>(${j.getByOffset("w_offset")}, ${j.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:c===1&&(B+=`
          dotProd = dotProd + dot(vec4<${W}>(${Y.getByOffset("x_offset")}, ${Y.getByOffset("x_offset + 1u")}, ${Y.getByOffset("x_offset + 2u")}, ${Y.getByOffset("x_offset + 3u")}), vec4<${W}>(${j.getByOffset("w_offset")}, ${j.getByOffset("w_offset + 1u")}, ${j.getByOffset("w_offset + 2u")}, ${j.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(B+=`
                  let xValue = ${s?Y.getByOffset(`${Y.indicesToOffset(`${Y.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c}`):Y.get("batch","inputChannel","idyR","idyC")};
        `,c===1)B+=`
          let w_offset = ${j.indicesToOffset(`${j.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${j.getByOffset(`w_offset / ${y}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let ee=0;ee<c;ee++)B+=`
            let wValue${ee} = ${j.getByOffset(`${j.indicesToOffset(`${j.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${ee}, wOutChannel)`)} / ${y}`)};
            dotProd = dotProd + xValue[${ee}] * wValue${ee};`;return B},Q=()=>{if(h===0)return"";if(!f)throw new Error(`packInputAs4 ${f} is not true.`);let B="";if(c===1){B+="dotProd = dotProd";for(let ee=0;ee<h;ee++)B+=`
            + ${Y.getByOffset(`x_offset + ${ee}`)} * ${j.getByOffset(`w_offset + ${ee}`)}`;B+=";"}else if(c===2){if(h!==2)throw new Error(`Invalid inputChannelsRemainder ${h}.`);B+=`
          let xValue = ${Y.getByOffset("x_offset")};
          let wValue = ${j.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return B},H=`
            let outputIndices = ${ce.offsetToIndices(`global_idx * ${m}`)};
            let batch = ${ce.indicesGet("outputIndices",0)};
            let d1 = ${ce.indicesGet("outputIndices",J)};
            let r = ${ce.indicesGet("outputIndices",V)};
            let c = ${ce.indicesGet("outputIndices",te)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${ce.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${W}(dyRCorner) + ${W}(wR)) / ${W}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${W}(uniforms.Dy_shape[${V}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${W}(dyCCorner) + ${W}(wC)) / ${W}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${W}(uniforms.Dy_shape[${te}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${f?`
                var x_offset = ${Y.indicesToOffset(`${Y.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c};
                var w_offset = ${j.indicesToOffset(`${j.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${y};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${f?4:c}) {
                  ${me()}
                  inputChannel = inputChannel + ${f?4:c};
                }
                ${Q()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${i?` + bias[d1 / ${m}]`:""};
            ${ce.setByOffset("global_idx","value")};
          `;return`
    ${R.registerUniforms(G).declareVariables(...X,ce)}
      ${R.mainStart()}
      ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${H}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${c}${y}${m}${f}${h}`,inputDependencies:_},getRunData:()=>({dispatchGroup:{x:g[0],y:g[1],z:g[2]},outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],programUniforms:P}),getShaderSource:O}}}),$3,A3,I3,K0,WG,P3,J0,k3,HG,Jne=dt(()=>{Kne(),fc(),Jl(),$3=(e,t,n,i,r,s)=>(e-1)*t+n+(i-1)*r+1-s,A3=(e,t,n,i,r)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(n[i]=s,n[r]=e-s):t==="SAME_LOWER"&&(n[i]=e-s,n[r]=s)},I3=(e,t,n,i,r,s,a,o,l,u)=>{let c=e.length-2,f=u.length===0;l.length<c&&l.push(...Array(c-l.length).fill(0));let d=e[0],h=t[o?3:1]*r;for(let m=0,y=e.length-c-(o?1:0);m<c;++m,++y){let M=e[y],g=f?M*a[m]:u[m],_=$3(M,a[m],s[m],t[y],n[m],g);A3(_,i,s,m,m+c),f&&u.push(a[m]*(M-1)+l[m]+(t[y]-1)*n[m]+1-s[m]-s[m+c])}u.splice(0,0,d),u.splice(o?3:1,0,h)},K0=(e,t)=>{let n=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((f,d)=>f*d,1)===0){n.length=0;for(let f=2;f<t[1].dims.length;++f)n.push(t[1].dims[f])}let i=e.format==="NHWC";n.splice(0,0,t[1].dims[0]),n.splice(i?3:1,0,t[1].dims[1]);let r=e.pads.slice(),s=e.outputShape.slice(),a=e.outputPadding.slice(),o=t[0].dims,l=e.dilations.slice();if(l.reduce((f,d)=>f+d,0)===0){let f=t[0].dims.length-2;l=new Array(f).fill(1)}let u=e.strides.slice();if(u.reduce((f,d)=>f+d,0)===0){let f=t[0].dims.length-2;u=new Array(f).fill(1)}I3(o,n,l,e.autoPad,e.group,r,u,i,a,s);let c=Object.assign({},e);return Object.assign(c,{kernelShape:n,pads:r,outputPadding:a,outputShape:s,dilations:l,strides:u}),c},WG=e=>{let t=tT(e),n=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],r=e.dilations,s=e.group,a=e.kernelShape,o=e.pads,l=e.strides,u=e.wIsConst(),c=e.outputPadding,f=e.outputShape;return{autoPad:i,format:n,dilations:r,group:s,kernelShape:a,outputPadding:c,outputShape:f,pads:o,strides:l,wIsConst:u,...t,cacheKey:`${e.format};${t.activation};`}},P3=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let n=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[0];if(n!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let r=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==r))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((a,o)=>a+o,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((a,o)=>a+o,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((a,o)=>a+o,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((a,o)=>a+o,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},J0=(e,t,n,i)=>{let r=e.kernelCustomData.wT??e.compute(Ms(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r);let s=[t[0],r];t.length===3&&s.push(t[2]),e.compute(jG(s,n,i),{inputs:s})},k3=(e,t)=>{let n=t.format==="NHWC",i=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&i.push(e.inputs[2]);let r=t.kernelShape;(r.length===0||r[0]===0)&&(r=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let a=t.strides;(a.length===0||a[0]===0)&&(a=[1]);let o=t.pads;o.length===0&&(o=[0,0]),o=[0,o[0],0,o[1]],a=[1].concat(a),s=[1].concat(s),r=[1].concat(r);let l=t.outputPadding;l=[0].concat(l);let u=K0({...t,pads:o,strides:a,dilations:s,kernelShape:r,outputPadding:l},i);J0(e,i,u,c=>n?[c[0],c[2],c[3]]:[c[0],c[1],c[3]])},HG=(e,t)=>{if(P3(e.inputs,t),e.inputs[0].dims.length===3)k3(e,t);else{let n=K0(t,e.inputs);J0(e,e.inputs,n)}}}),D3,qG,KG,Yne=dt(()=>{en(),ln(),Ui(),cn(),D3=(e,t,n,i)=>{let r=We.size(t),s=t.length,a=Qe("input",e,s),o=Ot("output",e,s),l=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),u=We.normalizeAxis(l,s),c=f=>{let d=` i32(${a.indicesGet("inputIndices","uniforms.axis")}) `,h=Lt("uniforms.input_shape","uniforms.axis",s),m=i.reverse?d+(i.exclusive?" + 1":""):"0",y=i.reverse?h:d+(i.exclusive?"":" + 1");return`
                ${f.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(a,o)}
                ${f.mainStart()}
                  ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${o.offsetToIndices("global_idx")};
                  var sum = ${o.type.value}(0);
                  let first : i32 = ${m};
                  let last : i32 = ${y};
                  for (var i : i32 = first; i < last; i++) {
                    ${a.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${a.getByIndices("inputIndices")};
                  }
                  ${o.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:i.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:[{type:12,data:r},{type:12,data:u},...Bt(t,t)]}),getShaderSource:c}},qG=(e,t)=>{let n=e.inputs[0].dims,i=e.inputs[0].dataType,r=e.inputs[1];e.compute(D3(i,n,r,t),{inputs:[0]})},KG=e=>{let t=e.exclusive===1,n=e.reverse===1;return Qn({exclusive:t,reverse:n})}}),O3,R3,N3,JG,YG,Xne=dt(()=>{en(),ln(),Ui(),cn(),O3=e=>{if(!e||e.length!==1)throw new Error("DepthToSpace requires 1 input.");if(e[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},R3=(e,t,n,i)=>{let r=[];r.push(`fn perm(i: ${i.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`);for(let s=0;s<t;++s)r.push(n.indicesSet("a",e[s],`i[${s}]`));return r.push("return a;}"),r.join(`
`)},N3=(e,t)=>{let n,i,r,s,a,o,l=t.format==="NHWC",u=t.blocksize,c=t.mode==="DCR";l?([n,i,r,s]=e.dims,a=c?[n,i,r,u,u,s/u**2]:[n,i,r,s/u**2,u,u],o=c?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,i,r,s]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],a=c?[n,u,u,s/u**2,i,r]:[n,s/u**2,u,u,i,r],o=c?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let f=e.reshape(a),d=f.dims.length,h=e.dataType,m=Qe("a",h,d),y=Ot("output",h,d),M=g=>`
  ${g.registerUniform("output_size","u32").declareVariables(m,y)}

  ${R3(o,d,m,y)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${y.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${y.setByOffset("global_idx",m.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:g=>{let _=l?[n,i*u,r*u,s/u**2]:[n,s/u**2,i*u,r*u],T=We.size(_),x=f.dims,S=We.sortBasedOnPerm(x,o);return{outputs:[{dims:_,dataType:g[0].dataType}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:[{type:12,data:T},...Bt(x,S)]}},getShaderSource:M}},JG=(e,t)=>{O3(e.inputs),e.compute(N3(e.inputs[0],t))},YG=e=>Qn({blocksize:e.blocksize,mode:e.mode,format:e.format})}),Lh,of,Y0,L3,z3,F3,B3,X0,U3,XG,QG,Qne=dt(()=>{en(),ln(),Ui(),cn(),Lh="[a-zA-Z]|\\.\\.\\.",of="("+Lh+")+",Y0="^"+of+"$",L3="("+of+",)*"+of,z3="^"+L3+"$",F3=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);n===void 0?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},B3=class{constructor(e,t){var r;this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,i]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(z3)))throw new Error("Invalid LHS term");if(n.split(",").forEach((s,a)=>{let o=e[a].dims.slice();if(!s.match(RegExp(Y0)))throw new Error("Invalid LHS term");let l=this.processTerm(s,!0,o,a);this.lhs.push(l)}),i==="")i+=[...this.symbolToInfo.entries()].filter(([s,a])=>a.count===1||s==="...").map(([s])=>s).join("");else if(!i.match(RegExp(of)))throw new Error("Invalid RHS");(r=i.match(RegExp(Lh,"g")))==null||r.forEach(s=>{if(s==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let a=this.symbolToInfo.get(s);if(a===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(a.dimValue)}}),this.rhs=this.processTerm(i,!1,this.outputDims)}addSymbol(e,t,n){let i=this.symbolToInfo.get(e);if(i!==void 0){if(i.dimValue!==t&&i.count!==1)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(n)}else i={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,i)}processTerm(e,t,n,i=-1){let r=n.length,s=!1,a=[],o=0;if(!e.match(RegExp(Y0))&&!t&&e!=="")throw new Error("Invalid LHS term");let l=e.match(RegExp(Lh,"g")),u=new F3(i);return l==null||l.forEach((c,f)=>{if(c==="..."){if(s)throw new Error("Only one ellipsis is allowed per input term");s=!0;let d=r-l.length+1;if(d<0)throw new Error("Ellipsis out of bounds");if(a=n.slice(o,o+d),this.hasEllipsis){if(this.ellipsisDims.length!==a.length||this.ellipsisDims.toString()!==a.toString())throw new Error("Ellipsis dimensions mismatch")}else if(t)this.hasEllipsis=!0,this.ellipsisDims=a;else throw new Error("Ellipsis must be specified in the LHS");for(let h=0;h<a.length;h++){let m=String.fromCharCode(48+h);u.addSymbol(m,f+h),this.addSymbol(m,n[o++],i)}}else u.addSymbol(c,f+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(c,n[o++],i)}),u}},X0=e=>e+"_max",U3=(e,t,n,i)=>{let r=e.map(u=>u.length).map((u,c)=>Qe(`input${c}`,t,u)),s=We.size(i),a=Ot("output",t,i.length),o=[...n.symbolToInfo.keys()].filter(u=>!n.rhs.symbolToIndices.has(u)),l=u=>{let c=[],f="var prod = 1.0;",d="var sum = 0.0;",h="sum += prod;",m=[],y=[],M=[],g=[],_=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((x,S)=>{var $;if(n.rhs.symbolToIndices.has(S)){let C=($=n.rhs.symbolToIndices.get(S))==null?void 0:$[0];C!==void 0&&n.lhs.forEach((P,O)=>{if(x.inputIndices.includes(O)){let R=P.symbolToIndices.get(S);if(R===void 0)throw new Error("Invalid symbol error");R.forEach(G=>{c.push(`${r[O].indicesSet(`input${O}Indices`,G,a.indicesGet("outputIndices",C))}`)})}})}else n.lhs.forEach((C,P)=>{if(x.inputIndices.includes(P)){let O=C.symbolToIndices.get(S);if(O===void 0)throw new Error("Invalid symbol error");O.forEach(R=>{m.push(`${r[P].indicesSet(`input${P}Indices`,R,`${S}`)}`)}),g.push(`prod *= ${r[P].getByIndices(`input${P}Indices`)};`)}}),y.push(`for(var ${S}: u32 = 0; ${S} < uniforms.${X0(S)}; ${S}++) {`),M.push("}")});let T=_?[...c,`let sum = ${r.map((x,S)=>x.getByIndices(`input${S}Indices`)).join(" * ")};`]:[...c,d,...y,...m,f,...g,h,...M];return`
            ${u.registerUniforms(o.map(x=>({name:`${X0(x)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...r,a)}

            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${a.offsetToIndices("global_idx")};
            ${r.map((x,S)=>`var input${S}Indices: ${r[S].type.indices};`).join(`
`)}
            ${T.join(`
`)};
            ${a.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let u=o.filter(f=>n.symbolToInfo.has(f)).map(f=>{var d;return{type:12,data:((d=n.symbolToInfo.get(f))==null?void 0:d.dimValue)||0}});u.push({type:12,data:s});let c=e.map((f,d)=>[...Bt(f)]).reduce((f,d)=>f.concat(d),u);return c.push(...Bt(i)),{outputs:[{dims:i,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:c}},getShaderSource:l}},XG=(e,t)=>{let n=new B3(e.inputs,t.equation),i=n.outputDims,r=e.inputs.map((s,a)=>s.dims);e.compute(U3(r,e.inputs[0].dataType,n,i))},QG=e=>{let t=e.equation.replace(/\s+/g,"");return Qn({equation:t})}}),V3,Q0,G3,j3,ZG,Zne=dt(()=>{en(),ln(),cn(),V3=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),i=n.length<t.length?0:n.length-t.length,r=t.length<n.length?0:t.length-n.length;for(;i<n.length&&r<t.length;++i,++r)if(n[i]!==t[r]&&n[i]!==1&&t[r]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Q0=(e,t)=>{let n=e.length-t.length,i=[];for(let r=0;r<n;++r)i.push(e[r]);for(let r=0;r<t.length;++r)i.push(t[r]===1?e[r+n]:t[r]);return i},G3=(e,t)=>e.length>t.length?Q0(e,t):Q0(t,e),j3=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),i=G3(t,n),r=e[0].dataType,s=r===9||We.size(t)===1,a=r===9||t.length>0&&t[t.length-1]%4===0?4:1,o=s||i.length>0&&i[i.length-1]%4===0?4:1,l=Math.ceil(We.size(i)/o),u=f=>{let d=Qe("input",r,t.length,a),h=Ot("output",r,i.length,o),m;if(r===9){let y=(M,g,_="")=>`
          let outputIndices${g} = ${h.offsetToIndices(`outputOffset + ${g}u`)};
          let offset${g} = ${d.broadcastedIndicesToOffset(`outputIndices${g}`,h)};
          let index${g} = offset${g} / 4u;
          let component${g} = offset${g} % 4u;
          ${M}[${g}] = ${_}(${d.getByOffset(`index${g}`)}[component${g}]);
        `;m=`
        let outputOffset = global_idx * ${o};
        var data = vec4<u32>(0);
        ${y("data",0,"u32")}
        ${y("data",1,"u32")}
        ${y("data",2,"u32")}
        ${y("data",3,"u32")}
        ${h.setByOffset("global_idx","data")}
      }`}else m=`
        let outputIndices = ${h.offsetToIndices(`global_idx * ${o}`)};
        let inputOffset = ${d.broadcastedIndicesToOffset("outputIndices",h)};
        let data = ${h.type.value}(${d.getByOffset(`inputOffset / ${a}`)});
        ${h.setByOffset("global_idx","data")}
      }`;return`
    ${f.registerUniform("vec_size","u32").declareVariables(d,h)}
    ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${m}`},c=[{type:12,data:l},...Bt(t,i)];return{name:"Expand",shaderCache:{hint:`${i.length};${a}${o}`,inputDependencies:["rank"]},getShaderSource:u,getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c})}},ZG=e=>{V3(e.inputs),e.compute(j3(e.inputs),{inputs:[0]})}}),W3,e6,eie=dt(()=>{en(),ln(),cn(),eT(),W3=e=>{let t=e[0].dataType,n=We.size(e[0].dims),i=We.size(e[1].dims),r=i%4===0,s=a=>{let o=Qe("x",t,[1],4),l=Qe("bias",t,[1],4),u=Ot("y",t,[1],4),c=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],f=h=>`
      let bias${h}_offset: u32 = (global_idx * 4 + ${h}) % uniforms.bias_size;
      let bias${h} = ${l.getByOffset(`bias${h}_offset / 4`)}[bias${h}_offset % 4];`,d=r?`
      let bias = ${l.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${f(0)}${f(1)}${f(2)}${f(3)}
      let bias = ${o.type.value}(bias0, bias1, bias2, bias3);`;return`${a.registerUniforms(c).declareVariables(o,l,u)}

    ${Qb(Nr(t))}

    ${a.mainStart(Sd)}
      ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${o.getByOffset("global_idx")};
      ${d}
      let x_in = x + bias;
      ${u.setByOffset("global_idx",Zb("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${r}`,inputDependencies:["type","type"]},getShaderSource:s,getRunData:a=>({outputs:[{dims:a[0].dims,dataType:a[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:i}],dispatchGroup:{x:Math.ceil(n/Sd/4)}})}},e6=e=>{e.inputs.length<2||We.size(e.inputs[1].dims)===0?wG(e):e.compute(W3(e.inputs))}}),H3,q3,t6,n6,tie=dt(()=>{en(),ln(),Ui(),cn(),H3=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},q3=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n.length,s=We.normalizeAxis(t.axis,r),a=n.slice(0);a.splice(s,1,...i);let o=n[s],l=e[0].dataType===9?4:1,u=Math.ceil(We.size(a)/l),c=[{type:12,data:u},{type:6,data:o},{type:12,data:s},...Bt(e[0].dims,e[1].dims,a)],f=d=>{let h=Qe("data",e[0].dataType,e[0].dims.length,l),m=Qe("inputIndices",e[1].dataType,e[1].dims.length),y=Ot("output",e[0].dataType,a.length,l),M=_=>{let T=i.length,x=`var indicesIndices${_}  = ${m.type.indices}(0);`;for(let S=0;S<T;S++)x+=`${T>1?`indicesIndices${_}[${S}]`:`indicesIndices${_}`} = ${a.length>1?`outputIndices${_}[uniforms.axis + ${S}]`:`outputIndices${_}`};`;x+=`
          var idx${_} = ${m.getByIndices(`indicesIndices${_}`)};
          if (idx${_} < 0) {
            idx${_} = idx${_} + uniforms.axisDimLimit;
          }
          var dataIndices${_} : ${h.type.indices};
        `;for(let S=0,$=0;S<r;S++)S===s?(x+=`${r>1?`dataIndices${_}[${S}]`:`dataIndices${_}`} = u32(idx${_});`,$+=T):(x+=`${r>1?`dataIndices${_}[${S}]`:`dataIndices${_}`} = ${a.length>1?`outputIndices${_}[${$}]`:`outputIndices${_}`};`,$++);return x},g;if(e[0].dataType===9){let _=(T,x,S="")=>`
          let outputIndices${x} = ${y.offsetToIndices(`outputOffset + ${x}u`)};
          ${M(x)};
          let offset${x} = ${h.indicesToOffset(`dataIndices${x}`)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${T}[${x}] = ${S}(${h.getByOffset(`index${x}`)}[component${x}]);
        `;g=`
        let outputOffset = global_idx * ${l};
        var value = vec4<u32>(0);
        ${_("value",0,"u32")}
        ${_("value",1,"u32")}
        ${_("value",2,"u32")}
        ${_("value",3,"u32")}
        ${y.setByOffset("global_idx","value")}
      `}else g=`
      let outputIndices = ${y.offsetToIndices("global_idx")};
      ${M("")};
      let value = ${h.getByIndices("dataIndices")};
      ${y.setByOffset("global_idx","value")};
      `;return`
      ${d.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(h,m,y)}
      ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${g}
      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c}),getShaderSource:f}},t6=e=>Qn({axis:e.axis}),n6=(e,t)=>{let n=e.inputs;H3(n),e.compute(q3(e.inputs,t))}}),K3,i6,r6,nie=dt(()=>{en(),ln(),cn(),K3=(e,t,n,i,r,s,a,o,l)=>{let u=[{type:12,data:s},{type:12,data:i},{type:12,data:r},{type:12,data:n},{type:12,data:a},{type:12,data:o},{type:12,data:l}],c=[s];u.push(...Bt(t.dims,c));let f=d=>{let h=Qe("indices_data",t.dataType,t.dims.length),m=Ot("input_slice_offsets_data",12,1,1),y=[h,m],M=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:r.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${d.registerUniforms(M).declareVariables(...y)}
  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${r.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${n.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${r.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:c,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:u}),getShaderSource:f},{inputs:[t],outputs:[-1]})[0]},i6=(e,t)=>{let n=e.inputs,i=n[0].dims,r=n[0].dataType,s=n[1].dims,a=s[s.length-1],o=We.sizeToDimension(s,s.length-1),l=We.sizeFromDimension(i,t.batchDims+a),u=We.sizeToDimension(i,t.batchDims),c=We.sizeFromDimension(i,t.batchDims),f=o/u,d=new Array(a),h=l;for(let x=0;x<a;++x)d[a-1-x]=h,h*=i[t.batchDims+a-1-x];let m=K3(e,n[1],d,t.batchDims,i,o,f,c,a),y=t.batchDims+a;if(y>i.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let M=s.slice(0,-1).concat(i.slice(y)),g=We.size(M),_=[{type:12,data:g},{type:12,data:l},...Bt(n[0].dims,m.dims,M)],T=x=>{let S=Qe("data",n[0].dataType,n[0].dims.length),$=Qe("slice_offsets",12,m.dims.length),C=Ot("output",n[0].dataType,M.length);return`
          ${x.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(S,$,C)}
            ${x.mainStart()}
            ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:M,dataType:r}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:_}),getShaderSource:T},{inputs:[n[0],m]})},r6=e=>({batchDims:e.batch_dims,cacheKey:""})}),J3,Y3,s6,a6,iie=dt(()=>{en(),ln(),Ui(),cn(),J3=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=We.normalizeAxis(t.quantizeAxis,e[0].dims.length),i=t.blockSize,r=e[0],s=e[2],a=e.length===4?e[3]:void 0;if(s.dims.length!==r.dims.length||!r.dims.map((o,l)=>l===n?Math.ceil(o/i)===s.dims[l]:o===s.dims[l]).reduce((o,l)=>o&&l,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(a){if(a.dataType!==r.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(a.dims.length!==s.dims.length||!a.dims.map((o,l)=>o===s.dims[l]).reduce((o,l)=>o&&l,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},Y3=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n.length,s=We.normalizeAxis(t.gatherAxis,r),a=We.normalizeAxis(t.quantizeAxis,r),o=n.slice(0);o.splice(s,1,...i);let l=We.size(o),u=e[2].dataType,c=e[0].dataType===22,f=[{type:12,data:l},{type:12,data:a},{type:12,data:s},{type:12,data:t.blockSize},...Bt(...e.map((h,m)=>h.dims),o)],d=h=>{let m=Qe("data",e[0].dataType,e[0].dims.length),y=Qe("inputIndices",e[1].dataType,e[1].dims.length),M=Qe("scales",e[2].dataType,e[2].dims.length),g=e.length>3?Qe("zeroPoint",e[3].dataType,e[3].dims.length):void 0,_=Ot("output",u,o.length),T=[m,y,M];g&&T.push(g);let x=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${h.registerUniforms(x).declareVariables(...T,_)}
        ${h.mainStart()}
        let output_indices = ${_.offsetToIndices("global_idx")};
        var indices_indices = ${y.type.indices}(0);
        ${i.length>1?`
          for (var i: u32 = 0; i < ${i.length}; i++) {
            let index = ${_.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${y.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${_.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${m.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${_.indicesGet("output_indices","i")};
          ${m.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${y.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${n[s]};
        }
        ${m.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${o.length}; i++) {
          let index = ${_.indicesGet("output_indices",`i + ${i.length} - 1`)};
          ${m.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${m.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${m.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${M.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${M.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${M.getByIndices("scale_indices")};
        ${g?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${g.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${g.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${Nr(u)}(quantized_data - zero_point) * scale;
        ${_.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter((h,m)=>m!==1).map(h=>h.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:e.length},(h,m)=>"rank")},getRunData:()=>({outputs:[{dims:o,dataType:u}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:f}),getShaderSource:d}},s6=(e,t)=>{let n=e.inputs;J3(n,t),e.compute(Y3(e.inputs,t))},a6=e=>Qn({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})}),X3,Q3,o6,l6,rie=dt(()=>{en(),ln(),Ui(),cn(),X3=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Q3=(e,t)=>{let n=e[0].dims,i=e[0].dataType,r=n.length,s=e[1].dims,a=e[1].dataType,o=We.normalizeAxis(t.axis,r),l=n[o],u=s.slice(0),c=We.size(u),f=Qe("input",i,r),d=Qe("indicesInput",a,s.length),h=Ot("output",i,u.length),m=[{type:12,data:c},{type:6,data:l},{type:12,data:o}];return m.push(...Bt(n,s,u)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:m}),getShaderSource:y=>`
      ${y.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(f,d,h)}
      ${y.mainStart()}
      ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${h.offsetToIndices("global_idx")};

      var idx = ${d.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${f.type.indices}(outputIndices);
      ${f.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${f.getByIndices("inputIndices")};

      ${h.setByOffset("global_idx","value")};
  }`}},o6=e=>Qn({axis:e.axis}),l6=(e,t)=>{let n=e.inputs;X3(n),e.compute(Q3(e.inputs,t))}}),Z3,eD,u6,c6,sie=dt(()=>{en(),ln(),cn(),Z3=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},eD=(e,t)=>{let n=e[0].dims.slice(),i=e[1].dims.slice(),[r,s,a]=oV.getShapeOfGemmResult(n,t.transA,i,t.transB,e.length===3?e[2].dims:void 0),o=[r,s];if(!o)throw new Error("Can't use gemm on the given tensors");let l=16,u=Math.ceil(s/l),c=Math.ceil(r/l),f=!0,d=We.size(o),h=[{type:12,data:f?u:d},{type:12,data:r},{type:12,data:s},{type:12,data:a},{type:1,data:t.alpha},{type:1,data:t.beta}],m=["type","type"];e.length===3&&(h.push(...Bt(e[2].dims)),m.push("rank")),h.push(...Bt(o));let y=g=>{let _="";t.transA&&t.transB?_="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?_="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?_="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(_="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let T=t.alpha===1?"":"value *= uniforms.alpha;",x=Qe("a",e[0].dataType,e[0].dims),S=Qe("b",e[1].dataType,e[1].dims),$=x.type.value,C=null,P=[x,S];e.length===3&&(C=Qe("c",e[2].dataType,e[2].dims.length),P.push(C));let O=Ot("output",e[0].dataType,o.length);P.push(O);let R=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${g.registerUniforms(R).declareVariables(...P)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${$}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${_}
    }

    ${T}
    ${C!=null?`let cOffset = ${C.broadcastedIndicesToOffset("vec2(m, n)",O)}; value += ${$}(uniforms.beta) * ${C.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},M=g=>{let _=Qe("a",e[0].dataType,e[0].dims),T=Qe("b",e[1].dataType,e[1].dims),x=null,S=[_,T];e.length===3&&(x=Qe("c",e[2].dataType,e[2].dims.length),S.push(x));let $=Ot("output",e[0].dataType,o.length);S.push($);let C=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],P="",O="";t.transA&&t.transB?(O=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,P="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(O=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,P="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(O=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,P="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(O=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,P="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let R=t.alpha===1?"":"value *= uniforms.alpha;";return`
  ${g.registerUniforms(C).declareVariables(...S)}
  var<workgroup> tile_a: array<array<${_.type.storage}, ${l}>, ${l}>;
  var<workgroup> tile_b: array<array<${T.type.storage}, ${l}>, ${l}>;
  ${g.mainStart([l,l,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};
    let num_tiles = (uniforms.K - 1) / ${l} + 1;
    var k_start = 0u;
    var value = ${$.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${O}
      k_start = k_start + ${l};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${l}; k++) {
        ${P}
      }
      workgroupBarrier();
    }

    ${R}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${x!=null?`let cOffset = ${x.broadcastedIndicesToOffset("vec2(m, n)",$)}; value += ${$.type.value}(uniforms.beta) * ${x.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return f?{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u*c},programUniforms:h}),getShaderSource:M}:{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:y}},u6=e=>{let t=e.transA,n=e.transB,i=e.alpha,r=e.beta;return{transA:t,transB:n,alpha:i,beta:r,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},c6=(e,t)=>{Z3(e.inputs),e.compute(eD(e.inputs,t))}}),Ha,vo,gu,_u,tD,nD,iD,rD,sD,aD,oD,lD,d6,f6,aie=dt(()=>{en(),ln(),Ui(),cn(),[Ha,vo,gu,_u]=[0,1,2,3],tD=e=>{if(e[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${e[0].dims.length-2}`);if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},nD=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,iD=e=>`
  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,rD=e=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${e.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,sD=e=>`
  ${e.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,aD=(e,t,n)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {
     var pixel = ${t}(0);
     var indices = vec4<u32>(0);
     indices[${Ha}] = batch;
     indices[${vo}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${gu}] = u32(r);
            indices[${_u}] = u32(c);
          } else {
            return ${t}(0);
          }
        `;case"border":return`
          indices[${gu}] = u32(clamp(r, 0, H - 1));
          indices[${_u}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${gu}] = gs_reflect(r, border[1], border[3]);
          indices[${_u}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`
    return ${e.getByIndices("indices")};
  }
`,oD=(e,t,n)=>(()=>{switch(n.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${Ha}], indices[${vo}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${Ha}], indices[${vo}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${Ha}], indices[${vo}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${Ha}], indices[${vo}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${Ha}], indices[${vo}], border);

          let dx2 = ${t}(f32(x2) - x);
          let dx1 = ${t}(x - f32(x1));
          let dy2 = ${t}(f32(y2) - y);
          let dy1 = ${t}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${t}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${Ha}], indices[${vo}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,lD=(e,t)=>{let n=Qe("x",e[0].dataType,e[0].dims.length),i=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],r=Qe("grid",e[1].dataType,i.length,2),s=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];t.format==="NHWC"&&(s=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[Ha,vo,gu,_u]=[0,3,1,2]);let a=Ot("output",e[0].dataType,s.length),o=n.type.value,l=We.size(s),u=[{type:12,data:l},...Bt(e[0].dims,i,s)],c=f=>`
  ${f.registerUniform("output_size","u32").declareVariables(n,r,a)}
  ${nD}
  ${iD(o)}
  ${rD(t)}
  ${sD(t)}
  ${aD(n,o,t)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${gu}]);
      let W_in = i32(uniforms.x_shape[${_u}]);

      ${t.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${a.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${Ha}], indices[${gu}], indices[${_u}]);
      let nxy = ${r.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${oD(a,o,t)}
  }`;return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:f=>{let d=We.size(s);return{outputs:[{dims:s,dataType:f[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:u}},getShaderSource:c}},d6=(e,t)=>{tD(e.inputs),e.compute(lD(e.inputs,t))},f6=e=>Qn({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})}),Gr,uD,p6,Z0,cD,Df,h6,m6=dt(()=>{en(),ln(),Ui(),Yx(),Zx(),cn(),Jl(),Gr=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,uD=(e,t)=>{let n=e[0],i=Gr(e,1),r=Gr(e,2),s=Gr(e,3),a=Gr(e,4),o=Gr(e,5),l=Gr(e,6),u=Gr(e,7);if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let c=n.dims[0],f=n.dims[1],d=n.dims.length===3?n.dims[2]:t.numHeads*n.dims[4],h=f,m=0,y=0,M=Math.floor(d/t.numHeads);if(l&&u&&We.size(l.dims)&&We.size(u.dims)){if(l.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(l.dims[0]!==c||l.dims[1]!==t.numHeads||l.dims[3]!==M)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(u.dims[0]!==c||u.dims[1]!==t.numHeads||u.dims[3]!==M)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==u.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(u.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');m=l.dims[2],y=l.dims[2]}else if(l&&We.size(l.dims)||u&&We.size(u.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let g;if(i&&We.size(i.dims)>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(i.dims.length===3){if(i.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');g=2,h=i.dims[1]}else if(i.dims.length===5){if(i.dims[2]!==t.numHeads||i.dims[3]!==2||i.dims[4]!==M)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');g=5,h=i.dims[1]}else{if(i.dims[1]!==t.numHeads||i.dims[3]!==M)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');g=0,h=i.dims[2]}}else{if(n.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==t.numHeads||n.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');g=3}if(s&&We.size(s.dims)>0){if(s.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(i&&i.dims.length===5&&i.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let _=m+h,T=0;if(a&&We.size(a.dims)>0){T=8;let C=a.dims;throw C.length===1?C[0]===c?T=1:C[0]===3*c+2&&(T=3):C.length===2&&C[0]===c&&C[1]===_&&(T=5),T===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let x=!1,S=d;if(r&&We.size(r.dims)>0){if(r.dims.length!==3&&r.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(r.dims.length===3){if(h!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');S=r.dims[2]}else{if(h!==r.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');S=r.dims[1]*r.dims[3],x=!0}}let $=!1;if(a&&We.size(a.dims)>0)throw new Error("Key padding mask is not supported");if(o&&We.size(o.dims)>0){if(o.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(o.dims[0]!==c||o.dims[1]!==t.numHeads||o.dims[2]!==f||o.dims[3]!==_)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:c,sequenceLength:f,pastSequenceLength:m,kvSequenceLength:h,totalSequenceLength:_,maxSequenceLength:y,inputHiddenSize:0,hiddenSize:d,vHiddenSize:S,headSize:M,vHeadSize:Math.floor(S/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:T,scale:t.scale,broadcastResPosBias:$,passPastInKv:x,qkvFormat:g}},p6=e=>Qn({...e}),Z0=Qn({perm:[0,2,1,3]}),cD=(e,t,n,i,r,s,a)=>{let o=[i,r,s],l=We.size(o),u=[{type:12,data:l},{type:12,data:a},{type:12,data:s}],c=f=>{let d=Ot("qkv_with_bias",t.dataType,o),h=Qe("qkv",t.dataType,o),m=Qe("bias",n.dataType,o),y=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${f.registerUniforms(y).declareVariables(h,m,d)}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u}),getShaderSource:c},{inputs:[t,n],outputs:[-1]})[0]},Df=(e,t,n,i,r,s,a,o)=>{let l=s;if(a&&We.size(a.dims)>0){if(i===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=cD(e,s,a,t,i,n*r,o),l=l.reshape([t,i,n,r]),n===1||i===1?l:e.compute(Ms(l,Z0.perm),{inputs:[l],outputs:[-1]})[0]}else return s.dims.length===3&&(l=s.reshape([t,i,n,r])),n===1||i===1?l:e.compute(Ms(l,Z0.perm),{inputs:[l],outputs:[-1]})[0]},h6=(e,t)=>{let n=uD(e.inputs,t),i=e.inputs[0],r=Gr(e.inputs,1),s=Gr(e.inputs,2),a=Gr(e.inputs,3),o=Gr(e.inputs,4),l=Gr(e.inputs,5),u=Gr(e.inputs,6),c=Gr(e.inputs,7);if(i.dims.length===5)throw new Error("Packed QKV is not implemented");if((r==null?void 0:r.dims.length)===5)throw new Error("Packed KV is not implemented");let f=r&&s&&r.dims.length===4&&s.dims.length===4,d=Df(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,i,a,0);if(f)return _p(e,d,r,s,o,void 0,u,c,l,n);if(!r||!s)throw new Error("key and value must be provided");let h=Df(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,r,a,n.hiddenSize),m=Df(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,s,a,2*n.hiddenSize);_p(e,d,h,m,o,void 0,u,c,l,n)}}),dD,fD,pD,hD,r1,g6,_6,y6=dt(()=>{en(),ln(),Ui(),cn(),dD=e=>{if(!e||e.length<1)throw new Error("too few inputs")},fD=(e,t)=>{let n=[],i=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(r=>n.push(Number(r))),i=n.length),Qn({numOutputs:i,axis:t.axis,splitSizes:n})},pD=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < ${Lt("uniforms.size_in_split_axis","i",e)}) {
        return i;
    }
    }
    return ${e}u;
}`,hD=e=>{let t=e.length,n=[];for(let i=0;i<t;++i){let r=e[i].setByIndices("indices","input[global_idx]");t===1?n.push(r):i===0?n.push(`if (output_number == ${i}u) { ${r} }`):i===t-1?n.push(`else { ${r} }`):n.push(`else if (output_number == ${i}) { ${r} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${n.join(`
`)}
      }`},r1=(e,t)=>{let n=e[0].dims,i=We.size(n),r=e[0].dataType,s=We.normalizeAxis(t.axis,n.length),a=new Array(t.numOutputs),o=Qe("input",r,n.length),l=new Array(t.numOutputs),u=[],c=[],f=0,d=[{type:12,data:i}];for(let m=0;m<t.numOutputs;m++){f+=t.splitSizes[m],l[m]=f;let y=n.slice();y[s]=t.splitSizes[m],c.push(y),a[m]=Ot(`output${m}`,r,y.length),u.push({dims:c[m],dataType:e[0].dataType})}d.push({type:12,data:l},...Bt(n,...c));let h=m=>`
  ${m.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(o,...a)}
  ${pD(l.length)}
  ${hD(a)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${o.offsetToIndices("global_idx")};
    var index = ${o.indicesGet("indices",s)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Lt("uniforms.size_in_split_axis","output_number - 1u",l.length)};
      ${o.indicesSet("indices",s,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:h,getRunData:()=>({outputs:u,dispatchGroup:{x:Math.ceil(i/64)},programUniforms:d})}},g6=(e,t)=>{dD(e.inputs);let n=e.inputs.length===1?t:fD(e.inputs,t);e.compute(r1(e.inputs,n),{inputs:[0]})},_6=e=>{let t=e.axis,n=e.splitSizes,i=e.numOutputs<0?n.length:e.numOutputs;if(i!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return Qn({axis:t,numOutputs:i,splitSizes:n})}}),mD,yg,v6,w6=dt(()=>{en(),ln(),Ui(),cn(),mD=(e,t)=>{let[n,i,r,s]=e,{numHeads:a,rotaryEmbeddingDim:o}=t;if(n.dims.length!==3&&n.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!We.areEqual(i.dims,[])&&!We.areEqual(i.dims,[1])&&i.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${i.dims.length}`);if(r.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${r.dims.length}`);if(s.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${s.dims.length}`);if(!We.areEqual(r.dims,s.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(o>0&&a===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let l=n.dims[0],u=n.dims[n.dims.length-2],c=r.dims[0],f=We.sizeFromDimension(n.dims,1)/u,d=o===0?r.dims[1]*2:f/a;if(o>d)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(i.dims.length===2){if(l!==i.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${i.dims[0]}`);if(u!==i.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${i.dims[1]}`)}if(d/2!==r.dims[1]&&o/2!==r.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${r.dims[1]}`);if(u>c)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},yg=(e,t)=>{let{interleaved:n,numHeads:i,rotaryEmbeddingDim:r,scale:s}=t,a=e[0].dims[0],o=We.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],u=o/l,c=e[2].dims[1],f=r===0?c*2:u/i,d=new Array(a,l,u/f,f-c),h=We.computeStrides(d),m=[{type:1,data:s},{type:12,data:d},{type:12,data:h},...e[0].dims.length===3?new Array({type:12,data:[o,u,f,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[o,f,l*f,1]}):[],...Bt(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],y=M=>{let g=Qe("input",e[0].dataType,e[0].dims.length),_=Qe("position_ids",e[1].dataType,e[1].dims.length),T=Qe("cos_cache",e[2].dataType,e[2].dims.length),x=Qe("sin_cache",e[3].dataType,e[3].dims.length),S=Ot("output",e[0].dataType,e[0].dims.length);return M.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:d.length},{name:"global_strides",type:"u32",length:h.length},{name:"input_output_strides",type:"u32",length:h.length}]),`
        ${M.declareVariables(g,_,T,x,S)}

        ${M.mainStart(Sd)}
          let half_rotary_emb_dim = uniforms.${T.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${M.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${_.broadcastedIndicesToOffset("bsnh.xy",Ot("",_.type.tensor,2))};
            let position_id =
                u32(${_.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});
            let j = i + select(half_rotary_emb_dim, 1, ${n});
            let re = ${g.getByOffset("i")} * ${T.get("position_id","bsnh[3]")} -
                ${g.getByOffset("j")} * ${x.get("position_id","bsnh[3]")};
            ${S.setByOffset("i","re")}
            let im = ${g.getByOffset("i")} * ${x.get("position_id","bsnh[3]")} +
                ${g.getByOffset("j")} * ${T.get("position_id","bsnh[3]")};
            ${S.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${S.setByOffset("k",g.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:Qn({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(We.size(d)/Sd)},programUniforms:m})}},v6=(e,t)=>{mD(e.inputs,t),e.compute(yg(e.inputs,t))}}),gD,_D,ev,yD,b6,oie=dt(()=>{Ui(),en(),Zx(),m6(),y6(),Jl(),w6(),cn(),gD=(e,t)=>{if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=e[0],i=e[1],r=e[2],s=e[3],a=e[4];if(t.doRotary!==0&&e.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(t.localWindowSize!==-1)throw new Error("Local attention is not supported");if(t.softcap!==0)throw new Error("Softcap is not supported");if(t.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let o=!1,l=n.dims[0],u=n.dims[1],c=n.dims.length===3?o?n.dims[2]/3:n.dims[2]:t.numHeads*n.dims[4],f=u,d=0,h=!i||i.dims.length===0,m=Math.floor(h?c/(t.numHeads+2*t.kvNumHeads):c/t.numHeads);h&&(c=m*t.numHeads);let y=s&&s.dims.length!==0,M=a&&a.dims.length!==0;if(y&&s.dims.length===4&&s.dims[0]===l&&s.dims[1]!==t.kvNumHeads&&s.dims[2]===t.kvNumHeads&&s.dims[3]===m)throw new Error("BSNH pastKey/pastValue is not supported");if(y&&M){if(s.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(a.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');d=s.dims[2]}else if(y||M)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let g=1;if(i&&i.dims.length>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(i.dims.length===3){if(n.dims[2]%i.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');f=i.dims[1]}else if(i.dims.length===5){if(i.dims[2]!==t.numHeads||i.dims[3]!==2||i.dims[4]!==m)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');f=i.dims[1]}else{if(i.dims[1]!==t.numHeads||i.dims[3]!==m)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');f=i.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==t.numHeads||n.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');g=3}let _=0,T=!1,x=t.kvNumHeads?m*t.kvNumHeads:c;if(r&&r.dims.length>0){if(r.dims.length!==3&&r.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(r.dims.length===3){if(f!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');x=r.dims[2]}else{if(f!==r.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');x=r.dims[1]*r.dims[3],T=!0}}let S=e.length>4?e[5]:void 0;if(S&&S.dims.length!==1&&S.dims[0]!==l)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:l,sequenceLength:u,pastSequenceLength:d,kvSequenceLength:f,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:c,vHiddenSize:x,headSize:m,vHeadSize:Math.floor(x/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:_,scale:t.scale,broadcastResPosBias:!1,passPastInKv:T,qkvFormat:g}},_D=Qn({perm:[0,2,1,3]}),ev=(e,t,n)=>{let i=t,r=n.kvNumHeads;return t.dims.length===3&&n.kvSequenceLength!==0&&(i=t.reshape([n.batchSize,n.kvSequenceLength,r,n.headSize]),i=e.compute(Ms(i,_D.perm),{inputs:[i],outputs:[-1]})[0]),i},yD=(e,t,n,i)=>{let r=7,s=["type","type"],a=[e*t],o=e*t,l=[{type:12,data:o},{type:12,data:t},{type:12,data:e}],u=c=>{let f=Qe("seq_lens",n.dataType,n.dims),d=Qe("total_seq_lens",i.dataType,i.dims),h=Ot("pos_ids",r,a),m=[{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}];return`
  ${c.registerUniforms(m).declareVariables(f,d,h)}
  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${d.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${f.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${h.setByOffset("global_idx","pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${h.setByOffset("global_idx","pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${h.setByOffset("global_idx","seqlen")}
    };
  }
  `};return{name:"GeneratePositionIds",shaderCache:{hint:`${e};${t}`,inputDependencies:s},getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:l}),getShaderSource:u}},b6=(e,t)=>{var x;let n=gD(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((x=e.inputs[1])==null?void 0:x.dims.length)===5)throw new Error("Packed KV is not implemented");let i=e.inputs[0],r=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,s=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,a=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,o=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,u=e.inputs.length>5?e.inputs[6]:void 0,c=n.kvNumHeads?n.kvNumHeads:n.numHeads,f=Qn({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,c*n.headSize,c*n.headSize]}),[d,h,m]=!r&&!s?e.compute(r1([i],f),{inputs:[i],outputs:[-1,-1,-1]}):[i,r,s],y,M;if(t.doRotary){let S=e.compute(yD(n.batchSize,n.sequenceLength,l,u),{inputs:[l,u],outputs:[-1]})[0],$=e.inputs[7],C=e.inputs[8],P=Qn({interleaved:t.rotaryInterleaved!==0,numHeads:n.numHeads,rotaryEmbeddingDim:0,scale:t.scale}),O=[d,S,$,C],R=[-1];y=e.compute(yg(O,P),{inputs:O,outputs:R})[0],O.splice(0,1,h);let G=Qn({interleaved:t.rotaryInterleaved!==0,numHeads:n.kvNumHeads,rotaryEmbeddingDim:0,scale:t.scale});M=e.compute(yg(O,G),{inputs:O,outputs:R})[0]}let g=Df(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,t.doRotary?y:d,void 0,0),_=ev(e,t.doRotary?M:h,n),T=ev(e,m,n);_p(e,g,_,T,void 0,void 0,a,o,void 0,n,l,u)}}),tv,vD,wD,x6,lie=dt(()=>{en(),ln(),Jl(),cn(),tv=(e,t,n,i,r,s,a,o)=>{let l=zi(s),u=l===1?"f32":`vec${l}f`,c=l===1?"vec2f":`mat2x${l}f`,f=r*a,d=64;f===1&&(d=256);let h=[r,a,s/l],m=[r,a,2],y=["rank","type","type"],M=[];M.push(...Bt(h,m));let g=_=>{let T=Qe("x",t.dataType,3,l),x=Qe("scale",n.dataType,n.dims),S=Qe("bias",i.dataType,i.dims),$=Ot("output",1,3,2),C=[T,x,S,$];return`
  var<workgroup> workgroup_shared : array<${c}, ${d}>;
  const workgroup_size = ${d}u;
  ${_.declareVariables(...C)}
  ${_.mainStart(d)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${u}(0);
    var squared_sum = ${u}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${u}(${T.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${c}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${jl("workgroup_shared[0][0]",l)} / f32(hight * ${l});
      let squared_sum_final = ${jl("workgroup_shared[0][1]",l)} / f32(hight * ${l});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${o}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${o};${d}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:m,dataType:1}],dispatchGroup:{x:f},programUniforms:M}),getShaderSource:g},{inputs:[t,n,i],outputs:[-1]})[0]},vD=(e,t,n)=>{let i=t[0].dims,r=i,s=2,a=i[0],o=i[1],l=We.sizeFromDimension(i,s),u=zi(l),c=We.size(r)/u,f=tv(e,t[0],t[1],t[2],a,l,o,n.epsilon),d=[a,o,l/u],h=[a,o],m=["type","none"],y=M=>{let g=Qe("x",t[0].dataType,d.length,u),_=Qe("scale_shift",1,h.length,2),T=Ot("output",t[0].dataType,d.length,u),x=[g,_,T];return`
  ${M.registerUniform("output_size","u32").declareVariables(...x)}
  ${M.mainStart()}
  ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${T.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${_.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${g.getByOffset("global_idx")} * ${T.type.value}(scale_shift.x) + ${T.type.value}(scale_shift.y);
      ${T.setByOffset("global_idx","value")};
  }`};e.compute({name:"InstanceNormalization",shaderCache:{hint:`${u}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:[{type:12,data:c},...Bt(d,h,d)]}),getShaderSource:y},{inputs:[t[0],f]})},wD=(e,t,n)=>{let i=t[0].dims,r=i,s=i[0],a=i[i.length-1],o=We.sizeFromDimension(i,1)/a,l=zi(a),u=We.size(r)/l,c=[{type:12,data:o},{type:12,data:Math.floor(a/l)}],f=["type","type"],d=!1,h=[0,i.length-1];for(let g=0;g<i.length-2;g++)d=d||i[g+1]!==1,h.push(g+1);d=d&&i[i.length-1]!==1;let m=d?e.compute(Ms(e.inputs[0],h),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:i.length},(g,_)=>i[h[_]])),y=tv(e,m,t[1],t[2],s,o,a,n.epsilon),M=g=>{let _=hr(t[0].dataType),T=l===1?"vec2f":`mat${l}x2f`,x=C=>{let P=C===0?"x":"y",O=l===1?"f32":`vec${l}f`;switch(l){case 1:return`${_}(${O}(scale.${P}))`;case 2:return`vec2<${_}>(${O}(scale[0].${P}, scale[1].${P}))`;case 4:return`vec4<${_}>(${O}(scale[0].${P}, scale[1].${P}, scale[2].${P}, scale[3].${P}))`;default:throw new Error(`Not supported compoents ${l}`)}},S=Qe("input",t[0].dataType,t[0].dims,l),$=Ot("output",t[0].dataType,r,l);return`
  @group(0) @binding(0) var<storage, read> input : array<${S.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${T}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${$.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${g.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${x(0)}, ${x(1)});
  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c}),getShaderSource:M},{inputs:[t[0],y]})},x6=(e,t)=>{t.format==="NHWC"?wD(e,e.inputs,t):vD(e,e.inputs,t)}}),bD,xD,T6,uie=dt(()=>{en(),ln(),cn(),bD=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},xD=(e,t,n)=>{let i=t.simplified,r=e[0].dims,s=e[1],a=!i&&e[2],o=r,l=We.normalizeAxis(t.axis,r.length),u=We.sizeToDimension(r,l),c=We.sizeFromDimension(r,l),f=We.size(s.dims),d=a?We.size(a.dims):0;if(f!==c||a&&d!==c)throw new Error(`Size of X.shape()[axis:] == ${c}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${f} and bias size of ${d}`);let h=[];for(let S=0;S<r.length;++S)S<l?h.push(r[S]):h.push(1);let m=zi(c),y=["type","type"],M=[{type:12,data:u},{type:1,data:c},{type:12,data:Math.floor(c/m)},{type:1,data:t.epsilon}];a&&y.push("type");let g=n>1,_=n>2,T=S=>{let $=hr(e[0].dataType),C=[Qe("x",e[0].dataType,e[0].dims,m),Qe("scale",s.dataType,s.dims,m)];a&&C.push(Qe("bias",a.dataType,a.dims,m)),C.push(Ot("output",e[0].dataType,o,m)),g&&C.push(Ot("mean_data_output",1,h)),_&&C.push(Ot("inv_std_output",1,h));let P=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${S.registerUniforms(P).declareVariables(...C)}
  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Jb("f32",m)};
    var mean_square_vector = ${Jb("f32",m)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${nd($,m,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${jl("mean_vector",m)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${jl("mean_square_vector",m)} / uniforms.norm_size ${i?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${nd($,m,"x[j + offset]")};
      let f32scale = ${nd($,m,"scale[j]")};
      output[j + offset] = ${C[0].type.value}((f32input ${i?"":"- mean"}) * inv_std_dev * f32scale
        ${a?`+ ${nd($,m,"bias[j]")}`:""}
      );
    }

    ${g?"mean_data_output[global_idx] = mean":""};
    ${_?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},x=[{dims:o,dataType:e[0].dataType}];return g&&x.push({dims:h,dataType:1}),_&&x.push({dims:h,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${m};${n};${i}`,inputDependencies:y},getRunData:()=>({outputs:x,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:M}),getShaderSource:T}},T6=(e,t)=>{bD(e.inputs),e.compute(xD(e.inputs,t,e.outputCount))}}),TD,M6,cie=dt(()=>{ln(),rT(),sT(),TD=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},M6=e=>{TD(e.inputs);let t=Ed.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let n=t[t.length-1],i=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&i<8)e.compute(iT(e.inputs,{activation:""},t));else{let r=t[t.length-2],s=We.size(e.inputs[0].dims.slice(0,-2)),a=We.size(e.inputs[1].dims.slice(0,-2));if(s!==1&&r===1&&a===1){let o=e.inputs[0].reshape([1,s,i]),l=e.inputs[1].reshape([1,i,n]),u=[1,s,n],c=[o,l];e.compute(_g(c,{activation:""},t,u),{inputs:c})}else e.compute(_g(e.inputs,{activation:""},t))}}}),MD,ED,SD,E6,S6,die=dt(()=>{en(),ln(),Ui(),cn(),MD=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=e[0],i=n.dims.length;if(n.dims[i-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let r=Math.floor((t.k+t.blockSize-1)/t.blockSize),s=t.blockSize/8*t.bits,a=e[1];if(!We.areEqual(a.dims,[t.n,r,s]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let o=e[2].dims;if(We.size(o)!==t.n*r)throw new Error("scales input size error.");if(e.length===4){let l=e[3].dims,u=t.bits>4?t.n*r:t.n*Math.floor((r+1)/2);if(We.size(l)!==u)throw new Error("zeroPoints input size error.")}},ED=(e,t)=>{let n=e[0].dims,i=n.length,r=n[i-2],s=t.k,a=t.n,o=n.slice(0,i-2),l=We.size(o),u=e[1].dims[2]/4,c=e[0].dataType,f=zi(t.k),d=zi(u),h=zi(a),m=o.concat([r,a]),y=r>1&&a/h%2===0?2:1,M=We.size(m)/h/y,g=64,_=[],T=[l,r,s/f],x=We.convertShape(e[1].dims).slice();x.splice(-1,1,u/d),_.push(...Bt(T)),_.push(...Bt(x)),_.push(...Bt(e[2].dims)),e.length===4&&_.push(...Bt(We.convertShape(e[3].dims)));let S=[l,r,a/h];_.push(...Bt(S));let $=C=>{let P=T.length,O=Qe("a",e[0].dataType,P,f),R=Qe("b",12,x.length,d),G=Qe("scales",e[2].dataType,e[2].dims.length),W=[O,R,G],V=e.length===4?Qe("zero_points",12,e[3].dims.length):void 0;V&&W.push(V);let te=S.length,J=Ot("output",e[0].dataType,te,h),j=hr(e[0].dataType),Y=(()=>{switch(f){case 1:return`array<${j}, 8>`;case 2:return`mat4x2<${j}>`;case 4:return`mat2x4<${j}>`;default:throw new Error(`${f}-component is not supported.`)}})(),X=()=>{let Q=`
          // reuse a data
            var input_offset = ${O.indicesToOffset(`${O.type.indices}(batch, row, word_offset)`)};
            var a_data: ${Y};
            for (var j: u32 = 0; j < ${8/f}; j++) {
              a_data[j] = ${O.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let H=0;H<h*y;H++)Q+=`
            b_value = ${d===1?`b${H}_data`:`b${H}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${Y}(${Array.from({length:4},(B,ee)=>`${j}(b_value_lower[${ee}]), ${j}(b_value_upper[${ee}])`).join(", ")});
            b_dequantized_values = ${f===1?`${Y}(${Array.from({length:8},(B,ee)=>`(b_quantized_values[${ee}] - ${V?`zero_point${H}`:"zero_point"}) * scale${H}`).join(", ")});`:`(b_quantized_values - ${Y}(${Array(8).fill(`${V?`zero_point${H}`:"zero_point"}`).join(",")})) * scale${H};`};
            workgroup_shared[local_id.x * ${y} + ${Math.floor(H/h)}]${h>1?`[${H%h}]`:""} += ${Array.from({length:8/f},(B,ee)=>`${f===1?`a_data[${ee}] * b_dequantized_values[${ee}]`:`dot(a_data[${ee}], b_dequantized_values[${ee}])`}`).join(" + ")};
          `;return Q},ce=()=>{let Q=`
            var col_index = col * ${h};
            ${V?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${j}(8);`}
            `;for(let H=0;H<h*y;H++)Q+=`
            let scale${H} = ${G.getByOffset("col_index * nBlocksPerCol + block")};
            ${V?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${V.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${H} = ${j}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return Q},me=()=>{let Q=`col_index = col * ${h};`;for(let H=0;H<h*y;H++)Q+=`
            let b${H}_data = ${R.getByIndices(`${R.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return Q+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${Y};
            var b_dequantized_values: ${Y};`,Q};return`
        var<workgroup> workgroup_shared: array<${J.type.value}, ${y*g}>;
        ${C.declareVariables(...W,J)}
        ${C.mainStart([g,1,1])}
          let output_indices = ${J.offsetToIndices(`(global_idx / ${g}) * ${y}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${g}) {
            //process one block
            var word_offset: u32 = block * ${t.blockSize/f};
            ${ce()}
            for (var word: u32 = 0; word < ${u}; word += ${d}) {
              ${me()}
              for (var i: u32 = 0; i < ${d}; i++) {
                ${X()}
                word_offset += ${8/f};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${y}) {
            var output_value: ${J.type.value} = ${J.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${g}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${y};
            }
            ${J.setByIndices(`${J.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${f};${d};${h};${y};${g}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:m,dataType:c}],dispatchGroup:{x:M},programUniforms:_}),getShaderSource:$}},SD=(e,t)=>{let n=e[0].dims,i=n.length,r=n[i-2],s=t.k,a=t.n,o=n.slice(0,i-2),l=We.size(o),u=e[1].dims[2]/4,c=e[0].dataType,f=zi(t.k),d=zi(u),h=o.concat([r,a]),m=128,y=a%8===0?8:a%4===0?4:1,M=m/y,g=M*d*8,_=g/f,T=g/t.blockSize,x=We.size(h)/y,S=[],$=[l,r,s/f],C=We.convertShape(e[1].dims).slice();C.splice(-1,1,u/d),S.push(...Bt($)),S.push(...Bt(C)),S.push(...Bt(e[2].dims)),e.length===4&&S.push(...Bt(We.convertShape(e[3].dims)));let P=[l,r,a];S.push(...Bt(P));let O=R=>{let G=$.length,W=Qe("a",e[0].dataType,G,f),V=Qe("b",12,C.length,d),te=Qe("scales",e[2].dataType,e[2].dims.length),J=[W,V,te],j=e.length===4?Qe("zero_points",12,e[3].dims.length):void 0;j&&J.push(j);let Y=P.length,X=Ot("output",e[0].dataType,Y),ce=hr(e[0].dataType),me=()=>{switch(f){case 1:return`
          let a_data0 = vec4<${ce}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${ce}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${ce}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${ce}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${f}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${W.type.value}, ${_}>;
        var<workgroup> inter_results: array<array<${X.type.value}, ${M}>, ${y}>;
        ${R.declareVariables(...J,X)}
        ${R.mainStart([M,y,1])}
          let output_indices = ${X.offsetToIndices(`workgroup_index * ${y}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${T} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${_};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${_}; a_offset += ${m})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${W.getByIndices(`${W.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${W.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${T} + local_id.x;
            ${j?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${j.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${ce}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${ce}(8);`}
            let scale = ${te.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${V.getByIndices(`${V.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${t.blockSize/f};
            for (var i: u32 = 0; i < ${d}; i++) {
              ${me()}
              let b_value = ${d===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${ce}>(${Array.from({length:4},(Q,H)=>`${ce}(b_value_lower[${H}]), ${ce}(b_value_upper[${H}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${ce}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(Q,H)=>`${`dot(a_data${H}, b_dequantized_values[${H}])`}`).join(" + ")};
              word_offset += ${8/f};
            }
            workgroupBarrier();
          }

          if (local_idx < ${y}) {
            var output_value: ${X.type.value} = ${X.type.value}(0);
            for (var b = 0u; b < ${M}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${X.setByIndices(`${X.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${f};${d};${M};${y}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:h,dataType:c}],dispatchGroup:{x},programUniforms:S}),getShaderSource:O}},E6=(e,t)=>{MD(e.inputs,t),t.blockSize===32&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(SD(e.inputs,t)):e.compute(ED(e.inputs,t))},S6=e=>Qn(e)}),CD,$D,AD,ID,PD,kD,DD,OD,C6,fie=dt(()=>{en(),ln(),cn(),CD=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},$D=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`
            k = i32(${e.indicesGet("indices",r)}) - ${Lt("uniforms.pads",r,n)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${Lt("uniforms.x_shape",r,t)})) {
              break;
            }
            offset += k * i32(${Lt("uniforms.x_strides",r,t)});
        `;return`
          value = ${e.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${i}
            value = x[offset];
          }
      `},AD=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`
                k = i32(${e.indicesGet("indices",r)}) - ${Lt("uniforms.pads",r,n)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${Lt("uniforms.x_shape",r,t)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${Lt("uniforms.x_shape",r,t)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${Lt("uniforms.x_strides",r,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},ID=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`
                k = i32(${e.indicesGet("indices",r)}) - ${Lt("uniforms.pads",r,n)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${Lt("uniforms.x_shape",r,t)})) {
                  k = i32(${Lt("uniforms.x_shape",r,t)}) - 1;
                }
                offset += k * i32(${Lt("uniforms.x_strides",r,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},PD=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`
                k = i32(${e.indicesGet("indices",r)}) - ${Lt("uniforms.pads",r,n)};
                if (k < 0)  {
                  k += i32(${Lt("uniforms.x_shape",r,t)}]);
                }
                if (k >= i32(${Lt("uniforms.x_shape",r,t)})) {
                  k -= i32(${Lt("uniforms.x_shape",r,t)});
                }
                offset += k * i32(${Lt("uniforms.x_strides",r,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},kD=(e,t,n)=>{switch(n.mode){case 0:return $D(e,t,n.pads.length);case 1:return AD(e,t,n.pads.length);case 2:return ID(e,t,n.pads.length);case 3:return PD(e,t,n.pads.length);default:throw new Error("Invalid mode")}},DD=(e,t)=>{let n=We.padShape(e[0].dims.slice(),t.pads),i=e[0].dims,r=We.size(n),s=[{type:12,data:r},{type:6,data:t.pads}],a=e.length>=3&&e[2].data;t.mode===0&&s.push({type:a?e[2].dataType:1,data:t.value}),s.push(...Bt(e[0].dims,n));let o=["rank"],l=u=>{let c=Ot("output",e[0].dataType,n.length),f=Qe("x",e[0].dataType,i.length),d=f.type.value,h=kD(c,i.length,t),m=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&m.push({name:"constant_value",type:a?d:"f32"}),`
            ${u.registerUniforms(m).declareVariables(f,c)}
            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${c.offsetToIndices("global_idx")};

            var value = ${d}(0);
            ${h}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}${a}`,inputDependencies:o},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(We.size(n)/64)},programUniforms:s}),getShaderSource:l}},OD=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),i=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,r=e[0].dims.length,s=new Int32Array(2*r).fill(0);if(e.length>=4){let o=e[3].getBigInt64Array();for(let l=0;l<o.length;l++)s[Number(o[l])]=Number(n[l]),s[Number(o[l])+r]=Number(n[l+o.length])}else n.forEach((o,l)=>s[Number(l)]=Number(o));let a=[];return s.forEach(o=>a.push(o)),{mode:t.mode,value:i,pads:a}}else return t},C6=(e,t)=>{CD(e.inputs);let n=OD(e.inputs,t);e.compute(DD(e.inputs,n),{inputs:[0]})}}),lf,nv,iv,rv,sv,RD,ND,av,ov,$6,A6,lv,I6,P6,uv,k6,D6,O6,R6,pie=dt(()=>{Oa(),en(),ln(),cn(),lf=e=>{if(wi.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},nv=(e,t,n)=>{let i=t.format==="NHWC",r=e.dims.slice();i&&r.splice(1,0,r.pop());let s=Object.hasOwnProperty.call(t,"dilations"),a=t.kernelShape.slice(),o=t.strides.slice(),l=s?t.dilations.slice():[],u=t.pads.slice();mg.adjustPoolAttributes(n,r,a,o,l,u);let c=mg.computePoolOutputShape(n,r,o,l,a,u,t.autoPad),f=Object.assign({},t);s?Object.assign(f,{kernelShape:a,strides:o,pads:u,dilations:l,cacheKey:t.cacheKey}):Object.assign(f,{kernelShape:a,strides:o,pads:u,cacheKey:t.cacheKey});let d=c.slice();return d.push(d.splice(1,1)[0]),[f,i?d:c]},iv=(e,t)=>{let n=t.format==="NHWC",i=We.size(e),r=We.size(t.kernelShape),s=[{type:12,data:i},{type:12,data:r}],a=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let o=t.kernelShape[t.kernelShape.length-1],l=t.strides[t.strides.length-1],u=t.pads[t.pads.length/2-1],c=t.pads[t.pads.length-1],f=!!(u+c);s.push({type:12,data:o},{type:12,data:l},{type:12,data:u},{type:12,data:c}),a.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let d=!1;if(t.kernelShape.length===2){let h=t.kernelShape[t.kernelShape.length-2],m=t.strides[t.strides.length-2],y=t.pads[t.pads.length/2-2],M=t.pads[t.pads.length-2];d=!!(y+M),s.push({type:12,data:h},{type:12,data:m},{type:12,data:y},{type:12,data:M}),a.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[s,a,!0,f,d]}else{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let o=We.computeStrides(t.kernelShape);s.push({type:12,data:o},{type:12,data:t.pads},{type:12,data:t.strides}),a.push({name:"kernelStrides",type:"u32",length:o.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let l=t.pads.reduce((u,c)=>u+c);return[s,a,!!l,!1,!1]}},rv=(e,t,n,i,r,s,a,o,l,u,c,f)=>{let d=r.format==="NHWC",h=t.type.value,m=Ot("output",t.type.tensor,i);if(r.kernelShape.length<=2){let y="",M="",g="",_=n-(d?2:1);if(c?y=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${_}] < 0 || xIndices[${_}]
                      >= uniforms.x_shape[${_}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`:y=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`,r.kernelShape.length===2){let T=n-(d?3:2);f?M=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${T}] < 0 || xIndices[${T}] >= uniforms.x_shape[${T}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:M=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;
                `,g=`
              }
            `}return`
            ${e.registerUniforms(l).declareVariables(t,m)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${m.offsetToIndices("global_idx")};
              var xIndices = ${m.offsetToIndices("global_idx")};

              var value = ${h}(${o});
              var pad = 0;
              ${M}
              ${y}
              ${g}
              ${a}

              output[global_idx] = value;
            }`}else{if(d)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let y=r.kernelShape.length,M=r.pads.length,g="";return u?g=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${s}
              }`:g=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${s}
            `,`
            ${e.registerUniforms(l).declareVariables(t,m)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${m.offsetToIndices("global_idx")};
              var xIndices = ${m.offsetToIndices("global_idx")};

              var offsets: array<u32, ${y}>;

              var value = ${h}(${o});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${y-1}u; j++) {
                  offsets[j] = offset / ${Lt("uniforms.kernelStrides","j",y)};
                  offset -= offsets[j] * ${Lt("uniforms.kernelStrides","j",y)};
                }
                offsets[${y-1}] = offset;

                isPad = false;
                for (var j = ${n-y}u; j < ${n}u; j++) {
                  xIndices[j] = indices[j] * ${Lt("uniforms.strides",`j - ${n-y}u`,y)}
                    + offsets[j - ${n-y}u] - ${Lt("uniforms.pads","j - 2u",M)};
                  ${g}
              }
              ${a}

              output[global_idx] = value;
            }`}},sv=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,RD=e=>`${sv(e)};${e.countIncludePad}`,ND=e=>`${sv(e)};${e.storageOrder};${e.dilations}`,av=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),ov=(e,t,n,i)=>{let[r,s]=nv(t,i,n),a=Qe("x",t.dataType,t.dims.length),o=a.type.value,l="value += x_val;",u="";r.countIncludePad?u+=`value /= ${o}(uniforms.kernelSize);`:u+=`value /= ${o}(i32(uniforms.kernelSize) - pad);`;let[c,f,d,h,m]=iv(s,r);c.push(...Bt(t.dims,s));let y=["rank"];return{name:e,shaderCache:{hint:`${i.cacheKey};${d};${h};${m}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(We.size(s)/64)},programUniforms:c}),getShaderSource:M=>rv(M,a,t.dims.length,s.length,r,l,u,0,f,d,h,m)}},$6=e=>{let t=e.count_include_pad!==0,n=av(e);if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let i={countIncludePad:t,...n,cacheKey:""};return{...i,cacheKey:RD(i)}},A6=(e,t)=>{lf(e.inputs),e.compute(ov("AveragePool",e.inputs[0],!1,t))},lv={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},I6=e=>{let t=e.format;return{format:t,...lv,cacheKey:t}},P6=(e,t)=>{lf(e.inputs),e.compute(ov("GlobalAveragePool",e.inputs[0],!0,t))},uv=(e,t,n,i)=>{let[r,s]=nv(t,i,n),a=`
      value = max(x_val, value);
    `,o="",l=Qe("x",t.dataType,t.dims.length),u=["rank"],[c,f,d,h,m]=iv(s,r);return c.push(...Bt(t.dims,s)),{name:e,shaderCache:{hint:`${i.cacheKey};${d};${h};${m}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(We.size(s)/64)},programUniforms:c}),getShaderSource:y=>rv(y,l,t.dims.length,s.length,r,a,o,t.dataType===10?-65504:-1e5,f,d,h,m)}},k6=(e,t)=>{lf(e.inputs),e.compute(uv("MaxPool",e.inputs[0],!1,t))},D6=e=>{let t=e.storage_order,n=e.dilations,i=av(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let r={storageOrder:t,dilations:n,...i,cacheKey:""};return{...r,cacheKey:ND(r)}},O6=e=>{let t=e.format;return{format:t,...lv,cacheKey:t}},R6=(e,t)=>{lf(e.inputs),e.compute(uv("GlobalMaxPool",e.inputs[0],!0,t))}}),LD,zD,N6,L6,hie=dt(()=>{en(),ln(),Ui(),cn(),LD=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(e.length===3&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[0].dataType===6&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map((n,i)=>n===e[2].dims[i]).reduce((n,i)=>n&&i,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map((r,s)=>s===t.axis||r===e[0].dims[s]).reduce((r,s)=>r&&s,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=e[0].dims[t.axis],i=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/i)||t.blockSize>Math.ceil(n/(i-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},zD=(e,t)=>{let n=We.normalizeAxis(t.axis,e[0].dims.length),i=e[0].dataType,r=i===3,s=e[0].dims,a=e[1].dataType,o=We.size(s),l=i===3||i===2,u=l?[Math.ceil(We.size(e[0].dims)/4)]:e[0].dims,c=e[1].dims,f=e.length>2?e[2]:void 0,d=f?l?[Math.ceil(We.size(f.dims)/4)]:f.dims:void 0,h=c.length===0||c.length===1&&c[0]===1,m=h===!1&&c.length===1,y=zi(o),M=h&&(!l||y===4),g=M?y:1,_=M&&!l?y:1,T=Qe("input",l?12:i,u.length,_),x=Qe("scale",a,c.length),S=f?Qe("zero_point",l?12:i,d.length):void 0,$=Ot("output",a,s.length,g),C=[T,x];S&&C.push(S);let P=[u,c];f&&P.push(d);let O=[{type:12,data:o/g},{type:12,data:n},{type:12,data:t.blockSize},...Bt(...P,s)],R=G=>{let W=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${G.registerUniforms(W).declareVariables(...C,$)}
      ${G.mainStart()}
          ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${$.offsetToIndices("global_idx")};

          // Set input x
          ${l?`
            let input = ${T.getByOffset("global_idx / 4")};
            let x_vec = ${r?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${g===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${T.getByOffset("global_idx")};`};

          // Set scale input
          ${h?`let scale_value= ${x.getByOffset("0")}`:m?`
            let scale_index = ${$.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${x.getByOffset("scale_index")};`:`
            var scale_indices: ${x.type.indices} = output_indices;
            let index = ${x.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${x.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${x.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${S?h?l?`
                let zero_point_input = ${S.getByOffset("0")};
                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${S.getByOffset("0")}`:m?l?`
                let zero_point_index = ${$.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${S.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${$.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${S.getByOffset("zero_point_index")};`:l?`
                let zero_point_offset = ${x.indicesToOffset("scale_indices")};
                let zero_point_input = ${S.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${S.getByIndices("scale_indices")};`:`let zero_point_value = ${l?r?"i32":"u32":T.type.value}(0);`};
      // Compute and write output
      ${$.setByOffset("global_idx",`${$.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:S?["rank","rank","rank"]:["rank","rank"]},getShaderSource:R,getRunData:()=>({outputs:[{dims:s,dataType:a}],dispatchGroup:{x:Math.ceil(o/g/64),y:1,z:1},programUniforms:O})}},N6=(e,t)=>{LD(e.inputs,t),e.compute(zD(e.inputs,t))},L6=e=>Qn({axis:e.axis,blockSize:e.blockSize})}),FD,BD,z6,mie=dt(()=>{Oa(),en(),cn(),FD=(e,t,n)=>{let i=e===t,r=e<t&&n<0,s=e>t&&n>0;if(i||r||s)throw new Error("Range these inputs' contents are invalid.")},BD=(e,t,n,i)=>{let r=Math.abs(Math.ceil((t-e)/n)),s=[r],a=r,o=[{type:12,data:a},{type:i,data:e},{type:i,data:n},...Bt(s)],l=u=>{let c=Ot("output",i,s.length),f=c.type.value,d=[{name:"outputSize",type:"u32"},{name:"start",type:f},{name:"delta",type:f}];return`
        ${u.registerUniforms(d).declareVariables(c)}
        ${u.mainStart()}
        ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${f}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${i}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:s,dataType:i}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:o})}},z6=e=>{let t=0,n=0,i=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],i=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],i=e.inputs[2].getFloat32Array()[0]),wi.webgpu.validateInputContent&&FD(t,n,i),e.compute(BD(t,n,i,e.inputs[0].dataType),{inputs:[]})}}),UD,cv,dv,VD,F6,B6,gie=dt(()=>{en(),ln(),Ui(),cn(),UD=(e,t,n,i)=>{if(e!=="none"&&i!=="i32"&&i!=="u32"&&i!=="f32")throw new Error(`Input ${i} is not supported with reduction ${e}.`);let r=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,s=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(e){case"none":return`${t}=${n};`;case"add":return i==="i32"||i==="u32"?`atomicAdd(&${t}, bitcast<${i}>(${n}));`:`
              ${r}bitcast<${i}>(oldValue) + (${n})${s}`;case"max":return i==="i32"||i==="u32"?`atomicMax(&${t}, bitcast<${i}>(${n}));`:`
                ${r}max(bitcast<f32>(oldValue), (${n}))${s}`;case"min":return i==="i32"||i==="u32"?`atomicMin(&${t}, bitcast<${i}>(${n}));`:`${r}min(bitcast<${i}>(oldValue), (${n}))${s}`;case"mul":return`${r}(bitcast<${i}>(oldValue) * (${n}))${s}`;default:throw new Error(`Reduction ${e} is not supported.`)}},cv=(e,t)=>`${e===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[${t?"i - indices_start":"i"}];
    let dim_value = uniforms.output_shape[${t?"i - indices_start":"i"} + uniforms.last_index_dimension];`}
    
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));`,dv=(e,t,n)=>`for (var i = 0u; i < uniforms.num_updates_elements; i++) {
        let value = updates[uniforms.num_updates_elements * ${n?"global_idx":"idx"} + i];
        ${UD(e.reduction,"output[data_offset + i]","value",t)}
      }`,VD=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n,s=1,a=Math.ceil(We.size(i)/s),o=i[i.length-1],l=We.sizeFromDimension(n,o),u=We.sizeFromDimension(i,0)/o,c=[{type:12,data:a},{type:12,data:o},{type:12,data:l},...Bt(e[1].dims,e[2].dims,r)],f=d=>{let h=Qe("indices",e[1].dataType,e[1].dims.length),m=Qe("updates",e[2].dataType,e[2].dims.length,s),y=t.reduction!=="none"&&t.reduction!==""?hV("output",e[0].dataType,r.length):Ot("output",e[0].dataType,r.length,s);return`
      ${d.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(h,m,y)}
      ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${t.reduction==="none"}) {
    for (var i = 0; i < ${u}; i = i + 1) {
      for (var j = i + 1; j < ${u}; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  if (${t.reduction==="none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    // Process each index-update pair individually when duplicates exist
    for (var idx = 0u; idx < ${u}u; idx++) {
      var data_offset = 0u;
      for (var i = 0u; i < uniforms.last_index_dimension; i++) {
        var index = i32(indices[idx * uniforms.last_index_dimension + i].x);
        ${cv(n.length,!1)}
      }
      ${dv(t,y.type.value,!1)}
    }
    return;
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  var indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${cv(n.length,!0)}
  }
  ${dv(t,y.type.value,!0)}
  }`};return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:c}),getShaderSource:f}},F6=e=>Qn({reduction:e.reduction}),B6=(e,t)=>{e.compute(VD(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}}),GD,jD,WD,fv,HD,qD,KD,JD,YD,XD,QD,ZD,pv,eO,tO,nO,iO,rO,U6,V6,_ie=dt(()=>{en(),ln(),Ui(),cn(),GD=(e,t)=>{if(e.every(n=>n>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},jD=(e,t,n)=>{t.every(r=>r>=0&&r<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let i=new Array(n).fill(1);return t.forEach((r,s)=>i[r]=e[s]),i},WD=(e,t,n,i,r,s)=>{let[a,o,l]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],u=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach(c=>s.push(c));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&e.length>o&&e[o].dims.length===1&&e[o].dims[0]>0){if(e[o].getFloat32Array().forEach(c=>i.push(c)),i.length!==0&&i.length!==u&&n>=18&&i.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");GD(i,t),t.axes.length>0&&jD(i,t.axes,u).forEach((c,f)=>i[f]=c)}if(l>0&&e.length>l&&e[l].dims.length===1&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach(c=>r.push(Number(c))),r.length!==0&&r.length!==u&&n>=18&&r.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(i.length!==0&&i.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(r.length!==0&&r.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof i<"u"&&typeof r<"u"&&i.length>0&&r.length>u)throw new Error("Resize requires only of scales or sizes to be specified")},fv=(e,t,n,i)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${e}) * (${t});
  let whole = ${i}(big / (${n}));
  let fract = ${i}(big % (${n})) / ${i}(${n});
  return whole + fract;
`,HD=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${t}(xResized) / ${t}(xScale);
          } else {
            ${fv("xResized","lengthOriginal","lengthResized",t)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${fv("xResized","lengthOriginal - 1","lengthResized - 1",t)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +
                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /
                        ${t}(lengthResized - 1);
                  } else {
                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);
                  const adjustment = ${t}(lengthResized) / outputWidth;
                  const center = ${t}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",qD=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",KD=(e,t,n)=>{let i=new Array(n).fill(0).concat(new Array(n).fill(1)),r=e.length===0?i:e.slice();return t.length>0?(t.forEach((s,a)=>{i[s]=r[a],i[a+n]=r[t.length+a]}),i):r},JD=(e,t,n,i)=>{let r=[];if(n.length>0)if(i.length>0){if(e.forEach(s=>r.push(s)),Math.max(...i)>e.length)throw new Error("axes is out of bound");i.forEach((s,a)=>r[s]=n[a])}else n.forEach(s=>r.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");r=e.map((s,a)=>Math.round(s*t[a]))}return r},YD=(e,t,n)=>{let i=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(s=>t[s]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(s=>t[s]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let r=e.slice();return n.axes.length>0?(n.axes.forEach(s=>t[s]=i),n.axes.forEach(s=>r[s]=Math.round(e[s]*t[s]))):(t.fill(i,0,t.length),r.forEach((s,a)=>r[a]=Math.round(s*t[a]))),r},XD=(e,t,n,i,r)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {
      var original_indices: array<${e.type.value}, ${n.length}>;
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var scale = ${Lt("uniforms.scales","i",i)};
        var roi_low = ${Lt("uniforms.roi","i",r)};
        var roi_hi = ${Lt("uniforms.roi",`i + ${t.length}`,r)};
        if (scale == 1.0) {
          original_indices[i] = ${e.type.value}(output_index);
        } else {
          var input_shape_i = ${Lt("uniforms.input_shape","i",t.length)};
          var output_shape_i = ${Lt("uniforms.output_shape","i",n.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,QD=(e,t,n,i,r,s,a)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
      var input_indices: ${e.type.indices};
      for (var i:u32 = 0; i < ${i.length}; i++) {
        var output_index = ${t.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${Lt("uniforms.scales","i",r)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${Lt("uniforms.roi","i",s)};
          var roi_hi = ${Lt("uniforms.roi",`i + ${n.length}`,s)};
          var input_shape_i = ${Lt("uniforms.input_shape","i",n.length)};
          var output_shape_i = ${Lt("uniforms.output_shape","i",i.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${e.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,ZD=(e,t)=>`
    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var input_index = ${e.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${Lt("uniforms.input_shape","i",t.length)}) {
          return false;
        }
      }
      return true;
    }`,pv=(e,t,n,i)=>e.rank>i?`
    ${e.indicesSet("input_indices",t,"channel")};
    ${e.indicesSet("input_indices",n,"batch")};
`:"",eO=(e,t,n,i,r)=>{let[s,a,o,l]=n.length===2?[-1,0,1,-1]:[0,2,3,1],u=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${u} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",a,`max(0, min(row, ${n[a]} - 1))`)};
      ${e.indicesSet("input_indices",o,`max(0, min(col, ${n[o]} - 1))`)};
      ${pv(e,l,s,2)}
      return ${e.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${u} = originalIndices[${a}];
      var col:${u} = originalIndices[${o}];
      ${i?`if (row < 0 || row > (${n[a]} - 1) || col < 0 || col > (${n[o]} - 1)) {
        return ${r};
      }`:""};
      row = max(0, min(row, ${n[a]} - 1));
      col = max(0, min(col, ${n[o]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${n.length>2?`u32(originalIndices[${l}])`:"0"};
      var batch: u32 =  ${n.length>2?`u32(originalIndices[${s}])`:"0"};
      var x11: ${u} = getInputValue(batch, channel, row1, col1);
      var x12: ${u} = getInputValue(batch, channel, row1, col2);
      var x21: ${u} = getInputValue(batch, channel, row2, col1);
      var x22: ${u} = getInputValue(batch, channel, row2, col2);
      var dx1: ${u} = abs(row - ${u}(row1));
      var dx2: ${u} = abs(${u}(row2) - row);
      var dy1: ${u} = abs(col - ${u}(col1));
      var dy2: ${u} = abs(${u}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},tO=(e,t,n,i,r,s,a,o,l,u)=>{let c=n.length===2,[f,d]=c?[0,1]:[2,3],h=e.type.value,m=y=>{let M=y===f?"row":"col";return`
      fn ${M}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${h} {
        var output_index = ${t.indicesGet("output_indices",y)};
        var originalIdx: ${h} = getOriginalCoordinateFromResizedCoordinate(output_index, ${r[y]},
        ${i[y]}, ${n[y]}, ${s[y]}, ${s[y]} + ${n.length});
        var fractOriginalIdx: ${h} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${o} && (originalIdx < 0 || originalIdx > (${n[y]} - 1))) {
          return ${l};
        }
        var data: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${M}: ${h} = originalIdx + ${h}(i);
          if (${M} < 0 || ${M} >= ${n[y]}) {
            ${u?`coefs[i + 1] = 0.0;
                        continue;`:o?`return ${l};`:`${M} = max(0, min(${M}, ${n[y]} - 1));`};
          }
        var input_indices_copy: ${e.type.indices} = input_indices;
          ${e.indicesSet("input_indices_copy",y,`u32(${M})`)};
          data[i + 1] = ${y===f?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${m(f)};
    ${m(d)};
  fn getCubicInterpolationCoefs(s: ${h}) -> array<${h}, 4> {
    var absS = abs(s);
    var coeffs: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${h} = 1.0 - absS;
    var twoMinusAbsS: ${h} = 2.0 - absS;
    var onePlusAbsS: ${h} = 1.0 + absS;
    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};
    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;
    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${h}, 4>, coefs: array<${h}, 4>) -> ${h} {
    var coefsSum: ${h} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${h} {
    var input_indices: ${e.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},nO=(e,t,n,i,r)=>{let[s,a,o,l,u]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],c=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${c} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",a,`max(0, min(depth, ${n[a]} - 1))`)};
      ${e.indicesSet("input_indices",o,`max(0, min(height, ${n[o]} - 1))`)};
      ${e.indicesSet("input_indices",l,`max(0, min(width, ${n[l]} - 1))`)};
      ${pv(e,u,s,3)}
      return ${e.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${c} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${c} = originalIndices[${a}];
      var height:${c} = originalIndices[${o}];
      var width:${c} = originalIndices[${l}];
      ${i?`if (depth < 0 || depth > (${n[a]} - 1) || height < 0 || height > (${n[o]} - 1) || width < 0 || (width > ${n[l]} - 1)) {
      return ${r};
        }`:""};

    depth = max(0, min(depth, ${n[a]} - 1));
      height = max(0, min(height, ${n[o]} - 1));
      width = max(0, min(width, ${n[l]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${n.length>3?`u32(originalIndices[${u}])`:"0"};
      var batch: u32 =  ${n.length>3?`u32(originalIndices[${s}])`:"0"};

      var x111: ${c} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${c} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${c} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${c} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${c} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${c} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${c} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${c} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${c} = abs(depth - ${c}(depth1));
      var dx2: ${c} = abs(${c}(depth2) - depth);
      var dy1: ${c} = abs(height - ${c}(height1));
      var dy2: ${c} = abs(${c}(height2) - height);
      var dz1: ${c} = abs(width - ${c}(width1));
      var dz2: ${c} = abs(${c}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},iO=(e,t,n,i,r,s)=>{let a=e.dims,o=KD(s,t.axes,a.length),l=JD(a,i,r,t.axes),u=i.slice();i.length===0&&(u=a.map((_,T)=>_===0?1:l[T]/_),t.keepAspectRatioPolicy!=="stretch"&&(l=YD(a,u,t)));let c=Ot("output",e.dataType,l.length),f=Qe("input",e.dataType,a.length),d=We.size(l),h=a.length===l.length&&a.every((_,T)=>_===l[T]),m=t.coordinateTransformMode==="tf_crop_and_resize",y=t.extrapolationValue,M=f.type.value,g=_=>`
      ${h?"":`
      ${HD(t.coordinateTransformMode,M)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${ZD(f,a)};
              ${qD(t.nearestMode,n,M)};
              ${QD(f,c,a,l,u.length,o.length,m)};
              `;case"linear":return`
              ${XD(c,a,l,u.length,o.length)};
              ${(()=>{if(a.length===2||a.length===4)return`${eO(f,c,a,m,y)}`;if(a.length===3||a.length===5)return`${nO(f,c,a,m,y)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(a.length===2||a.length===4)return`${tO(f,c,a,l,u,o,t.cubicCoeffA,m,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${_.registerUniform("output_size","u32").registerUniform("scales","f32",u.length).registerUniform("roi","f32",o.length).declareVariables(f,c)}
      ${_.mainStart()}
        ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${h?"output[global_idx] = input[global_idx];":`
        let output_indices = ${c.offsetToIndices("global_idx")};
        var input_indices: ${f.type.indices};
        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${f.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${t.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${a.length===2||a.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${u.length>0?t.mode==="cubic"?u:u.length:""}|${r.length>0?r:""}|${o.length>0?o:""}|${h}|${t.mode==="nearest"?a.length:a}`,inputDependencies:["rank"]},getShaderSource:g,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},{type:1,data:u},{type:1,data:o},...Bt(a,l)]})}},rO=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},U6=(e,t)=>{let n=[],i=[],r=[],s=rO(e);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");WD(e.inputs,t,s,n,i,r),e.compute(iO(e.inputs[0],t,s,n,i,r),{inputs:[0]})},V6=e=>{let t=e.antialias,n=e.axes,i=e.coordinateTransformMode,r=e.cubicCoeffA,s=e.excludeOutside!==0,a=e.extrapolationValue,o=e.keepAspectRatioPolicy,l=e.mode,u=e.nearestMode===""?"simple":e.nearestMode;return Qn({antialias:t,axes:n,coordinateTransformMode:i,cubicCoeffA:r,excludeOutside:s,extrapolationValue:a,keepAspectRatioPolicy:o,mode:l,nearestMode:u})}}),sO,aO,G6,yie=dt(()=>{en(),ln(),cn(),sO=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],i=e[2];if(t.dataType!==n.dataType||t.dataType!==i.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Skip must be 2D or 3D");let r=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==r)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(i.dims.length!==1)throw new Error("Gamma must be 1D");if(i.dims[i.dims.length-1]!==r)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let a=e[3];if(a.dims.length!==1)throw new Error("Beta must be 1D");if(a.dims[a.dims.length-1]!==r)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let a=e[4];if(a.dims.length!==1)throw new Error("Bias must be 1D");if(a.dims[a.dims.length-1]!==r)throw new Error("Bias must have the same hidden size as input")}},aO=(e,t,n,i)=>{let r=t.simplified,s=e[0].dims,a=We.size(s),o=s,l=a,u=s.slice(-1)[0],c=i?s.slice(0,-1).concat(1):[],f=!r&&e.length>3,d=e.length>4,h=i&&n>1,m=i&&n>2,y=n>3,M=64,g=zi(u),_=[{type:12,data:l},{type:12,data:g},{type:12,data:u},{type:1,data:t.epsilon}],T=S=>{let $=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],C=[Qe("x",e[0].dataType,e[0].dims,g),Qe("skip",e[1].dataType,e[1].dims,g),Qe("gamma",e[2].dataType,e[2].dims,g)];f&&C.push(Qe("beta",e[3].dataType,e[3].dims,g)),d&&C.push(Qe("bias",e[4].dataType,e[4].dims,g)),C.push(Ot("output",e[0].dataType,o,g)),h&&C.push(Ot("mean_output",1,c)),m&&C.push(Ot("inv_std_output",1,c)),y&&C.push(Ot("input_skip_bias_sum",e[0].dataType,o,g));let P=hr(e[0].dataType),O=hr(1,g);return`

      ${S.registerUniforms($).declareVariables(...C)}
      var<workgroup> sum_shared : array<${O}, ${M}>;
      var<workgroup> sum_squared_shared : array<${O}, ${M}>;

      ${S.mainStart([M,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${M};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${M};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${M-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${d?"bias[offset1d + i]":P+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${y?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${nd(P,g,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${M};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${jl("sum",g)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${jl("square_sum",g)} / f32(uniforms.hidden_size) ${r?"":"- mean * mean"} + uniforms.epsilon);
        ${h?"mean_output[global_idx] = mean;":""}
        ${m?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${r?"":`- ${P}(mean)`}) *
            ${P}(inv_std_dev) * gamma[offset1d + i]
            ${f?"+ beta[offset1d + i]":""};
        }
      }`},x=[{dims:o,dataType:e[0].dataType}];return n>1&&x.push({dims:c,dataType:1}),n>2&&x.push({dims:c,dataType:1}),n>3&&x.push({dims:s,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${g};${h};${m};${y}`,inputDependencies:e.map((S,$)=>"type")},getShaderSource:T,getRunData:()=>({outputs:x,dispatchGroup:{x:Math.ceil(l/u)},programUniforms:_})}},G6=(e,t)=>{sO(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(aO(e.inputs,t,e.outputCount,!1),{outputs:n})}}),oO,uf,lO,hv,uO,cO,j6,W6,vie=dt(()=>{en(),ln(),Ui(),cn(),oO=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((n,i)=>{if(e[i+1].dataType!==6&&e[i+1].dataType!==7)throw new Error(`Input ${i} must be an array of int32 or int64`)})},uf=(e,t)=>{let n=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(i=>n.push(Number(i)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(i=>n.push(Number(i)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return n},lO=(e,t)=>{if(e.length>1){let n=uf(e,1),i=uf(e,2),r=uf(e,3);return r.length===0&&(r=[...Array(e[0].dims.length).keys()]),Qn({starts:n,ends:i,axes:r})}else return t},hv=(e,t,n,i,r)=>{let s=e;return e<0&&(s+=n[i[t]]),r[t]<0?Math.max(0,Math.min(s,n[i[t]]-1)):Math.max(0,Math.min(s,n[i[t]]))},uO=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
          var input_indices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${n.length}; i >= 0; i--) {
            let input_shape_i = ${Lt("uniforms.input_shape","i",n.length)};
            let steps_i = ${Lt("uniforms.steps","i",n.length)};
            let signs_i = ${Lt("uniforms.signs","i",n.length)};
            let starts_i = ${Lt("uniforms.starts","i",n.length)};
            var output_index = ${t.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${e.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,cO=(e,t)=>{let n=e[0].dims,i=We.size(n),r=t.axes.length>0?We.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],s=uf(e,4);s.forEach(g=>g!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(r.length).fill(1));let a=t.starts.map((g,_)=>hv(g,_,n,r,s)),o=t.ends.map((g,_)=>hv(g,_,n,r,s));if(r.length!==a.length||r.length!==o.length)throw new Error("start, ends and axes should have the same number of elements");if(r.length!==n.length)for(let g=0;g<n.length;++g)r.includes(g)||(a.splice(g,0,0),o.splice(g,0,n[g]),s.splice(g,0,1));let l=s.map(g=>Math.sign(g));s.forEach((g,_,T)=>{if(g<0){let x=(o[_]-a[_])/g,S=a[_],$=S+x*s[_];a[_]=$,o[_]=S,T[_]=-g}});let u=n.slice(0);r.forEach((g,_)=>{u[g]=Math.ceil((o[g]-a[g])/s[g])});let c={dims:u,dataType:e[0].dataType},f=Ot("output",e[0].dataType,u.length),d=Qe("input",e[0].dataType,e[0].dims.length),h=We.size(u),m=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:a.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:s.length}],y=[{type:12,data:h},{type:12,data:a},{type:6,data:l},{type:12,data:s},...Bt(e[0].dims,u)],M=g=>`
      ${g.registerUniforms(m).declareVariables(d,f)}
        ${uO(d,f,n)}
        ${g.mainStart()}
          ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${f.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${f.setByOffset("global_idx",d.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${l.length}_${a.length}_${s.length}`,inputDependencies:["rank"]},getShaderSource:M,getRunData:()=>({outputs:[c],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:y})}},j6=(e,t)=>{oO(e.inputs,t);let n=lO(e.inputs,t);e.compute(cO(e.inputs,n),{inputs:[0]})},W6=e=>{let t=e.starts,n=e.ends,i=e.axes;return Qn({starts:t,ends:n,axes:i})}}),dO,fO,H6,q6,wie=dt(()=>{en(),ln(),Ui(),Jl(),cn(),dO=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},fO=(e,t)=>{let n=e.inputs[0],i=n.dims,r=We.size(i),s=i.length,a=We.normalizeAxis(t.axis,s),o=a<i.length-1,l,u=[];o?(u=Array.from({length:s},(C,P)=>P),u[a]=s-1,u[s-1]=a,l=e.compute(Ms(n,u),{inputs:[n],outputs:[-1]})[0]):l=n;let c=l.dims,f=c[s-1],d=r/f,h=zi(f),m=f/h,y=64;d===1&&(y=256);let M=(C,P)=>P===4?`max(max(${C}.x, ${C}.y), max(${C}.z, ${C}.w))`:P===2?`max(${C}.x, ${C}.y)`:P===3?`max(max(${C}.x, ${C}.y), ${C}.z)`:C,g=Qe("x",l.dataType,l.dims,h),_=Ot("result",l.dataType,l.dims,h),T=g.type.value,x=hr(l.dataType)==="f32"?`var threadMax = ${T}(-3.402823e+38f);`:`var threadMax = ${T}(-65504.0h);`,S=C=>`
      var<workgroup> rowMaxShared : ${T};
      var<workgroup> rowSumShared : ${T};
      var<workgroup> threadShared : array<${T}, ${y}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${T} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${T}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${C.registerUniform("packedCols","i32").declareVariables(g,_)}
      ${C.mainStart(y)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${y};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${x}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${T}(${M("threadShared[0]",h)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${T}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${T}(${jl("threadShared[0]",h)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,$=e.compute({name:"Softmax",shaderCache:{hint:`${h};${y}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:c,dataType:l.dataType}],dispatchGroup:{x:d},programUniforms:[{type:6,data:m}]}),getShaderSource:S},{inputs:[l],outputs:[o?-1:0]})[0];o&&e.compute(Ms($,u),{inputs:[$]})},H6=(e,t)=>{dO(e.inputs),fO(e,t)},q6=e=>Qn({axis:e.axis})}),mv,pO,hO,mO,K6,bie=dt(()=>{en(),ln(),cn(),mv=e=>Array.from(e.getBigInt64Array(),Number),pO=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(mv(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},hO=(e,t)=>{let n=[];for(let i=0;i<e.length;++i)n.push(e[i]*t[i]);return n},mO=(e,t)=>{let n=e[0].dims,i=t??mv(e[1]),r=hO(n,i),s=We.size(r),a=e[0].dataType,o=Qe("input",a,n.length),l=Ot("output",a,r.length),u=c=>`
      const inputShape = ${o.indices(...n)};
      ${c.registerUniform("output_size","u32").declareVariables(o,l)}
      ${c.mainStart()}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${l.offsetToIndices("global_idx")};
      var input_indices: ${o.type.indices};
      for (var i = 0; i < ${n.length}; i++) {
        let input_dim_i = ${o.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;

        ${o.indicesSet("input_indices","i","input_dim_value")}
      }
      ${l.setByOffset("global_idx",o.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${i}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},...Bt(e[0].dims,r)]}),getShaderSource:u}},K6=e=>{pO(e.inputs),e.compute(mO(e.inputs),{inputs:[0]})}}),gO,_O,J6,xie=dt(()=>{en(),ln(),cn(),gO=(e,t,n,i,r)=>{let s=Ot("output_data",r,n.length,4),a=Qe("a_data",t[1].dataType,t[1].dims.length,4),o=Qe("b_data",t[2].dataType,t[2].dims.length,4),l=Qe("c_data",t[0].dataType,t[0].dims.length,4),u,c=(f,d,h)=>`select(${d}, ${f}, ${h})`;if(!i)u=s.setByOffset("global_idx",c(a.getByOffset("global_idx"),o.getByOffset("global_idx"),l.getByOffset("global_idx")));else{let f=(d,h,m="")=>{let y=`a_data[index_a${h}][component_a${h}]`,M=`b_data[index_b${h}][component_b${h}]`,g=`bool(c_data[index_c${h}] & (0xffu << (component_c${h} * 8)))`;return`
            let output_indices${h} = ${s.offsetToIndices(`global_idx * 4u + ${h}u`)};
            let offset_a${h} = ${a.broadcastedIndicesToOffset(`output_indices${h}`,s)};
            let offset_b${h} = ${o.broadcastedIndicesToOffset(`output_indices${h}`,s)};
            let offset_c${h} = ${l.broadcastedIndicesToOffset(`output_indices${h}`,s)};
            let index_a${h} = offset_a${h} / 4u;
            let index_b${h} = offset_b${h} / 4u;
            let index_c${h} = offset_c${h} / 4u;
            let component_a${h} = offset_a${h} % 4u;
            let component_b${h} = offset_b${h} % 4u;
            let component_c${h} = offset_c${h} % 4u;
            ${d}[${h}] = ${m}(${c(y,M,g)});
          `};r===9?u=`
            var data = vec4<u32>(0);
            ${f("data",0,"u32")}
            ${f("data",1,"u32")}
            ${f("data",2,"u32")}
            ${f("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:u=`
            ${f("output_data[global_idx]",0)}
            ${f("output_data[global_idx]",1)}
            ${f("output_data[global_idx]",2)}
            ${f("output_data[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(l,a,o,s)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${u}
      }`},_O=e=>{let t=e[1].dims,n=e[2].dims,i=e[0].dims,r=e[1].dataType,s=!(We.areEqual(t,n)&&We.areEqual(n,i)),a=t,o=We.size(t);if(s){let u=Ed.calcShape(Ed.calcShape(t,n,!1),i,!1);if(!u)throw new Error("Can't perform where op on the given tensors");a=u,o=We.size(a)}let l=Math.ceil(o/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:u=>gO(u,e,a,s,r),getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:Math.ceil(o/64/4)},programUniforms:[{type:12,data:l},...Bt(i,t,n,a)]})}},J6=e=>{e.compute(_O(e.inputs))}}),Y6,Tie=dt(()=>{Lne(),Zx(),zne(),Fne(),Bne(),Une(),Vne(),qne(),Jne(),Yne(),Xne(),Qne(),Zne(),eie(),tie(),nie(),iie(),rie(),sie(),aie(),oie(),lie(),uie(),cie(),die(),m6(),fie(),pie(),hie(),mie(),gie(),Qx(),_ie(),w6(),yie(),vie(),wie(),y6(),bie(),Jl(),eT(),xie(),Y6=new Map([["Abs",[GV]],["Acos",[jV]],["Acosh",[WV]],["Add",[EG]],["ArgMax",[FV,Xb]],["ArgMin",[zV,Xb]],["Asin",[HV]],["Asinh",[qV]],["Atan",[KV]],["Atanh",[JV]],["Attention",[BV]],["AveragePool",[A6,$6]],["BatchNormalization",[UV]],["BiasAdd",[VV]],["BiasSplitGelu",[MG]],["Cast",[XV,YV]],["Ceil",[ZV]],["Clip",[QV]],["Concat",[RG,NG]],["Conv",[i1,n1]],["ConvTranspose",[HG,WG]],["Cos",[eG]],["Cosh",[tG]],["CumSum",[qG,KG]],["DepthToSpace",[JG,YG]],["DequantizeLinear",[N6,L6]],["Div",[SG]],["Einsum",[XG,QG]],["Elu",[nG,kf]],["Equal",[CG]],["Erf",[iG]],["Exp",[rG]],["Expand",[ZG]],["FastGelu",[e6]],["Floor",[sG]],["FusedConv",[i1,n1]],["Gather",[n6,t6]],["GatherElements",[l6,o6]],["GatherBlockQuantized",[s6,a6]],["GatherND",[i6,r6]],["Gelu",[aG]],["Gemm",[c6,u6]],["GlobalAveragePool",[P6,I6]],["GlobalMaxPool",[R6,O6]],["Greater",[PG]],["GreaterOrEqual",[DG]],["GridSample",[d6,f6]],["GroupQueryAttention",[b6]],["HardSigmoid",[hG,pG]],["InstanceNormalization",[x6]],["LayerNormalization",[T6]],["LeakyRelu",[oG,kf]],["Less",[kG]],["LessOrEqual",[OG]],["Log",[xG]],["MatMul",[M6]],["MatMulNBits",[E6,S6]],["MaxPool",[k6,D6]],["Mul",[$G]],["MultiHeadAttention",[h6,p6]],["Neg",[uG]],["Not",[lG]],["Pad",[C6]],["Pow",[AG]],["QuickGelu",[TG,kf]],["Range",[z6]],["Reciprocal",[cG]],["ReduceMin",[DV]],["ReduceMean",[$V]],["ReduceMax",[kV]],["ReduceSum",[RV]],["ReduceProd",[OV]],["ReduceL1",[AV]],["ReduceL2",[IV]],["ReduceLogSum",[LV]],["ReduceLogSumExp",[PV]],["ReduceSumSquare",[NV]],["Relu",[dG]],["Resize",[U6,V6]],["RotaryEmbedding",[v6]],["ScatterND",[B6,F6]],["Sigmoid",[fG]],["Sin",[mG]],["Sinh",[gG]],["Slice",[j6,W6]],["SkipLayerNormalization",[G6]],["Split",[g6,_6]],["Sqrt",[_G]],["Softmax",[H6,q6]],["Sub",[IG]],["Tan",[yG]],["Tanh",[vG]],["ThresholdedRelu",[bG,kf]],["Tile",[K6]],["Transpose",[gV,_V]],["Where",[J6]]])}),X6,Mie=dt(()=>{Oa(),Vo(),cn(),X6=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,i,r){Ia(e.programInfo.name);let s=this.backend.device,a=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let o=[];for(let u of t)o.push({binding:o.length,resource:{buffer:u.buffer}});for(let u of n)o.push({binding:o.length,resource:{buffer:u.buffer}});r&&o.push({binding:o.length,resource:r});let l=s.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:o,label:e.programInfo.name});if(this.backend.sessionStatus==="capturing"){let u={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:l,dispatchGroup:i};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(u)}a.setPipeline(e.computePipeline),a.setBindGroup(0,l),a.dispatchWorkgroups(...i),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Qs(e.programInfo.name)}dispose(){}build(e,t){Ia(e.name);let n=this.backend.device,i=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(u=>{n.features.has(u.feature)&&i.push(`enable ${u.extension};`)});let r=mV(t,this.backend.device.limits),s=e.getShaderSource(r),a=`${i.join(`
`)}
${r.additionalImplementations}
${s}`,o=n.createShaderModule({code:a,label:e.name});Nn("verbose",()=>`[WebGPU] ${e.name} shader code: ${a}`);let l=n.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:e.name});return Qs(e.name),{programInfo:e,computePipeline:l,uniformVariablesInfo:r.variablesInfo}}normalizeDispatchGroupSize(e){let t=typeof e=="number"?e:e.x,n=typeof e=="number"?1:e.y||1,i=typeof e=="number"?1:e.z||1,r=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=r&&n<=r&&i<=r)return[t,n,i];let s=t*n*i,a=Math.ceil(Math.sqrt(s));if(a>r){if(a=Math.ceil(Math.cbrt(s)),a>r)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[a,a,a]}else return[a,a,1]}}}),Q6={};Ud(Q6,{WebGpuBackend:()=>Z6});var yO,vO,wO,Z6,Eie=dt(()=>{Oa(),en(),Vo(),cV(),Rne(),Tie(),Mie(),yO=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let i=0;i<e.length;++i){let r=e[i].dataType;switch(t[i]){case"none":{n.push("");break}case"type":{n.push(`${r}`);break}case"rank":{let s=e[i].dims.length;n.push(`${r};${s}`);break}case"dims":{let s=e[i].dims.join(",");n.push(`${r};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[i]}`)}}return n.join("|")},vO=(e,t,n)=>{var r,s;let i=e.name;return(r=e.shaderCache)!=null&&r.hint&&(i+="["+e.shaderCache.hint+"]"),i+=":"+n+`:${yO(t,((s=e.shaderCache)==null?void 0:s.inputDependencies)??new Array(t.length).fill("dims"))}`,i},wO=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},Z6=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},r=s=>t.features.has(s)&&n.push(s)&&!0;r("chromium-experimental-timestamp-query-inside-passes")||r("timestamp-query"),r("shader-f16"),r("subgroups"),this.device=await t.requestDevice(i),this.adapterInfo=new wO(t.info||await t.requestAdapterInfo()),this.gpuDataManager=pV(this),this.programManager=new X6(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Kx(e.logLevel,!!e.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};this.queryType==="at-passes"&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Ia(),this.endComputePass();let e;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),e=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&e.mapAsync(GPUMapMode.READ).then(()=>{var i;let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let r=0;r<t.length/2;r++){let s=n[r],a=s.kernelId,o=this.kernels.get(a),l=o.kernelType,u=o.kernelName,c=s.programName,f=s.inputTensorViews,d=s.outputTensorViews,h=t[r*2],m=t[r*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=h);let y=Number(h-this.queryTimeBase),M=Number(m-this.queryTimeBase);if(!Number.isSafeInteger(y)||!Number.isSafeInteger(M))throw new RangeError("incorrect timestamp range");if((i=this.env.webgpu.profiling)!=null&&i.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:f.map(g=>({dims:g.dims,dataType:Eo(g.dataType)})),outputsMetadata:d.map(g=>({dims:g.dims,dataType:Eo(g.dataType)})),kernelId:a,kernelType:l,kernelName:u,programName:c,startTime:y,endTime:M});else{let g="";f.forEach((T,x)=>{g+=`input[${x}]: [${T.dims}] | ${Eo(T.dataType)}, `});let _="";d.forEach((T,x)=>{_+=`output[${x}]: [${T.dims}] | ${Eo(T.dataType)}, `}),console.log(`[profiling] kernel "${a}|${l}|${u}|${c}" ${g}${_}execution time: ${M-y} ns`)}gp("GPU",`${c}::${h}::${m}`)}e.unmap(),this.pendingQueries.delete(e)}),Qs()}run(e,t,n,i,r,s){Ia(e.name);let a=[];for(let _=0;_<t.length;++_){let T=t[_].data;if(T===0)continue;let x=this.gpuDataManager.get(T);if(!x)throw new Error(`no GPU data for input: ${T}`);a.push(x)}let{outputs:o,dispatchGroup:l,programUniforms:u}=e.getRunData(t),c=n.length===0?o.map((_,T)=>T):n;if(c.length!==o.length)throw new Error(`Output size ${c.length} must be equal to ${o.length}.`);let f=[],d=[];for(let _=0;_<o.length;++_){if(!Number.isInteger(c[_])||c[_]<-3||c[_]>=s)throw new Error(`Invalid output index: ${c[_]}`);if(c[_]===-3)continue;let T=c[_]===-1,x=c[_]===-2,S=T||x?r(o[_].dataType,o[_].dims):i(c[_],o[_].dataType,o[_].dims);if(f.push(S),S.data===0)continue;let $=this.gpuDataManager.get(S.data);if(!$)throw new Error(`no GPU data for output: ${S.data}`);if(T&&this.temporaryData.push($),x){let C=this.kernelPersistentData.get(this.currentKernelId);C||(C=[],this.kernelPersistentData.set(this.currentKernelId,C)),C.push($)}d.push($)}if(a.length!==t.length||d.length!==f.length){if(d.length===0)return Qs(e.name),f;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let h;if(u){let _=0,T=[];u.forEach(C=>{let P=typeof C.data=="number"?[C.data]:C.data;if(P.length===0)return;let O=C.type===10?2:4,R,G;C.type===10?(G=P.length>4?16:P.length>2?8:P.length*O,R=P.length>4?16:O*P.length):(G=P.length<=2?P.length*O:16,R=16),_=Math.ceil(_/G)*G,T.push(_);let W=C.type===10?8:4;_+=P.length>4?Math.ceil(P.length/W)*R:P.length*O});let x=16;_=Math.ceil(_/x)*x;let S=new ArrayBuffer(_);u.forEach((C,P)=>{let O=T[P],R=typeof C.data=="number"?[C.data]:C.data;if(C.type===6)new Int32Array(S,O,R.length).set(R);else if(C.type===12)new Uint32Array(S,O,R.length).set(R);else if(C.type===10)new Uint16Array(S,O,R.length).set(R);else if(C.type===1)new Float32Array(S,O,R.length).set(R);else throw new Error(`Unsupported uniform type: ${Eo(C.type)}`)});let $=this.gpuDataManager.create(_,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer($.buffer,0,S,0,_),this.gpuDataManager.release($.id),h={offset:0,size:_,buffer:$.buffer}}let m=this.programManager.normalizeDispatchGroupSize(l),y=m[1]===1&&m[2]===1,M=vO(e,t,y),g=this.programManager.getArtifact(M);if(g||(g=this.programManager.build(e,m),this.programManager.setArtifact(M,g),Nn("info",()=>`[artifact] key: ${M}, programName: ${e.name}`)),u&&g.uniformVariablesInfo){if(u.length!==g.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${g.uniformVariablesInfo.length}, got ${u.length} in program "${g.programInfo.name}".`);for(let _=0;_<u.length;_++){let T=u[_],x=T.type,S=typeof T.data=="number"?1:T.data.length,[$,C]=g.uniformVariablesInfo[_];if(x!==$||S!==C)throw new Error(`Uniform variable ${_} mismatch: expect type ${$} with size ${C}, got type ${x} with size ${S} in program "${g.programInfo.name}".`)}}if(Nn("info",()=>`[ProgramManager] run "${e.name}" (key=${M}) with ${m[0]}x${m[1]}x${m[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let _={kernelId:this.currentKernelId,programName:g.programInfo.name,inputTensorViews:t,outputTensorViews:f};this.pendingKernels.push(_),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(_)}return this.programManager.run(g,a,d,m,h),Qs(e.name),f}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,i){let r=Y6.get(e);if(!r)throw new Error(`kernel not implemented: ${e}`);let s={kernelType:e,kernelName:i,kernelEntry:r[0],attributes:[r[1],n]};this.kernels.set(t,s)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let n of t)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let i=this.kernels.get(e);if(!i)throw new Error(`kernel not created: ${e}`);let r=i.kernelType,s=i.kernelName,a=i.kernelEntry,o=i.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${r}] ${s}" is not allowed to be called recursively`);this.currentKernelId=e,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),Nn("info",()=>`[WebGPU] Start to run kernel "[${r}] ${s}"...`);let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),a(t,o[1]),0}catch(u){return n.push(Promise.resolve(`[WebGPU] Kernel "[${r}] ${s}" failed. ${u}`)),1}finally{l&&n.push(this.device.popErrorScope().then(u=>u?`GPU validation error for kernel "[${r}] ${s}": ${u.message}`:null));for(let u of this.temporaryData)this.gpuDataManager.release(u.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,i){let r=this.sessionExternalDataMapping.get(e);r||(r=new Map,this.sessionExternalDataMapping.set(e,r));let s=r.get(t),a=this.gpuDataManager.registerExternalBuffer(n,i,s);return r.set(t,[a,n]),a}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[0])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let i=await Kb(this,e,t);return Jx(i.buffer,n)}}writeTimestamp(e){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){var e;this.queryType="none",(((e=this.env.webgpu.profiling)==null?void 0:e.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Nn("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Nn("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Nn("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),n=e.length;this.pendingKernels=[];for(let i=0;i<n;i++){let r=this.getComputePassEncoder(),s=e[i];this.writeTimestamp(this.pendingDispatchNumber*2),r.setPipeline(s.computePipeline),r.setBindGroup(0,s.bindGroup),r.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(t[i]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}}),e8={};Ud(e8,{init:()=>t8});var zh,bO,t8,Sie=dt(()=>{en(),Vo(),ln(),One(),zh=class n8{constructor(t,n,i,r){this.module=t,this.dataType=n,this.data=i,this.dims=r}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=We.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=We.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=We.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let t=We.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(We.size(t)!==We.size(this.dims))throw new Error("Invalid new shape");return new n8(this.module,this.dataType,this.data,t)}},bO=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo;let i=e.PTR_SIZE,r=n/e.PTR_SIZE,s=i===4?"i32":"i64";this.opKernelContext=Number(e.getValue(i*r++,s));let a=Number(e.getValue(i*r++,s));this.outputCount=Number(e.getValue(i*r++,s)),this.customDataOffset=Number(e.getValue(i*r++,"*")),this.customDataSize=Number(e.getValue(i*r++,s));let o=[];for(let l=0;l<a;l++){let u=Number(e.getValue(i*r++,s)),c=Number(e.getValue(i*r++,"*")),f=Number(e.getValue(i*r++,s)),d=[];for(let h=0;h<f;h++)d.push(Number(e.getValue(i*r++,s)));o.push(new zh(e,u,c,d))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){var a;let n=((a=t==null?void 0:t.inputs)==null?void 0:a.map(o=>typeof o=="number"?this.inputs[o]:o))??this.inputs,i=(t==null?void 0:t.outputs)??[],r=(o,l,u)=>new zh(this.module,l,this.output(o,u),u),s=(o,l)=>{let u=Pu(o,l);if(!u)throw new Error(`Unsupported data type: ${o}`);let c=u>0?this.backend.gpuDataManager.create(u).id:0;return new zh(this.module,o,c,l)};return this.backend.run(e,n,i,r,s,this.outputCount)}output(e,t){let n=this.module.stackSave();try{let i=this.module.PTR_SIZE,r=i===4?"i32":"i64",s=this.module.stackAlloc((1+t.length)*i);this.module.setValue(s,t.length,r);for(let a=0;a<t.length;a++)this.module.setValue(s+i*(a+1),t[a],r);return this.module._JsepOutput(this.opKernelContext,e,s)}catch(i){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${i}`)}finally{this.module.stackRestore(n)}}},t8=async(e,t,n,i)=>{let r=t.jsepInit;if(!r)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(e==="webgpu"){let s=(Eie(),mp(Q6)).WebGpuBackend,a=new s;await a.initialize(n,i),r("webgpu",[a,o=>a.alloc(Number(o)),o=>a.free(o),(o,l,u,c=!1)=>{if(c)Nn("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(o)}, dst=${Number(l)}, size=${Number(u)}`),a.memcpy(Number(o),Number(l));else{Nn("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(o)}, gpuDataId=${Number(l)}, size=${Number(u)}`);let f=t.HEAPU8.subarray(Number(o>>>0),Number(o>>>0)+Number(u));a.upload(Number(l),f)}},async(o,l,u)=>{Nn("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${o}, dataOffset=${l}, size=${u}`),await a.download(Number(o),()=>t.HEAPU8.subarray(Number(l)>>>0,Number(l+u)>>>0))},(o,l,u)=>a.createKernel(o,Number(l),u,t.UTF8ToString(t._JsepGetNodeName(Number(l)))),o=>a.releaseKernel(o),(o,l,u,c)=>{Nn("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${o}, contextDataOffset=${l}`);let f=new bO(t,a,Number(l));return a.computeKernel(Number(o),f,c)},()=>a.captureBegin(),()=>a.captureEnd(),()=>a.replay()])}else{let s=new fV(n);r("webnn",[s,()=>s.reserveTensorId(),a=>s.releaseTensorId(a),async(a,o,l,u,c)=>s.ensureTensor(a,o,l,u,c),(a,o)=>{s.uploadTensor(a,o)},async(a,o)=>s.downloadTensor(a,o)])}}}),xO,aT,oT,fl,TO,gv,vg,lT,uT,_v,cT,dT,fT,i8=dt(()=>{Pne(),kne(),en(),dc(),Gx(),aV(),xO=(e,t)=>{mi()._OrtInit(e,t)!==0&&ii("Can't initialize onnxruntime.")},aT=async e=>{xO(e.wasm.numThreads,hg(e.logLevel))},oT=async(e,t)=>{var n,i;(i=(n=mi()).asyncInit)==null||i.call(n);{let r=(Sie(),mp(e8)).init;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let s=e.webgpu.adapter;if(s){if(typeof s.limits!="object"||typeof s.features!="object"||typeof s.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let a=e.webgpu.powerPreference;if(a!==void 0&&a!=="low-power"&&a!=="high-performance")throw new Error(`Invalid powerPreference setting: "${a}"`);let o=e.webgpu.forceFallbackAdapter;if(o!==void 0&&typeof o!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${o}"`);if(s=await navigator.gpu.requestAdapter({powerPreference:a,forceFallbackAdapter:o}),!s)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await r("webgpu",mi(),e,s)}if(t==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await r("webnn",mi(),e)}}},fl=new Map,TO=e=>{let t=mi(),n=t.stackSave();try{let i=t.PTR_SIZE,r=t.stackAlloc(2*i);t._OrtGetInputOutputCount(e,r,r+i)!==0&&ii("Can't get session input/output count.");let s=i===4?"i32":"i64";return[Number(t.getValue(r,s)),Number(t.getValue(r+i,s))]}finally{t.stackRestore(n)}},gv=(e,t)=>{let n=mi(),i=n.stackSave(),r=0;try{let s=n.PTR_SIZE,a=n.stackAlloc(2*s);n._OrtGetInputOutputMetadata(e,t,a,a+s)!==0&&ii("Can't get session input/output metadata.");let o=Number(n.getValue(a,"*"));r=Number(n.getValue(a+s,"*"));let l=n.HEAP32[r/4];if(l===0)return[o,0];let u=n.HEAPU32[r/4+1],c=[];for(let f=0;f<u;f++){let d=Number(n.getValue(r+8+f*s,"*"));c.push(d!==0?n.UTF8ToString(d):Number(n.getValue(r+8+(f+u)*s,"*")))}return[o,l,c]}finally{n.stackRestore(i),r!==0&&n._OrtFree(r)}},vg=e=>{let t=mi(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},lT=async(e,t)=>{var f,d,h,m;let n,i,r=mi();Array.isArray(e)?[n,i]=e:e.buffer===r.HEAPU8.buffer?[n,i]=[e.byteOffset,e.byteLength]:[n,i]=vg(e);let s=0,a=0,o=0,l=[],u=[],c=[];try{if([a,l]=await sV(t),(t==null?void 0:t.externalData)&&r.mountExternalData){let P=[];for(let O of t.externalData){let R=typeof O=="string"?O:O.path;P.push(qx(typeof O=="string"?O:O.data).then(G=>{r.mountExternalData(R,G)}))}await Promise.all(P)}for(let P of(t==null?void 0:t.executionProviders)??[])if((typeof P=="string"?P:P.name)==="webnn"){if(r.shouldTransferToMLTensor=!1,typeof P!="string"){let O=P,R=O==null?void 0:O.context,G=O==null?void 0:O.gpuDevice,W=O==null?void 0:O.deviceType,V=O==null?void 0:O.powerPreference;R?r.currentContext=R:G?r.currentContext=await r.webnnCreateMLContext(G):r.currentContext=await r.webnnCreateMLContext({deviceType:W,powerPreference:V})}else r.currentContext=await r.webnnCreateMLContext();break}s=await r._OrtCreateSession(n,i,a),(f=r.webgpuOnCreateSession)==null||f.call(r,s),s===0&&ii("Can't create a session."),(d=r.jsepOnCreateSession)==null||d.call(r),r.currentContext&&(r.webnnRegisterMLContext(s,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[y,M]=TO(s),g=!!(t!=null&&t.enableGraphCapture),_=[],T=[],x=[],S=[],$=[];for(let P=0;P<y;P++){let[O,R,G]=gv(s,P);O===0&&ii("Can't get an input name."),u.push(O);let W=r.UTF8ToString(O);_.push(W),x.push(R===0?{name:W,isTensor:!1}:{name:W,isTensor:!0,type:Eo(R),shape:G})}for(let P=0;P<M;P++){let[O,R,G]=gv(s,P+y);O===0&&ii("Can't get an output name."),c.push(O);let W=r.UTF8ToString(O);T.push(W),S.push(R===0?{name:W,isTensor:!1}:{name:W,isTensor:!0,type:Eo(R),shape:G});{if(g&&(t==null?void 0:t.preferredOutputLocation)===void 0){$.push("gpu-buffer");continue}let V=typeof(t==null?void 0:t.preferredOutputLocation)=="string"?t.preferredOutputLocation:((h=t==null?void 0:t.preferredOutputLocation)==null?void 0:h[W])??"cpu";if(V!=="cpu"&&V!=="cpu-pinned"&&V!=="gpu-buffer"&&V!=="ml-tensor")throw new Error(`Not supported preferred output location: ${V}.`);if(g&&V!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${V}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);$.push(V)}}let C=null;return $.some(P=>P==="gpu-buffer"||P==="ml-tensor")&&(o=r._OrtCreateBinding(s),o===0&&ii("Can't create IO binding."),C={handle:o,outputPreferredLocations:$,outputPreferredLocationsEncoded:$.map(P=>Hb(P))}),fl.set(s,[s,u,c,C,g,!1]),[s,_,T,x,S]}catch(y){throw u.forEach(M=>r._OrtFree(M)),c.forEach(M=>r._OrtFree(M)),o!==0&&r._OrtReleaseBinding(o)!==0&&ii("Can't release IO binding."),s!==0&&r._OrtReleaseSession(s)!==0&&ii("Can't release session."),y}finally{r._free(n),a!==0&&r._OrtReleaseSessionOptions(a)!==0&&ii("Can't release session options."),l.forEach(y=>r._free(y)),(m=r.unmountExternalData)==null||m.call(r)}},uT=e=>{var l,u,c;let t=mi(),n=fl.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[i,r,s,a,o]=n;a&&(o&&t._OrtClearBoundOutputs(a.handle)!==0&&ii("Can't clear bound outputs."),t._OrtReleaseBinding(a.handle)!==0&&ii("Can't release IO binding.")),(l=t.jsepOnReleaseSession)==null||l.call(t,e),(u=t.webnnOnReleaseSession)==null||u.call(t,e),(c=t.webgpuOnReleaseSession)==null||c.call(t,e),r.forEach(f=>t._OrtFree(f)),s.forEach(f=>t._OrtFree(f)),t._OrtReleaseSession(i)!==0&&ii("Can't release session."),fl.delete(e)},_v=async(e,t,n,i,r,s,a=!1)=>{if(!e){t.push(0);return}let o=mi(),l=o.PTR_SIZE,u=e[0],c=e[1],f=e[3],d=f,h,m;if(u==="string"&&(f==="gpu-buffer"||f==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(a&&f!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${s} when enableGraphCapture is true.`);if(f==="gpu-buffer"){let g=e[2].gpuBuffer;m=Pu(Bc(u),c);{let _=o.jsepRegisterBuffer;if(!_)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');h=_(i,s,g,m)}}else if(f==="ml-tensor"){let g=e[2].mlTensor;m=Pu(Bc(u),c);let _=o.webnnRegisterMLTensor;if(!_)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');h=_(i,g,Bc(u),c)}else{let g=e[2];if(Array.isArray(g)){m=l*g.length,h=o._malloc(m),n.push(h);for(let _=0;_<g.length;_++){if(typeof g[_]!="string")throw new TypeError(`tensor data at index ${_} is not a string`);o.setValue(h+_*l,xa(g[_],n),"*")}}else{let _=o.webnnIsGraphInput;if(u!=="string"&&_){let T=o.UTF8ToString(r);if(_(i,T)){let x=Bc(u);m=Pu(x,c),d="ml-tensor";let S=o.webnnCreateTemporaryTensor,$=o.webnnUploadTensor;if(!S||!$)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let C=await S(i,x,c);$(C,new Uint8Array(g.buffer,g.byteOffset,g.byteLength)),h=C}else m=g.byteLength,h=o._malloc(m),n.push(h),o.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,m),h)}else m=g.byteLength,h=o._malloc(m),n.push(h),o.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,m),h)}}let y=o.stackSave(),M=o.stackAlloc(4*c.length);try{c.forEach((_,T)=>o.setValue(M+T*l,_,l===4?"i32":"i64"));let g=o._OrtCreateTensor(Bc(u),h,m,M,c.length,Hb(d));g===0&&ii(`Can't create tensor for input/output. session=${i}, index=${s}.`),t.push(g)}finally{o.stackRestore(y)}},cT=async(e,t,n,i,r,s)=>{var G,W,V,te;let a=mi(),o=a.PTR_SIZE,l=fl.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let u=l[0],c=l[1],f=l[2],d=l[3],h=l[4],m=l[5],y=t.length,M=i.length,g=0,_=[],T=[],x=[],S=[],$=a.stackSave(),C=a.stackAlloc(y*o),P=a.stackAlloc(y*o),O=a.stackAlloc(M*o),R=a.stackAlloc(M*o);try{[g,_]=rV(s);for(let Y=0;Y<y;Y++)await _v(n[Y],T,S,e,c[t[Y]],t[Y],h);for(let Y=0;Y<M;Y++)await _v(r[Y],x,S,e,f[i[Y]],y+i[Y],h);for(let Y=0;Y<y;Y++)a.setValue(C+Y*o,T[Y],"*"),a.setValue(P+Y*o,c[t[Y]],"*");for(let Y=0;Y<M;Y++)a.setValue(O+Y*o,x[Y],"*"),a.setValue(R+Y*o,f[i[Y]],"*");if(d&&!m){let{handle:Y,outputPreferredLocations:X,outputPreferredLocationsEncoded:ce}=d;if(c.length!==y)throw new Error(`input count from feeds (${y}) is expected to be always equal to model's input count (${c.length}).`);for(let me=0;me<y;me++){let Q=t[me];await a._OrtBindInput(Y,c[Q],T[me])!==0&&ii(`Can't bind input[${me}] for session=${e}.`)}for(let me=0;me<M;me++){let Q=i[me];(G=r[me])!=null&&G[3]?a._OrtBindOutput(Y,f[Q],x[me],0)!==0&&ii(`Can't bind pre-allocated output[${me}] for session=${e}.`):a._OrtBindOutput(Y,f[Q],0,ce[Q])!==0&&ii(`Can't bind output[${me}] to ${X[me]} for session=${e}.`)}fl.set(e,[u,c,f,d,h,!0])}(W=a.jsepOnRunStart)==null||W.call(a,u),(V=a.webnnOnRunStart)==null||V.call(a,u);let J;d?J=await a._OrtRunWithBinding(u,d.handle,M,O,g):J=await a._OrtRun(u,P,C,y,R,M,O,g),J!==0&&ii("failed to call OrtRun().");let j=[];for(let Y=0;Y<M;Y++){let X=Number(a.getValue(O+Y*o,"*"));if(X===x[Y]){j.push(r[Y]);continue}let ce=a.stackSave(),me=a.stackAlloc(4*o),Q=!1,H,B=0;try{a._OrtGetTensorData(X,me,me+o,me+2*o,me+3*o)!==0&&ii(`Can't access output tensor data on index ${Y}.`);let ee=o===4?"i32":"i64",_e=Number(a.getValue(me,ee));B=a.getValue(me+o,"*");let le=a.getValue(me+o*2,"*"),ae=Number(a.getValue(me+o*3,ee)),Ne=[];for(let ue=0;ue<ae;ue++)Ne.push(Number(a.getValue(le+ue*o,ee)));a._OrtFree(le)!==0&&ii("Can't free memory for tensor dims.");let Ye=Ne.reduce((ue,U)=>ue*U,1);H=Eo(_e);let ze=d==null?void 0:d.outputPreferredLocations[i[Y]];if(H==="string"){if(ze==="gpu-buffer"||ze==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let ue=[];for(let U=0;U<Ye;U++){let we=a.getValue(B+U*o,"*"),Pe=a.getValue(B+(U+1)*o,"*"),ke=U===Ye-1?void 0:Pe-we;ue.push(a.UTF8ToString(we,ke))}j.push([H,Ne,ue,"cpu"])}else if(ze==="gpu-buffer"&&Ye>0){let ue=a.jsepGetBuffer;if(!ue)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let U=ue(B),we=Pu(_e,Ye);if(we===void 0||!Wx(H))throw new Error(`Unsupported data type: ${H}`);Q=!0,j.push([H,Ne,{gpuBuffer:U,download:a.jsepCreateDownloader(U,we,H),dispose:()=>{a._OrtReleaseTensor(X)!==0&&ii("Can't release tensor.")}},"gpu-buffer"])}else if(ze==="ml-tensor"&&Ye>0){let ue=a.webnnEnsureTensor,U=a.webnnIsInt64Supported;if(!ue||!U)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Pu(_e,Ye)===void 0||!Hx(H))throw new Error(`Unsupported data type: ${H}`);if(H==="int64"&&!U(e))throw new Error('preferredLocation "ml-tensor" for int64 output is not supported by current WebNN Context.');let we=await ue(e,B,_e,Ne,!1);Q=!0,j.push([H,Ne,{mlTensor:we,download:a.webnnCreateMLTensorDownloader(B,H),dispose:()=>{a.webnnReleaseTensorId(B),a._OrtReleaseTensor(X)}},"ml-tensor"])}else{let ue=jx(H),U=new ue(Ye);new Uint8Array(U.buffer,U.byteOffset,U.byteLength).set(a.HEAPU8.subarray(B,B+U.byteLength)),j.push([H,Ne,U,"cpu"])}}finally{a.stackRestore(ce),H==="string"&&B&&a._free(B),Q||a._OrtReleaseTensor(X),(te=a.webnnOnRunEnd)==null||te.call(a,u)}}return d&&!h&&(a._OrtClearBoundOutputs(d.handle)!==0&&ii("Can't clear bound outputs."),fl.set(e,[u,c,f,d,h,!1])),j}finally{a.stackRestore($),T.forEach(J=>a._OrtReleaseTensor(J)),x.forEach(J=>a._OrtReleaseTensor(J)),S.forEach(J=>a._free(J)),g!==0&&a._OrtReleaseRunOptions(g),_.forEach(J=>a._free(J))}},dT=e=>{let t=mi(),n=fl.get(e);if(!n)throw new Error("invalid session id");let i=n[0],r=t._OrtEndProfiling(i);r===0&&ii("Can't get an profile file name."),t._OrtFree(r)},fT=e=>{let t=[];for(let n of e){let i=n[2];!Array.isArray(i)&&"buffer"in i&&t.push(i.buffer)}return t}}),pl,es,Ac,cf,df,Fh,yv,Bh,yu,vu,MO,r8,s8,a8,o8,l8,u8,c8,d8=dt(()=>{Oa(),i8(),dc(),Ux(),pl=()=>!!wi.wasm.proxy&&typeof document<"u",Ac=!1,cf=!1,df=!1,Bh=new Map,yu=(e,t)=>{let n=Bh.get(e);n?n.push(t):Bh.set(e,[t])},vu=()=>{if(Ac||!cf||df||!es)throw new Error("worker not ready")},MO=e=>{switch(e.data.type){case"init-wasm":Ac=!1,e.data.err?(df=!0,yv[1](e.data.err)):(cf=!0,yv[0]()),Fh&&(URL.revokeObjectURL(Fh),Fh=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=Bh.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},r8=async()=>{if(!cf){if(Ac)throw new Error("multiple calls to 'initWasm()' detected.");if(df)throw new Error("previous call to 'initWasm()' failed.");if(Ac=!0,pl())return new Promise((e,t)=>{es==null||es.terminate(),nV().then(([n,i])=>{try{es=i,es.onerror=s=>t(s),es.onmessage=MO,yv=[e,t];let r={type:"init-wasm",in:wi};!r.in.wasm.wasmPaths&&(n||Wb)&&(r.in.wasm.wasmPaths={wasm:new URL("/Gemini-AI-Translator/assets/ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href}),es.postMessage(r),Fh=n}catch(r){t(r)}},t)});try{await Vx(wi.wasm),await aT(wi),cf=!0}catch(e){throw df=!0,e}finally{Ac=!1}}},s8=async e=>{if(pl())return vu(),new Promise((t,n)=>{yu("init-ep",[t,n]);let i={type:"init-ep",in:{epName:e,env:wi}};es.postMessage(i)});await oT(wi,e)},a8=async e=>pl()?(vu(),new Promise((t,n)=>{yu("copy-from",[t,n]);let i={type:"copy-from",in:{buffer:e}};es.postMessage(i,[e.buffer])})):vg(e),o8=async(e,t)=>{if(pl()){if(t!=null&&t.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return vu(),new Promise((n,i)=>{yu("create",[n,i]);let r={type:"create",in:{model:e,options:{...t}}},s=[];e instanceof Uint8Array&&s.push(e.buffer),es.postMessage(r,s)})}else return lT(e,t)},l8=async e=>{if(pl())return vu(),new Promise((t,n)=>{yu("release",[t,n]);let i={type:"release",in:e};es.postMessage(i)});uT(e)},u8=async(e,t,n,i,r,s)=>{if(pl()){if(n.some(a=>a[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(r.some(a=>a))throw new Error("pre-allocated output tensor is not supported for proxy.");return vu(),new Promise((a,o)=>{yu("run",[a,o]);let l=n,u={type:"run",in:{sessionId:e,inputIndices:t,inputs:l,outputIndices:i,options:s}};es.postMessage(u,fT(l))})}else return cT(e,t,n,i,r,s)},c8=async e=>{if(pl())return vu(),new Promise((t,n)=>{yu("end-profiling",[t,n]);let i={type:"end-profiling",in:e};es.postMessage(i)});dT(e)}}),vv,EO,f8,Cie=dt(()=>{Oa(),d8(),en(),Bx(),aV(),vv=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},EO=e=>{switch(e[3]){case"cpu":return new Ma(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Wx(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:i,dispose:r}=e[2];return Ma.fromGpuBuffer(n,{dataType:t,dims:e[1],download:i,dispose:r})}case"ml-tensor":{let t=e[0];if(!Hx(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:i,dispose:r}=e[2];return Ma.fromMLTensor(n,{dataType:t,dims:e[1],download:i,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},f8=class{async fetchModelAndCopyToWasmMemory(e){return a8(await qx(e))}async loadModel(e,t){Ia();let n;typeof e=="string"?n=await this.fetchModelAndCopyToWasmMemory(e):n=e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await o8(n,t),Qs()}async dispose(){return l8(this.sessionId)}async run(e,t,n){Ia();let i=[],r=[];Object.entries(e).forEach(f=>{let d=f[0],h=f[1],m=this.inputNames.indexOf(d);if(m===-1)throw new Error(`invalid input '${d}'`);i.push(h),r.push(m)});let s=[],a=[];Object.entries(t).forEach(f=>{let d=f[0],h=f[1],m=this.outputNames.indexOf(d);if(m===-1)throw new Error(`invalid output '${d}'`);s.push(h),a.push(m)});let o=i.map((f,d)=>vv(f,()=>`input "${this.inputNames[r[d]]}"`)),l=s.map((f,d)=>f?vv(f,()=>`output "${this.outputNames[a[d]]}"`):null),u=await u8(this.sessionId,r,o,a,l,n),c={};for(let f=0;f<u.length;f++)c[this.outputNames[a[f]]]=s[f]??EO(u[f]);return Qs(),c}startProfiling(){}endProfiling(){c8(this.sessionId)}}}),p8={};Ud(p8,{OnnxruntimeWebAssemblyBackend:()=>a1,initializeFlags:()=>s1,wasmBackend:()=>h8});var s1,a1,h8,$ie=dt(()=>{Oa(),d8(),Cie(),s1=()=>{(typeof wi.wasm.initTimeout!="number"||wi.wasm.initTimeout<0)&&(wi.wasm.initTimeout=0);let e=wi.wasm.simd;if(typeof e!="boolean"&&e!==void 0&&e!=="fixed"&&e!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),wi.wasm.simd=!1),typeof wi.wasm.proxy!="boolean"&&(wi.wasm.proxy=!1),typeof wi.wasm.trace!="boolean"&&(wi.wasm.trace=!1),typeof wi.wasm.numThreads!="number"||!Number.isInteger(wi.wasm.numThreads)||wi.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)wi.wasm.numThreads=1;else{let t=typeof navigator>"u"?hne("node:os").cpus().length:navigator.hardwareConcurrency;wi.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},a1=class{async init(e){s1(),await r8(),await s8(e)}async createInferenceSessionHandler(e,t){let n=new f8;return await n.loadModel(e,t),n}},h8=new a1});Oa();Oa();Oa();var Aie="1.22.0-dev.20250409-89f8206ba4",Iie=YU;{let e=($ie(),mp(p8)).wasmBackend;Nu("webgpu",e,5),Nu("webnn",e,5),Nu("cpu",e,10),Nu("wasm",e,10)}Object.defineProperty(wi.versions,"web",{value:Aie,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pie=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return Fx},get TRACE(){return gp},get TRACE_FUNC_BEGIN(){return Ia},get TRACE_FUNC_END(){return Qs},get Tensor(){return Ma},default:Iie,get env(){return wi},get registerBackend(){return Nu}},Symbol.toStringTag,{value:"Module"}));var wo={},kie={"onnxruntime-common":e=>{e.exports=cne},"onnxruntime-web":e=>{e.exports=Pie},"?2ce3":()=>{},"?7992":()=>{},"?5af5":()=>{},"?2b25":()=>{},"?db59":()=>{},"?383f":()=>{},"?fa4b":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(e,t,n)=>{n.r(t),n.d(t,{Environment:()=>ct,Interpreter:()=>hn,Template:()=>nr,parse:()=>ae,tokenize:()=>f});var i=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Comment:"Comment"}),r=class{constructor(L,oe){this.value=L,this.type=oe}};function s(L){return/\w/.test(L)}function a(L){return/[0-9]/.test(L)}function o(L){return/\s/.test(L)}var l=[["{%",i.OpenStatement],["%}",i.CloseStatement],["{{",i.OpenExpression],["}}",i.CloseExpression],["(",i.OpenParen],[")",i.CloseParen],["{",i.OpenCurlyBracket],["}",i.CloseCurlyBracket],["[",i.OpenSquareBracket],["]",i.CloseSquareBracket],[",",i.Comma],[".",i.Dot],[":",i.Colon],["|",i.Pipe],["<=",i.ComparisonBinaryOperator],[">=",i.ComparisonBinaryOperator],["==",i.ComparisonBinaryOperator],["!=",i.ComparisonBinaryOperator],["<",i.ComparisonBinaryOperator],[">",i.ComparisonBinaryOperator],["+",i.AdditiveBinaryOperator],["-",i.AdditiveBinaryOperator],["~",i.AdditiveBinaryOperator],["*",i.MultiplicativeBinaryOperator],["/",i.MultiplicativeBinaryOperator],["%",i.MultiplicativeBinaryOperator],["=",i.Equals]],u=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function c(L,oe={}){return L.endsWith(`
`)&&(L=L.slice(0,-1)),oe.lstrip_blocks&&(L=L.replace(/^[ \t]*({[#%-])/gm,"$1")),oe.trim_blocks&&(L=L.replace(/([#%-]})\n/g,"$1")),L.replace(/{%\s*(end)?generation\s*%}/gs,"")}function f(L,oe={}){var mt,Ht;const K=[],re=c(L,oe);let de=0,xe=0;const Ue=It=>{let Zt="";for(;It(re[de]);){if(re[de]==="\\"){if(++de,de>=re.length)throw new SyntaxError("Unexpected end of input");const St=re[de++],tn=u.get(St);if(tn===void 0)throw new SyntaxError(`Unexpected escaped character: ${St}`);Zt+=tn;continue}if(Zt+=re[de++],de>=re.length)throw new SyntaxError("Unexpected end of input")}return Zt},_t=()=>{const It=K.at(-1);It&&It.type===i.Text&&(It.value=It.value.trimEnd(),It.value===""&&K.pop())},$t=()=>{for(;de<re.length&&o(re[de]);)++de};e:for(;de<re.length;){const It=(mt=K.at(-1))==null?void 0:mt.type;if(It===void 0||It===i.CloseStatement||It===i.CloseExpression||It===i.Comment){let St="";for(;de<re.length&&!(re[de]==="{"&&(re[de+1]==="%"||re[de+1]==="{"||re[de+1]==="#"));)St+=re[de++];if(St.length>0){K.push(new r(St,i.Text));continue}}if(re[de]==="{"&&re[de+1]==="#"){de+=2;const St=re[de]==="-";St&&++de;let tn="";for(;re[de]!=="#"||re[de+1]!=="}";){if(de+2>=re.length)throw new SyntaxError("Missing end of comment tag");tn+=re[de++]}const vn=tn.endsWith("-");vn&&(tn=tn.slice(0,-1)),St&&_t(),K.push(new r(tn,i.Comment)),de+=2,vn&&$t();continue}if(re.slice(de,de+3)==="{%-"){_t(),K.push(new r("{%",i.OpenStatement)),de+=3;continue}if(re.slice(de,de+3)==="{{-"){_t(),K.push(new r("{{",i.OpenExpression)),xe=0,de+=3;continue}if(Ue(o),re.slice(de,de+3)==="-%}"){K.push(new r("%}",i.CloseStatement)),de+=3,$t();continue}if(re.slice(de,de+3)==="-}}"){K.push(new r("}}",i.CloseExpression)),de+=3,$t();continue}const Zt=re[de];if(Zt==="-"||Zt==="+"){const St=(Ht=K.at(-1))==null?void 0:Ht.type;if(St===i.Text||St===void 0)throw new SyntaxError(`Unexpected character: ${Zt}`);switch(St){case i.Identifier:case i.NumericLiteral:case i.StringLiteral:case i.CloseParen:case i.CloseSquareBracket:break;default:{++de;const tn=Ue(a);K.push(new r(`${Zt}${tn}`,tn.length>0?i.NumericLiteral:i.UnaryOperator));continue}}}for(const[St,tn]of l){if(St==="}}"&&xe>0)continue;if(re.slice(de,de+St.length)===St){K.push(new r(St,tn)),tn===i.OpenExpression?xe=0:tn===i.OpenCurlyBracket?++xe:tn===i.CloseCurlyBracket&&--xe,de+=St.length;continue e}}if(Zt==="'"||Zt==='"'){++de;const St=Ue(tn=>tn!==Zt);K.push(new r(St,i.StringLiteral)),++de;continue}if(a(Zt)){let St=Ue(a);if(re[de]==="."&&a(re[de+1])){++de;const tn=Ue(a);St=`${St}.${tn}`}K.push(new r(St,i.NumericLiteral));continue}if(s(Zt)){const St=Ue(s);K.push(new r(St,i.Identifier));continue}throw new SyntaxError(`Unexpected character: ${Zt}`)}return K}var d=class{constructor(){fe(this,"type","Statement")}},h=class extends d{constructor(oe){super();fe(this,"type","Program");this.body=oe}},m=class extends d{constructor(oe,K,re){super();fe(this,"type","If");this.test=oe,this.body=K,this.alternate=re}},y=class extends d{constructor(oe,K,re,de){super();fe(this,"type","For");this.loopvar=oe,this.iterable=K,this.body=re,this.defaultBlock=de}},M=class extends d{constructor(){super(...arguments);fe(this,"type","Break")}},g=class extends d{constructor(){super(...arguments);fe(this,"type","Continue")}},_=class extends d{constructor(oe,K,re){super();fe(this,"type","Set");this.assignee=oe,this.value=K,this.body=re}},T=class extends d{constructor(oe,K,re){super();fe(this,"type","Macro");this.name=oe,this.args=K,this.body=re}},x=class extends d{constructor(oe){super();fe(this,"type","Comment");this.value=oe}},S=class extends d{constructor(){super(...arguments);fe(this,"type","Expression")}},$=class extends S{constructor(oe,K,re){super();fe(this,"type","MemberExpression");this.object=oe,this.property=K,this.computed=re}},C=class extends S{constructor(oe,K){super();fe(this,"type","CallExpression");this.callee=oe,this.args=K}},P=class extends S{constructor(oe){super();fe(this,"type","Identifier");this.value=oe}},O=class extends S{constructor(oe){super();fe(this,"type","Literal");this.value=oe}},R=class extends O{constructor(){super(...arguments);fe(this,"type","IntegerLiteral")}},G=class extends O{constructor(){super(...arguments);fe(this,"type","FloatLiteral")}},W=class extends O{constructor(){super(...arguments);fe(this,"type","StringLiteral")}},V=class extends O{constructor(){super(...arguments);fe(this,"type","ArrayLiteral")}},te=class extends O{constructor(){super(...arguments);fe(this,"type","TupleLiteral")}},J=class extends O{constructor(){super(...arguments);fe(this,"type","ObjectLiteral")}},j=class extends S{constructor(oe,K,re){super();fe(this,"type","BinaryExpression");this.operator=oe,this.left=K,this.right=re}},Y=class extends S{constructor(oe,K){super();fe(this,"type","FilterExpression");this.operand=oe,this.filter=K}},X=class extends d{constructor(oe,K){super();fe(this,"type","FilterStatement");this.filter=oe,this.body=K}},ce=class extends S{constructor(oe,K){super();fe(this,"type","SelectExpression");this.lhs=oe,this.test=K}},me=class extends S{constructor(oe,K,re){super();fe(this,"type","TestExpression");this.operand=oe,this.negate=K,this.test=re}},Q=class extends S{constructor(oe,K){super();fe(this,"type","UnaryExpression");this.operator=oe,this.argument=K}},H=class extends S{constructor(oe=void 0,K=void 0,re=void 0){super();fe(this,"type","SliceExpression");this.start=oe,this.stop=K,this.step=re}},B=class extends S{constructor(oe,K){super();fe(this,"type","KeywordArgumentExpression");this.key=oe,this.value=K}},ee=class extends S{constructor(oe){super();fe(this,"type","SpreadExpression");this.argument=oe}},_e=class extends d{constructor(oe,K,re){super();fe(this,"type","CallStatement");this.call=oe,this.callerArgs=K,this.body=re}},le=class extends S{constructor(oe,K,re){super();fe(this,"type","Ternary");this.condition=oe,this.trueExpr=K,this.falseExpr=re}};function ae(L){const oe=new h([]);let K=0;function re(ot,lt){const wt=L[K++];if(!wt||wt.type!==ot)throw new Error(`Parser Error: ${lt}. ${wt.type} !== ${ot}.`);return wt}function de(ot){if(!$t(ot))throw new SyntaxError(`Expected ${ot}`);++K}function xe(){switch(L[K].type){case i.Comment:return new x(L[K++].value);case i.Text:return mt();case i.OpenStatement:return Ht();case i.OpenExpression:return It();default:throw new SyntaxError(`Unexpected token type: ${L[K].type}`)}}function Ue(...ot){return K+ot.length<=L.length&&ot.every((lt,wt)=>lt===L[K+wt].type)}function _t(...ot){var lt,wt,mn;return((lt=L[K])==null?void 0:lt.type)===i.OpenStatement&&((wt=L[K+1])==null?void 0:wt.type)===i.Identifier&&ot.includes((mn=L[K+1])==null?void 0:mn.value)}function $t(...ot){return K+ot.length<=L.length&&ot.every((lt,wt)=>L[K+wt].type==="Identifier"&&lt===L[K+wt].value)}function mt(){return new W(re(i.Text,"Expected text token").value)}function Ht(){if(re(i.OpenStatement,"Expected opening statement token"),L[K].type!==i.Identifier)throw new SyntaxError(`Unknown statement, got ${L[K].type}`);const ot=L[K].value;let lt;switch(ot){case"set":++K,lt=Zt();break;case"if":++K,lt=St(),re(i.OpenStatement,"Expected {% token"),de("endif"),re(i.CloseStatement,"Expected %} token");break;case"macro":++K,lt=tn(),re(i.OpenStatement,"Expected {% token"),de("endmacro"),re(i.CloseStatement,"Expected %} token");break;case"for":++K,lt=Wn(),re(i.OpenStatement,"Expected {% token"),de("endfor"),re(i.CloseStatement,"Expected %} token");break;case"call":{++K;let wt=null;Ue(i.OpenParen)&&(wt=Un());const mn=Hi();if(mn.type!=="Identifier")throw new SyntaxError("Expected identifier following call statement");const os=Un();re(i.CloseStatement,"Expected closing statement token");const Yr=[];for(;!_t("endcall");)Yr.push(xe());re(i.OpenStatement,"Expected '{%'"),de("endcall"),re(i.CloseStatement,"Expected closing statement token");const ls=new C(mn,os);lt=new _e(ls,wt,Yr);break}case"break":++K,re(i.CloseStatement,"Expected closing statement token"),lt=new M;break;case"continue":++K,re(i.CloseStatement,"Expected closing statement token"),lt=new g;break;case"filter":{++K;let wt=Hi();wt instanceof P&&Ue(i.OpenParen)&&(wt=ni(wt)),re(i.CloseStatement,"Expected closing statement token");const mn=[];for(;!_t("endfilter");)mn.push(xe());re(i.OpenStatement,"Expected '{%'"),de("endfilter"),re(i.CloseStatement,"Expected '%}'"),lt=new X(wt,mn);break}default:throw new SyntaxError(`Unknown statement type: ${ot}`)}return lt}function It(){re(i.OpenExpression,"Expected opening expression token");const ot=ei();return re(i.CloseExpression,"Expected closing expression token"),ot}function Zt(){const ot=vn();let lt=null;const wt=[];if(Ue(i.Equals))++K,lt=vn();else{for(re(i.CloseStatement,"Expected %} token");!_t("endset");)wt.push(xe());re(i.OpenStatement,"Expected {% token"),de("endset")}return re(i.CloseStatement,"Expected closing statement token"),new _(ot,lt,wt)}function St(){const ot=ei();re(i.CloseStatement,"Expected closing statement token");const lt=[],wt=[];for(;!_t("elif","else","endif");)lt.push(xe());if(_t("elif")){++K,++K;const mn=St();wt.push(mn)}else if(_t("else"))for(++K,++K,re(i.CloseStatement,"Expected closing statement token");!_t("endif");)wt.push(xe());return new m(ot,lt,wt)}function tn(){const ot=Hi();if(ot.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const lt=Un();re(i.CloseStatement,"Expected closing statement token");const wt=[];for(;!_t("endmacro");)wt.push(xe());return new T(ot,lt,wt)}function vn(ot=!1){const lt=ot?Hi:ei,wt=[lt()],mn=Ue(i.Comma);for(;mn&&(++K,wt.push(lt()),!!Ue(i.Comma)););return mn?new te(wt):wt[0]}function Wn(){const ot=vn(!0);if(!(ot instanceof P||ot instanceof te))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${ot.type} instead`);if(!$t("in"))throw new SyntaxError("Expected `in` keyword following loop variable");++K;const lt=ei();re(i.CloseStatement,"Expected closing statement token");const wt=[];for(;!_t("endfor","else");)wt.push(xe());const mn=[];if(_t("else"))for(++K,++K,re(i.CloseStatement,"Expected closing statement token");!_t("endfor");)mn.push(xe());return new y(ot,lt,wt,mn)}function ei(){return Bn()}function Bn(){const ot=Je();if($t("if")){++K;const lt=Je();if($t("else")){++K;const wt=Bn();return new le(lt,ot,wt)}else return new ce(ot,lt)}return ot}function Je(){let ot=qt();for(;$t("or");){const lt=L[K];++K;const wt=qt();ot=new j(lt,ot,wt)}return ot}function qt(){let ot=Pt();for(;$t("and");){const lt=L[K];++K;const wt=Pt();ot=new j(lt,ot,wt)}return ot}function Pt(){let ot;for(;$t("not");){const lt=L[K];++K;const wt=Pt();ot=new Q(lt,wt)}return ot??kt()}function kt(){let ot=An();for(;;){let lt;if($t("not","in"))lt=new r("not in",i.Identifier),K+=2;else if($t("in"))lt=L[K++];else if(Ue(i.ComparisonBinaryOperator))lt=L[K++];else break;const wt=An();ot=new j(lt,ot,wt)}return ot}function An(){let ot=ci();for(;Ue(i.AdditiveBinaryOperator);){const lt=L[K];++K;const wt=ci();ot=new j(lt,ot,wt)}return ot}function zn(){const ot=Mi(Hi());return Ue(i.OpenParen)?ni(ot):ot}function ni(ot){let lt=new C(ot,Un());return lt=Mi(lt),Ue(i.OpenParen)&&(lt=ni(lt)),lt}function Un(){re(i.OpenParen,"Expected opening parenthesis for arguments list");const ot=In();return re(i.CloseParen,"Expected closing parenthesis for arguments list"),ot}function In(){const ot=[];for(;!Ue(i.CloseParen);){let lt;if(L[K].type===i.MultiplicativeBinaryOperator&&L[K].value==="*"){++K;const wt=ei();lt=new ee(wt)}else if(lt=ei(),Ue(i.Equals)){if(++K,!(lt instanceof P))throw new SyntaxError("Expected identifier for keyword argument");const wt=ei();lt=new B(lt,wt)}ot.push(lt),Ue(i.Comma)&&++K}return ot}function ir(){const ot=[];let lt=!1;for(;!Ue(i.CloseSquareBracket);)Ue(i.Colon)?(ot.push(void 0),++K,lt=!0):(ot.push(ei()),Ue(i.Colon)&&(++K,lt=!0));if(ot.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(lt){if(ot.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new H(...ot)}return ot[0]}function Mi(ot){for(;Ue(i.Dot)||Ue(i.OpenSquareBracket);){const lt=L[K];++K;let wt;const mn=lt.type===i.OpenSquareBracket;if(mn)wt=ir(),re(i.CloseSquareBracket,"Expected closing square bracket");else if(wt=Hi(),wt.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");ot=new $(ot,wt,mn)}return ot}function ci(){let ot=Xi();for(;Ue(i.MultiplicativeBinaryOperator);){const lt=L[K++],wt=Xi();ot=new j(lt,ot,wt)}return ot}function Xi(){let ot=Cr();for(;$t("is");){++K;const lt=$t("not");lt&&++K;const wt=Hi();if(!(wt instanceof P))throw new SyntaxError("Expected identifier for the test");ot=new me(ot,lt,wt)}return ot}function Cr(){let ot=zn();for(;Ue(i.Pipe);){++K;let lt=Hi();if(!(lt instanceof P))throw new SyntaxError("Expected identifier for the filter");Ue(i.OpenParen)&&(lt=ni(lt)),ot=new Y(ot,lt)}return ot}function Hi(){const ot=L[K++];switch(ot.type){case i.NumericLiteral:{const lt=ot.value;return lt.includes(".")?new G(Number(lt)):new R(Number(lt))}case i.StringLiteral:{let lt=ot.value;for(;Ue(i.StringLiteral);)lt+=L[K++].value;return new W(lt)}case i.Identifier:return new P(ot.value);case i.OpenParen:{const lt=vn();return re(i.CloseParen,"Expected closing parenthesis, got ${tokens[current].type} instead."),lt}case i.OpenSquareBracket:{const lt=[];for(;!Ue(i.CloseSquareBracket);)lt.push(ei()),Ue(i.Comma)&&++K;return++K,new V(lt)}case i.OpenCurlyBracket:{const lt=new Map;for(;!Ue(i.CloseCurlyBracket);){const wt=ei();re(i.Colon,"Expected colon between key and value in object literal");const mn=ei();lt.set(wt,mn),Ue(i.Comma)&&++K}return++K,new J(lt)}default:throw new SyntaxError(`Unexpected token: ${ot.type}`)}}for(;K<L.length;)oe.body.push(xe());return oe}function Ne(L,oe,K=1){oe===void 0&&(oe=L,L=0);const re=[];for(let de=L;de<oe;de+=K)re.push(de);return re}function Ye(L,oe,K,re=1){const de=Math.sign(re);de>=0?(oe=(oe??(oe=0))<0?Math.max(L.length+oe,0):Math.min(oe,L.length),K=(K??(K=L.length))<0?Math.max(L.length+K,0):Math.min(K,L.length)):(oe=(oe??(oe=L.length-1))<0?Math.max(L.length+oe,-1):Math.min(oe,L.length-1),K=(K??(K=-1))<-1?Math.max(L.length+K,-1):Math.min(K,L.length-1));const xe=[];for(let Ue=oe;de*Ue<de*K;Ue+=re)xe.push(L[Ue]);return xe}function ze(L){return L.replace(/\b\w/g,oe=>oe.toUpperCase())}function ue(L){return U(new Date,L)}function U(L,oe){const K=new Intl.DateTimeFormat(void 0,{month:"long"}),re=new Intl.DateTimeFormat(void 0,{month:"short"}),de=xe=>xe<10?"0"+xe:xe.toString();return oe.replace(/%[YmdbBHM%]/g,xe=>{switch(xe){case"%Y":return L.getFullYear().toString();case"%m":return de(L.getMonth()+1);case"%d":return de(L.getDate());case"%b":return re.format(L);case"%B":return K.format(L);case"%H":return de(L.getHours());case"%M":return de(L.getMinutes());case"%%":return"%";default:return xe}})}function we(L){return L.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function Pe(L,oe,K,re){if(re===0)return L;let de=re==null||re<0?1/0:re;const xe=oe.length===0?new RegExp("(?=)","gu"):new RegExp(we(oe),"gu");return L.replaceAll(xe,Ue=>de>0?(--de,K):Ue)}var ke=class extends Error{},Le=class extends Error{},Ge=class{constructor(L=void 0){fe(this,"type","RuntimeValue");fe(this,"value");fe(this,"builtins",new Map);this.value=L}__bool__(){return new He(!!this.value)}toString(){return String(this.value)}},$e=class extends Ge{constructor(){super(...arguments);fe(this,"type","IntegerValue")}},et=class extends Ge{constructor(){super(...arguments);fe(this,"type","FloatValue")}toString(){return this.value%1===0?this.value.toFixed(1):this.value.toString()}},Ce=class extends Ge{constructor(){super(...arguments);fe(this,"type","StringValue");fe(this,"builtins",new Map([["upper",new Be(()=>new Ce(this.value.toUpperCase()))],["lower",new Be(()=>new Ce(this.value.toLowerCase()))],["strip",new Be(()=>new Ce(this.value.trim()))],["title",new Be(()=>new Ce(ze(this.value)))],["capitalize",new Be(()=>new Ce(this.value.charAt(0).toUpperCase()+this.value.slice(1)))],["length",new $e(this.value.length)],["rstrip",new Be(()=>new Ce(this.value.trimEnd()))],["lstrip",new Be(()=>new Ce(this.value.trimStart()))],["startswith",new Be(oe=>{if(oe.length===0)throw new Error("startswith() requires at least one argument");const K=oe[0];if(K instanceof Ce)return new He(this.value.startsWith(K.value));if(K instanceof ye){for(const re of K.value){if(!(re instanceof Ce))throw new Error("startswith() tuple elements must be strings");if(this.value.startsWith(re.value))return new He(!0)}return new He(!1)}throw new Error("startswith() argument must be a string or tuple of strings")})],["endswith",new Be(oe=>{if(oe.length===0)throw new Error("endswith() requires at least one argument");const K=oe[0];if(K instanceof Ce)return new He(this.value.endsWith(K.value));if(K instanceof ye){for(const re of K.value){if(!(re instanceof Ce))throw new Error("endswith() tuple elements must be strings");if(this.value.endsWith(re.value))return new He(!0)}return new He(!1)}throw new Error("endswith() argument must be a string or tuple of strings")})],["split",new Be(oe=>{const K=oe[0]??new Se;if(!(K instanceof Ce||K instanceof Se))throw new Error("sep argument must be a string or null");const re=oe[1]??new $e(-1);if(!(re instanceof $e))throw new Error("maxsplit argument must be a number");let de=[];if(K instanceof Se){const xe=this.value.trimStart();for(const{0:Ue,index:_t}of xe.matchAll(/\S+/g)){if(re.value!==-1&&de.length>=re.value&&_t!==void 0){de.push(Ue+xe.slice(_t+Ue.length));break}de.push(Ue)}}else{if(K.value==="")throw new Error("empty separator");de=this.value.split(K.value),re.value!==-1&&de.length>re.value&&de.push(de.splice(re.value).join(K.value))}return new ye(de.map(xe=>new Ce(xe)))})],["replace",new Be(oe=>{if(oe.length<2)throw new Error("replace() requires at least two arguments");const K=oe[0],re=oe[1];if(!(K instanceof Ce&&re instanceof Ce))throw new Error("replace() arguments must be strings");let de;if(oe.length>2?oe[2].type==="KeywordArgumentsValue"?de=oe[2].value.get("count")??new Se:de=oe[2]:de=new Se,!(de instanceof $e||de instanceof Se))throw new Error("replace() count argument must be a number or null");return new Ce(Pe(this.value,K.value,re.value,de.value))})]]))}},He=class extends Ge{constructor(){super(...arguments);fe(this,"type","BooleanValue")}};function at(L,oe,K,re=!0){const de=K??0;switch(L.type){case"NullValue":return"null";case"UndefinedValue":return re?"null":"undefined";case"IntegerValue":case"FloatValue":case"StringValue":case"BooleanValue":return JSON.stringify(L.value);case"ArrayValue":case"ObjectValue":{const xe=oe?" ".repeat(oe):"",Ue=`
`+xe.repeat(de),_t=Ue+xe;if(L.type==="ArrayValue"){const $t=L.value.map(mt=>at(mt,oe,de+1,re));return oe?`[${_t}${$t.join(`,${_t}`)}${Ue}]`:`[${$t.join(", ")}]`}else{const $t=Array.from(L.value.entries()).map(([mt,Ht])=>{const It=`"${mt}": ${at(Ht,oe,de+1,re)}`;return oe?`${_t}${It}`:It});return oe?`{${$t.join(",")}${Ue}}`:`{${$t.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${L.type}`)}}var Z=class extends Ge{constructor(){super(...arguments);fe(this,"type","ObjectValue");fe(this,"builtins",new Map([["get",new Be(([oe,K])=>{if(!(oe instanceof Ce))throw new Error(`Object key must be a string: got ${oe.type}`);return this.value.get(oe.value)??K??new Se})],["items",new Be(()=>this.items())],["keys",new Be(()=>this.keys())],["values",new Be(()=>this.values())],["dictsort",new Be(oe=>{let K=new Map;const re=oe.filter($t=>$t instanceof he?(K=$t.value,!1):!0),de=re.at(0)??K.get("case_sensitive")??new He(!1);if(!(de instanceof He))throw new Error("case_sensitive must be a boolean");const xe=re.at(1)??K.get("by")??new Ce("key");if(!(xe instanceof Ce))throw new Error("by must be a string");if(!["key","value"].includes(xe.value))throw new Error("by must be either 'key' or 'value'");const Ue=re.at(2)??K.get("reverse")??new He(!1);if(!(Ue instanceof He))throw new Error("reverse must be a boolean");const _t=Array.from(this.value.entries()).map(([$t,mt])=>new ye([new Ce($t),mt])).sort(($t,mt)=>{const Ht=xe.value==="key"?0:1,It=$t.value[Ht],Zt=mt.value[Ht],St=Et(It,Zt,de.value);return Ue.value?-St:St});return new ye(_t)})]]))}__bool__(){return new He(this.value.size>0)}items(){return new ye(Array.from(this.value.entries()).map(([oe,K])=>new ye([new Ce(oe),K])))}keys(){return new ye(Array.from(this.value.keys()).map(oe=>new Ce(oe)))}values(){return new ye(Array.from(this.value.values()))}toString(){return at(this,null,0,!1)}},he=class extends Z{constructor(){super(...arguments);fe(this,"type","KeywordArgumentsValue")}},ye=class extends Ge{constructor(){super(...arguments);fe(this,"type","ArrayValue");fe(this,"builtins",new Map([["length",new $e(this.value.length)]]))}__bool__(){return new He(this.value.length>0)}toString(){return at(this,null,0,!1)}},Ke=class extends ye{constructor(){super(...arguments);fe(this,"type","TupleValue")}},Be=class extends Ge{constructor(){super(...arguments);fe(this,"type","FunctionValue")}},Se=class extends Ge{constructor(){super(...arguments);fe(this,"type","NullValue")}},Oe=class extends Ge{constructor(){super(...arguments);fe(this,"type","UndefinedValue")}},ct=class{constructor(L){fe(this,"variables",new Map([["namespace",new Be(L=>{if(L.length===0)return new Z(new Map);if(L.length!==1||!(L[0]instanceof Z))throw new Error("`namespace` expects either zero arguments or a single object argument");return L[0]})]]));fe(this,"tests",new Map([["boolean",L=>L.type==="BooleanValue"],["callable",L=>L instanceof Be],["odd",L=>{if(!(L instanceof $e))throw new Error(`cannot odd on ${L.type}`);return L.value%2!==0}],["even",L=>{if(!(L instanceof $e))throw new Error(`cannot even on ${L.type}`);return L.value%2===0}],["false",L=>L.type==="BooleanValue"&&!L.value],["true",L=>L.type==="BooleanValue"&&L.value],["none",L=>L.type==="NullValue"],["string",L=>L.type==="StringValue"],["number",L=>L instanceof $e||L instanceof et],["integer",L=>L instanceof $e],["iterable",L=>L.type==="ArrayValue"||L.type==="StringValue"],["mapping",L=>L.type==="ObjectValue"],["lower",L=>{const oe=L.value;return L.type==="StringValue"&&oe===oe.toLowerCase()}],["upper",L=>{const oe=L.value;return L.type==="StringValue"&&oe===oe.toUpperCase()}],["none",L=>L.type==="NullValue"],["defined",L=>L.type!=="UndefinedValue"],["undefined",L=>L.type==="UndefinedValue"],["equalto",(L,oe)=>L.value===oe.value],["eq",(L,oe)=>L.value===oe.value]]));this.parent=L}set(L,oe){return this.declareVariable(L,En(oe))}declareVariable(L,oe){if(this.variables.has(L))throw new SyntaxError(`Variable already declared: ${L}`);return this.variables.set(L,oe),oe}setVariable(L,oe){return this.variables.set(L,oe),oe}resolve(L){if(this.variables.has(L))return this;if(this.parent)return this.parent.resolve(L);throw new Error(`Unknown variable: ${L}`)}lookupVariable(L){try{return this.resolve(L).variables.get(L)??new Oe}catch{return new Oe}}};function bt(L){L.set("false",!1),L.set("true",!0),L.set("none",null),L.set("raise_exception",oe=>{throw new Error(oe)}),L.set("range",Ne),L.set("strftime_now",ue),L.set("True",!0),L.set("False",!1),L.set("None",null)}function Ct(L,oe){const K=oe.split(".");let re=L;for(const de of K)if(re instanceof Z)re=re.value.get(de)??new Oe;else if(re instanceof ye){const xe=parseInt(de,10);if(!isNaN(xe)&&xe>=0&&xe<re.value.length)re=re.value[xe];else return new Oe}else return new Oe;return re}function Et(L,oe,K=!1){if(L instanceof Se&&oe instanceof Se)return 0;if(L instanceof Se||oe instanceof Se)throw new Error(`Cannot compare ${L.type} with ${oe.type}`);if(L instanceof Oe&&oe instanceof Oe)return 0;if(L instanceof Oe||oe instanceof Oe)throw new Error(`Cannot compare ${L.type} with ${oe.type}`);const re=xe=>xe instanceof $e||xe instanceof et||xe instanceof He,de=xe=>xe instanceof He?xe.value?1:0:xe.value;if(re(L)&&re(oe)){const xe=de(L),Ue=de(oe);return xe<Ue?-1:xe>Ue?1:0}if(L.type!==oe.type)throw new Error(`Cannot compare different types: ${L.type} and ${oe.type}`);switch(L.type){case"StringValue":{let xe=L.value,Ue=oe.value;return K||(xe=xe.toLowerCase(),Ue=Ue.toLowerCase()),xe<Ue?-1:xe>Ue?1:0}default:throw new Error(`Cannot compare type: ${L.type}`)}}var hn=class{constructor(L){fe(this,"global");this.global=L??new ct}run(L){return this.evaluate(L,this.global)}evaluateBinaryExpression(L,oe){const K=this.evaluate(L.left,oe);switch(L.operator.value){case"and":return K.__bool__().value?this.evaluate(L.right,oe):K;case"or":return K.__bool__().value?K:this.evaluate(L.right,oe)}const re=this.evaluate(L.right,oe);switch(L.operator.value){case"==":return new He(K.value==re.value);case"!=":return new He(K.value!=re.value)}if(K instanceof Oe||re instanceof Oe){if(re instanceof Oe&&["in","not in"].includes(L.operator.value))return new He(L.operator.value==="not in");throw new Error(`Cannot perform operation ${L.operator.value} on undefined values`)}else{if(K instanceof Se||re instanceof Se)throw new Error("Cannot perform operation on null values");if(L.operator.value==="~")return new Ce(K.value.toString()+re.value.toString());if((K instanceof $e||K instanceof et)&&(re instanceof $e||re instanceof et)){const de=K.value,xe=re.value;switch(L.operator.value){case"+":case"-":case"*":{const Ue=L.operator.value==="+"?de+xe:L.operator.value==="-"?de-xe:de*xe;return K instanceof et||re instanceof et?new et(Ue):new $e(Ue)}case"/":return new et(de/xe);case"%":{const Ue=de%xe;return K instanceof et||re instanceof et?new et(Ue):new $e(Ue)}case"<":return new He(de<xe);case">":return new He(de>xe);case">=":return new He(de>=xe);case"<=":return new He(de<=xe)}}else if(K instanceof ye&&re instanceof ye)switch(L.operator.value){case"+":return new ye(K.value.concat(re.value))}else if(re instanceof ye){const de=re.value.find(xe=>xe.value===K.value)!==void 0;switch(L.operator.value){case"in":return new He(de);case"not in":return new He(!de)}}}if(K instanceof Ce||re instanceof Ce)switch(L.operator.value){case"+":return new Ce(K.value.toString()+re.value.toString())}if(K instanceof Ce&&re instanceof Ce)switch(L.operator.value){case"in":return new He(re.value.includes(K.value));case"not in":return new He(!re.value.includes(K.value))}if(K instanceof Ce&&re instanceof Z)switch(L.operator.value){case"in":return new He(re.value.has(K.value));case"not in":return new He(!re.value.has(K.value))}throw new SyntaxError(`Unknown operator "${L.operator.value}" between ${K.type} and ${re.type}`)}evaluateArguments(L,oe){const K=[],re=new Map;for(const de of L)if(de.type==="SpreadExpression"){const xe=de,Ue=this.evaluate(xe.argument,oe);if(!(Ue instanceof ye))throw new Error(`Cannot unpack non-iterable type: ${Ue.type}`);for(const _t of Ue.value)K.push(_t)}else if(de.type==="KeywordArgumentExpression"){const xe=de;re.set(xe.key.value,this.evaluate(xe.value,oe))}else{if(re.size>0)throw new Error("Positional arguments must come before keyword arguments");K.push(this.evaluate(de,oe))}return[K,re]}applyFilter(L,oe,K){if(oe.type==="Identifier"){const re=oe;if(re.value==="tojson")return new Ce(at(L));if(L instanceof ye)switch(re.value){case"list":return L;case"first":return L.value[0];case"last":return L.value[L.value.length-1];case"length":return new $e(L.value.length);case"reverse":return new ye(L.value.slice().reverse());case"sort":return new ye(L.value.slice().sort((de,xe)=>Et(de,xe,!1)));case"join":return new Ce(L.value.map(de=>de.value).join(""));case"string":return new Ce(at(L,null,0,!1));case"unique":{const de=new Set,xe=[];for(const Ue of L.value)de.has(Ue.value)||(de.add(Ue.value),xe.push(Ue));return new ye(xe)}default:throw new Error(`Unknown ArrayValue filter: ${re.value}`)}else if(L instanceof Ce)switch(re.value){case"length":case"upper":case"lower":case"title":case"capitalize":{const de=L.builtins.get(re.value);if(de instanceof Be)return de.value([],K);if(de instanceof $e)return de;throw new Error(`Unknown StringValue filter: ${re.value}`)}case"trim":return new Ce(L.value.trim());case"indent":return new Ce(L.value.split(`
`).map((de,xe)=>xe===0||de.length===0?de:"    "+de).join(`
`));case"join":case"string":return L;case"int":{const de=parseInt(L.value,10);return new $e(isNaN(de)?0:de)}case"float":{const de=parseFloat(L.value);return new et(isNaN(de)?0:de)}default:throw new Error(`Unknown StringValue filter: ${re.value}`)}else if(L instanceof $e||L instanceof et)switch(re.value){case"abs":return L instanceof $e?new $e(Math.abs(L.value)):new et(Math.abs(L.value));case"int":return new $e(Math.floor(L.value));case"float":return new et(L.value);default:throw new Error(`Unknown NumericValue filter: ${re.value}`)}else if(L instanceof Z)switch(re.value){case"items":return new ye(Array.from(L.value.entries()).map(([de,xe])=>new ye([new Ce(de),xe])));case"length":return new $e(L.value.size);default:{const de=L.builtins.get(re.value);if(de)return de instanceof Be?de.value([],K):de;throw new Error(`Unknown ObjectValue filter: ${re.value}`)}}else if(L instanceof He)switch(re.value){case"bool":return new He(L.value);case"int":return new $e(L.value?1:0);case"float":return new et(L.value?1:0);case"string":return new Ce(L.value?"true":"false");default:throw new Error(`Unknown BooleanValue filter: ${re.value}`)}throw new Error(`Cannot apply filter "${re.value}" to type: ${L.type}`)}else if(oe.type==="CallExpression"){const re=oe;if(re.callee.type!=="Identifier")throw new Error(`Unknown filter: ${re.callee.type}`);const de=re.callee.value;if(de==="tojson"){const[,xe]=this.evaluateArguments(re.args,K),Ue=xe.get("indent")??new Se;if(!(Ue instanceof $e||Ue instanceof Se))throw new Error("If set, indent must be a number");return new Ce(at(L,Ue.value))}else if(de==="join"){let xe;if(L instanceof Ce)xe=Array.from(L.value);else if(L instanceof ye)xe=L.value.map(mt=>mt.value);else throw new Error(`Cannot apply filter "${de}" to type: ${L.type}`);const[Ue,_t]=this.evaluateArguments(re.args,K),$t=Ue.at(0)??_t.get("separator")??new Ce("");if(!($t instanceof Ce))throw new Error("separator must be a string");return new Ce(xe.join($t.value))}else if(de==="int"||de==="float"){const[xe,Ue]=this.evaluateArguments(re.args,K),_t=xe.at(0)??Ue.get("default")??(de==="int"?new $e(0):new et(0));if(L instanceof Ce){const $t=de==="int"?parseInt(L.value,10):parseFloat(L.value);return isNaN($t)?_t:de==="int"?new $e($t):new et($t)}else{if(L instanceof $e||L instanceof et)return L;if(L instanceof He)return de==="int"?new $e(L.value?1:0):new et(L.value?1:0);throw new Error(`Cannot apply filter "${de}" to type: ${L.type}`)}}else if(de==="default"){const[xe,Ue]=this.evaluateArguments(re.args,K),_t=xe[0]??new Ce(""),$t=xe[1]??Ue.get("boolean")??new He(!1);if(!($t instanceof He))throw new Error("`default` filter flag must be a boolean");return L instanceof Oe||$t.value&&!L.__bool__().value?_t:L}if(L instanceof ye){switch(de){case"sort":{const[xe,Ue]=this.evaluateArguments(re.args,K),_t=xe.at(0)??Ue.get("reverse")??new He(!1);if(!(_t instanceof He))throw new Error("reverse must be a boolean");const $t=xe.at(1)??Ue.get("case_sensitive")??new He(!1);if(!($t instanceof He))throw new Error("case_sensitive must be a boolean");const mt=xe.at(2)??Ue.get("attribute")??new Se;if(!(mt instanceof Ce||mt instanceof $e||mt instanceof Se))throw new Error("attribute must be a string, integer, or null");const Ht=It=>{if(mt instanceof Se)return It;const Zt=mt instanceof $e?String(mt.value):mt.value;return Ct(It,Zt)};return new ye(L.value.slice().sort((It,Zt)=>{const St=Ht(It),tn=Ht(Zt),vn=Et(St,tn,$t.value);return _t.value?-vn:vn}))}case"selectattr":case"rejectattr":{const xe=de==="selectattr";if(L.value.some(It=>!(It instanceof Z)))throw new Error(`\`${de}\` can only be applied to array of objects`);if(re.args.some(It=>It.type!=="StringLiteral"))throw new Error(`arguments of \`${de}\` must be strings`);const[Ue,_t,$t]=re.args.map(It=>this.evaluate(It,K));let mt;if(_t){const It=K.tests.get(_t.value);if(!It)throw new Error(`Unknown test: ${_t.value}`);mt=It}else mt=(...It)=>It[0].__bool__().value;const Ht=L.value.filter(It=>{const Zt=It.value.get(Ue.value),St=Zt?mt(Zt,$t):!1;return xe?St:!St});return new ye(Ht)}case"map":{const[,xe]=this.evaluateArguments(re.args,K);if(xe.has("attribute")){const Ue=xe.get("attribute");if(!(Ue instanceof Ce))throw new Error("attribute must be a string");const _t=xe.get("default"),$t=L.value.map(mt=>{if(!(mt instanceof Z))throw new Error("items in map must be an object");const Ht=Ct(mt,Ue.value);return Ht instanceof Oe?_t??new Oe:Ht});return new ye($t)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${de}`)}else if(L instanceof Ce){switch(de){case"indent":{const[xe,Ue]=this.evaluateArguments(re.args,K),_t=xe.at(0)??Ue.get("width")??new $e(4);if(!(_t instanceof $e))throw new Error("width must be a number");const $t=xe.at(1)??Ue.get("first")??new He(!1),mt=xe.at(2)??Ue.get("blank")??new He(!1),Ht=L.value.split(`
`),It=" ".repeat(_t.value),Zt=Ht.map((St,tn)=>!$t.value&&tn===0||!mt.value&&St.length===0?St:It+St);return new Ce(Zt.join(`
`))}case"replace":{const xe=L.builtins.get("replace");if(!(xe instanceof Be))throw new Error("replace filter not available");const[Ue,_t]=this.evaluateArguments(re.args,K);return xe.value([...Ue,new he(_t)],K)}}throw new Error(`Unknown StringValue filter: ${de}`)}else if(L instanceof Z){const xe=L.builtins.get(de);if(xe&&xe instanceof Be){const[Ue,_t]=this.evaluateArguments(re.args,K);return _t.size>0&&Ue.push(new he(_t)),xe.value(Ue,K)}throw new Error(`Unknown ObjectValue filter: ${de}`)}else throw new Error(`Cannot apply filter "${de}" to type: ${L.type}`)}throw new Error(`Unknown filter: ${oe.type}`)}evaluateFilterExpression(L,oe){const K=this.evaluate(L.operand,oe);return this.applyFilter(K,L.filter,oe)}evaluateTestExpression(L,oe){const K=this.evaluate(L.operand,oe),re=oe.tests.get(L.test.value);if(!re)throw new Error(`Unknown test: ${L.test.value}`);const de=re(K);return new He(L.negate?!de:de)}evaluateSelectExpression(L,oe){return this.evaluate(L.test,oe).__bool__().value?this.evaluate(L.lhs,oe):new Oe}evaluateUnaryExpression(L,oe){const K=this.evaluate(L.argument,oe);switch(L.operator.value){case"not":return new He(!K.value);default:throw new SyntaxError(`Unknown operator: ${L.operator.value}`)}}evaluateTernaryExpression(L,oe){return this.evaluate(L.condition,oe).__bool__().value?this.evaluate(L.trueExpr,oe):this.evaluate(L.falseExpr,oe)}evalProgram(L,oe){return this.evaluateBlock(L.body,oe)}evaluateBlock(L,oe){let K="";for(const re of L){const de=this.evaluate(re,oe);de.type!=="NullValue"&&de.type!=="UndefinedValue"&&(K+=de.toString())}return new Ce(K)}evaluateIdentifier(L,oe){return oe.lookupVariable(L.value)}evaluateCallExpression(L,oe){const[K,re]=this.evaluateArguments(L.args,oe);re.size>0&&K.push(new he(re));const de=this.evaluate(L.callee,oe);if(de.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${de.type}`);return de.value(K,oe)}evaluateSliceExpression(L,oe,K){if(!(L instanceof ye||L instanceof Ce))throw new Error("Slice object must be an array or string");const re=this.evaluate(oe.start,K),de=this.evaluate(oe.stop,K),xe=this.evaluate(oe.step,K);if(!(re instanceof $e||re instanceof Oe))throw new Error("Slice start must be numeric or undefined");if(!(de instanceof $e||de instanceof Oe))throw new Error("Slice stop must be numeric or undefined");if(!(xe instanceof $e||xe instanceof Oe))throw new Error("Slice step must be numeric or undefined");return L instanceof ye?new ye(Ye(L.value,re.value,de.value,xe.value)):new Ce(Ye(Array.from(L.value),re.value,de.value,xe.value).join(""))}evaluateMemberExpression(L,oe){const K=this.evaluate(L.object,oe);let re;if(L.computed){if(L.property.type==="SliceExpression")return this.evaluateSliceExpression(K,L.property,oe);re=this.evaluate(L.property,oe)}else re=new Ce(L.property.value);let de;if(K instanceof Z){if(!(re instanceof Ce))throw new Error(`Cannot access property with non-string: got ${re.type}`);de=K.value.get(re.value)??K.builtins.get(re.value)}else if(K instanceof ye||K instanceof Ce)if(re instanceof $e)de=K.value.at(re.value),K instanceof Ce&&(de=new Ce(K.value.at(re.value)));else if(re instanceof Ce)de=K.builtins.get(re.value);else throw new Error(`Cannot access property with non-string/non-number: got ${re.type}`);else{if(!(re instanceof Ce))throw new Error(`Cannot access property with non-string: got ${re.type}`);de=K.builtins.get(re.value)}return de instanceof Ge?de:new Oe}evaluateSet(L,oe){const K=L.value?this.evaluate(L.value,oe):this.evaluateBlock(L.body,oe);if(L.assignee.type==="Identifier"){const re=L.assignee.value;oe.setVariable(re,K)}else if(L.assignee.type==="TupleLiteral"){const re=L.assignee;if(!(K instanceof ye))throw new Error(`Cannot unpack non-iterable type in set: ${K.type}`);const de=K.value;if(de.length!==re.value.length)throw new Error(`Too ${re.value.length>de.length?"few":"many"} items to unpack in set`);for(let xe=0;xe<re.value.length;++xe){const Ue=re.value[xe];if(Ue.type!=="Identifier")throw new Error(`Cannot unpack to non-identifier in set: ${Ue.type}`);oe.setVariable(Ue.value,de[xe])}}else if(L.assignee.type==="MemberExpression"){const re=L.assignee,de=this.evaluate(re.object,oe);if(!(de instanceof Z))throw new Error("Cannot assign to member of non-object");if(re.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");de.value.set(re.property.value,K)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(L.assignee)}`);return new Se}evaluateIf(L,oe){const K=this.evaluate(L.test,oe);return this.evaluateBlock(K.__bool__().value?L.body:L.alternate,oe)}evaluateFor(L,oe){const K=new ct(oe);let re,de;if(L.iterable.type==="SelectExpression"){const mt=L.iterable;de=this.evaluate(mt.lhs,K),re=mt.test}else de=this.evaluate(L.iterable,K);if(!(de instanceof ye||de instanceof Z))throw new Error(`Expected iterable or object type in for loop: got ${de.type}`);de instanceof Z&&(de=de.keys());const xe=[],Ue=[];for(let mt=0;mt<de.value.length;++mt){const Ht=new ct(K),It=de.value[mt];let Zt;if(L.loopvar.type==="Identifier")Zt=St=>St.setVariable(L.loopvar.value,It);else if(L.loopvar.type==="TupleLiteral"){const St=L.loopvar;if(It.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${It.type}`);const tn=It;if(St.value.length!==tn.value.length)throw new Error(`Too ${St.value.length>tn.value.length?"few":"many"} items to unpack`);Zt=vn=>{for(let Wn=0;Wn<St.value.length;++Wn){if(St.value[Wn].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${St.value[Wn].type}`);vn.setVariable(St.value[Wn].value,tn.value[Wn])}}}else throw new Error(`Invalid loop variable(s): ${L.loopvar.type}`);re&&(Zt(Ht),!this.evaluate(re,Ht).__bool__().value)||(xe.push(It),Ue.push(Zt))}let _t="",$t=!0;for(let mt=0;mt<xe.length;++mt){const Ht=new Map([["index",new $e(mt+1)],["index0",new $e(mt)],["revindex",new $e(xe.length-mt)],["revindex0",new $e(xe.length-mt-1)],["first",new He(mt===0)],["last",new He(mt===xe.length-1)],["length",new $e(xe.length)],["previtem",mt>0?xe[mt-1]:new Oe],["nextitem",mt<xe.length-1?xe[mt+1]:new Oe]]);K.setVariable("loop",new Z(Ht)),Ue[mt](K);try{const It=this.evaluateBlock(L.body,K);_t+=It.value}catch(It){if(It instanceof Le)continue;if(It instanceof ke)break;throw It}$t=!1}if($t){const mt=this.evaluateBlock(L.defaultBlock,K);_t+=mt.value}return new Ce(_t)}evaluateMacro(L,oe){return oe.setVariable(L.name.value,new Be((K,re)=>{var Ue;const de=new ct(re);K=K.slice();let xe;((Ue=K.at(-1))==null?void 0:Ue.type)==="KeywordArgumentsValue"&&(xe=K.pop());for(let _t=0;_t<L.args.length;++_t){const $t=L.args[_t],mt=K[_t];if($t.type==="Identifier"){const Ht=$t;if(!mt)throw new Error(`Missing positional argument: ${Ht.value}`);de.setVariable(Ht.value,mt)}else if($t.type==="KeywordArgumentExpression"){const Ht=$t,It=mt??(xe==null?void 0:xe.value.get(Ht.key.value))??this.evaluate(Ht.value,de);de.setVariable(Ht.key.value,It)}else throw new Error(`Unknown argument type: ${$t.type}`)}return this.evaluateBlock(L.body,de)})),new Se}evaluateCallStatement(L,oe){const K=new Be((_t,$t)=>{const mt=new ct($t);if(L.callerArgs)for(let Ht=0;Ht<L.callerArgs.length;++Ht){const It=L.callerArgs[Ht];if(It.type!=="Identifier")throw new Error(`Caller parameter must be an identifier, got ${It.type}`);mt.setVariable(It.value,_t[Ht]??new Oe)}return this.evaluateBlock(L.body,mt)}),[re,de]=this.evaluateArguments(L.call.args,oe);re.push(new he(de));const xe=this.evaluate(L.call.callee,oe);if(xe.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${xe.type}`);const Ue=new ct(oe);return Ue.setVariable("caller",K),xe.value(re,Ue)}evaluateFilterStatement(L,oe){const K=this.evaluateBlock(L.body,oe);return this.applyFilter(K,L.filter,oe)}evaluate(L,oe){if(!L)return new Oe;switch(L.type){case"Program":return this.evalProgram(L,oe);case"Set":return this.evaluateSet(L,oe);case"If":return this.evaluateIf(L,oe);case"For":return this.evaluateFor(L,oe);case"Macro":return this.evaluateMacro(L,oe);case"CallStatement":return this.evaluateCallStatement(L,oe);case"Break":throw new ke;case"Continue":throw new Le;case"IntegerLiteral":return new $e(L.value);case"FloatLiteral":return new et(L.value);case"StringLiteral":return new Ce(L.value);case"ArrayLiteral":return new ye(L.value.map(K=>this.evaluate(K,oe)));case"TupleLiteral":return new Ke(L.value.map(K=>this.evaluate(K,oe)));case"ObjectLiteral":{const K=new Map;for(const[re,de]of L.value){const xe=this.evaluate(re,oe);if(!(xe instanceof Ce))throw new Error(`Object keys must be strings: got ${xe.type}`);K.set(xe.value,this.evaluate(de,oe))}return new Z(K)}case"Identifier":return this.evaluateIdentifier(L,oe);case"CallExpression":return this.evaluateCallExpression(L,oe);case"MemberExpression":return this.evaluateMemberExpression(L,oe);case"UnaryExpression":return this.evaluateUnaryExpression(L,oe);case"BinaryExpression":return this.evaluateBinaryExpression(L,oe);case"FilterExpression":return this.evaluateFilterExpression(L,oe);case"FilterStatement":return this.evaluateFilterStatement(L,oe);case"TestExpression":return this.evaluateTestExpression(L,oe);case"SelectExpression":return this.evaluateSelectExpression(L,oe);case"Ternary":return this.evaluateTernaryExpression(L,oe);case"Comment":return new Se;default:throw new SyntaxError(`Unknown node type: ${L.type}`)}}};function En(L){switch(typeof L){case"number":return Number.isInteger(L)?new $e(L):new et(L);case"string":return new Ce(L);case"boolean":return new He(L);case"undefined":return new Oe;case"object":return L===null?new Se:Array.isArray(L)?new ye(L.map(En)):new Z(new Map(Object.entries(L).map(([oe,K])=>[oe,En(K)])));case"function":return new Be((oe,K)=>{const re=L(...oe.map(de=>de.value))??null;return En(re)});default:throw new Error(`Cannot convert to runtime value: ${L}`)}}var Kt=`
`,yi="{%- ",Ji=" -%}";function tr(L){switch(L.operator.type){case"MultiplicativeBinaryOperator":return 4;case"AdditiveBinaryOperator":return 3;case"ComparisonBinaryOperator":return 2;case"Identifier":return L.operator.value==="and"?1:L.operator.value==="in"||L.operator.value==="not in"?2:0}return 0}function Ti(L,oe="	"){const K=typeof oe=="number"?" ".repeat(oe):oe;return $n(L.body,0,K).replace(/\n$/,"")}function Yn(...L){return yi+L.join(" ")+Ji}function $n(L,oe,K){return L.map(re=>Yi(re,oe,K)).join(Kt)}function Yi(L,oe,K){const re=K.repeat(oe);switch(L.type){case"Program":return $n(L.body,oe,K);case"If":return Gi(L,oe,K);case"For":return xt(L,oe,K);case"Set":return ji(L,oe,K);case"Macro":return Wi(L,oe,K);case"Break":return re+Yn("break");case"Continue":return re+Yn("continue");case"CallStatement":return Sn(L,oe,K);case"FilterStatement":return Ii(L,oe,K);case"Comment":return re+"{# "+L.value+" #}";default:return re+"{{- "+Xt(L)+" -}}"}}function Gi(L,oe,K){const re=K.repeat(oe),de=[];let xe=L;for(;xe&&(de.push({test:xe.test,body:xe.body}),xe.alternate.length===1&&xe.alternate[0].type==="If");)xe=xe.alternate[0];let Ue=re+Yn("if",Xt(de[0].test))+Kt+$n(de[0].body,oe+1,K);for(let _t=1;_t<de.length;++_t)Ue+=Kt+re+Yn("elif",Xt(de[_t].test))+Kt+$n(de[_t].body,oe+1,K);return xe&&xe.alternate.length>0&&(Ue+=Kt+re+Yn("else")+Kt+$n(xe.alternate,oe+1,K)),Ue+=Kt+re+Yn("endif"),Ue}function xt(L,oe,K){const re=K.repeat(oe);let de="";if(L.iterable.type==="SelectExpression"){const Ue=L.iterable;de=`${Xt(Ue.lhs)} if ${Xt(Ue.test)}`}else de=Xt(L.iterable);let xe=re+Yn("for",Xt(L.loopvar),"in",de)+Kt+$n(L.body,oe+1,K);return L.defaultBlock.length>0&&(xe+=Kt+re+Yn("else")+Kt+$n(L.defaultBlock,oe+1,K)),xe+=Kt+re+Yn("endfor"),xe}function ji(L,oe,K){const re=K.repeat(oe),de=Xt(L.assignee),xe=L.value?Xt(L.value):"",Ue=re+Yn("set",`${de}${L.value?" = "+xe:""}`);return L.body.length===0?Ue:Ue+Kt+$n(L.body,oe+1,K)+Kt+re+Yn("endset")}function Wi(L,oe,K){const re=K.repeat(oe),de=L.args.map(Xt).join(", ");return re+Yn("macro",`${L.name.value}(${de})`)+Kt+$n(L.body,oe+1,K)+Kt+re+Yn("endmacro")}function Sn(L,oe,K){const re=K.repeat(oe),de=L.callerArgs&&L.callerArgs.length>0?`(${L.callerArgs.map(Xt).join(", ")})`:"",xe=Xt(L.call);let Ue=re+Yn(`call${de}`,xe)+Kt;return Ue+=$n(L.body,oe+1,K)+Kt,Ue+=re+Yn("endcall"),Ue}function Ii(L,oe,K){const re=K.repeat(oe),de=L.filter.type==="Identifier"?L.filter.value:Xt(L.filter);let xe=re+Yn("filter",de)+Kt;return xe+=$n(L.body,oe+1,K)+Kt,xe+=re+Yn("endfilter"),xe}function Xt(L,oe=-1){switch(L.type){case"SpreadExpression":return`*${Xt(L.argument)}`;case"Identifier":return L.value;case"IntegerLiteral":return`${L.value}`;case"FloatLiteral":return`${L.value}`;case"StringLiteral":return JSON.stringify(L.value);case"BinaryExpression":{const K=L,re=tr(K),de=Xt(K.left,re),xe=Xt(K.right,re+1),Ue=`${de} ${K.operator.value} ${xe}`;return re<oe?`(${Ue})`:Ue}case"UnaryExpression":{const K=L;return K.operator.value+(K.operator.value==="not"?" ":"")+Xt(K.argument,1/0)}case"CallExpression":{const K=L,re=K.args.map(Xt).join(", ");return`${Xt(K.callee)}(${re})`}case"MemberExpression":{const K=L;let re=Xt(K.object);["Identifier","MemberExpression","CallExpression","StringLiteral","IntegerLiteral","FloatLiteral","ArrayLiteral","TupleLiteral","ObjectLiteral"].includes(K.object.type)||(re=`(${re})`);let de=Xt(K.property);return!K.computed&&K.property.type!=="Identifier"&&(de=`(${de})`),K.computed?`${re}[${de}]`:`${re}.${de}`}case"FilterExpression":{const K=L,re=Xt(K.operand,1/0);return K.filter.type==="CallExpression"?`${re} | ${Xt(K.filter)}`:`${re} | ${K.filter.value}`}case"SelectExpression":{const K=L;return`${Xt(K.lhs)} if ${Xt(K.test)}`}case"TestExpression":{const K=L;return`${Xt(K.operand)} is${K.negate?" not":""} ${K.test.value}`}case"ArrayLiteral":case"TupleLiteral":{const K=L.value.map(Xt),re=L.type==="ArrayLiteral"?"[]":"()";return`${re[0]}${K.join(", ")}${re[1]}`}case"ObjectLiteral":return`{${Array.from(L.value.entries()).map(([re,de])=>`${Xt(re)}: ${Xt(de)}`).join(", ")}}`;case"SliceExpression":{const K=L,re=K.start?Xt(K.start):"",de=K.stop?Xt(K.stop):"",xe=K.step?`:${Xt(K.step)}`:"";return`${re}:${de}${xe}`}case"KeywordArgumentExpression":{const K=L;return`${K.key.value}=${Xt(K.value)}`}case"Ternary":{const K=L,re=`${Xt(K.trueExpr)} if ${Xt(K.condition,0)} else ${Xt(K.falseExpr)}`;return oe>-1?`(${re})`:re}default:throw new Error(`Unknown expression type: ${L.type}`)}}var nr=class{constructor(L){fe(this,"parsed");const oe=f(L,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=ae(oe)}render(L){const oe=new ct;if(bt(oe),L)for(const[de,xe]of Object.entries(L))oe.set(de,xe);return new hn(oe).run(this.parsed).value}format(L){return Ti(this.parsed,(L==null?void 0:L.indent)||"	")}}},"./src/backends/onnx.js":(e,t,n)=>{var i;n.r(t),n.d(t,{Tensor:()=>o.Tensor,createInferenceSession:()=>M,deviceToExecutionProviders:()=>m,isONNXProxy:()=>$,isONNXTensor:()=>x,runInferenceSession:()=>T});var r=n("./src/env.js"),s=n("?2ce3"),a=n("onnxruntime-web"),o=n("onnxruntime-common");const l=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),u=[];let c,f;const d=Symbol.for("onnxruntime");if(d in globalThis)f=globalThis[d];else if(r.apis.IS_NODE_ENV){switch(f=s??(i||(i=n.t(s,2))),process.platform){case"win32":u.push("dml");break;case"linux":process.arch==="x64"&&u.push("cuda");break}u.push("cpu"),c=["cpu"]}else f=a,r.apis.IS_WEBNN_AVAILABLE&&u.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),r.apis.IS_WEBGPU_AVAILABLE&&u.push("webgpu"),u.push("wasm"),c=["wasm"];const h=f.InferenceSession;function m(C=null){if(!C)return c;switch(C){case"auto":return u;case"gpu":return u.filter(P=>["webgpu","cuda","dml","webnn-gpu"].includes(P))}if(u.includes(C))return[l[C]??C];throw new Error(`Unsupported device: "${C}". Should be one of: ${u.join(", ")}.`)}let y=null;async function M(C,P,O){y&&await y;const R=h.create(C,P);y??(y=R);const G=await R;return G.config=O,G}let g=Promise.resolve();const _=r.apis.IS_BROWSER_ENV||r.apis.IS_WEBWORKER_ENV;async function T(C,P){const O=()=>C.run(P);return await(_?g=g.then(O):O())}function x(C){return C instanceof f.Tensor}const S=f==null?void 0:f.env;S!=null&&S.wasm&&(!(typeof ServiceWorkerGlobalScope<"u"&&self instanceof ServiceWorkerGlobalScope)&&!S.wasm.wasmPaths&&(S.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${r.env.version}/dist/`),S.wasm.proxy=!1),S!=null&&S.webgpu&&(S.webgpu.powerPreference="high-performance");function $(){var C;return(C=S==null?void 0:S.wasm)==null?void 0:C.proxy}r.env.backends.onnx=S},"./src/base/feature_extraction_utils.js":(e,t,n)=>{n.r(t),n.d(t,{FeatureExtractor:()=>a,validate_audio_inputs:()=>o});var i=n("./src/utils/constants.js"),r=n("./src/utils/generic.js"),s=n("./src/utils/hub.js");class a extends r.Callable{constructor(u){super(),this.config=u}static async from_pretrained(u,c={}){const f=await(0,s.getModelJSON)(u,i.FEATURE_EXTRACTOR_NAME,!0,c);return new this(f)}}function o(l,u){var c;if(!(l instanceof Float32Array||l instanceof Float64Array))throw new Error(`${u} expects input to be a Float32Array or a Float64Array, but got ${((c=l==null?void 0:l.constructor)==null?void 0:c.name)??typeof l} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}},"./src/base/image_processors_utils.js":(e,t,n)=>{n.r(t),n.d(t,{ImageProcessor:()=>x,center_to_corners_format:()=>f,post_process_instance_segmentation:()=>T,post_process_object_detection:()=>d,post_process_panoptic_segmentation:()=>_,post_process_semantic_segmentation:()=>h});var i=n("./src/utils/generic.js"),r=n("./src/utils/tensor.js"),s=n("./src/utils/maths.js");n("./src/utils/image.js");var a=n("./src/utils/core.js"),o=n("./src/utils/hub.js"),l=n("./src/utils/constants.js");function u(S,$,C=0,P=null){const O=S/$;let R=(0,s.bankers_round)(O)*$;return P!==null&&R>P&&(R=Math.floor(O)*$),R<C&&(R=Math.ceil(O)*$),R}function c([S,$],C){return[Math.max(Math.floor(S/C),1)*C,Math.max(Math.floor($/C),1)*C]}function f([S,$,C,P]){return[S-C/2,$-P/2,S+C/2,$+P/2]}function d(S,$=.5,C=null,P=!1){const O=S.logits,R=S.pred_boxes,[G,W,V]=O.dims;if(C!==null&&C.length!==G)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let te=[];for(let J=0;J<G;++J){let j=C!==null?C[J]:null,Y={boxes:[],classes:[],scores:[]},X=O[J],ce=R[J];for(let me=0;me<W;++me){let Q=X[me],H=[],B;if(P){B=Q.sigmoid().data;for(let ee=0;ee<B.length;++ee)B[ee]>$&&H.push(ee)}else{let ee=(0,s.max)(Q.data)[1];if(ee===V-1||(B=(0,s.softmax)(Q.data),B[ee]<$))continue;H.push(ee)}for(const ee of H){let _e=ce[me].data;_e=f(_e),j!==null&&(_e=_e.map((le,ae)=>le*j[(ae+1)%2])),Y.boxes.push(_e),Y.classes.push(ee),Y.scores.push(B[ee])}}te.push(Y)}return te}function h(S,$=null){const C=S.logits,P=C.dims[0];if($!==null&&$.length!==P)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const O=[];for(let R=0;R<P;++R){const G=$!==null?$[R]:null;let W=C[R];G!==null&&(W=(0,r.interpolate)(W,G,"bilinear",!1));const[V,te]=G??W.dims.slice(-2),J=new r.Tensor("int32",new Int32Array(V*te),[V,te]),j=W[0].data,Y=J.data;for(let me=1;me<W.dims[0];++me){const Q=W[me].data;for(let H=0;H<Q.length;++H)Q[H]>j[H]&&(j[H]=Q[H],Y[H]=me)}const X=new Array(W.dims[0]);for(let me=0;me<Y.length;++me){const Q=Y[me];X[Q]=Q}const ce=X.filter(me=>me!==void 0);O.push({segmentation:J,labels:ce})}return O}function m(S,$,C,P){const O=[],R=[],G=[];for(let W=0;W<S.dims[0];++W){const V=S[W],te=$[W],J=(0,s.max)(V.data)[1];if(J===P)continue;const Y=(0,s.softmax)(V.data)[J];Y>C&&(O.push(te),R.push(Y),G.push(J))}return[O,R,G]}function y(S,$,C,P=.5,O=.8){const R=[];let G=0,W=0;const V=$[C].data;for(let J=0;J<S.length;++J)S[J]===C&&(R.push(J),++G),V[J]>=P&&++W;let te=G>0&&W>0;return te&&(te=G/W>O),[te,R]}function M(S,$,C,P,O,R=null,G=null){const[W,V]=G??S[0].dims,te=new r.Tensor("int32",new Int32Array(W*V),[W,V]),J=[];if(G!==null)for(let me=0;me<S.length;++me)S[me]=(0,r.interpolate)(S[me],G,"bilinear",!1);const j=new Int32Array(S[0].data.length),Y=new Float32Array(S[0].data.length);for(let me=0;me<S.length;++me){let Q=$[me];const H=S[me].data;for(let B=0;B<H.length;++B)H[B]*=Q,H[B]>Y[B]&&(j[B]=me,Y[B]=H[B])}let X=0;const ce=te.data;for(let me=0;me<C.length;++me){const Q=C[me],[H,B]=y(j,S,me,P,O);if(H){++X;for(const ee of B)ce[ee]=X;J.push({id:X,label_id:Q,score:$[me]})}}return[te,J]}function g(S,$,C=28,P=56*56,O=14*14*4*1280){if(S<C||$<C)throw new Error(`height:${S} or width:${$} must be larger than factor:${C}`);if(Math.max(S,$)/Math.min(S,$)>200)throw new Error(`absolute aspect ratio must be smaller than 200, got ${Math.max(S,$)/Math.min(S,$)}`);let R=Math.round(S/C)*C,G=Math.round($/C)*C;if(R*G>O){const W=Math.sqrt(S*$/O);R=Math.floor(S/W/C)*C,G=Math.floor($/W/C)*C}else if(R*G<P){const W=Math.sqrt(P/(S*$));R=Math.ceil(S*W/C)*C,G=Math.ceil($*W/C)*C}return[R,G]}function _(S,$=.5,C=.5,P=.8,O=null,R=null){O===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),O=new Set);const G=S.class_queries_logits??S.logits,V=(S.masks_queries_logits??S.pred_masks).sigmoid();let[te,J,j]=G.dims;if(j-=1,R!==null&&R.length!==te)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let Y=[];for(let X=0;X<te;++X){let ce=R!==null?R[X]:null,me=G[X],Q=V[X],[H,B,ee]=m(me,Q,$,j);if(ee.length===0){let[ae,Ne]=ce??Q.dims.slice(-2),Ye=new r.Tensor("int32",new Int32Array(ae*Ne).fill(-1),[ae,Ne]);Y.push({segmentation:Ye,segments_info:[]});continue}let[_e,le]=M(H,B,ee,C,P,O,ce);Y.push({segmentation:_e,segments_info:le})}return Y}function T(S,$=.5,C=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class x extends i.Callable{constructor($){super(),this.image_mean=$.image_mean??$.mean,this.image_std=$.image_std??$.std,this.resample=$.resample??2,this.do_rescale=$.do_rescale??!0,this.rescale_factor=$.rescale_factor??1/255,this.do_normalize=$.do_normalize,this.do_thumbnail=$.do_thumbnail,this.size=$.size??$.image_size,this.do_resize=$.do_resize??this.size!==void 0,this.size_divisibility=$.size_divisibility??$.size_divisor,this.do_center_crop=$.do_center_crop,this.crop_size=$.crop_size,this.do_convert_rgb=$.do_convert_rgb??!0,this.do_crop_margin=$.do_crop_margin,this.pad_size=$.pad_size,this.do_pad=$.do_pad,this.min_pixels=$.min_pixels,this.max_pixels=$.max_pixels,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=$.do_flip_channel_order??!1,this.config=$}async thumbnail($,C,P=2){const O=$.height,R=$.width,G=C.height,W=C.width;let V=Math.min(O,G),te=Math.min(R,W);return V===O&&te===R?$:(O>R?te=Math.floor(R*V/O):R>O&&(V=Math.floor(O*te/R)),await $.resize(te,V,{resample:P}))}async crop_margin($,C=200){const P=$.clone().grayscale(),O=(0,s.min)(P.data)[0],G=(0,s.max)(P.data)[0]-O;if(G===0)return $;const W=C/255;let V=P.width,te=P.height,J=0,j=0;const Y=P.data;for(let X=0;X<P.height;++X){const ce=X*P.width;for(let me=0;me<P.width;++me)(Y[ce+me]-O)/G<W&&(V=Math.min(V,me),te=Math.min(te,X),J=Math.max(J,me),j=Math.max(j,X))}return $=await $.crop([V,te,J,j]),$}pad_image($,C,P,{mode:O="constant",center:R=!1,constant_values:G=0}={}){const[W,V,te]=C;let J,j;if(typeof P=="number"?(J=P,j=P):P==="square"?J=j=Math.max(W,V):(J=P.width,j=P.height),J!==V||j!==W){const Y=new Float32Array(J*j*te);if(Array.isArray(G))for(let me=0;me<Y.length;++me)Y[me]=G[me%te];else G!==0&&Y.fill(G);const[X,ce]=R?[Math.floor((J-V)/2),Math.floor((j-W)/2)]:[0,0];for(let me=0;me<W;++me){const Q=(me+ce)*J,H=me*V;for(let B=0;B<V;++B){const ee=(Q+B+X)*te,_e=(H+B)*te;for(let le=0;le<te;++le)Y[ee+le]=$[_e+le]}}if(O==="symmetric"){if(R)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const me=W-1,Q=V-1;for(let H=0;H<j;++H){const B=H*J,ee=(0,a.calculateReflectOffset)(H,me)*V;for(let _e=0;_e<J;++_e){if(H<W&&_e<V)continue;const le=(B+_e)*te,ae=(ee+(0,a.calculateReflectOffset)(_e,Q))*te;for(let Ne=0;Ne<te;++Ne)Y[le+Ne]=$[ae+Ne]}}}$=Y,C=[j,J,te]}return[$,C]}rescale($){for(let C=0;C<$.length;++C)$[C]=this.rescale_factor*$[C]}get_resize_output_image_size($,C){const[P,O]=$.size;let R,G;if(this.do_thumbnail){const{height:W,width:V}=C;R=Math.min(W,V)}else Number.isInteger(C)?(R=C,G=this.config.max_size??R):C!==void 0&&(R=C.shortest_edge,G=C.longest_edge);if(R!==void 0||G!==void 0){const W=R===void 0?1:Math.max(R/P,R/O),V=P*W,te=O*W,J=G===void 0?1:Math.min(G/V,G/te);let j=Math.floor(Number((V*J).toFixed(2))),Y=Math.floor(Number((te*J).toFixed(2)));return this.size_divisibility!==void 0&&([j,Y]=c([j,Y],this.size_divisibility)),[j,Y]}else if(C!==void 0&&C.width!==void 0&&C.height!==void 0){let W=C.width,V=C.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let te=V/O,J=W/P;Math.abs(1-J)<Math.abs(1-te)?te=J:J=te,V=u(te*O,this.config.ensure_multiple_of),W=u(J*P,this.config.ensure_multiple_of)}return[W,V]}else{if(this.size_divisibility!==void 0)return c([P,O],this.size_divisibility);if(this.min_pixels!==void 0&&this.max_pixels!==void 0){const W=this.config.patch_size*this.config.merge_size;return g(O,P,W,this.min_pixels,this.max_pixels)}else throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(C)}`)}}async resize($){const[C,P]=this.get_resize_output_image_size($,this.size);return await $.resize(C,P,{resample:this.resample})}async preprocess($,{do_normalize:C=null,do_pad:P=null,do_convert_rgb:O=null,do_convert_grayscale:R=null,do_flip_channel_order:G=null}={}){this.do_crop_margin&&($=await this.crop_margin($));const[W,V]=$.size;if(O??this.do_convert_rgb?$=$.rgb():R&&($=$.grayscale()),this.do_resize&&($=await this.resize($)),this.do_thumbnail&&($=await this.thumbnail($,this.size,this.resample)),this.do_center_crop){let X,ce;Number.isInteger(this.crop_size)?(X=this.crop_size,ce=this.crop_size):(X=this.crop_size.width,ce=this.crop_size.height),$=await $.center_crop(X,ce)}const te=[$.height,$.width];let J=Float32Array.from($.data),j=[$.height,$.width,$.channels];if(this.do_rescale&&this.rescale(J),C??this.do_normalize){let X=this.image_mean;Array.isArray(this.image_mean)||(X=new Array($.channels).fill(X));let ce=this.image_std;if(Array.isArray(this.image_std)||(ce=new Array($.channels).fill(ce)),X.length!==$.channels||ce.length!==$.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${X.length}) and \`image_std\` (${ce.length}) must match the number of channels in the image (${$.channels}).`);for(let me=0;me<J.length;me+=$.channels)for(let Q=0;Q<$.channels;++Q)J[me+Q]=(J[me+Q]-X[Q])/ce[Q]}if(P??this.do_pad){if(this.pad_size)[J,j]=this.pad_image(J,[$.height,$.width,$.channels],this.pad_size);else if(this.size_divisibility){const[X,ce]=c([j[1],j[0]],this.size_divisibility);[J,j]=this.pad_image(J,j,{width:X,height:ce})}}if(G??this.do_flip_channel_order){if(j[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let X=0;X<J.length;X+=3){const ce=J[X];J[X]=J[X+2],J[X+2]=ce}}const Y=new r.Tensor("float32",J,j).permute(2,0,1);return{original_size:[V,W],reshaped_input_size:te,pixel_values:Y}}async _call($,...C){Array.isArray($)||($=[$]);const P=await Promise.all($.map(R=>this.preprocess(R)));return{pixel_values:(0,r.stack)(P.map(R=>R.pixel_values),0),original_sizes:P.map(R=>R.original_size),reshaped_input_sizes:P.map(R=>R.reshaped_input_size)}}static async from_pretrained($,C={}){const P=await(0,o.getModelJSON)($,l.IMAGE_PROCESSOR_NAME,!0,C);return new this(P)}}},"./src/base/processing_utils.js":(e,t,n)=>{n.r(t),n.d(t,{Processor:()=>a});var i=n("./src/utils/constants.js"),r=n("./src/utils/generic.js"),s=n("./src/utils/hub.js");class a extends r.Callable{constructor(l,u,c){super(),this.config=l,this.components=u,this.chat_template=c}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(l,u={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(l,{tokenize:!1,chat_template:this.chat_template??void 0,...u})}batch_decode(...l){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...l)}decode(...l){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.decode(...l)}async _call(l,...u){for(const c of[this.image_processor,this.feature_extractor,this.tokenizer])if(c)return c(l,...u);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(l,u={}){const[c,f,d]=await Promise.all([this.uses_processor_config?(0,s.getModelJSON)(l,i.PROCESSOR_NAME,!0,u):{},Promise.all(this.classes.filter(h=>h in this).map(async h=>{const m=await this[h].from_pretrained(l,u);return[h.replace(/_class$/,""),m]})).then(Object.fromEntries),this.uses_chat_template_file?(0,s.getModelText)(l,i.CHAT_TEMPLATE_NAME,!0,u):null]);return new this(c,f,d)}}fe(a,"classes",["image_processor_class","tokenizer_class","feature_extractor_class"]),fe(a,"uses_processor_config",!1),fe(a,"uses_chat_template_file",!1)},"./src/configs.js":(e,t,n)=>{n.r(t),n.d(t,{AutoConfig:()=>c,PretrainedConfig:()=>u,getCacheShapes:()=>o});var i=n("./src/utils/core.js"),r=n("./src/utils/hub.js");async function s(f,d){return await(0,r.getModelJSON)(f,"config.json",!0,d)}function a(f){const d={};let h={};switch(f.model_type){case"llava":case"paligemma":case"gemma3":case"florence2":case"llava_onevision":case"idefics3":case"ultravox":case"voxtral":case"smolvlm":case"gemma3n":case"mistral3":h=a(f.text_config);break;case"moondream1":h=a(f.phi_config);break;case"musicgen":h=a(f.decoder);break;case"multi_modality":h=a(f.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":d.num_heads="n_head",d.num_layers="n_layer",d.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":case"modernbert-decoder":d.num_heads="num_attention_heads",d.num_layers="num_hidden_layers",d.hidden_size="hidden_size";break;case"llama":case"llama4_text":case"nanochat":case"arcee":case"lfm2":case"smollm3":case"olmo":case"olmo2":case"mobilellm":case"granite":case"granitemoehybrid":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":case"llava_qwen2":d.num_heads="num_key_value_heads",d.num_layers="num_hidden_layers",d.hidden_size="hidden_size",d.num_attention_heads="num_attention_heads",d.dim_kv="head_dim";break;case"qwen3":case"gemma":case"gemma2":case"vaultgemma":case"gemma3_text":case"gemma3n_text":case"glm":case"helium":case"ernie4_5":case"ministral":case"ministral3":d.num_heads="num_key_value_heads",d.num_layers="num_hidden_layers",d.dim_kv="head_dim";break;case"openelm":d.num_heads="num_kv_heads",d.num_layers="num_transformer_layers",d.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":d.num_heads="num_heads",d.num_layers="num_layers",d.hidden_size="hidden_size";break;case"bloom":d.num_heads="n_head",d.num_layers="n_layer",d.hidden_size="hidden_size";break;case"mpt":d.num_heads="n_heads",d.num_layers="n_layers",d.hidden_size="d_model";break;case"exaone":d.num_heads="num_key_value_heads",d.num_layers="num_layers",d.dim_kv="head_dim",d.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":d.num_decoder_layers="num_decoder_layers",d.num_decoder_heads="num_heads",d.decoder_dim_kv="d_kv",d.num_encoder_layers="num_layers",d.num_encoder_heads="num_heads",d.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"lite-whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":d.num_decoder_layers="decoder_layers",d.num_decoder_heads="decoder_attention_heads",d.decoder_hidden_size="d_model",d.num_encoder_layers="encoder_layers",d.num_encoder_heads="encoder_attention_heads",d.encoder_hidden_size="d_model";break;case"speecht5":d.num_decoder_layers="decoder_layers",d.num_decoder_heads="decoder_attention_heads",d.decoder_hidden_size="hidden_size",d.num_encoder_layers="encoder_layers",d.num_encoder_heads="encoder_attention_heads",d.encoder_hidden_size="hidden_size";break;case"trocr":d.num_encoder_layers=d.num_decoder_layers="decoder_layers",d.num_encoder_heads=d.num_decoder_heads="decoder_attention_heads",d.encoder_hidden_size=d.decoder_hidden_size="d_model";break;case"musicgen_decoder":d.num_encoder_layers=d.num_decoder_layers="num_hidden_layers",d.num_encoder_heads=d.num_decoder_heads="num_attention_heads",d.encoder_hidden_size=d.decoder_hidden_size="hidden_size";break;case"moonshine":d.num_decoder_layers="decoder_num_hidden_layers",d.num_decoder_heads="decoder_num_key_value_heads",d.num_encoder_layers="encoder_num_hidden_layers",d.num_encoder_heads="encoder_num_key_value_heads",d.encoder_hidden_size=d.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const y=a(f.decoder),M="num_decoder_layers"in y,g=(0,i.pick)(f,["model_type","is_encoder_decoder"]);return M?(g.num_decoder_layers=y.num_decoder_layers,g.num_decoder_heads=y.num_decoder_heads,g.decoder_hidden_size=y.decoder_hidden_size,g.num_encoder_layers=y.num_encoder_layers,g.num_encoder_heads=y.num_encoder_heads,g.encoder_hidden_size=y.encoder_hidden_size):(g.num_layers=y.num_layers,g.num_heads=y.num_heads,g.hidden_size=y.hidden_size),g}const m={...h,...(0,i.pick)(f,["model_type","multi_query","is_encoder_decoder"])};for(const y in d)m[y]=f[d[y]];return m}function o(f,d){if(f.model_type==="lfm2"){const h=(d==null?void 0:d.prefix)??"past_key_values",m=h==="present"?"present":"past",y={},{layer_types:M,num_attention_heads:g,num_key_value_heads:_,hidden_size:T,conv_L_cache:x}=f,S=T/g,$=(d==null?void 0:d.batch_size)??1;for(let C=0;C<M.length;++C)if(M[C]==="full_attention")for(const P of["key","value"])y[`${h}.${C}.${P}`]=[$,_,0,S];else if(M[C]==="conv")y[`${m}_conv.${C}`]=[$,T,x];else throw new Error(`Unsupported layer type: ${M[C]}`);return y}return l(f,d)}function l(f,{prefix:d="past_key_values",batch_size:h=1}={}){const m={},y=f.normalized_config;if(y.is_encoder_decoder&&"num_encoder_heads"in y&&"num_decoder_heads"in y){const M=y.encoder_dim_kv??y.encoder_hidden_size/y.num_encoder_heads,g=y.decoder_dim_kv??y.decoder_hidden_size/y.num_decoder_heads,_=[h,y.num_encoder_heads,0,M],T=[h,y.num_decoder_heads,0,g];for(let x=0;x<y.num_decoder_layers;++x)m[`${d}.${x}.encoder.key`]=_,m[`${d}.${x}.encoder.value`]=_,m[`${d}.${x}.decoder.key`]=T,m[`${d}.${x}.decoder.value`]=T}else{const M=y.num_heads,g=y.num_layers,_=y.dim_kv??y.hidden_size/(y.num_attention_heads??M);if(y.model_type==="falcon"){const T=[h*M,0,_];for(let x=0;x<g;++x)m[`${d}.${x}.key`]=T,m[`${d}.${x}.value`]=T}else if(y.multi_query){const T=[h*M,0,2*_];for(let x=0;x<g;++x)m[`${d}.${x}.key_value`]=T}else if(y.model_type==="bloom"){const T=[h*M,_,0],x=[h*M,0,_];for(let S=0;S<g;++S)m[`${d}.${S}.key`]=T,m[`${d}.${S}.value`]=x}else if(y.model_type==="openelm")for(let T=0;T<g;++T){const x=[h,M[T],0,_];m[`${d}.${T}.key`]=x,m[`${d}.${T}.value`]=x}else{const T=[h,M,0,_];for(let x=0;x<g;++x)m[`${d}.${x}.key`]=T,m[`${d}.${x}.value`]=T}}return m}class u{constructor(d){fe(this,"model_type",null);fe(this,"is_encoder_decoder",!1);fe(this,"max_position_embeddings");fe(this,"transformers.js_config");Object.assign(this,d),this.normalized_config=a(this)}static async from_pretrained(d,{progress_callback:h=null,config:m=null,cache_dir:y=null,local_files_only:M=!1,revision:g="main"}={}){m&&!(m instanceof u)&&(m=new u(m));const _=m??await s(d,{progress_callback:h,config:m,cache_dir:y,local_files_only:M,revision:g});return new this(_)}}class c{static async from_pretrained(...d){return u.from_pretrained(...d)}}},"./src/env.js":(e,t,n)=>{var O,R;n.r(t),n.d(t,{apis:()=>g,env:()=>C});var i=n("?db59"),r=n("?383f"),s=n("?fa4b");const a="3.8.1",o=typeof window<"u"&&typeof window.document<"u",l=typeof self<"u"&&["DedicatedWorkerGlobalScope","ServiceWorkerGlobalScope","SharedWorkerGlobalScope"].includes((O=self.constructor)==null?void 0:O.name),u=typeof self<"u"&&"caches"in self,c=typeof navigator<"u"&&"gpu"in navigator,f=typeof navigator<"u"&&"ml"in navigator,d=typeof process<"u",h=d&&((R=process==null?void 0:process.release)==null?void 0:R.name)==="node",m=!P(i),y=!P(r),M=typeof globalThis.Deno<"u",g=Object.freeze({IS_BROWSER_ENV:o,IS_WEBWORKER_ENV:l,IS_WEB_CACHE_AVAILABLE:u,IS_WEBGPU_AVAILABLE:c,IS_WEBNN_AVAILABLE:f,IS_PROCESS_AVAILABLE:d,IS_NODE_ENV:h,IS_FS_AVAILABLE:m,IS_PATH_AVAILABLE:y}),_=m&&y;let T="./";if(_){const G=Object(import.meta).url;G?T=r.dirname(r.dirname(s.fileURLToPath(G))):typeof __dirname<"u"&&(T=r.dirname(__dirname))}const x=_?r.join(T,"/.cache/"):null,S="/models/",$=_?r.join(T,S):S,C={version:a,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(o||l),localModelPath:$,useFS:m,useBrowserCache:u&&!M,useFSCache:m,cacheDir:x,useCustomCache:!1,customCache:null};function P(G){return Object.keys(G).length===0}},"./src/generation/configuration_utils.js":(e,t,n)=>{n.r(t),n.d(t,{GenerationConfig:()=>r});var i=n("./src/utils/core.js");class r{constructor(a){fe(this,"max_length",20);fe(this,"max_new_tokens",null);fe(this,"min_length",0);fe(this,"min_new_tokens",null);fe(this,"early_stopping",!1);fe(this,"max_time",null);fe(this,"do_sample",!1);fe(this,"num_beams",1);fe(this,"num_beam_groups",1);fe(this,"penalty_alpha",null);fe(this,"use_cache",!0);fe(this,"temperature",1);fe(this,"top_k",50);fe(this,"top_p",1);fe(this,"typical_p",1);fe(this,"epsilon_cutoff",0);fe(this,"eta_cutoff",0);fe(this,"diversity_penalty",0);fe(this,"repetition_penalty",1);fe(this,"encoder_repetition_penalty",1);fe(this,"length_penalty",1);fe(this,"no_repeat_ngram_size",0);fe(this,"bad_words_ids",null);fe(this,"force_words_ids",null);fe(this,"renormalize_logits",!1);fe(this,"constraints",null);fe(this,"forced_bos_token_id",null);fe(this,"forced_eos_token_id",null);fe(this,"remove_invalid_values",!1);fe(this,"exponential_decay_length_penalty",null);fe(this,"suppress_tokens",null);fe(this,"streamer",null);fe(this,"begin_suppress_tokens",null);fe(this,"forced_decoder_ids",null);fe(this,"guidance_scale",null);fe(this,"num_return_sequences",1);fe(this,"output_attentions",!1);fe(this,"output_hidden_states",!1);fe(this,"output_scores",!1);fe(this,"return_dict_in_generate",!1);fe(this,"pad_token_id",null);fe(this,"bos_token_id",null);fe(this,"eos_token_id",null);fe(this,"encoder_no_repeat_ngram_size",0);fe(this,"decoder_start_token_id",null);fe(this,"generation_kwargs",{});Object.assign(this,(0,i.pick)(a,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(e,t,n)=>{n.r(t),n.d(t,{ClassifierFreeGuidanceLogitsProcessor:()=>g,ForcedBOSTokenLogitsProcessor:()=>l,ForcedEOSTokenLogitsProcessor:()=>u,LogitsProcessor:()=>s,LogitsProcessorList:()=>o,LogitsWarper:()=>a,MinLengthLogitsProcessor:()=>m,MinNewTokensLengthLogitsProcessor:()=>y,NoBadWordsLogitsProcessor:()=>M,NoRepeatNGramLogitsProcessor:()=>d,RepetitionPenaltyLogitsProcessor:()=>h,SuppressTokensAtBeginLogitsProcessor:()=>c,TemperatureLogitsWarper:()=>_,TopKLogitsWarper:()=>x,TopPLogitsWarper:()=>T,WhisperTimeStampLogitsProcessor:()=>f});var i=n("./src/utils/generic.js");n("./src/utils/tensor.js");var r=n("./src/utils/maths.js");class s extends i.Callable{_call($,C){throw Error("`_call` should be implemented in a subclass")}}class a extends i.Callable{_call($,C){throw Error("`_call` should be implemented in a subclass")}}class o extends i.Callable{constructor(){super(),this.processors=[]}push($){this.processors.push($)}extend($){this.processors.push(...$)}_call($,C){let P=C;for(const O of this.processors)P=O($,P);return P}[Symbol.iterator](){return this.processors.values()}}class l extends s{constructor($){super(),this.bos_token_id=$}_call($,C){for(let P=0;P<$.length;++P)if($[P].length===1){const O=C[P].data;O.fill(-1/0),O[this.bos_token_id]=0}return C}}class u extends s{constructor($,C){super(),this.max_length=$,this.eos_token_id=Array.isArray(C)?C:[C]}_call($,C){for(let P=0;P<$.length;++P)if($[P].length===this.max_length-1){const O=C[P].data;O.fill(-1/0);for(const R of this.eos_token_id)O[R]=0}return C}}class c extends s{constructor($,C){super(),this.begin_suppress_tokens=$,this.begin_index=C}_call($,C){for(let P=0;P<$.length;++P)if($[P].length===this.begin_index){const O=C[P].data;for(const R of this.begin_suppress_tokens)O[R]=-1/0}return C}}class f extends s{constructor($,C){super(),this.eos_token_id=Array.isArray($.eos_token_id)?$.eos_token_id[0]:$.eos_token_id,this.no_timestamps_token_id=$.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=C.length,C.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=$.max_initial_timestamp_index}_call($,C){for(let P=0;P<$.length;++P){const O=C[P].data;if(O[this.no_timestamps_token_id]=-1/0,$[P].length===this.begin_index-1){O.fill(-1/0),O[this.timestamp_begin]=0;continue}const R=$[P].slice(this.begin_index),G=R.length>=1&&R[R.length-1]>=this.timestamp_begin,W=R.length<2||R[R.length-2]>=this.timestamp_begin;if(G&&(W?O.subarray(this.timestamp_begin).fill(-1/0):O.subarray(0,this.eos_token_id).fill(-1/0)),$[P].length===this.begin_index&&this.max_initial_timestamp_index!==null){const j=this.timestamp_begin+this.max_initial_timestamp_index;O.subarray(j+1).fill(-1/0)}const V=(0,r.log_softmax)(O),te=Math.log(V.subarray(this.timestamp_begin).map(Math.exp).reduce((j,Y)=>j+Y)),J=(0,r.max)(V.subarray(0,this.timestamp_begin))[0];te>J&&O.subarray(0,this.timestamp_begin).fill(-1/0)}return C}}class d extends s{constructor($){super(),this.no_repeat_ngram_size=$}getNgrams($){const C=$.length,P=[];for(let R=0;R<C+1-this.no_repeat_ngram_size;++R){const G=[];for(let W=0;W<this.no_repeat_ngram_size;++W)G.push($[R+W]);P.push(G.map(Number))}const O=new Map;for(const R of P){const G=R.slice(0,R.length-1),W=JSON.stringify(G),V=O.get(W)??[];V.push(R[R.length-1]),O.set(W,V)}return O}getGeneratedNgrams($,C){const P=C.slice(C.length+1-this.no_repeat_ngram_size,C.length);return $.get(JSON.stringify(P.map(Number)))??[]}calcBannedNgramTokens($){const C=[];if($.length+1<this.no_repeat_ngram_size)return C;{const P=this.getNgrams($);return this.getGeneratedNgrams(P,$)}}_call($,C){for(let P=0;P<$.length;++P){const O=C[P].data,R=this.calcBannedNgramTokens($[P]);for(const G of R)O[G]=-1/0}return C}}class h extends s{constructor($){super(),this.penalty=$}_call($,C){for(let P=0;P<$.length;++P){const O=C[P].data;for(const R of new Set($[P])){const G=Number(R);O[G]<0?O[G]*=this.penalty:O[G]/=this.penalty}}return C}}class m extends s{constructor($,C){super(),this.min_length=$,this.eos_token_id=Array.isArray(C)?C:[C]}_call($,C){for(let P=0;P<$.length;++P)if($[P].length<this.min_length){const O=C[P].data;for(const R of this.eos_token_id)O[R]=-1/0}return C}}class y extends s{constructor($,C,P){super(),this.prompt_length_to_skip=$,this.min_new_tokens=C,this.eos_token_id=Array.isArray(P)?P:[P]}_call($,C){for(let P=0;P<$.length;++P)if($[P].length-this.prompt_length_to_skip<this.min_new_tokens){const R=C[P].data;for(const G of this.eos_token_id)R[G]=-1/0}return C}}class M extends s{constructor($,C){super(),this.bad_words_ids=$,this.eos_token_id=Array.isArray(C)?C:[C]}_call($,C){for(let P=0;P<$.length;++P){const O=C[P].data,R=$[P];for(const G of this.bad_words_ids){if(R.length<G.length-1)continue;let W=!0;for(let V=1;V<=G.length-1;++V)if(G.at(-V-1)!=R.at(-V)){W=!1;break}W&&(O[G.at(-1)]=-1/0)}}return C}}class g extends s{constructor($){if(super(),$<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${$}.`);this.guidance_scale=$}_call($,C){if(C.dims[0]!==2*$.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${C.dims[0]} for the logits and ${$.length} for the input ids.`);const P=$.length,O=C.slice([0,P],null),R=C.slice([P,C.dims[0]],null);for(let G=0;G<R.data.length;++G)R.data[G]+=(O.data[G]-R.data[G])*this.guidance_scale;return R}}class _ extends a{constructor($){super(),this.temperature=$}_call($,C){const P=C.data;for(let O=0;O<P.length;++O)P[O]/=this.temperature;return C}}class T extends a{constructor($,{filter_value:C=-1/0,min_tokens_to_keep:P=1}={}){if(super(),$<0||$>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${$}`);if(!Number.isInteger(P)||P<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${P}`);this.top_p=$,this.filter_value=C,this.min_tokens_to_keep=P}}class x extends a{constructor($,{filter_value:C=-1/0,min_tokens_to_keep:P=1}={}){if(super(),!Number.isInteger($)||$<0)throw new Error(`\`top_k\` must be a positive integer, but is ${$}`);this.top_k=Math.max($,P),this.filter_value=C}}},"./src/generation/logits_sampler.js":(e,t,n)=>{n.r(t),n.d(t,{LogitsSampler:()=>a});var i=n("./src/utils/generic.js"),r=n("./src/utils/tensor.js"),s=n("./src/utils/maths.js");n("./src/generation/configuration_utils.js");class a extends i.Callable{constructor(f){super(),this.generation_config=f}async _call(f){return this.sample(f)}async sample(f){throw Error("sample should be implemented in subclasses.")}getLogits(f,d){let h=f.dims.at(-1),m=f.data;if(d===-1)m=m.slice(-h);else{let y=d*h;m=m.slice(y,y+h)}return m}randomSelect(f){let d=0;for(let m=0;m<f.length;++m)d+=f[m];let h=Math.random()*d;for(let m=0;m<f.length;++m)if(h-=f[m],h<=0)return m;return 0}static getSampler(f){if(f.do_sample)return new l(f);if(f.num_beams>1)return new u(f);if(f.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${f.num_return_sequences}.`);return new o(f)}}class o extends a{async sample(f){const d=(0,s.max)(f.data)[1];return[[BigInt(d),0]]}}class l extends a{async sample(f){let d=f.dims.at(-1);this.generation_config.top_k>0&&(d=Math.min(this.generation_config.top_k,d));const[h,m]=await(0,r.topk)(f,d),y=(0,s.softmax)(h.data);return Array.from({length:this.generation_config.num_beams},()=>{const M=this.randomSelect(y);return[m.data[M],Math.log(y[M])]})}}class u extends a{async sample(f){let d=f.dims.at(-1);this.generation_config.top_k>0&&(d=Math.min(this.generation_config.top_k,d));const[h,m]=await(0,r.topk)(f,d),y=(0,s.softmax)(h.data);return Array.from({length:this.generation_config.num_beams},(M,g)=>[m.data[g],Math.log(y[g])])}}},"./src/generation/stopping_criteria.js":(e,t,n)=>{n.r(t),n.d(t,{EosTokenCriteria:()=>o,InterruptableStoppingCriteria:()=>l,MaxLengthCriteria:()=>a,StoppingCriteria:()=>r,StoppingCriteriaList:()=>s});var i=n("./src/utils/generic.js");class r extends i.Callable{_call(c,f){throw Error("StoppingCriteria needs to be subclassed")}}class s extends i.Callable{constructor(){super(),this.criteria=[]}push(c){this.criteria.push(c)}extend(c){c instanceof s?c=c.criteria:c instanceof r&&(c=[c]),this.criteria.push(...c)}_call(c,f){const d=new Array(c.length).fill(!1);for(const h of this.criteria){const m=h(c,f);for(let y=0;y<d.length;++y)d[y]||(d[y]=m[y])}return d}[Symbol.iterator](){return this.criteria.values()}}class a extends r{constructor(c,f=null){super(),this.max_length=c,this.max_position_embeddings=f}_call(c){return c.map(f=>f.length>=this.max_length)}}class o extends r{constructor(c){super(),Array.isArray(c)||(c=[c]),this.eos_token_id=c}_call(c,f){return c.map(d=>{const h=d.at(-1);return this.eos_token_id.some(m=>h==m)})}}class l extends r{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(c,f){return new Array(c.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(e,t,n)=>{n.r(t),n.d(t,{BaseStreamer:()=>a,TextStreamer:()=>l,WhisperTextStreamer:()=>u});var i=n("./src/utils/core.js"),r=n("./src/tokenizers.js"),s=n("./src/env.js");class a{put(f){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const o=s.apis.IS_PROCESS_AVAILABLE?c=>process.stdout.write(c):c=>console.log(c);class l extends a{constructor(f,{skip_prompt:d=!1,callback_function:h=null,token_callback_function:m=null,skip_special_tokens:y=!0,decode_kwargs:M={},...g}={}){super(),this.tokenizer=f,this.skip_prompt=d,this.callback_function=h??o,this.token_callback_function=m,this.decode_kwargs={skip_special_tokens:y,...M,...g},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(f){var M;if(f.length>1)throw Error("TextStreamer only supports batch size of 1");const d=this.next_tokens_are_prompt;if(d&&(this.next_tokens_are_prompt=!1,this.skip_prompt))return;const h=f[0];(M=this.token_callback_function)==null||M.call(this,h),this.token_cache=(0,i.mergeArrays)(this.token_cache,h);const m=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let y;d||m.endsWith(`
`)?(y=m.slice(this.print_len),this.token_cache=[],this.print_len=0):m.length>0&&(0,r.is_chinese_char)(m.charCodeAt(m.length-1))?(y=m.slice(this.print_len),this.print_len+=y.length):(y=m.slice(this.print_len,m.lastIndexOf(" ")+1),this.print_len+=y.length),this.on_finalized_text(y,!1)}end(){let f;this.token_cache.length>0?(f=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):f="",this.next_tokens_are_prompt=!0,this.on_finalized_text(f,!0)}on_finalized_text(f,d){var h,m;f.length>0&&((h=this.callback_function)==null||h.call(this,f)),d&&this.callback_function===o&&s.apis.IS_PROCESS_AVAILABLE&&((m=this.callback_function)==null||m.call(this,`
`))}}class u extends l{constructor(f,{skip_prompt:d=!1,callback_function:h=null,token_callback_function:m=null,on_chunk_start:y=null,on_chunk_end:M=null,on_finalize:g=null,time_precision:_=.02,skip_special_tokens:T=!0,decode_kwargs:x={}}={}){super(f,{skip_prompt:d,skip_special_tokens:T,callback_function:h,token_callback_function:m,decode_kwargs:x}),this.timestamp_begin=f.timestamp_begin,this.on_chunk_start=y,this.on_chunk_end=M,this.on_finalize=g,this.time_precision=_,this.waiting_for_timestamp=!1}put(f){var h,m,y;if(f.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const d=f[0];if(d.length===1){const M=Number(d[0])-this.timestamp_begin;if(M>=0){const g=M*this.time_precision;this.waiting_for_timestamp?(h=this.on_chunk_end)==null||h.call(this,g):(m=this.on_chunk_start)==null||m.call(this,g),this.waiting_for_timestamp=!this.waiting_for_timestamp,(y=this.token_callback_function)==null||y.call(this,d);return}}return super.put(f)}end(){var f;super.end(),(f=this.on_finalize)==null||f.call(this)}}},"./src/models.js":(e,t,n)=>{n.r(t),n.d(t,{ASTForAudioClassification:()=>Na,ASTModel:()=>nu,ASTPreTrainedModel:()=>no,AlbertForMaskedLM:()=>Mt,AlbertForQuestionAnswering:()=>gt,AlbertForSequenceClassification:()=>yt,AlbertModel:()=>ut,AlbertPreTrainedModel:()=>Fe,ArceeForCausalLM:()=>vr,ArceeModel:()=>ui,ArceePreTrainedModel:()=>Jt,AutoModel:()=>Sy,AutoModelForAudioClassification:()=>f$,AutoModelForAudioFrameClassification:()=>h$,AutoModelForAudioTextToText:()=>T$,AutoModelForCTC:()=>d$,AutoModelForCausalLM:()=>e$,AutoModelForDepthEstimation:()=>y$,AutoModelForDocumentQuestionAnswering:()=>m$,AutoModelForImageClassification:()=>r$,AutoModelForImageFeatureExtraction:()=>b$,AutoModelForImageMatting:()=>g$,AutoModelForImageSegmentation:()=>s$,AutoModelForImageTextToText:()=>x$,AutoModelForImageToImage:()=>_$,AutoModelForMaskGeneration:()=>c$,AutoModelForMaskedLM:()=>t$,AutoModelForNormalEstimation:()=>v$,AutoModelForObjectDetection:()=>l$,AutoModelForPoseEstimation:()=>w$,AutoModelForQuestionAnswering:()=>n$,AutoModelForSemanticSegmentation:()=>a$,AutoModelForSeq2SeqLM:()=>YC,AutoModelForSequenceClassification:()=>KC,AutoModelForSpeechSeq2Seq:()=>XC,AutoModelForTextToSpectrogram:()=>QC,AutoModelForTextToWaveform:()=>ZC,AutoModelForTokenClassification:()=>JC,AutoModelForUniversalSegmentation:()=>o$,AutoModelForVision2Seq:()=>i$,AutoModelForXVector:()=>p$,AutoModelForZeroShotObjectDetection:()=>u$,BartForConditionalGeneration:()=>tt,BartForSequenceClassification:()=>it,BartModel:()=>_r,BartPretrainedModel:()=>Pi,BaseModelOutput:()=>Pe,BeitForImageClassification:()=>pE,BeitModel:()=>fE,BeitPreTrainedModel:()=>z_,BertForMaskedLM:()=>Ge,BertForQuestionAnswering:()=>Ce,BertForSequenceClassification:()=>$e,BertForTokenClassification:()=>et,BertModel:()=>Le,BertPreTrainedModel:()=>ke,BlenderbotForConditionalGeneration:()=>li,BlenderbotModel:()=>Dn,BlenderbotPreTrainedModel:()=>Mn,BlenderbotSmallForConditionalGeneration:()=>$r,BlenderbotSmallModel:()=>Bi,BlenderbotSmallPreTrainedModel:()=>Vn,BloomForCausalLM:()=>RM,BloomModel:()=>OM,BloomPreTrainedModel:()=>S_,CLIPModel:()=>qo,CLIPPreTrainedModel:()=>Xr,CLIPSegForImageSegmentation:()=>Va,CLIPSegModel:()=>Ns,CLIPSegPreTrainedModel:()=>Ni,CLIPTextModel:()=>lu,CLIPTextModelWithProjection:()=>Ko,CLIPVisionModel:()=>xc,CLIPVisionModelWithProjection:()=>Jo,CamembertForMaskedLM:()=>xe,CamembertForQuestionAnswering:()=>$t,CamembertForSequenceClassification:()=>Ue,CamembertForTokenClassification:()=>_t,CamembertModel:()=>de,CamembertPreTrainedModel:()=>re,CausalLMOutput:()=>ll,CausalLMOutputWithPast:()=>EH,ChineseCLIPModel:()=>Ft,ChineseCLIPPreTrainedModel:()=>uo,ClapAudioModelWithProjection:()=>I2,ClapModel:()=>$2,ClapPreTrainedModel:()=>Wp,ClapTextModelWithProjection:()=>A2,CodeGenForCausalLM:()=>k,CodeGenModel:()=>I,CodeGenPreTrainedModel:()=>E,CohereForCausalLM:()=>pM,CohereModel:()=>fM,CoherePreTrainedModel:()=>g_,ConvBertForMaskedLM:()=>xt,ConvBertForQuestionAnswering:()=>Sn,ConvBertForSequenceClassification:()=>ji,ConvBertForTokenClassification:()=>Wi,ConvBertModel:()=>Gi,ConvBertPreTrainedModel:()=>Yi,ConvNextForImageClassification:()=>oS,ConvNextModel:()=>aS,ConvNextPreTrainedModel:()=>Z_,ConvNextV2ForImageClassification:()=>uS,ConvNextV2Model:()=>lS,ConvNextV2PreTrainedModel:()=>ey,DFineForObjectDetection:()=>SE,DFineModel:()=>EE,DFinePreTrainedModel:()=>j_,DINOv3ConvNextModel:()=>_S,DINOv3ConvNextPreTrainedModel:()=>gS,DINOv3ViTModel:()=>mS,DINOv3ViTPreTrainedModel:()=>hS,DPTForDepthEstimation:()=>VE,DPTModel:()=>UE,DPTPreTrainedModel:()=>Y_,DacDecoderModel:()=>yC,DacDecoderOutput:()=>mC,DacEncoderModel:()=>_C,DacEncoderOutput:()=>hC,DacModel:()=>gC,DacPreTrainedModel:()=>Qp,DebertaForMaskedLM:()=>It,DebertaForQuestionAnswering:()=>tn,DebertaForSequenceClassification:()=>Zt,DebertaForTokenClassification:()=>St,DebertaModel:()=>Ht,DebertaPreTrainedModel:()=>mt,DebertaV2ForMaskedLM:()=>ei,DebertaV2ForQuestionAnswering:()=>qt,DebertaV2ForSequenceClassification:()=>Bn,DebertaV2ForTokenClassification:()=>Je,DebertaV2Model:()=>Wn,DebertaV2PreTrainedModel:()=>vn,DecisionTransformerModel:()=>X2,DecisionTransformerPreTrainedModel:()=>Y2,DeiTForImageClassification:()=>PE,DeiTModel:()=>IE,DeiTPreTrainedModel:()=>H_,DepthAnythingForDepthEstimation:()=>jE,DepthAnythingPreTrainedModel:()=>GE,DepthProForDepthEstimation:()=>JE,DepthProPreTrainedModel:()=>KE,DetrForObjectDetection:()=>mE,DetrForSegmentation:()=>F_,DetrModel:()=>hE,DetrObjectDetectionOutput:()=>B_,DetrPreTrainedModel:()=>zp,DetrSegmentationOutput:()=>gE,Dinov2ForImageClassification:()=>dS,Dinov2Model:()=>cS,Dinov2PreTrainedModel:()=>ty,Dinov2WithRegistersForImageClassification:()=>pS,Dinov2WithRegistersModel:()=>fS,Dinov2WithRegistersPreTrainedModel:()=>ny,DistilBertForMaskedLM:()=>Un,DistilBertForQuestionAnswering:()=>ni,DistilBertForSequenceClassification:()=>An,DistilBertForTokenClassification:()=>zn,DistilBertModel:()=>kt,DistilBertPreTrainedModel:()=>Pt,DonutSwinModel:()=>sS,DonutSwinPreTrainedModel:()=>rS,EdgeTamModel:()=>$S,EfficientNetForImageClassification:()=>L2,EfficientNetModel:()=>N2,EfficientNetPreTrainedModel:()=>gy,ElectraForMaskedLM:()=>nr,ElectraForQuestionAnswering:()=>K,ElectraForSequenceClassification:()=>L,ElectraForTokenClassification:()=>oe,ElectraModel:()=>Xt,ElectraPreTrainedModel:()=>Ii,Ernie4_5ForCausalLM:()=>T2,Ernie4_5Model:()=>x2,Ernie4_5PreTrainedModel:()=>dy,EsmForMaskedLM:()=>Mi,EsmForSequenceClassification:()=>ci,EsmForTokenClassification:()=>Xi,EsmModel:()=>ir,EsmPreTrainedModel:()=>In,ExaoneForCausalLM:()=>tM,ExaoneModel:()=>eM,ExaonePreTrainedModel:()=>c_,FalconForCausalLM:()=>C2,FalconModel:()=>S2,FalconPreTrainedModel:()=>py,FastViTForImageClassification:()=>tE,FastViTModel:()=>eE,FastViTPreTrainedModel:()=>D_,Florence2ForConditionalGeneration:()=>vc,Florence2PreTrainedModel:()=>yc,GLPNForDepthEstimation:()=>iS,GLPNModel:()=>nS,GLPNPreTrainedModel:()=>Q_,GPT2LMHeadModel:()=>Zo,GPT2Model:()=>Qo,GPT2PreTrainedModel:()=>co,GPTBigCodeForCausalLM:()=>v,GPTBigCodeModel:()=>p,GPTBigCodePreTrainedModel:()=>ho,GPTJForCausalLM:()=>sl,GPTJModel:()=>rl,GPTJPreTrainedModel:()=>po,GPTNeoForCausalLM:()=>Ga,GPTNeoModel:()=>Ls,GPTNeoPreTrainedModel:()=>fo,GPTNeoXForCausalLM:()=>il,GPTNeoXModel:()=>nl,GPTNeoXPreTrainedModel:()=>la,Gemma2ForCausalLM:()=>_M,Gemma2Model:()=>gM,Gemma2PreTrainedModel:()=>y_,Gemma3ForCausalLM:()=>bM,Gemma3Model:()=>wM,Gemma3PreTrainedModel:()=>w_,Gemma3nForConditionalGeneration:()=>Fa,Gemma3nPreTrainedModel:()=>au,GemmaForCausalLM:()=>mM,GemmaModel:()=>hM,GemmaPreTrainedModel:()=>__,GlmForCausalLM:()=>ZT,GlmModel:()=>QT,GlmPreTrainedModel:()=>u_,GraniteForCausalLM:()=>uM,GraniteModel:()=>lM,GraniteMoeHybridForCausalLM:()=>dM,GraniteMoeHybridModel:()=>cM,GraniteMoeHybridPreTrainedModel:()=>m_,GranitePreTrainedModel:()=>h_,GroundingDinoForObjectDetection:()=>vS,GroundingDinoPreTrainedModel:()=>yS,GroupViTModel:()=>ZM,GroupViTPreTrainedModel:()=>QM,HeliumForCausalLM:()=>XT,HeliumModel:()=>YT,HeliumPreTrainedModel:()=>l_,HieraForImageClassification:()=>DE,HieraModel:()=>kE,HieraPreTrainedModel:()=>q_,HubertForCTC:()=>t2,HubertForSequenceClassification:()=>n2,HubertModel:()=>e2,HubertPreTrainedModel:()=>dH,IJepaForImageClassification:()=>GM,IJepaModel:()=>VM,IJepaPreTrainedModel:()=>I_,Idefics3ForConditionalGeneration:()=>sa,Idefics3PreTrainedModel:()=>Ba,ImageMattingOutput:()=>E$,JAISLMHeadModel:()=>tl,JAISModel:()=>el,JAISPreTrainedModel:()=>oa,JinaCLIPModel:()=>Yo,JinaCLIPPreTrainedModel:()=>Xe,JinaCLIPTextModel:()=>Xo,JinaCLIPVisionModel:()=>aa,Lfm2ForCausalLM:()=>al,Lfm2Model:()=>ja,Lfm2PreTrainedModel:()=>cs,LiteWhisperForConditionalGeneration:()=>mc,Llama4ForCausalLM:()=>Re,Llama4PreTrainedModel:()=>Te,LlamaForCausalLM:()=>ge,LlamaModel:()=>ie,LlamaPreTrainedModel:()=>F,LlavaForConditionalGeneration:()=>ro,LlavaOnevisionForConditionalGeneration:()=>gc,LlavaPreTrainedModel:()=>io,LlavaQwen2ForCausalLM:()=>La,LongT5ForConditionalGeneration:()=>Hn,LongT5Model:()=>wn,LongT5PreTrainedModel:()=>Pn,M2M100ForConditionalGeneration:()=>DS,M2M100Model:()=>kS,M2M100PreTrainedModel:()=>sy,MBartForCausalLM:()=>kn,MBartForConditionalGeneration:()=>Gt,MBartForSequenceClassification:()=>rn,MBartModel:()=>vt,MBartPreTrainedModel:()=>Ve,MPNetForMaskedLM:()=>Yr,MPNetForQuestionAnswering:()=>Ee,MPNetForSequenceClassification:()=>ls,MPNetForTokenClassification:()=>ia,MPNetModel:()=>os,MPNetPreTrainedModel:()=>mn,MT5ForConditionalGeneration:()=>Si,MT5Model:()=>oi,MT5PreTrainedModel:()=>Ei,MarianMTModel:()=>PS,MarianModel:()=>IS,MarianPreTrainedModel:()=>ry,MaskFormerForInstanceSegmentation:()=>tS,MaskFormerModel:()=>eS,MaskFormerPreTrainedModel:()=>X_,MaskedLMOutput:()=>dr,Metric3DForDepthEstimation:()=>XE,Metric3DPreTrainedModel:()=>YE,Metric3Dv2ForDepthEstimation:()=>ZE,Metric3Dv2PreTrainedModel:()=>QE,MgpstrForSceneTextRecognition:()=>nC,MgpstrModelOutput:()=>eC,MgpstrPreTrainedModel:()=>tC,MimiDecoderModel:()=>pC,MimiDecoderOutput:()=>cC,MimiEncoderModel:()=>fC,MimiEncoderOutput:()=>uC,MimiModel:()=>dC,MimiPreTrainedModel:()=>Xp,Ministral3ForCausalLM:()=>b2,Ministral3Model:()=>w2,Ministral3PreTrainedModel:()=>cy,MinistralForCausalLM:()=>v2,MinistralModel:()=>y2,MinistralPreTrainedModel:()=>uy,Mistral3ForConditionalGeneration:()=>za,MistralForCausalLM:()=>_2,MistralModel:()=>g2,MistralPreTrainedModel:()=>ly,MobileBertForMaskedLM:()=>ot,MobileBertForQuestionAnswering:()=>wt,MobileBertForSequenceClassification:()=>lt,MobileBertModel:()=>Hi,MobileBertPreTrainedModel:()=>Cr,MobileLLMForCausalLM:()=>iM,MobileLLMModel:()=>nM,MobileLLMPreTrainedModel:()=>d_,MobileNetV1ForImageClassification:()=>F2,MobileNetV1ForSemanticSegmentation:()=>B2,MobileNetV1Model:()=>z2,MobileNetV1PreTrainedModel:()=>qp,MobileNetV2ForImageClassification:()=>V2,MobileNetV2ForSemanticSegmentation:()=>G2,MobileNetV2Model:()=>U2,MobileNetV2PreTrainedModel:()=>Kp,MobileNetV3ForImageClassification:()=>W2,MobileNetV3ForSemanticSegmentation:()=>H2,MobileNetV3Model:()=>j2,MobileNetV3PreTrainedModel:()=>Jp,MobileNetV4ForImageClassification:()=>K2,MobileNetV4ForSemanticSegmentation:()=>J2,MobileNetV4Model:()=>q2,MobileNetV4PreTrainedModel:()=>Yp,MobileViTForImageClassification:()=>sE,MobileViTModel:()=>rE,MobileViTPreTrainedModel:()=>O_,MobileViTV2ForImageClassification:()=>oE,MobileViTV2Model:()=>aE,MobileViTV2PreTrainedModel:()=>R_,ModelOutput:()=>we,ModernBertDecoderForCausalLM:()=>hn,ModernBertDecoderModel:()=>Et,ModernBertDecoderPreTrainedModel:()=>Ct,ModernBertForMaskedLM:()=>Oe,ModernBertForSequenceClassification:()=>ct,ModernBertForTokenClassification:()=>bt,ModernBertModel:()=>Se,ModernBertPreTrainedModel:()=>Be,Moondream1ForConditionalGeneration:()=>_c,MoonshineForConditionalGeneration:()=>ru,MoonshineModel:()=>iu,MoonshinePreTrainedModel:()=>Ho,MptForCausalLM:()=>LM,MptModel:()=>NM,MptPreTrainedModel:()=>C_,MultiModalityCausalLM:()=>Z2,MultiModalityPreTrainedModel:()=>Q2,MusicgenForCausalLM:()=>mH,MusicgenForConditionalGeneration:()=>yy,MusicgenModel:()=>hH,MusicgenPreTrainedModel:()=>_y,NanoChatForCausalLM:()=>At,NanoChatModel:()=>ht,NanoChatPreTrainedModel:()=>nt,NeoBertForMaskedLM:()=>Z,NeoBertForQuestionAnswering:()=>Ke,NeoBertForSequenceClassification:()=>he,NeoBertForTokenClassification:()=>ye,NeoBertModel:()=>at,NeoBertPreTrainedModel:()=>He,NomicBertModel:()=>Kt,NomicBertPreTrainedModel:()=>En,OPTForCausalLM:()=>FM,OPTModel:()=>zM,OPTPreTrainedModel:()=>$_,Olmo2ForCausalLM:()=>oM,Olmo2Model:()=>aM,Olmo2PreTrainedModel:()=>p_,OlmoForCausalLM:()=>sM,OlmoModel:()=>rM,OlmoPreTrainedModel:()=>f_,OpenELMForCausalLM:()=>TM,OpenELMModel:()=>xM,OpenELMPreTrainedModel:()=>b_,OwlViTForObjectDetection:()=>uE,OwlViTModel:()=>lE,OwlViTPreTrainedModel:()=>N_,Owlv2ForObjectDetection:()=>dE,Owlv2Model:()=>cE,Owlv2PreTrainedModel:()=>L_,PaliGemmaForConditionalGeneration:()=>bc,PaliGemmaPreTrainedModel:()=>wc,ParakeetForCTC:()=>FS,ParakeetPreTrainedModel:()=>zS,PatchTSMixerForPrediction:()=>aC,PatchTSMixerModel:()=>sC,PatchTSMixerPreTrainedModel:()=>wy,PatchTSTForPrediction:()=>rC,PatchTSTModel:()=>iC,PatchTSTPreTrainedModel:()=>vy,Phi3ForCausalLM:()=>DM,Phi3Model:()=>kM,Phi3PreTrainedModel:()=>E_,Phi3VForCausalLM:()=>Ua,Phi3VPreTrainedModel:()=>ou,PhiForCausalLM:()=>PM,PhiModel:()=>IM,PhiPreTrainedModel:()=>M_,PreTrainedModel:()=>U,PretrainedMixin:()=>qn,PvtForImageClassification:()=>qM,PvtModel:()=>HM,PvtPreTrainedModel:()=>P_,PyAnnoteForAudioFrameClassification:()=>US,PyAnnoteModel:()=>BS,PyAnnotePreTrainedModel:()=>ay,QuestionAnsweringModelOutput:()=>Ar,Qwen2ForCausalLM:()=>EM,Qwen2Model:()=>MM,Qwen2PreTrainedModel:()=>x_,Qwen2VLForConditionalGeneration:()=>AM,Qwen2VLPreTrainedModel:()=>$M,Qwen3ForCausalLM:()=>CM,Qwen3Model:()=>SM,Qwen3PreTrainedModel:()=>T_,RFDetrForObjectDetection:()=>TE,RFDetrModel:()=>xE,RFDetrObjectDetectionOutput:()=>ME,RFDetrPreTrainedModel:()=>G_,RTDetrForObjectDetection:()=>yE,RTDetrModel:()=>_E,RTDetrObjectDetectionOutput:()=>Gd,RTDetrPreTrainedModel:()=>U_,RTDetrV2ForObjectDetection:()=>wE,RTDetrV2Model:()=>vE,RTDetrV2ObjectDetectionOutput:()=>bE,RTDetrV2PreTrainedModel:()=>V_,ResNetForImageClassification:()=>RE,ResNetModel:()=>OE,ResNetPreTrainedModel:()=>K_,RoFormerForMaskedLM:()=>tr,RoFormerForQuestionAnswering:()=>$n,RoFormerForSequenceClassification:()=>Ti,RoFormerForTokenClassification:()=>Yn,RoFormerModel:()=>Ji,RoFormerPreTrainedModel:()=>yi,RobertaForMaskedLM:()=>As,RobertaForQuestionAnswering:()=>Ps,RobertaForSequenceClassification:()=>us,RobertaForTokenClassification:()=>Is,RobertaModel:()=>$s,RobertaPreTrainedModel:()=>yr,Sam2ImageSegmentationOutput:()=>SS,Sam2Model:()=>Up,Sam2PreTrainedModel:()=>CS,Sam3TrackerModel:()=>AS,SamImageSegmentationOutput:()=>ES,SamModel:()=>MS,SamPreTrainedModel:()=>TS,SapiensForDepthEstimation:()=>HE,SapiensForNormalEstimation:()=>qE,SapiensForSemanticSegmentation:()=>WE,SapiensPreTrainedModel:()=>Bp,SegformerForImageClassification:()=>k2,SegformerForSemanticSegmentation:()=>D2,SegformerModel:()=>pH,SegformerPreTrainedModel:()=>Hp,Seq2SeqLMOutput:()=>MH,SequenceClassifierOutput:()=>an,SiglipModel:()=>oo,SiglipPreTrainedModel:()=>ao,SiglipTextModel:()=>uu,SiglipVisionModel:()=>lo,SmolLM3ForCausalLM:()=>JT,SmolLM3Model:()=>Lp,SmolLM3PreTrainedModel:()=>cu,SmolVLMForConditionalGeneration:()=>so,SnacDecoderModel:()=>bC,SnacEncoderModel:()=>wC,SnacModel:()=>vC,SnacPreTrainedModel:()=>Zp,SpeechT5ForSpeechToText:()=>c2,SpeechT5ForTextToSpeech:()=>d2,SpeechT5HifiGan:()=>f2,SpeechT5Model:()=>fH,SpeechT5PreTrainedModel:()=>jp,SqueezeBertForMaskedLM:()=>pe,SqueezeBertForQuestionAnswering:()=>Me,SqueezeBertForSequenceClassification:()=>be,SqueezeBertModel:()=>ne,SqueezeBertPreTrainedModel:()=>z,StableLmForCausalLM:()=>R2,StableLmModel:()=>O2,StableLmPreTrainedModel:()=>my,Starcoder2ForCausalLM:()=>E2,Starcoder2Model:()=>M2,Starcoder2PreTrainedModel:()=>fy,StyleTextToSpeech2Model:()=>u2,StyleTextToSpeech2PreTrainedModel:()=>l2,SupertonicForConditionalGeneration:()=>oy,SupertonicPreTrainedModel:()=>p2,Swin2SRForImageSuperResolution:()=>BE,Swin2SRModel:()=>FE,Swin2SRPreTrainedModel:()=>J_,SwinForImageClassification:()=>LE,SwinForSemanticSegmentation:()=>zE,SwinModel:()=>NE,SwinPreTrainedModel:()=>Fp,T5ForConditionalGeneration:()=>Tn,T5Model:()=>Cn,T5PreTrainedModel:()=>Wt,TableTransformerForObjectDetection:()=>$E,TableTransformerModel:()=>CE,TableTransformerObjectDetectionOutput:()=>AE,TableTransformerPreTrainedModel:()=>W_,TokenClassifierOutput:()=>rr,TrOCRForCausalLM:()=>m2,TrOCRPreTrainedModel:()=>h2,UltravoxModel:()=>by,UltravoxPreTrainedModel:()=>oC,UniSpeechForCTC:()=>WS,UniSpeechForSequenceClassification:()=>HS,UniSpeechModel:()=>jS,UniSpeechPreTrainedModel:()=>Vp,UniSpeechSatForAudioFrameClassification:()=>YS,UniSpeechSatForCTC:()=>KS,UniSpeechSatForSequenceClassification:()=>JS,UniSpeechSatModel:()=>qS,UniSpeechSatPreTrainedModel:()=>jd,VaultGemmaForCausalLM:()=>vM,VaultGemmaModel:()=>yM,VaultGemmaPreTrainedModel:()=>v_,ViTForImageClassification:()=>UM,ViTMAEModel:()=>JM,ViTMAEPreTrainedModel:()=>KM,ViTMSNForImageClassification:()=>XM,ViTMSNModel:()=>YM,ViTMSNPreTrainedModel:()=>k_,ViTModel:()=>BM,ViTPreTrainedModel:()=>A_,VisionEncoderDecoderModel:()=>su,VitMatteForImageMatting:()=>iE,VitMattePreTrainedModel:()=>nE,VitPoseForPoseEstimation:()=>WM,VitPosePreTrainedModel:()=>jM,VitsModel:()=>hy,VitsModelOutput:()=>S$,VitsPreTrainedModel:()=>P2,VoxtralForConditionalGeneration:()=>lC,Wav2Vec2BertForCTC:()=>QS,Wav2Vec2BertForSequenceClassification:()=>ZS,Wav2Vec2BertModel:()=>XS,Wav2Vec2BertPreTrainedModel:()=>Gp,Wav2Vec2ForAudioFrameClassification:()=>LS,Wav2Vec2ForCTC:()=>RS,Wav2Vec2ForSequenceClassification:()=>NS,Wav2Vec2Model:()=>OS,Wav2Vec2PreTrainedModel:()=>ol,WavLMForAudioFrameClassification:()=>o2,WavLMForCTC:()=>r2,WavLMForSequenceClassification:()=>s2,WavLMForXVector:()=>a2,WavLMModel:()=>i2,WavLMPreTrainedModel:()=>Tc,WeSpeakerResNetModel:()=>GS,WeSpeakerResNetPreTrainedModel:()=>VS,WhisperForConditionalGeneration:()=>ra,WhisperModel:()=>Wo,WhisperPreTrainedModel:()=>jo,XLMForQuestionAnswering:()=>Ra,XLMForSequenceClassification:()=>Os,XLMForTokenClassification:()=>Rs,XLMModel:()=>ks,XLMPreTrainedModel:()=>Rr,XLMRobertaForMaskedLM:()=>Ql,XLMRobertaForQuestionAnswering:()=>tu,XLMRobertaForSequenceClassification:()=>Zl,XLMRobertaForTokenClassification:()=>eu,XLMRobertaModel:()=>Xl,XLMRobertaPreTrainedModel:()=>Br,XLMWithLMHeadModel:()=>Ds,XVectorOutput:()=>M$,YolosForObjectDetection:()=>bS,YolosModel:()=>wS,YolosObjectDetectionOutput:()=>xS,YolosPreTrainedModel:()=>iy});var i=n("./src/configs.js"),r=n("./src/backends/onnx.js"),s=n("./src/utils/dtypes.js"),a=n("./src/utils/generic.js"),o=n("./src/utils/core.js"),l=n("./src/utils/hub.js"),u=n("./src/utils/constants.js"),c=n("./src/generation/logits_process.js"),f=n("./src/generation/configuration_utils.js"),d=n("./src/utils/tensor.js"),h=n("./src/utils/image.js"),m=n("./src/utils/maths.js"),y=n("./src/generation/stopping_criteria.js"),M=n("./src/generation/logits_sampler.js"),g=n("./src/env.js"),_=n("./src/models/whisper/generation_whisper.js"),T=n("./src/models/whisper/common_whisper.js");const x={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7,MultiModality:8,Phi3V:9,AudioTextToText:10,AutoEncoder:11,ImageAudioTextToText:12,Supertonic:13},S=new Map,$=new Map,C=new Map;async function P(D,N,q){var fr;let ve=((fr=q.config)==null?void 0:fr["transformers.js_config"])??{},De=q.device??ve.device;De&&typeof De!="string"&&(De.hasOwnProperty(N)?De=De[N]:(console.warn(`device not specified for "${N}". Using the default device.`),De=null));const Ae=De??(g.apis.IS_NODE_ENV?"cpu":"wasm"),je=(0,r.deviceToExecutionProviders)(Ae),st=ve.device_config??{};st.hasOwnProperty(Ae)&&(ve={...ve,...st[Ae]});let pt=q.dtype??ve.dtype;if(typeof pt!="string"&&(pt&&pt.hasOwnProperty(N)?pt=pt[N]:(pt=s.DEFAULT_DEVICE_DTYPE_MAPPING[Ae]??s.DATA_TYPES.fp32,console.warn(`dtype not specified for "${N}". Using the default dtype (${pt}) for this device (${Ae}).`))),pt===s.DATA_TYPES.auto){let _n=ve.dtype;typeof _n!="string"&&(_n=_n==null?void 0:_n[N]),_n&&_n!==s.DATA_TYPES.auto&&s.DATA_TYPES.hasOwnProperty(_n)?pt=_n:pt=s.DEFAULT_DEVICE_DTYPE_MAPPING[Ae]??s.DATA_TYPES.fp32}const Tt=pt;if(s.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(Tt)){if(Tt===s.DATA_TYPES.fp16&&Ae==="webgpu"&&!await(0,s.isWebGpuFp16Supported)())throw new Error(`The device (${Ae}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${Tt}. Should be one of: ${Object.keys(s.DATA_TYPES).join(", ")}`);const Vt=ve.kv_cache_dtype,Yt=Vt?typeof Vt=="string"?Vt:Vt[Tt]??"float32":void 0;if(Yt&&!["float32","float16"].includes(Yt))throw new Error(`Invalid kv_cache_dtype: ${Yt}. Should be one of: float32, float16`);const nn={dtype:Tt,kv_cache_dtype:Yt,device:Ae},bn=s.DEFAULT_DTYPE_SUFFIX_MAPPING[Tt],jt=`${N}${bn}.onnx`,sn=`${q.subfolder??""}/${jt}`,Nt={...q.session_options};Nt.executionProviders??(Nt.executionProviders=je);const gn=ve.free_dimension_overrides;gn?Nt.freeDimensionOverrides??(Nt.freeDimensionOverrides=gn):Ae.startsWith("webnn")&&!Nt.freeDimensionOverrides&&console.warn(`WebNN does not currently support dynamic shapes and requires 'free_dimension_overrides' to be set in config.json, preferably as a field within config["transformers.js_config"]["device_config"]["${Ae}"]. When 'free_dimension_overrides' is not set, you may experience significant performance degradation.`);const Gn=g.apis.IS_NODE_ENV&&g.env.useFSCache,pi=(0,l.getModelFile)(D,sn,!0,q,Gn),vi=q.use_external_data_format??ve.use_external_data_format;let Ci=[];if(vi){let _n;typeof vi=="object"?vi.hasOwnProperty(jt)?_n=vi[jt]:vi.hasOwnProperty(N)?_n=vi[N]:_n=!1:_n=vi;const sr=+_n;if(sr>l.MAX_EXTERNAL_DATA_CHUNKS)throw new Error(`The number of external data chunks (${sr}) exceeds the maximum allowed value (${l.MAX_EXTERNAL_DATA_CHUNKS}).`);for(let ds=0;ds<sr;++ds){const du=`${jt}_data${ds===0?"":"_"+ds}`,Ur=`${q.subfolder??""}/${du}`;Ci.push(new Promise(async(zs,eh)=>{const fu=await(0,l.getModelFile)(D,Ur,!0,q,Gn);zs(fu instanceof Uint8Array?{path:du,data:fu}:du)}))}}else Nt.externalData!==void 0&&(Ci=Nt.externalData.map(async _n=>{if(typeof _n.data=="string"){const sr=await(0,l.getModelFile)(D,_n.data,!0,q);return{..._n,data:sr}}return _n}));if(Ci.length>0){const _n=await Promise.all(Ci);g.apis.IS_NODE_ENV||(Nt.externalData=_n)}if(Ae==="webgpu"){const _n=(0,i.getCacheShapes)(q.config,{prefix:"present"});if(Object.keys(_n).length>0&&!(0,r.isONNXProxy)()){const sr={};for(const ds in _n)sr[ds]="gpu-buffer";Nt.preferredOutputLocation=sr}}return{buffer_or_path:await pi,session_options:Nt,session_config:nn}}async function O(D,N,q){return Object.fromEntries(await Promise.all(Object.keys(N).map(async ve=>{const{buffer_or_path:De,session_options:Ae,session_config:je}=await P(D,N[ve],q),st=await(0,r.createInferenceSession)(De,Ae,je);return[ve,st]})))}async function R(D,N,q){return Object.fromEntries(await Promise.all(Object.keys(N).map(async ve=>{const De=await(0,l.getModelJSON)(D,N[ve],!1,q);return[ve,De]})))}function G(D,N){const q=Object.create(null),ve=[];for(const je of D.inputNames){const st=N[je];if(!(st instanceof d.Tensor)){ve.push(je);continue}q[je]=(0,r.isONNXProxy)()?st.clone():st}if(ve.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${ve.join(", ")}.`);const De=Object.keys(N).length,Ae=D.inputNames.length;if(De>Ae){let je=Object.keys(N).filter(st=>!D.inputNames.includes(st));console.warn(`WARNING: Too many inputs were provided (${De} > ${Ae}). The following inputs will be ignored: "${je.join(", ")}".`)}return q}async function W(D,N){const q=G(D,N);try{const ve=Object.fromEntries(Object.entries(q).map(([Ae,je])=>[Ae,je.ort_tensor])),De=await(0,r.runInferenceSession)(D,ve);return V(De)}catch(ve){const De=Object.fromEntries(Object.entries(q).map(([Ae,je])=>{const st={type:je.type,dims:je.dims,location:je.location};return st.location!=="gpu-buffer"&&(st.data=je.data),[Ae,st]}));throw console.error(`An error occurred during model execution: "${ve}".`),console.error("Inputs given to model:",De),ve}}function V(D){for(let N in D)(0,r.isONNXTensor)(D[N])?D[N]=new d.Tensor(D[N]):typeof D[N]=="object"&&V(D[N]);return D}function te(D){if(D instanceof d.Tensor)return D;if(D.length===0)throw Error("items must be non-empty");if(Array.isArray(D[0])){if(D.some(N=>N.length!==D[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new d.Tensor("int64",BigInt64Array.from(D.flat().map(N=>BigInt(N))),[D.length,D[0].length])}else return new d.Tensor("int64",BigInt64Array.from(D.map(N=>BigInt(N))),[1,D.length])}function J(D){return new d.Tensor("bool",[D],[1])}async function j(D,N){let{encoder_outputs:q,input_ids:ve,decoder_input_ids:De,...Ae}=N;if(!q){const st=(0,o.pick)(N,D.sessions.model.inputNames);q=(await Y(D,st)).last_hidden_state}return Ae.input_ids=De,Ae.encoder_hidden_states=q,D.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(Ae.encoder_attention_mask=N.attention_mask),await ce(D,Ae,!0)}async function Y(D,N){const q=D.sessions.model,ve=(0,o.pick)(N,q.inputNames);if(q.inputNames.includes("inputs_embeds")&&!ve.inputs_embeds){if(!N.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");ve.inputs_embeds=await D.encode_text({input_ids:N.input_ids})}if(q.inputNames.includes("token_type_ids")&&!ve.token_type_ids){if(!ve.input_ids)throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");ve.token_type_ids=(0,d.zeros_like)(ve.input_ids)}if(q.inputNames.includes("pixel_mask")&&!ve.pixel_mask){if(!ve.pixel_values)throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");const De=ve.pixel_values.dims;ve.pixel_mask=(0,d.ones)([De[0],De[2],De[3]])}return await W(q,ve)}async function X(D,N){const q=await D.encode(N);return await D.decode(q)}async function ce(D,N,q=!1){const ve=D.sessions[q?"decoder_model_merged":"model"],{past_key_values:De,...Ae}=N;if(ve.inputNames.includes("use_cache_branch")&&(Ae.use_cache_branch=J(!!De)),ve.inputNames.includes("position_ids")&&Ae.attention_mask&&!Ae.position_ids){const st=["paligemma","gemma3_text","gemma3"].includes(D.config.model_type)?1:0;Ae.position_ids=ae(Ae,De,st)}D.addPastKeyValues(Ae,De);const je=(0,o.pick)(Ae,ve.inputNames);return await W(ve,je)}function me({modality_token_id:D,inputs_embeds:N,modality_features:q,input_ids:ve,attention_mask:De}){const Ae=ve.tolist().map(Tt=>Tt.reduce((Vt,Yt,nn)=>(Yt==D&&Vt.push(nn),Vt),[])),je=Ae.reduce((Tt,Vt)=>Tt+Vt.length,0),st=q.dims[0];if(je!==st)throw new Error(`Number of tokens and features do not match: tokens: ${je}, features ${st}`);let pt=0;for(let Tt=0;Tt<Ae.length;++Tt){const Vt=Ae[Tt],Yt=N[Tt];for(let nn=0;nn<Vt.length;++nn)Yt[Vt[nn]].data.set(q[pt++].data)}return{inputs_embeds:N,attention_mask:De}}function Q({image_token_id:D,inputs_embeds:N,image_features:q,input_ids:ve,attention_mask:De}){return me({modality_token_id:D,inputs_embeds:N,modality_features:q,input_ids:ve,attention_mask:De})}function H({audio_token_id:D,inputs_embeds:N,audio_features:q,input_ids:ve,attention_mask:De}){return me({modality_token_id:D,inputs_embeds:N,modality_features:q,input_ids:ve,attention_mask:De})}async function B(D,{encode_function:N,merge_function:q,modality_input_name:ve,modality_output_name:De,input_ids:Ae=null,attention_mask:je=null,position_ids:st=null,inputs_embeds:pt=null,past_key_values:Tt=null,generation_config:Vt=null,logits_processor:Yt=null,...nn}){const bn=nn[ve];if(!pt){if(pt=await D.encode_text({input_ids:Ae,...nn}),bn&&Ae.dims[1]!==1){const sn=await N({[ve]:bn,...nn});({inputs_embeds:pt,attention_mask:je}=q({[De]:sn,inputs_embeds:pt,input_ids:Ae,attention_mask:je}))}else if(Tt&&bn&&Ae.dims[1]===1){const sn=Ae.dims[1],Nt=Object.values(Tt)[0].dims.at(-2);je=(0,d.cat)([(0,d.ones)([Ae.dims[0],Nt]),je.slice(null,[je.dims[1]-sn,je.dims[1]])],1)}}if(!st&&D.config.model_type==="qwen2_vl"){const{image_grid_thw:sn,video_grid_thw:Nt}=nn;[st]=D.get_rope_index(Ae,sn,Nt,je)}return await ce(D,{inputs_embeds:pt,past_key_values:Tt,attention_mask:je,position_ids:st,generation_config:Vt,logits_processor:Yt},!0)}async function ee(D,N){return await B(D,{...N,modality_input_name:"audio_values",modality_output_name:"audio_features",encode_function:D.encode_audio.bind(D),merge_function:D._merge_input_ids_with_audio_features.bind(D)})}async function _e(D,N){return await B(D,{...N,modality_input_name:"pixel_values",modality_output_name:"image_features",encode_function:D.encode_image.bind(D),merge_function:D._merge_input_ids_with_image_features.bind(D)})}function le(D,N=0){const[q,ve]=D.dims,De=D.data,Ae=new BigInt64Array(De.length);for(let je=0;je<q;++je){const st=je*ve;let pt=BigInt(N);for(let Tt=0;Tt<ve;++Tt){const Vt=st+Tt;De[Vt]===0n?Ae[Vt]=BigInt(1):(Ae[Vt]=pt,pt+=De[Vt])}}return{data:Ae,dims:D.dims}}function ae(D,N=null,q=0){const{input_ids:ve,inputs_embeds:De,attention_mask:Ae}=D,{data:je,dims:st}=le(Ae,q);let pt=new d.Tensor("int64",je,st);if(N){const Tt=-(ve??De).dims.at(1);pt=pt.slice(null,[Tt,null])}return pt}function Ne(D,N,q,ve){const De=q.past_key_values?Object.values(q.past_key_values)[0].dims.at(-2):0;if(!q.attention_mask){let Ae;for(const je of["input_ids","inputs_embeds","position_ids"])if(q[je]){Ae=q[je].dims;break}if(!Ae)throw new Error("attention_mask is not provided, and unable to infer its shape from model inputs.");q.attention_mask=(0,d.ones)([Ae[0],De+Ae[1]])}if(q.past_key_values){const{input_ids:Ae,attention_mask:je}=q;je&&je.dims[1]>Ae.dims[1]||De<Ae.dims[1]&&(q.input_ids=Ae.slice(null,[De,null]))}return q}function Ye(D,N,q,ve){return q.past_key_values&&(N=N.map(De=>[De.at(-1)])),{...q,decoder_input_ids:te(N)}}function ze(D,...N){return D.config.is_encoder_decoder?Ye(D,...N):Ne(D,...N)}function ue(D,N,q,ve){const De=!!q.past_key_values;return ve.guidance_scale!==null&&ve.guidance_scale>1&&(De?q.input_ids=(0,d.cat)([q.input_ids,q.input_ids],0):(q.input_ids=(0,d.cat)([q.input_ids,(0,d.full_like)(q.input_ids,BigInt(ve.pad_token_id))],0),q.attention_mask=(0,d.cat)([q.attention_mask,(0,d.full_like)(q.attention_mask,0n)],0))),(De||!q.pixel_values)&&(q.pixel_values=(0,d.full)([0,0,3,384,384],1)),De&&(q.images_seq_mask=new d.Tensor("bool",new Array(1).fill(!0).fill(!1,0,1),[1,1]),q.images_emb_mask=new d.Tensor("bool",new Array(0).fill(!1),[1,1,0])),q}class U extends a.Callable{constructor(q,ve,De){super();fe(this,"main_input_name","input_ids");fe(this,"forward_params",["input_ids","attention_mask"]);this.config=q,this.sessions=ve,this.configs=De;const Ae=C.get(this.constructor),je=S.get(Ae);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,je){case x.DecoderOnly:this.can_generate=!0,this._forward=ce,this._prepare_inputs_for_generation=Ne;break;case x.Seq2Seq:case x.Vision2Seq:case x.Musicgen:this.can_generate=!0,this._forward=j,this._prepare_inputs_for_generation=Ye;break;case x.EncoderDecoder:this._forward=j;break;case x.ImageTextToText:this.can_generate=!0,this._forward=_e,this._prepare_inputs_for_generation=ze;break;case x.AudioTextToText:this.can_generate=!0,this._forward=ee,this._prepare_inputs_for_generation=ze;break;case x.Phi3V:case x.ImageAudioTextToText:this.can_generate=!0,this._prepare_inputs_for_generation=ze;break;case x.MultiModality:this.can_generate=!0,this._prepare_inputs_for_generation=ue;break;case x.AutoEncoder:this._forward=X;break;default:this._forward=Y;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){var ve;const q=[];for(const De of Object.values(this.sessions))(ve=De==null?void 0:De.handler)!=null&&ve.dispose&&q.push(De.handler.dispose());return await Promise.all(q)}static async from_pretrained(q,{progress_callback:ve=null,config:De=null,cache_dir:Ae=null,local_files_only:je=!1,revision:st="main",model_file_name:pt=null,subfolder:Tt="onnx",device:Vt=null,dtype:Yt=null,use_external_data_format:nn=null,session_options:bn={}}={}){let jt={progress_callback:ve,config:De,cache_dir:Ae,local_files_only:je,revision:st,model_file_name:pt,subfolder:Tt,device:Vt,dtype:Yt,use_external_data_format:nn,session_options:bn};const sn=C.get(this),Nt=S.get(sn);De=jt.config=await i.AutoConfig.from_pretrained(q,jt);let gn;if(Nt===x.DecoderOnly)gn=await Promise.all([O(q,{model:jt.model_file_name??"model"},jt),R(q,{generation_config:"generation_config.json"},jt)]);else if(Nt===x.Seq2Seq||Nt===x.Vision2Seq)gn=await Promise.all([O(q,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},jt),R(q,{generation_config:"generation_config.json"},jt)]);else if(Nt===x.MaskGeneration)gn=await Promise.all([O(q,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},jt)]);else if(Nt===x.EncoderDecoder)gn=await Promise.all([O(q,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},jt)]);else if(Nt===x.ImageTextToText){const Gn={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};De.is_encoder_decoder&&(Gn.model="encoder_model"),gn=await Promise.all([O(q,Gn,jt),R(q,{generation_config:"generation_config.json"},jt)])}else if(Nt===x.AudioTextToText){const Gn={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",decoder_model_merged:"decoder_model_merged"};gn=await Promise.all([O(q,Gn,jt),R(q,{generation_config:"generation_config.json"},jt)])}else if(Nt===x.ImageAudioTextToText){const Gn={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};gn=await Promise.all([O(q,Gn,jt),R(q,{generation_config:"generation_config.json"},jt)])}else if(Nt===x.Musicgen)gn=await Promise.all([O(q,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},jt),R(q,{generation_config:"generation_config.json"},jt)]);else if(Nt===x.MultiModality)gn=await Promise.all([O(q,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},jt),R(q,{generation_config:"generation_config.json"},jt)]);else if(Nt===x.Phi3V)gn=await Promise.all([O(q,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},jt),R(q,{generation_config:"generation_config.json"},jt)]);else if(Nt===x.AutoEncoder)gn=await Promise.all([O(q,{encoder_model:"encoder_model",decoder_model:"decoder_model"},jt)]);else if(Nt===x.Supertonic)gn=await Promise.all([O(q,{text_encoder:"text_encoder",latent_denoiser:"latent_denoiser",voice_decoder:"voice_decoder"},jt)]);else{if(Nt!==x.EncoderOnly){const Gn=sn??(De==null?void 0:De.model_type);Gn!=="custom"&&console.warn(`Model type for '${Gn}' not found, assuming encoder-only architecture. Please report this at ${u.GITHUB_ISSUE_URL}.`)}gn=await Promise.all([O(q,{model:jt.model_file_name??"model"},jt)])}return new this(De,...gn)}async _call(q){return await this.forward(q)}async forward(q){return await this._forward(this,q)}get generation_config(){var q;return((q=this.configs)==null?void 0:q.generation_config)??null}_get_logits_processor(q,ve,De=null){const Ae=new c.LogitsProcessorList;if(q.repetition_penalty!==null&&q.repetition_penalty!==1&&Ae.push(new c.RepetitionPenaltyLogitsProcessor(q.repetition_penalty)),q.no_repeat_ngram_size!==null&&q.no_repeat_ngram_size>0&&Ae.push(new c.NoRepeatNGramLogitsProcessor(q.no_repeat_ngram_size)),q.bad_words_ids!==null&&Ae.push(new c.NoBadWordsLogitsProcessor(q.bad_words_ids,q.eos_token_id)),q.min_length!==null&&q.eos_token_id!==null&&q.min_length>0&&Ae.push(new c.MinLengthLogitsProcessor(q.min_length,q.eos_token_id)),q.min_new_tokens!==null&&q.eos_token_id!==null&&q.min_new_tokens>0&&Ae.push(new c.MinNewTokensLengthLogitsProcessor(ve,q.min_new_tokens,q.eos_token_id)),q.forced_bos_token_id!==null&&Ae.push(new c.ForcedBOSTokenLogitsProcessor(q.forced_bos_token_id)),q.forced_eos_token_id!==null&&Ae.push(new c.ForcedEOSTokenLogitsProcessor(q.max_length,q.forced_eos_token_id)),q.begin_suppress_tokens!==null){const je=ve>1||q.forced_bos_token_id===null?ve:ve+1;Ae.push(new c.SuppressTokensAtBeginLogitsProcessor(q.begin_suppress_tokens,je))}return q.guidance_scale!==null&&q.guidance_scale>1&&Ae.push(new c.ClassifierFreeGuidanceLogitsProcessor(q.guidance_scale)),q.temperature===0&&q.do_sample&&(console.warn("`do_sample` changed to false because `temperature: 0` implies greedy sampling (always selecting the most likely token), which is incompatible with `do_sample: true`."),q.do_sample=!1),q.do_sample&&q.temperature!==null&&q.temperature!==1&&Ae.push(new c.TemperatureLogitsWarper(q.temperature)),De!==null&&Ae.extend(De),Ae}_prepare_generation_config(q,ve,De=f.GenerationConfig){const Ae={...this.config};for(const st of["decoder","generator","text_config"])st in Ae&&Object.assign(Ae,Ae[st]);const je=new De(Ae);return Object.assign(je,this.generation_config??{}),q&&Object.assign(je,q),ve&&Object.assign(je,(0,o.pick)(ve,Object.getOwnPropertyNames(je))),je}_get_stopping_criteria(q,ve=null){const De=new y.StoppingCriteriaList;return q.max_length!==null&&De.push(new y.MaxLengthCriteria(q.max_length,this.config.max_position_embeddings??null)),q.eos_token_id!==null&&De.push(new y.EosTokenCriteria(q.eos_token_id)),ve&&De.extend(ve),De}_validate_model_class(){if(!this.can_generate){const q=[My,Ey,Ty,xy],ve=C.get(this.constructor),De=new Set,Ae=this.config.model_type;for(const st of q){const pt=st.get(Ae);pt&&De.add(pt[0])}let je=`The current model class (${ve}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw De.size>0&&(je+=` Please use the following class instead: ${[...De].join(", ")}`),Error(je)}}prepare_inputs_for_generation(...q){return this._prepare_inputs_for_generation(this,...q)}_update_model_kwargs_for_generation({generated_input_ids:q,outputs:ve,model_inputs:De,is_encoder_decoder:Ae}){return De.past_key_values=this.getPastKeyValues(ve,De.past_key_values),De.input_ids=new d.Tensor("int64",q.flat(),[q.length,1]),Ae||(De.attention_mask=(0,d.cat)([De.attention_mask,(0,d.ones)([De.attention_mask.dims[0],1])],1)),De.position_ids=null,De}_prepare_model_inputs({inputs:q,bos_token_id:ve,model_kwargs:De}){const Ae=(0,o.pick)(De,this.forward_params),je=this.main_input_name;if(je in Ae){if(q)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else Ae[je]=q;return{inputs_tensor:Ae[je],model_inputs:Ae,model_input_name:je}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:q,model_inputs:ve,model_input_name:De,generation_config:Ae}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!ve.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:st,pixel_values:pt,attention_mask:Tt,...Vt}=ve,Yt=await this._prepare_inputs_embeds(ve);ve={...Vt,...(0,o.pick)(Yt,["inputs_embeds","attention_mask"])}}let{last_hidden_state:je}=await Y(this,ve);if(Ae.guidance_scale!==null&&Ae.guidance_scale>1)je=(0,d.cat)([je,(0,d.full_like)(je,0)],0),"attention_mask"in ve&&(ve.attention_mask=(0,d.cat)([ve.attention_mask,(0,d.zeros_like)(ve.attention_mask)],0));else if(ve.decoder_input_ids){const st=te(ve.decoder_input_ids).dims[0];if(st!==je.dims[0]){if(je.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${je.dims[0]}) than the decoder inputs (${st}).`);je=(0,d.cat)(Array.from({length:st},()=>je),0)}}return ve.encoder_outputs=je,ve}_prepare_decoder_input_ids_for_generation({batch_size:q,model_input_name:ve,model_kwargs:De,decoder_start_token_id:Ae,bos_token_id:je,generation_config:st}){let{decoder_input_ids:pt,...Tt}=De;if(!(pt instanceof d.Tensor)){if(pt)Array.isArray(pt[0])||(pt=Array.from({length:q},()=>pt));else if(Ae??(Ae=je),this.config.model_type==="musicgen")pt=Array.from({length:q*this.config.decoder.num_codebooks},()=>[Ae]);else if(Array.isArray(Ae)){if(Ae.length!==q)throw new Error(`\`decoder_start_token_id\` expcted to have length ${q} but got ${Ae.length}`);pt=Ae}else pt=Array.from({length:q},()=>[Ae]);pt=te(pt)}return De.decoder_attention_mask=(0,d.ones_like)(pt),{input_ids:pt,model_inputs:Tt}}async generate({inputs:q=null,generation_config:ve=null,logits_processor:De=null,stopping_criteria:Ae=null,streamer:je=null,...st}){this._validate_model_class(),ve=this._prepare_generation_config(ve,st);let{inputs_tensor:pt,model_inputs:Tt,model_input_name:Vt}=this._prepare_model_inputs({inputs:q,model_kwargs:st});const Yt=this.config.is_encoder_decoder;Yt&&("encoder_outputs"in Tt||(Tt=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:pt,model_inputs:Tt,model_input_name:Vt,generation_config:ve})));let nn;Yt?{input_ids:nn,model_inputs:Tt}=this._prepare_decoder_input_ids_for_generation({batch_size:Tt[Vt].dims.at(0),model_input_name:Vt,model_kwargs:Tt,decoder_start_token_id:ve.decoder_start_token_id,bos_token_id:ve.bos_token_id,generation_config:ve}):nn=Tt[Vt];let bn=nn.dims.at(-1);ve.max_new_tokens!==null&&(ve.max_length=bn+ve.max_new_tokens);const jt=this._get_logits_processor(ve,bn,De),sn=this._get_stopping_criteria(ve,Ae),Nt=Tt[Vt].dims.at(0),gn=M.LogitsSampler.getSampler(ve),Gn=new Array(Nt).fill(0),pi=nn.tolist();je&&je.put(pi);let vi,Ci={};for(;;){if(Tt=this.prepare_inputs_for_generation(pi,Tt,ve),vi=await this.forward(Tt),ve.output_attentions&&ve.return_dict_in_generate){const Ur=this.getAttentions(vi);for(const zs in Ur)zs in Ci||(Ci[zs]=[]),Ci[zs].push(Ur[zs])}const _n=vi.logits.slice(null,-1,null),sr=jt(pi,_n),ds=[];for(let Ur=0;Ur<sr.dims.at(0);++Ur){const zs=sr[Ur],eh=await gn(zs);for(const[fu,th]of eh){const nh=BigInt(fu);Gn[Ur]+=th,pi[Ur].push(nh),ds.push([nh]);break}}if(je&&je.put(ds),sn(pi).every(Ur=>Ur))break;Tt=this._update_model_kwargs_for_generation({generated_input_ids:ds,outputs:vi,model_inputs:Tt,is_encoder_decoder:Yt})}je&&je.end();const Qi=this.getPastKeyValues(vi,Tt.past_key_values,!0),fr=new d.Tensor("int64",pi.flat(),[pi.length,pi[0].length]);if(ve.return_dict_in_generate)return{sequences:fr,past_key_values:Qi,...Ci};for(const _n of Object.values(vi))_n.location==="gpu-buffer"&&_n.dispose();return fr}getPastKeyValues(q,ve,De=!1){const Ae=Object.create(null);for(const je in q)if(je.startsWith("present")){const st=je.replace("present_conv","past_conv").replace("present","past_key_values"),pt=je.includes("encoder");if(pt&&ve?Ae[st]=ve[st]:Ae[st]=q[je],ve&&(!pt||De)){const Tt=ve[st];Tt.location==="gpu-buffer"&&Tt.dispose()}}return Ae}getAttentions(q){const ve={};for(const De of["cross_attentions","encoder_attentions","decoder_attentions"])for(const Ae in q)Ae.startsWith(De)&&(De in ve||(ve[De]=[]),ve[De].push(q[Ae]));return ve}addPastKeyValues(q,ve){var De,Ae,je;if(ve)Object.assign(q,ve);else{const st=this.sessions.decoder_model_merged??this.sessions.model,pt=((Ae=(De=q[this.main_input_name]??q.attention_mask)==null?void 0:De.dims)==null?void 0:Ae[0])??1,Tt=((je=st==null?void 0:st.config)==null?void 0:je.kv_cache_dtype)??"float32",Vt=Tt==="float16"?d.DataTypeMap.float16:d.DataTypeMap.float32,Yt=(0,i.getCacheShapes)(this.config,{batch_size:pt});for(const nn in Yt){const bn=Yt[nn].reduce((jt,sn)=>jt*sn,1);q[nn]=new d.Tensor(Tt,new Vt(bn),Yt[nn])}}}async encode_image({pixel_values:q}){return(await W(this.sessions.vision_encoder,{pixel_values:q})).image_features}async encode_text({input_ids:q}){return(await W(this.sessions.embed_tokens,{input_ids:q})).inputs_embeds}async encode_audio({audio_values:q}){return(await W(this.sessions.audio_encoder,{audio_values:q})).audio_features}}class we{}class Pe extends we{constructor({last_hidden_state:N,hidden_states:q=null,attentions:ve=null}){super(),this.last_hidden_state=N,this.hidden_states=q,this.attentions=ve}}class ke extends U{}class Le extends ke{}class Ge extends ke{async _call(N){return new dr(await super._call(N))}}class $e extends ke{async _call(N){return new an(await super._call(N))}}class et extends ke{async _call(N){return new rr(await super._call(N))}}class Ce extends ke{async _call(N){return new Ar(await super._call(N))}}class He extends U{}class at extends He{}class Z extends He{async _call(N){return new dr(await super._call(N))}}class he extends He{async _call(N){return new an(await super._call(N))}}class ye extends He{async _call(N){return new rr(await super._call(N))}}class Ke extends He{async _call(N){return new Ar(await super._call(N))}}class Be extends U{}class Se extends Be{}class Oe extends Be{async _call(N){return new dr(await super._call(N))}}class ct extends Be{async _call(N){return new an(await super._call(N))}}class bt extends Be{async _call(N){return new rr(await super._call(N))}}class Ct extends U{}class Et extends Ct{}class hn extends Ct{}class En extends U{}class Kt extends En{}class yi extends U{}class Ji extends yi{}class tr extends yi{async _call(N){return new dr(await super._call(N))}}class Ti extends yi{async _call(N){return new an(await super._call(N))}}class Yn extends yi{async _call(N){return new rr(await super._call(N))}}class $n extends yi{async _call(N){return new Ar(await super._call(N))}}class Yi extends U{}class Gi extends Yi{}class xt extends Yi{async _call(N){return new dr(await super._call(N))}}class ji extends Yi{async _call(N){return new an(await super._call(N))}}class Wi extends Yi{async _call(N){return new rr(await super._call(N))}}class Sn extends Yi{async _call(N){return new Ar(await super._call(N))}}class Ii extends U{}class Xt extends Ii{}class nr extends Ii{async _call(N){return new dr(await super._call(N))}}class L extends Ii{async _call(N){return new an(await super._call(N))}}class oe extends Ii{async _call(N){return new rr(await super._call(N))}}class K extends Ii{async _call(N){return new Ar(await super._call(N))}}class re extends U{}class de extends re{}class xe extends re{async _call(N){return new dr(await super._call(N))}}class Ue extends re{async _call(N){return new an(await super._call(N))}}class _t extends re{async _call(N){return new rr(await super._call(N))}}class $t extends re{async _call(N){return new Ar(await super._call(N))}}class mt extends U{}class Ht extends mt{}class It extends mt{async _call(N){return new dr(await super._call(N))}}class Zt extends mt{async _call(N){return new an(await super._call(N))}}class St extends mt{async _call(N){return new rr(await super._call(N))}}class tn extends mt{async _call(N){return new Ar(await super._call(N))}}class vn extends U{}class Wn extends vn{}class ei extends vn{async _call(N){return new dr(await super._call(N))}}class Bn extends vn{async _call(N){return new an(await super._call(N))}}class Je extends vn{async _call(N){return new rr(await super._call(N))}}class qt extends vn{async _call(N){return new Ar(await super._call(N))}}class Pt extends U{}class kt extends Pt{}class An extends Pt{async _call(N){return new an(await super._call(N))}}class zn extends Pt{async _call(N){return new rr(await super._call(N))}}class ni extends Pt{async _call(N){return new Ar(await super._call(N))}}class Un extends Pt{async _call(N){return new dr(await super._call(N))}}class In extends U{}class ir extends In{}class Mi extends In{async _call(N){return new dr(await super._call(N))}}class ci extends In{async _call(N){return new an(await super._call(N))}}class Xi extends In{async _call(N){return new rr(await super._call(N))}}class Cr extends U{}class Hi extends Cr{}class ot extends Cr{async _call(N){return new dr(await super._call(N))}}class lt extends Cr{async _call(N){return new an(await super._call(N))}}class wt extends Cr{async _call(N){return new Ar(await super._call(N))}}class mn extends U{}class os extends mn{}class Yr extends mn{async _call(N){return new dr(await super._call(N))}}class ls extends mn{async _call(N){return new an(await super._call(N))}}class ia extends mn{async _call(N){return new rr(await super._call(N))}}class Ee extends mn{async _call(N){return new Ar(await super._call(N))}}class z extends U{}class ne extends z{}class pe extends z{async _call(N){return new dr(await super._call(N))}}class be extends z{async _call(N){return new an(await super._call(N))}}class Me extends z{async _call(N){return new Ar(await super._call(N))}}class Fe extends U{}class ut extends Fe{}class yt extends Fe{async _call(N){return new an(await super._call(N))}}class gt extends Fe{async _call(N){return new Ar(await super._call(N))}}class Mt extends Fe{async _call(N){return new dr(await super._call(N))}}class Wt extends U{constructor(){super(...arguments);fe(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class Cn extends Wt{}class Tn extends Wt{}class Pn extends U{}class wn extends Pn{}class Hn extends Pn{}class Ei extends U{}class oi extends Ei{}class Si extends Ei{}class Pi extends U{}class _r extends Pi{}class tt extends Pi{}class it extends Pi{async _call(N){return new an(await super._call(N))}}class Ve extends U{}class vt extends Ve{}class Gt extends Ve{}class rn extends Ve{async _call(N){return new an(await super._call(N))}}class kn extends Ve{}class Mn extends U{}class Dn extends Mn{}class li extends Mn{}class Vn extends U{}class Bi extends Vn{}class $r extends Vn{}class yr extends U{}class $s extends yr{}class As extends yr{async _call(N){return new dr(await super._call(N))}}class us extends yr{async _call(N){return new an(await super._call(N))}}class Is extends yr{async _call(N){return new rr(await super._call(N))}}class Ps extends yr{async _call(N){return new Ar(await super._call(N))}}class Rr extends U{}class ks extends Rr{}class Ds extends Rr{async _call(N){return new dr(await super._call(N))}}class Os extends Rr{async _call(N){return new an(await super._call(N))}}class Rs extends Rr{async _call(N){return new rr(await super._call(N))}}class Ra extends Rr{async _call(N){return new Ar(await super._call(N))}}class Br extends U{}class Xl extends Br{}class Ql extends Br{async _call(N){return new dr(await super._call(N))}}class Zl extends Br{async _call(N){return new an(await super._call(N))}}class eu extends Br{async _call(N){return new rr(await super._call(N))}}class tu extends Br{async _call(N){return new Ar(await super._call(N))}}class no extends U{}class nu extends no{}class Na extends no{}class jo extends U{constructor(){super(...arguments);fe(this,"requires_attention_mask",!1);fe(this,"main_input_name","input_features");fe(this,"forward_params",["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class Wo extends jo{}class ra extends jo{_prepare_generation_config(N,q){return super._prepare_generation_config(N,q,_.WhisperGenerationConfig)}_retrieve_init_tokens(N){const q=[N.decoder_start_token_id];let ve=N.language;const De=N.task;if(N.is_multilingual){ve||(console.warn("No language specified - defaulting to English (en)."),ve="en");const je=`<|${(0,T.whisper_language_to_code)(ve)}|>`;q.push(N.lang_to_id[je]),q.push(N.task_to_id[De??"transcribe"])}else if(ve||De)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!N.return_timestamps&&N.no_timestamps_token_id&&q.at(-1)!==N.no_timestamps_token_id?q.push(N.no_timestamps_token_id):N.return_timestamps&&q.at(-1)===N.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),q.pop()),q.filter(Ae=>Ae!=null)}async generate({inputs:N=null,generation_config:q=null,logits_processor:ve=null,stopping_criteria:De=null,...Ae}){q=this._prepare_generation_config(q,Ae);const je=Ae.decoder_input_ids??this._retrieve_init_tokens(q);if(q.return_timestamps&&(ve??(ve=new c.LogitsProcessorList),ve.push(new c.WhisperTimeStampLogitsProcessor(q,je))),q.begin_suppress_tokens&&(ve??(ve=new c.LogitsProcessorList),ve.push(new c.SuppressTokensAtBeginLogitsProcessor(q.begin_suppress_tokens,je.length))),q.return_token_timestamps){if(!q.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");q.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),q.output_attentions=!0,q.return_dict_in_generate=!0}const st=await super.generate({inputs:N,generation_config:q,logits_processor:ve,decoder_input_ids:je,...Ae});return q.return_token_timestamps&&(st.token_timestamps=this._extract_token_timestamps(st,q.alignment_heads,q.num_frames)),st}_extract_token_timestamps(N,q,ve=null,De=.02){if(!N.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");ve==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let Ae=this.config.median_filter_width;Ae===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),Ae=7);const je=N.cross_attentions,st=Array.from({length:this.config.decoder_layers},(sn,Nt)=>(0,d.cat)(je.map(gn=>gn[Nt]),2)),pt=(0,d.stack)(q.map(([sn,Nt])=>{if(sn>=st.length)throw new Error(`Layer index ${sn} is out of bounds for cross attentions (length ${st.length}).`);return ve?st[sn].slice(null,Nt,null,[0,ve]):st[sn].slice(null,Nt)})).transpose(1,0,2,3),[Tt,Vt]=(0,d.std_mean)(pt,-2,0,!0),Yt=pt.clone();for(let sn=0;sn<Yt.dims[0];++sn){const Nt=Yt[sn];for(let gn=0;gn<Nt.dims[0];++gn){const Gn=Nt[gn],pi=Tt[sn][gn][0].data,vi=Vt[sn][gn][0].data;for(let Ci=0;Ci<Gn.dims[0];++Ci){let Qi=Gn[Ci].data;for(let fr=0;fr<Qi.length;++fr)Qi[fr]=(Qi[fr]-vi[fr])/pi[fr];Qi.set((0,m.medianFilter)(Qi,Ae))}}}const nn=[(0,d.mean)(Yt,1)],bn=N.sequences.dims,jt=new d.Tensor("float32",new Float32Array(bn[0]*bn[1]),bn);for(let sn=0;sn<bn[0];++sn){const Nt=nn[sn].neg().squeeze_(0),[gn,Gn]=(0,m.dynamic_time_warping)(Nt.tolist()),pi=Array.from({length:gn.length-1},(Qi,fr)=>gn[fr+1]-gn[fr]),vi=(0,o.mergeArrays)([1],pi).map(Qi=>!!Qi),Ci=[];for(let Qi=0;Qi<vi.length;++Qi)vi[Qi]&&Ci.push(Gn[Qi]*De);jt[sn].data.set(Ci,1)}return jt}}class mc extends ra{}class Ho extends U{constructor(){super(...arguments);fe(this,"requires_attention_mask",!1);fe(this,"main_input_name","input_values");fe(this,"forward_params",["input_values","decoder_input_ids","past_key_values"])}}class iu extends Ho{}class ru extends Ho{}class su extends U{constructor(){super(...arguments);fe(this,"main_input_name","pixel_values");fe(this,"forward_params",["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"])}}class io extends U{constructor(){super(...arguments);fe(this,"forward_params",["input_ids","attention_mask","pixel_values","position_ids","past_key_values"])}}class ro extends io{_merge_input_ids_with_image_features(N){const q=N.image_features.dims.at(-1),ve=N.image_features.view(-1,q);return Q({image_token_id:this.config.image_token_index,...N,image_features:ve})}}class gc extends ro{}class _c extends ro{}class yc extends U{constructor(){super(...arguments);fe(this,"forward_params",["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"]);fe(this,"main_input_name","inputs_embeds")}}class vc extends yc{_merge_input_ids_with_image_features({inputs_embeds:N,image_features:q,input_ids:ve,attention_mask:De}){return{inputs_embeds:(0,d.cat)([q,N],1),attention_mask:(0,d.cat)([(0,d.ones)(q.dims.slice(0,2)),De],1)}}async _prepare_inputs_embeds({input_ids:N,pixel_values:q,inputs_embeds:ve,attention_mask:De}){if(!N&&!q)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let Ae,je;return N&&(Ae=await this.encode_text({input_ids:N})),q&&(je=await this.encode_image({pixel_values:q})),Ae&&je?{inputs_embeds:ve,attention_mask:De}=this._merge_input_ids_with_image_features({inputs_embeds:Ae,image_features:je,input_ids:N,attention_mask:De}):ve=Ae||je,{inputs_embeds:ve,attention_mask:De}}async forward({input_ids:N,pixel_values:q,attention_mask:ve,decoder_input_ids:De,decoder_attention_mask:Ae,encoder_outputs:je,past_key_values:st,inputs_embeds:pt,decoder_inputs_embeds:Tt}){if(pt||({inputs_embeds:pt,attention_mask:ve}=await this._prepare_inputs_embeds({input_ids:N,pixel_values:q,inputs_embeds:pt,attention_mask:ve})),!je){let{last_hidden_state:nn}=await Y(this,{inputs_embeds:pt,attention_mask:ve});je=nn}if(!Tt){if(!De)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");Tt=await this.encode_text({input_ids:De})}return await ce(this,{inputs_embeds:Tt,attention_mask:Ae,encoder_attention_mask:ve,encoder_hidden_states:je,past_key_values:st},!0)}}class wc extends U{constructor(){super(...arguments);fe(this,"forward_params",["input_ids","attention_mask","pixel_values","position_ids","past_key_values"])}}class bc extends wc{_merge_input_ids_with_image_features(N){const q=N.image_features.dims.at(-1),ve=N.image_features.view(-1,q);return Q({image_token_id:this.config.image_token_index,...N,image_features:ve})}}class La extends io{_merge_input_ids_with_image_features(N){const q=N.image_features.dims.at(-1),ve=N.image_features.view(-1,q);return Q({image_token_id:this.config.image_token_index,...N,image_features:ve})}}class za extends La{}class au extends U{constructor(){super(...arguments);fe(this,"forward_params",["input_ids","attention_mask","inputs_embeds","per_layer_inputs","position_ids","pixel_values","input_features","input_features_mask","past_key_values"])}}class Fa extends au{async forward({input_ids:N=null,attention_mask:q=null,pixel_values:ve=null,input_features:De=null,input_features_mask:Ae=null,position_ids:je=null,inputs_embeds:st=null,per_layer_inputs:pt=null,past_key_values:Tt=null,generation_config:Vt=null,logits_processor:Yt=null,...nn}){if((!st||!pt)&&({inputs_embeds:st,per_layer_inputs:pt}=await W(this.sessions.embed_tokens,{input_ids:N}),N.dims[1]!==1)){if(ve){const{image_features:jt}=await W(this.sessions.vision_encoder,{pixel_values:ve});({inputs_embeds:st,attention_mask:q}=this._merge_input_ids_with_image_features({image_features:jt,inputs_embeds:st,input_ids:N,attention_mask:q}))}if(De){const{audio_features:jt}=await W(this.sessions.audio_encoder,{input_features:De,input_features_mask:Ae});({inputs_embeds:st,attention_mask:q}=this._merge_input_ids_with_audio_features({audio_features:jt,inputs_embeds:st,input_ids:N,attention_mask:q}))}}return await ce(this,{inputs_embeds:st,per_layer_inputs:pt,past_key_values:Tt,attention_mask:q,position_ids:je,generation_config:Vt,logits_processor:Yt},!0)}_merge_input_ids_with_image_features(N){const q=N.image_features.dims.at(-1),ve=N.image_features.view(-1,q);return Q({image_token_id:this.config.image_token_id,...N,image_features:ve})}_merge_input_ids_with_audio_features(N){const q=N.audio_features.dims.at(-1),ve=N.audio_features.view(-1,q);return H({audio_token_id:this.config.audio_token_id,...N,audio_features:ve})}}class Ba extends U{constructor(){super(...arguments);fe(this,"forward_params",["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"])}}class sa extends Ba{async encode_image({pixel_values:N,pixel_attention_mask:q}){return(await W(this.sessions.vision_encoder,{pixel_values:N,pixel_attention_mask:q})).image_features}_merge_input_ids_with_image_features(N){const q=N.image_features.dims.at(-1),ve=N.image_features.view(-1,q);return Q({image_token_id:this.config.image_token_id,...N,image_features:ve})}}class so extends sa{}class ou extends U{constructor(){super(...arguments);fe(this,"forward_params",["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"])}}class Ua extends ou{async forward({input_ids:N=null,attention_mask:q=null,pixel_values:ve=null,image_sizes:De=null,position_ids:Ae=null,inputs_embeds:je=null,past_key_values:st=null,generation_config:pt=null,logits_processor:Tt=null,...Vt}){if(!je){let nn;if(ve&&N.dims[1]!==1){if(!De)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:nn}=await W(this.sessions.vision_encoder,{pixel_values:ve,image_sizes:De}))}else{const bn=this.config.normalized_config.hidden_size;nn=new d.Tensor("float32",[],[0,bn])}({inputs_embeds:je}=await W(this.sessions.prepare_inputs_embeds,{input_ids:N,image_features:nn}))}return await ce(this,{inputs_embeds:je,past_key_values:st,attention_mask:q,position_ids:Ae,generation_config:pt,logits_processor:Tt},!1)}}class Xr extends U{}class qo extends Xr{}class lu extends Xr{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"text_model"})}}class Ko extends Xr{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"text_model"})}}class xc extends Xr{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"vision_model"})}}class Jo extends Xr{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"vision_model"})}}class ao extends U{}class oo extends ao{}class uu extends ao{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"text_model"})}}class lo extends Xr{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"vision_model"})}}class uo extends U{}class Ft extends uo{}class Xe extends U{}class Yo extends Xe{async forward(N){const q=!N.input_ids,ve=!N.pixel_values;if(q&&ve)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(q&&(N.input_ids=(0,d.ones)([N.pixel_values.dims[0],1])),ve){const{image_size:Tt}=this.config.vision_config;N.pixel_values=(0,d.full)([0,3,Tt,Tt],0)}const{text_embeddings:De,image_embeddings:Ae,l2norm_text_embeddings:je,l2norm_image_embeddings:st}=await super.forward(N),pt={};return q||(pt.text_embeddings=De,pt.l2norm_text_embeddings=je),ve||(pt.image_embeddings=Ae,pt.l2norm_image_embeddings=st),pt}}class Xo extends Xe{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"text_model"})}}class aa extends Xe{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"vision_model"})}}class Ni extends U{}class Ns extends Ni{}class Va extends Ni{}class co extends U{}class Qo extends co{}class Zo extends co{}class oa extends U{}class el extends oa{}class tl extends oa{}class fo extends U{}class Ls extends fo{}class Ga extends fo{}class la extends U{}class nl extends la{}class il extends la{}class po extends U{}class rl extends po{}class sl extends po{}class ho extends U{}class p extends ho{}class v extends ho{}class E extends U{}class I extends E{}class k extends E{}class F extends U{}class ie extends F{}class ge extends F{}class Te extends U{}class Re extends Te{}class nt extends U{}class ht extends nt{}class At extends nt{}class Jt extends U{}class ui extends Jt{}class vr extends Jt{}class cs extends U{}class ja extends cs{}class al extends cs{}class cu extends U{}class Lp extends cu{}class JT extends cu{}class l_ extends U{}class YT extends l_{}class XT extends l_{}class u_ extends U{}class QT extends u_{}class ZT extends u_{}class c_ extends U{}class eM extends c_{}class tM extends c_{}class d_ extends U{}class nM extends d_{}class iM extends d_{}class f_ extends U{}class rM extends f_{}class sM extends f_{}class p_ extends U{}class aM extends p_{}class oM extends p_{}class h_ extends U{}class lM extends h_{}class uM extends h_{}class m_ extends U{}class cM extends m_{}class dM extends m_{}class g_ extends U{}class fM extends g_{}class pM extends g_{}class __ extends U{}class hM extends __{}class mM extends __{}class y_ extends U{}class gM extends y_{}class _M extends y_{}class v_ extends U{}class yM extends v_{}class vM extends v_{}class w_ extends U{}class wM extends w_{}class bM extends w_{}class b_ extends U{}class xM extends b_{}class TM extends b_{}class x_ extends U{}class MM extends x_{}class EM extends x_{}class T_ extends U{}class SM extends T_{}class CM extends T_{}class $M extends U{constructor(){super(...arguments);fe(this,"forward_params",["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"])}}class AM extends $M{get_rope_index(N,q,ve,De){const{vision_config:Ae,image_token_id:je,video_token_id:st,vision_start_token_id:pt}=this.config,Tt=Ae.spatial_merge_size??2,Vt=[];if(q||ve){let Yt=N.tolist();De||(De=(0,d.ones_like)(N));const nn=De.tolist(),bn=Array.from({length:3},Gn=>Array.from({length:N.dims[0]},pi=>Array.from({length:N.dims[1]},vi=>1))),jt=q?q.tolist():[],sn=ve?ve.tolist():[];let Nt=0,gn=0;for(let Gn=0;Gn<Yt.length;++Gn){const pi=Yt[Gn].filter(($i,ar)=>nn[Gn][ar]==1),Ci=pi.reduce(($i,ar,ul)=>(ar==pt&&$i.push(ul),$i),[]).map($i=>pi[$i+1]),Qi=Ci.filter($i=>$i==je).length,fr=Ci.filter($i=>$i==st).length;let _n=[],sr=0,ds=Qi,du=fr;for(let $i=0;$i<Ci.length;++$i){const ar=pi.findIndex((hu,ua)=>ua>sr&&hu==je),ul=pi.findIndex((hu,ua)=>ua>sr&&hu==st),pu=ds>0&&ar!==-1?ar:pi.length+1,Ec=du>0&&ul!==-1?ul:pi.length+1;let ih,Cy,$y,Ay;pu<Ec?([Cy,$y,Ay]=jt[Nt],++Nt,--ds,ih=pu):([Cy,$y,Ay]=sn[gn],++gn,--du,ih=Ec);const[SH,Iy,rh]=[Number(Cy),Math.floor(Number($y)/Tt),Math.floor(Number(Ay)/Tt)],Py=ih-sr,C$=_n.length>0?(0,m.max)(_n.at(-1))[0]+1:0;_n.push(Array.from({length:3*Py},(hu,ua)=>C$+ua%Py));const ky=Py+C$,sh=SH*Iy*rh,CH=Array.from({length:sh},(hu,ua)=>ky+Math.floor(ua/(Iy*rh))),$H=Array.from({length:sh},(hu,ua)=>ky+Math.floor(ua/rh)%Iy),AH=Array.from({length:sh},(hu,ua)=>ky+ua%rh);_n.push([CH,$H,AH].flat()),sr=ih+sh}if(sr<pi.length){const $i=_n.length>0?(0,m.max)(_n.at(-1))[0]+1:0,ar=pi.length-sr;_n.push(Array.from({length:3*ar},(ul,pu)=>$i+pu%ar))}const Ur=_n.reduce(($i,ar)=>$i+ar.length,0),zs=new Array(Ur);let eh=0;for(let $i=0;$i<3;++$i)for(let ar=0;ar<_n.length;++ar){const ul=_n[ar],pu=ul.length/3;for(let Ec=$i*pu;Ec<($i+1)*pu;++Ec)zs[eh++]=ul[Ec]}let fu=0;const th=nn[Gn];for(let $i=0;$i<th.length;++$i)if(th[$i]==1){for(let ar=0;ar<3;++ar)bn[ar][Gn][$i]=zs[ar*Ur/3+fu];++fu}const nh=(0,m.max)(zs)[0];Vt.push(nh+1-Yt[Gn].length)}return[new d.Tensor("int64",bn.flat(1/0),[3,N.dims[0],N.dims[1]]),new d.Tensor("int64",Vt,[Vt.length,1])]}else if(De){const{data:Yt,dims:nn}=le(De),bn=BigInt64Array.from({length:3*Yt.length},(sn,Nt)=>Yt[Nt%Yt.length]),jt=Array.from({length:nn[0]},(sn,Nt)=>(0,m.max)(Yt.subarray(nn[1]*Nt,nn[1]*(Nt+1)))[0]+1n+BigInt(nn[1]));return[new d.Tensor("int64",bn,[3,...nn]),new d.Tensor("int64",jt,[jt.length,1])]}else{const[Yt,nn]=N.dims,bn=BigInt64Array.from({length:3*Yt*nn},(jt,sn)=>BigInt(Math.floor(sn%nn/Yt)));return[new d.Tensor("int64",bn,[3,...N.dims]),(0,d.zeros)([Yt,1])]}}async encode_image({pixel_values:N,image_grid_thw:q}){return(await W(this.sessions.vision_encoder,{pixel_values:N,grid_thw:q})).image_features}_merge_input_ids_with_image_features(N){return Q({image_token_id:this.config.image_token_id,...N})}prepare_inputs_for_generation(N,q,ve){if(q.attention_mask&&!q.position_ids)if(!q.past_key_values)[q.position_ids,q.rope_deltas]=this.get_rope_index(q.input_ids,q.image_grid_thw,q.video_grid_thw,q.attention_mask);else{q.pixel_values=null;const De=BigInt(Object.values(q.past_key_values)[0].dims.at(-2)),Ae=q.rope_deltas.map(je=>De+je);q.position_ids=(0,d.stack)([Ae,Ae,Ae],0)}return q}}class M_ extends U{}class IM extends M_{}class PM extends M_{}class E_ extends U{}class kM extends E_{}class DM extends E_{}class S_ extends U{}class OM extends S_{}class RM extends S_{}class C_ extends U{}class NM extends C_{}class LM extends C_{}class $_ extends U{}class zM extends $_{}class FM extends $_{}class A_ extends U{}class BM extends A_{}class UM extends A_{async _call(N){return new an(await super._call(N))}}class I_ extends U{}class VM extends I_{}class GM extends I_{async _call(N){return new an(await super._call(N))}}class jM extends U{}class WM extends jM{}class P_ extends U{}class HM extends P_{}class qM extends P_{async _call(N){return new an(await super._call(N))}}class KM extends U{}class JM extends KM{}class k_ extends U{}class YM extends k_{}class XM extends k_{async _call(N){return new an(await super._call(N))}}class QM extends U{}class ZM extends QM{}class D_ extends U{}class eE extends D_{}class tE extends D_{async _call(N){return new an(await super._call(N))}}class nE extends U{}class iE extends nE{async _call(N){return new E$(await super._call(N))}}class O_ extends U{}class rE extends O_{}class sE extends O_{async _call(N){return new an(await super._call(N))}}class R_ extends U{}class aE extends R_{}class oE extends R_{async _call(N){return new an(await super._call(N))}}class N_ extends U{}class lE extends N_{}class uE extends N_{}class L_ extends U{}class cE extends L_{}class dE extends L_{}class z_ extends U{}class fE extends z_{}class pE extends z_{async _call(N){return new an(await super._call(N))}}class zp extends U{}class hE extends zp{}class mE extends zp{async _call(N){return new B_(await super._call(N))}}class F_ extends zp{async _call(N){return new gE(await super._call(N))}}class B_ extends we{constructor({logits:N,pred_boxes:q}){super(),this.logits=N,this.pred_boxes=q}}class gE extends we{constructor({logits:N,pred_boxes:q,pred_masks:ve}){super(),this.logits=N,this.pred_boxes=q,this.pred_masks=ve}}class U_ extends U{}class _E extends U_{}class yE extends U_{async _call(N){return new Gd(await super._call(N))}}class Gd extends we{constructor({logits:N,pred_boxes:q}){super(),this.logits=N,this.pred_boxes=q}}class V_ extends U{}class vE extends V_{}class wE extends V_{async _call(N){return new bE(await super._call(N))}}class bE extends Gd{}class G_ extends U{}class xE extends G_{}class TE extends G_{async _call(N){return new ME(await super._call(N))}}class ME extends Gd{}class j_ extends U{}class EE extends j_{}class SE extends j_{async _call(N){return new Gd(await super._call(N))}}class W_ extends U{}class CE extends W_{}class $E extends W_{async _call(N){return new AE(await super._call(N))}}class AE extends B_{}class H_ extends U{}class IE extends H_{}class PE extends H_{async _call(N){return new an(await super._call(N))}}class q_ extends U{}class kE extends q_{}class DE extends q_{async _call(N){return new an(await super._call(N))}}class K_ extends U{}class OE extends K_{}class RE extends K_{async _call(N){return new an(await super._call(N))}}class Fp extends U{}class NE extends Fp{}class LE extends Fp{async _call(N){return new an(await super._call(N))}}class zE extends Fp{}class J_ extends U{}class FE extends J_{}class BE extends J_{}class Y_ extends U{}class UE extends Y_{}class VE extends Y_{}class GE extends U{}class jE extends GE{}class Bp extends U{}class WE extends Bp{}class HE extends Bp{}class qE extends Bp{}class KE extends U{}class JE extends KE{}class YE extends U{}class XE extends YE{}class QE extends U{}class ZE extends QE{}class X_ extends U{}class eS extends X_{}class tS extends X_{}class Q_ extends U{}class nS extends Q_{}class iS extends Q_{}class rS extends U{}class sS extends rS{}class Z_ extends U{}class aS extends Z_{}class oS extends Z_{async _call(N){return new an(await super._call(N))}}class ey extends U{}class lS extends ey{}class uS extends ey{async _call(N){return new an(await super._call(N))}}class ty extends U{}class cS extends ty{}class dS extends ty{async _call(N){return new an(await super._call(N))}}class ny extends U{}class fS extends ny{}class pS extends ny{async _call(N){return new an(await super._call(N))}}class hS extends U{}class mS extends hS{}class gS extends U{}class _S extends gS{}class yS extends U{}class vS extends yS{}class iy extends U{}class wS extends iy{}class bS extends iy{async _call(N){return new xS(await super._call(N))}}class xS extends we{constructor({logits:N,pred_boxes:q}){super(),this.logits=N,this.pred_boxes=q}}class TS extends U{}class MS extends TS{async get_image_embeddings({pixel_values:N}){return await Y(this,{pixel_values:N})}async forward(N){!N.image_embeddings||!N.image_positional_embeddings?N={...N,...await this.get_image_embeddings(N)}:N={...N},N.input_labels??(N.input_labels=(0,d.ones)(N.input_points.dims.slice(0,-1)));const q={image_embeddings:N.image_embeddings,image_positional_embeddings:N.image_positional_embeddings};return N.input_points&&(q.input_points=N.input_points),N.input_labels&&(q.input_labels=N.input_labels),N.input_boxes&&(q.input_boxes=N.input_boxes),await W(this.sessions.prompt_encoder_mask_decoder,q)}async _call(N){return new ES(await super._call(N))}}class ES extends we{constructor({iou_scores:N,pred_masks:q}){super(),this.iou_scores=N,this.pred_masks=q}}class SS extends we{constructor({iou_scores:N,pred_masks:q,object_score_logits:ve}){super(),this.iou_scores=N,this.pred_masks=q,this.object_score_logits=ve}}class CS extends U{}class Up extends CS{async get_image_embeddings({pixel_values:N}){return await Y(this,{pixel_values:N})}async forward(N){const{num_feature_levels:q}=this.config.vision_config;if(Array.from({length:q},(je,st)=>`image_embeddings.${st}`).some(je=>!N[je])?N={...N,...await this.get_image_embeddings(N)}:N={...N},N.input_points){if(N.input_boxes&&N.input_boxes.dims[1]!==1)throw new Error("When both `input_points` and `input_boxes` are provided, the number of boxes per image must be 1.");const je=N.input_points.dims;N.input_labels??(N.input_labels=(0,d.ones)(je.slice(0,-1))),N.input_boxes??(N.input_boxes=(0,d.full)([je[0],0,4],0))}else if(N.input_boxes){const je=N.input_boxes.dims;N.input_labels=(0,d.full)([je[0],je[1],0],-1n),N.input_points=(0,d.full)([je[0],1,0,2],0)}else throw new Error("At least one of `input_points` or `input_boxes` must be provided.");const De=this.sessions.prompt_encoder_mask_decoder,Ae=(0,o.pick)(N,De.inputNames);return await W(De,Ae)}async _call(N){return new SS(await super._call(N))}}class $S extends Up{}class AS extends Up{}class ry extends U{}class IS extends ry{}class PS extends ry{}class sy extends U{}class kS extends sy{}class DS extends sy{}class ol extends U{}class OS extends ol{}class RS extends ol{async _call(N){return new ll(await super._call(N))}}class NS extends ol{async _call(N){return new an(await super._call(N))}}class LS extends ol{async _call(N){return new rr(await super._call(N))}}class zS extends U{}class FS extends zS{async _call(N){return new ll(await super._call(N))}}class ay extends U{}class BS extends ay{}class US extends ay{async _call(N){return new rr(await super._call(N))}}class VS extends U{}class GS extends VS{}class Vp extends U{}class jS extends Vp{}class WS extends Vp{async _call(N){return new ll(await super._call(N))}}class HS extends Vp{async _call(N){return new an(await super._call(N))}}class jd extends U{}class qS extends jd{}class KS extends jd{async _call(N){return new ll(await super._call(N))}}class JS extends jd{async _call(N){return new an(await super._call(N))}}class YS extends jd{async _call(N){return new rr(await super._call(N))}}class Gp extends U{}class XS extends Gp{}class QS extends Gp{async _call(N){return new ll(await super._call(N))}}class ZS extends Gp{async _call(N){return new an(await super._call(N))}}class dH extends U{}class e2 extends ol{}class t2 extends ol{async _call(N){return new ll(await super._call(N))}}class n2 extends ol{async _call(N){return new an(await super._call(N))}}class Tc extends U{}class i2 extends Tc{}class r2 extends Tc{async _call(N){return new ll(await super._call(N))}}class s2 extends Tc{async _call(N){return new an(await super._call(N))}}class a2 extends Tc{async _call(N){return new M$(await super._call(N))}}class o2 extends Tc{async _call(N){return new rr(await super._call(N))}}class l2 extends U{}class u2 extends l2{}class jp extends U{}class fH extends jp{}class c2 extends jp{}class d2 extends jp{async generate_speech(N,q,{threshold:ve=.5,minlenratio:De=0,maxlenratio:Ae=20,vocoder:je=null}={}){const st={input_ids:N},{encoder_outputs:pt,encoder_attention_mask:Tt}=await Y(this,st),Vt=pt.dims[1]/this.config.reduction_factor,Yt=Math.floor(Vt*Ae),nn=Math.floor(Vt*De),bn=this.config.num_mel_bins;let jt=[],sn=null,Nt=null,gn=0;for(;;){++gn;const vi=J(!!Nt);let Ci;Nt?Ci=Nt.output_sequence_out:Ci=new d.Tensor("float32",new Float32Array(bn),[1,1,bn]);let Qi={use_cache_branch:vi,output_sequence:Ci,encoder_attention_mask:Tt,speaker_embeddings:q,encoder_hidden_states:pt};this.addPastKeyValues(Qi,sn),Nt=await W(this.sessions.decoder_model_merged,Qi),sn=this.getPastKeyValues(Nt,sn);const{prob:fr,spectrum:_n}=Nt;if(jt.push(_n),gn>=nn&&(Array.from(fr.data).filter(sr=>sr>=ve).length>0||gn>=Yt))break}const Gn=(0,d.cat)(jt),{waveform:pi}=await W(je.sessions.model,{spectrogram:Gn});return{spectrogram:Gn,waveform:pi}}}class f2 extends U{constructor(){super(...arguments);fe(this,"main_input_name","spectrogram")}}class p2 extends U{}class oy extends p2{async generate_speech({input_ids:N,attention_mask:q,style:ve,num_inference_steps:De=5,speed:Ae=1.05}){const{sampling_rate:je,chunk_compress_factor:st,base_chunk_size:pt,latent_dim:Tt}=this.config,{last_hidden_state:Vt,durations:Yt}=await W(this.sessions.text_encoder,{input_ids:N,attention_mask:q,style:ve});Yt.div_(Ae);const nn=Yt.max().item()*je,bn=pt*st,jt=Math.floor((nn+bn-1)/bn),sn=N.dims[0],Nt=(0,d.ones)([sn,jt]),gn=(0,d.full)([sn],De);let Gn=(0,d.randn)([sn,Tt*st,jt]);for(let vi=0;vi<De;++vi){const Ci=(0,d.full)([sn],vi);({denoised_latents:Gn}=await W(this.sessions.latent_denoiser,{style:ve,noisy_latents:Gn,latent_mask:Nt,encoder_outputs:Vt,attention_mask:q,timestep:Ci,num_inference_steps:gn}))}const{waveform:pi}=await W(this.sessions.voice_decoder,{latents:Gn});return{waveform:pi,durations:Yt}}}class h2 extends U{}class m2 extends h2{}class ly extends U{}class g2 extends ly{}class _2 extends ly{}class uy extends U{}class y2 extends uy{}class v2 extends uy{}class cy extends U{}class w2 extends cy{}class b2 extends cy{}class dy extends U{}class x2 extends dy{}class T2 extends dy{}class fy extends U{}class M2 extends fy{}class E2 extends fy{}class py extends U{}class S2 extends py{}class C2 extends py{}class Wp extends U{}class $2 extends Wp{}class A2 extends Wp{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"text_model"})}}class I2 extends Wp{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"audio_model"})}}class P2 extends U{}class hy extends P2{async _call(N){return new S$(await super._call(N))}}class Hp extends U{}class pH extends Hp{}class k2 extends Hp{}class D2 extends Hp{}class my extends U{}class O2 extends my{}class R2 extends my{}class gy extends U{}class N2 extends gy{}class L2 extends gy{async _call(N){return new an(await super._call(N))}}class _y extends U{}class hH extends _y{}class mH extends _y{}class yy extends U{constructor(){super(...arguments);fe(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}_apply_and_filter_by_delay_pattern_mask(q){const[ve,De]=q.dims,Ae=this.config.decoder.num_codebooks,je=De-Ae;let st=0;for(let Vt=0;Vt<q.size;++Vt){if(q.data[Vt]===this.config.decoder.pad_token_id)continue;const Yt=Vt%De,nn=Math.floor(Vt/De)%Ae,bn=Yt-nn;bn>0&&bn<=je&&(q.data[st++]=q.data[Vt])}const pt=Math.floor(ve/Ae),Tt=st/(pt*Ae);return new d.Tensor(q.type,q.data.slice(0,st),[pt,Ae,Tt])}prepare_inputs_for_generation(q,ve,De){let Ae=structuredClone(q);for(let st=0;st<Ae.length;++st)for(let pt=0;pt<Ae[st].length;++pt)st%this.config.decoder.num_codebooks>=pt&&(Ae[st][pt]=BigInt(this.config.decoder.pad_token_id));return De.guidance_scale!==null&&De.guidance_scale>1&&(Ae=Ae.concat(Ae)),super.prepare_inputs_for_generation(Ae,ve,De)}async generate(q){const ve=await super.generate(q),De=this._apply_and_filter_by_delay_pattern_mask(ve).unsqueeze_(0),{audio_values:Ae}=await W(this.sessions.encodec_decode,{audio_codes:De});return Ae}}class qp extends U{}class z2 extends qp{}class F2 extends qp{async _call(N){return new an(await super._call(N))}}class B2 extends qp{}class Kp extends U{}class U2 extends Kp{}class V2 extends Kp{async _call(N){return new an(await super._call(N))}}class G2 extends Kp{}class Jp extends U{}class j2 extends Jp{}class W2 extends Jp{async _call(N){return new an(await super._call(N))}}class H2 extends Jp{}class Yp extends U{}class q2 extends Yp{}class K2 extends Yp{async _call(N){return new an(await super._call(N))}}class J2 extends Yp{}class Y2 extends U{}class X2 extends Y2{}class Q2 extends U{}class Z2 extends Q2{constructor(...q){super(...q);fe(this,"forward_params",["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"]);this._generation_mode="text"}async forward(q){const ve=this._generation_mode??"text";let De;if(ve==="text"||!q.past_key_values){const Tt=this.sessions.prepare_inputs_embeds,Vt=(0,o.pick)(q,Tt.inputNames);De=await W(Tt,Vt)}else{const Tt=this.sessions.gen_img_embeds,Vt=(0,o.pick)({image_ids:q.input_ids},Tt.inputNames);De=await W(Tt,Vt)}const Ae={...q,...De},je=await ce(this,Ae),st=this.sessions[ve==="text"?"lm_head":"gen_head"];if(!st)throw new Error(`Unable to find "${st}" generation head`);const pt=await W(st,(0,o.pick)(je,st.inputNames));return{...De,...je,...pt}}async generate(q){return this._generation_mode="text",super.generate(q)}async generate_images(q){this._generation_mode="image";const ve=(q.inputs??q[this.main_input_name]).dims[1],Ae=(await super.generate(q)).slice(null,[ve,null]),je=this.sessions.image_decode,{decoded_image:st}=await W(je,{generated_tokens:Ae}),pt=st.add_(1).mul_(255/2).clamp_(0,255).to("uint8"),Tt=[];for(const Vt of pt){const Yt=h.RawImage.fromTensor(Vt);Tt.push(Yt)}return Tt}}class eC extends we{constructor({char_logits:N,bpe_logits:q,wp_logits:ve}){super(),this.char_logits=N,this.bpe_logits=q,this.wp_logits=ve}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class tC extends U{}class nC extends tC{async _call(N){return new eC(await super._call(N))}}class vy extends U{}class iC extends vy{}class rC extends vy{}class wy extends U{}class sC extends wy{}class aC extends wy{}class oC extends U{constructor(){super(...arguments);fe(this,"forward_params",["input_ids","attention_mask","position_ids","audio_values","past_key_values"])}}class by extends oC{_merge_input_ids_with_audio_features(N){const q=N.audio_features.dims.at(-1),ve=N.audio_features.view(-1,q);return H({audio_token_id:this.config.ignore_index??this.config.audio_token_id,...N,audio_features:ve})}}class lC extends by{}class Xp extends U{constructor(){super(...arguments);fe(this,"main_input_name","input_values");fe(this,"forward_params",["input_values"])}}class uC extends we{constructor({audio_codes:N}){super(),this.audio_codes=N}}class cC extends we{constructor({audio_values:N}){super(),this.audio_values=N}}class dC extends Xp{async encode(N){return new uC(await W(this.sessions.encoder_model,N))}async decode(N){return new cC(await W(this.sessions.decoder_model,N))}}class fC extends Xp{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"encoder_model"})}}class pC extends Xp{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"decoder_model"})}}class Qp extends U{constructor(){super(...arguments);fe(this,"main_input_name","input_values");fe(this,"forward_params",["input_values"])}}class hC extends we{constructor({audio_codes:N}){super(),this.audio_codes=N}}class mC extends we{constructor({audio_values:N}){super(),this.audio_values=N}}class gC extends Qp{async encode(N){return new hC(await W(this.sessions.encoder_model,N))}async decode(N){return new mC(await W(this.sessions.decoder_model,N))}}class _C extends Qp{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"encoder_model"})}}class yC extends Qp{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"decoder_model"})}}class Zp extends U{constructor(){super(...arguments);fe(this,"main_input_name","input_values");fe(this,"forward_params",["input_values"])}}class vC extends Zp{async encode(N){return await W(this.sessions.encoder_model,N)}async decode(N){return await W(this.sessions.decoder_model,N)}}class wC extends Zp{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"encoder_model"})}}class bC extends Zp{static async from_pretrained(N,q={}){return super.from_pretrained(N,{...q,model_file_name:q.model_file_name??"decoder_model"})}}class qn{static async from_pretrained(N,{progress_callback:q=null,config:ve=null,cache_dir:De=null,local_files_only:Ae=!1,revision:je="main",model_file_name:st=null,subfolder:pt="onnx",device:Tt=null,dtype:Vt=null,use_external_data_format:Yt=null,session_options:nn={}}={}){const bn={progress_callback:q,config:ve,cache_dir:De,local_files_only:Ae,revision:je,model_file_name:st,subfolder:pt,device:Tt,dtype:Vt,use_external_data_format:Yt,session_options:nn};if(bn.config=await i.AutoConfig.from_pretrained(N,bn),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);const jt=bn.config.model_type;for(const sn of this.MODEL_CLASS_MAPPINGS){let Nt=sn.get(jt);if(!Nt){for(const gn of sn.values())if(gn[0]===jt){Nt=gn;break}if(!Nt)continue}return await Nt[1].from_pretrained(N,bn)}if(this.BASE_IF_FAIL)return qC.has(jt)||console.warn(`Unknown model class "${jt}", attempting to construct from base class.`),await U.from_pretrained(N,bn);throw Error(`Unsupported model type: ${jt}`)}}fe(qn,"MODEL_CLASS_MAPPINGS",null),fe(qn,"BASE_IF_FAIL",!1);const gH=new Map([["bert",["BertModel",Le]],["neobert",["NeoBertModel",at]],["modernbert",["ModernBertModel",Se]],["nomic_bert",["NomicBertModel",Kt]],["roformer",["RoFormerModel",Ji]],["electra",["ElectraModel",Xt]],["esm",["EsmModel",ir]],["convbert",["ConvBertModel",Gi]],["camembert",["CamembertModel",de]],["deberta",["DebertaModel",Ht]],["deberta-v2",["DebertaV2Model",Wn]],["mpnet",["MPNetModel",os]],["albert",["AlbertModel",ut]],["distilbert",["DistilBertModel",kt]],["roberta",["RobertaModel",$s]],["xlm",["XLMModel",ks]],["xlm-roberta",["XLMRobertaModel",Xl]],["clap",["ClapModel",$2]],["clip",["CLIPModel",qo]],["clipseg",["CLIPSegModel",Ns]],["chinese_clip",["ChineseCLIPModel",Ft]],["siglip",["SiglipModel",oo]],["jina_clip",["JinaCLIPModel",Yo]],["mobilebert",["MobileBertModel",Hi]],["squeezebert",["SqueezeBertModel",ne]],["wav2vec2",["Wav2Vec2Model",OS]],["wav2vec2-bert",["Wav2Vec2BertModel",XS]],["unispeech",["UniSpeechModel",jS]],["unispeech-sat",["UniSpeechSatModel",qS]],["hubert",["HubertModel",e2]],["wavlm",["WavLMModel",i2]],["audio-spectrogram-transformer",["ASTModel",nu]],["vits",["VitsModel",hy]],["pyannote",["PyAnnoteModel",BS]],["wespeaker-resnet",["WeSpeakerResNetModel",GS]],["detr",["DetrModel",hE]],["rt_detr",["RTDetrModel",_E]],["rt_detr_v2",["RTDetrV2Model",vE]],["rf_detr",["RFDetrModel",xE]],["d_fine",["DFineModel",EE]],["table-transformer",["TableTransformerModel",CE]],["vit",["ViTModel",BM]],["ijepa",["IJepaModel",VM]],["pvt",["PvtModel",HM]],["vit_msn",["ViTMSNModel",YM]],["vit_mae",["ViTMAEModel",JM]],["groupvit",["GroupViTModel",ZM]],["fastvit",["FastViTModel",eE]],["mobilevit",["MobileViTModel",rE]],["mobilevitv2",["MobileViTV2Model",aE]],["owlvit",["OwlViTModel",lE]],["owlv2",["Owlv2Model",cE]],["beit",["BeitModel",fE]],["deit",["DeiTModel",IE]],["hiera",["HieraModel",kE]],["convnext",["ConvNextModel",aS]],["convnextv2",["ConvNextV2Model",lS]],["dinov2",["Dinov2Model",cS]],["dinov2_with_registers",["Dinov2WithRegistersModel",fS]],["dinov3_vit",["DINOv3ViTModel",mS]],["dinov3_convnext",["DINOv3ConvNextModel",_S]],["resnet",["ResNetModel",OE]],["swin",["SwinModel",NE]],["swin2sr",["Swin2SRModel",FE]],["donut-swin",["DonutSwinModel",sS]],["yolos",["YolosModel",wS]],["dpt",["DPTModel",UE]],["glpn",["GLPNModel",nS]],["hifigan",["SpeechT5HifiGan",f2]],["efficientnet",["EfficientNetModel",N2]],["decision_transformer",["DecisionTransformerModel",X2]],["patchtst",["PatchTSTForPrediction",iC]],["patchtsmixer",["PatchTSMixerForPrediction",sC]],["mobilenet_v1",["MobileNetV1Model",z2]],["mobilenet_v2",["MobileNetV2Model",U2]],["mobilenet_v3",["MobileNetV3Model",j2]],["mobilenet_v4",["MobileNetV4Model",q2]],["maskformer",["MaskFormerModel",eS]],["mgp-str",["MgpstrForSceneTextRecognition",nC]],["style_text_to_speech_2",["StyleTextToSpeech2Model",u2]]]),_H=new Map([["t5",["T5Model",Cn]],["longt5",["LongT5Model",wn]],["mt5",["MT5Model",oi]],["bart",["BartModel",_r]],["mbart",["MBartModel",vt]],["marian",["MarianModel",IS]],["whisper",["WhisperModel",Wo]],["m2m_100",["M2M100Model",kS]],["blenderbot",["BlenderbotModel",Dn]],["blenderbot-small",["BlenderbotSmallModel",Bi]]]),yH=new Map([["mimi",["MimiModel",dC]],["dac",["DacModel",gC]],["snac",["SnacModel",vC]]]),vH=new Map([["bloom",["BloomModel",OM]],["jais",["JAISModel",el]],["gpt2",["GPT2Model",Qo]],["gptj",["GPTJModel",rl]],["gpt_bigcode",["GPTBigCodeModel",p]],["gpt_neo",["GPTNeoModel",Ls]],["gpt_neox",["GPTNeoXModel",nl]],["codegen",["CodeGenModel",I]],["llama",["LlamaModel",ie]],["nanochat",["NanoChatModel",ht]],["arcee",["ArceeModel",ui]],["lfm2",["Lfm2Model",ja]],["smollm3",["SmolLM3Model",Lp]],["exaone",["ExaoneModel",eM]],["olmo",["OlmoModel",rM]],["olmo2",["Olmo2Model",aM]],["mobilellm",["MobileLLMModel",nM]],["granite",["GraniteModel",lM]],["granitemoehybrid",["GraniteMoeHybridModel",cM]],["cohere",["CohereModel",fM]],["gemma",["GemmaModel",hM]],["gemma2",["Gemma2Model",gM]],["vaultgemma",["VaultGemmaModel",yM]],["gemma3_text",["Gemma3Model",wM]],["helium",["HeliumModel",YT]],["glm",["GlmModel",QT]],["openelm",["OpenELMModel",xM]],["qwen2",["Qwen2Model",MM]],["qwen3",["Qwen3Model",SM]],["phi",["PhiModel",IM]],["phi3",["Phi3Model",kM]],["mpt",["MptModel",NM]],["opt",["OPTModel",zM]],["mistral",["MistralModel",g2]],["ministral",["MinistralModel",y2]],["ministral3",["Ministral3Model",w2]],["ernie4_5",["Ernie4_5Model",x2]],["starcoder2",["Starcoder2Model",M2]],["falcon",["FalconModel",S2]],["stablelm",["StableLmModel",O2]],["modernbert-decoder",["ModernBertDecoderModel",Et]]]),xy=new Map([["speecht5",["SpeechT5ForSpeechToText",c2]],["whisper",["WhisperForConditionalGeneration",ra]],["lite-whisper",["LiteWhisperForConditionalGeneration",mc]],["moonshine",["MoonshineForConditionalGeneration",ru]]]),xC=new Map([["speecht5",["SpeechT5ForTextToSpeech",d2]]]),TC=new Map([["vits",["VitsModel",hy]],["musicgen",["MusicgenForConditionalGeneration",yy]],["supertonic",["SupertonicForConditionalGeneration",oy]]]),MC=new Map([["bert",["BertForSequenceClassification",$e]],["neobert",["NeoBertForSequenceClassification",he]],["modernbert",["ModernBertForSequenceClassification",ct]],["roformer",["RoFormerForSequenceClassification",Ti]],["electra",["ElectraForSequenceClassification",L]],["esm",["EsmForSequenceClassification",ci]],["convbert",["ConvBertForSequenceClassification",ji]],["camembert",["CamembertForSequenceClassification",Ue]],["deberta",["DebertaForSequenceClassification",Zt]],["deberta-v2",["DebertaV2ForSequenceClassification",Bn]],["mpnet",["MPNetForSequenceClassification",ls]],["albert",["AlbertForSequenceClassification",yt]],["distilbert",["DistilBertForSequenceClassification",An]],["roberta",["RobertaForSequenceClassification",us]],["xlm",["XLMForSequenceClassification",Os]],["xlm-roberta",["XLMRobertaForSequenceClassification",Zl]],["bart",["BartForSequenceClassification",it]],["mbart",["MBartForSequenceClassification",rn]],["mobilebert",["MobileBertForSequenceClassification",lt]],["squeezebert",["SqueezeBertForSequenceClassification",be]]]),EC=new Map([["bert",["BertForTokenClassification",et]],["neobert",["NeoBertForTokenClassification",ye]],["modernbert",["ModernBertForTokenClassification",bt]],["roformer",["RoFormerForTokenClassification",Yn]],["electra",["ElectraForTokenClassification",oe]],["esm",["EsmForTokenClassification",Xi]],["convbert",["ConvBertForTokenClassification",Wi]],["camembert",["CamembertForTokenClassification",_t]],["deberta",["DebertaForTokenClassification",St]],["deberta-v2",["DebertaV2ForTokenClassification",Je]],["mpnet",["MPNetForTokenClassification",ia]],["distilbert",["DistilBertForTokenClassification",zn]],["roberta",["RobertaForTokenClassification",Is]],["xlm",["XLMForTokenClassification",Rs]],["xlm-roberta",["XLMRobertaForTokenClassification",eu]]]),Ty=new Map([["t5",["T5ForConditionalGeneration",Tn]],["longt5",["LongT5ForConditionalGeneration",Hn]],["mt5",["MT5ForConditionalGeneration",Si]],["bart",["BartForConditionalGeneration",tt]],["mbart",["MBartForConditionalGeneration",Gt]],["marian",["MarianMTModel",PS]],["m2m_100",["M2M100ForConditionalGeneration",DS]],["blenderbot",["BlenderbotForConditionalGeneration",li]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",$r]]]),My=new Map([["bloom",["BloomForCausalLM",RM]],["gpt2",["GPT2LMHeadModel",Zo]],["jais",["JAISLMHeadModel",tl]],["gptj",["GPTJForCausalLM",sl]],["gpt_bigcode",["GPTBigCodeForCausalLM",v]],["gpt_neo",["GPTNeoForCausalLM",Ga]],["gpt_neox",["GPTNeoXForCausalLM",il]],["codegen",["CodeGenForCausalLM",k]],["llama",["LlamaForCausalLM",ge]],["nanochat",["NanoChatForCausalLM",At]],["llama4_text",["Llama4ForCausalLM",Re]],["arcee",["ArceeForCausalLM",vr]],["lfm2",["Lfm2ForCausalLM",al]],["smollm3",["SmolLM3ForCausalLM",JT]],["exaone",["ExaoneForCausalLM",tM]],["olmo",["OlmoForCausalLM",sM]],["olmo2",["Olmo2ForCausalLM",oM]],["mobilellm",["MobileLLMForCausalLM",iM]],["granite",["GraniteForCausalLM",uM]],["granitemoehybrid",["GraniteMoeHybridForCausalLM",dM]],["cohere",["CohereForCausalLM",pM]],["gemma",["GemmaForCausalLM",mM]],["gemma2",["Gemma2ForCausalLM",_M]],["vaultgemma",["VaultGemmaForCausalLM",vM]],["gemma3_text",["Gemma3ForCausalLM",bM]],["helium",["HeliumForCausalLM",XT]],["glm",["GlmForCausalLM",ZT]],["openelm",["OpenELMForCausalLM",TM]],["qwen2",["Qwen2ForCausalLM",EM]],["qwen3",["Qwen3ForCausalLM",CM]],["phi",["PhiForCausalLM",PM]],["phi3",["Phi3ForCausalLM",DM]],["mpt",["MptForCausalLM",LM]],["opt",["OPTForCausalLM",FM]],["mbart",["MBartForCausalLM",kn]],["mistral",["MistralForCausalLM",_2]],["ministral",["MinistralForCausalLM",v2]],["ministral3",["Ministral3ForCausalLM",b2]],["ernie4_5",["Ernie4_5ForCausalLM",T2]],["starcoder2",["Starcoder2ForCausalLM",E2]],["falcon",["FalconForCausalLM",C2]],["trocr",["TrOCRForCausalLM",m2]],["stablelm",["StableLmForCausalLM",R2]],["modernbert-decoder",["ModernBertDecoderForCausalLM",hn]],["phi3_v",["Phi3VForCausalLM",Ua]]]),wH=new Map([["multi_modality",["MultiModalityCausalLM",Z2]]]),SC=new Map([["bert",["BertForMaskedLM",Ge]],["neobert",["NeoBertForMaskedLM",Z]],["modernbert",["ModernBertForMaskedLM",Oe]],["roformer",["RoFormerForMaskedLM",tr]],["electra",["ElectraForMaskedLM",nr]],["esm",["EsmForMaskedLM",Mi]],["convbert",["ConvBertForMaskedLM",xt]],["camembert",["CamembertForMaskedLM",xe]],["deberta",["DebertaForMaskedLM",It]],["deberta-v2",["DebertaV2ForMaskedLM",ei]],["mpnet",["MPNetForMaskedLM",Yr]],["albert",["AlbertForMaskedLM",Mt]],["distilbert",["DistilBertForMaskedLM",Un]],["roberta",["RobertaForMaskedLM",As]],["xlm",["XLMWithLMHeadModel",Ds]],["xlm-roberta",["XLMRobertaForMaskedLM",Ql]],["mobilebert",["MobileBertForMaskedLM",ot]],["squeezebert",["SqueezeBertForMaskedLM",pe]]]),CC=new Map([["bert",["BertForQuestionAnswering",Ce]],["neobert",["NeoBertForQuestionAnswering",Ke]],["roformer",["RoFormerForQuestionAnswering",$n]],["electra",["ElectraForQuestionAnswering",K]],["convbert",["ConvBertForQuestionAnswering",Sn]],["camembert",["CamembertForQuestionAnswering",$t]],["deberta",["DebertaForQuestionAnswering",tn]],["deberta-v2",["DebertaV2ForQuestionAnswering",qt]],["mpnet",["MPNetForQuestionAnswering",Ee]],["albert",["AlbertForQuestionAnswering",gt]],["distilbert",["DistilBertForQuestionAnswering",ni]],["roberta",["RobertaForQuestionAnswering",Ps]],["xlm",["XLMForQuestionAnswering",Ra]],["xlm-roberta",["XLMRobertaForQuestionAnswering",tu]],["mobilebert",["MobileBertForQuestionAnswering",wt]],["squeezebert",["SqueezeBertForQuestionAnswering",Me]]]),Ey=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",su]],["idefics3",["Idefics3ForConditionalGeneration",sa]],["smolvlm",["SmolVLMForConditionalGeneration",so]]]),$C=new Map([["llava",["LlavaForConditionalGeneration",ro]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",gc]],["moondream1",["Moondream1ForConditionalGeneration",_c]],["florence2",["Florence2ForConditionalGeneration",vc]],["qwen2-vl",["Qwen2VLForConditionalGeneration",AM]],["idefics3",["Idefics3ForConditionalGeneration",sa]],["smolvlm",["SmolVLMForConditionalGeneration",so]],["paligemma",["PaliGemmaForConditionalGeneration",bc]],["llava_qwen2",["LlavaQwen2ForCausalLM",La]],["gemma3n",["Gemma3nForConditionalGeneration",Fa]],["mistral3",["Mistral3ForConditionalGeneration",za]]]),AC=new Map([["ultravox",["UltravoxModel",by]],["voxtral",["VoxtralForConditionalGeneration",lC]]]),bH=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",su]]]),IC=new Map([["vit",["ViTForImageClassification",UM]],["ijepa",["IJepaForImageClassification",GM]],["pvt",["PvtForImageClassification",qM]],["vit_msn",["ViTMSNForImageClassification",XM]],["fastvit",["FastViTForImageClassification",tE]],["mobilevit",["MobileViTForImageClassification",sE]],["mobilevitv2",["MobileViTV2ForImageClassification",oE]],["beit",["BeitForImageClassification",pE]],["deit",["DeiTForImageClassification",PE]],["hiera",["HieraForImageClassification",DE]],["convnext",["ConvNextForImageClassification",oS]],["convnextv2",["ConvNextV2ForImageClassification",uS]],["dinov2",["Dinov2ForImageClassification",dS]],["dinov2_with_registers",["Dinov2WithRegistersForImageClassification",pS]],["resnet",["ResNetForImageClassification",RE]],["swin",["SwinForImageClassification",LE]],["segformer",["SegformerForImageClassification",k2]],["efficientnet",["EfficientNetForImageClassification",L2]],["mobilenet_v1",["MobileNetV1ForImageClassification",F2]],["mobilenet_v2",["MobileNetV2ForImageClassification",V2]],["mobilenet_v3",["MobileNetV3ForImageClassification",W2]],["mobilenet_v4",["MobileNetV4ForImageClassification",K2]]]),PC=new Map([["detr",["DetrForObjectDetection",mE]],["rt_detr",["RTDetrForObjectDetection",yE]],["rt_detr_v2",["RTDetrV2ForObjectDetection",wE]],["rf_detr",["RFDetrForObjectDetection",TE]],["d_fine",["DFineForObjectDetection",SE]],["table-transformer",["TableTransformerForObjectDetection",$E]],["yolos",["YolosForObjectDetection",bS]]]),kC=new Map([["owlvit",["OwlViTForObjectDetection",uE]],["owlv2",["Owlv2ForObjectDetection",dE]],["grounding-dino",["GroundingDinoForObjectDetection",vS]]]),Mc=new Map([["detr",["DetrForSegmentation",F_]],["clipseg",["CLIPSegForImageSegmentation",Va]]]),DC=new Map([["segformer",["SegformerForSemanticSegmentation",D2]],["sapiens",["SapiensForSemanticSegmentation",WE]],["swin",["SwinForSemanticSegmentation",zE]],["mobilenet_v1",["MobileNetV1ForSemanticSegmentation",B2]],["mobilenet_v2",["MobileNetV2ForSemanticSegmentation",G2]],["mobilenet_v3",["MobileNetV3ForSemanticSegmentation",H2]],["mobilenet_v4",["MobileNetV4ForSemanticSegmentation",J2]]]),OC=new Map([["detr",["DetrForSegmentation",F_]],["maskformer",["MaskFormerForInstanceSegmentation",tS]]]),RC=new Map([["sam",["SamModel",MS]],["sam2",["Sam2Model",Up]],["edgetam",["EdgeTamModel",$S]],["sam3_tracker",["Sam3TrackerModel",AS]]]),NC=new Map([["wav2vec2",["Wav2Vec2ForCTC",RS]],["wav2vec2-bert",["Wav2Vec2BertForCTC",QS]],["unispeech",["UniSpeechForCTC",WS]],["unispeech-sat",["UniSpeechSatForCTC",KS]],["wavlm",["WavLMForCTC",r2]],["hubert",["HubertForCTC",t2]],["parakeet_ctc",["ParakeetForCTC",FS]]]),LC=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",NS]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",ZS]],["unispeech",["UniSpeechForSequenceClassification",HS]],["unispeech-sat",["UniSpeechSatForSequenceClassification",JS]],["wavlm",["WavLMForSequenceClassification",s2]],["hubert",["HubertForSequenceClassification",n2]],["audio-spectrogram-transformer",["ASTForAudioClassification",Na]]]),zC=new Map([["wavlm",["WavLMForXVector",a2]]]),FC=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",YS]],["wavlm",["WavLMForAudioFrameClassification",o2]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",LS]],["pyannote",["PyAnnoteForAudioFrameClassification",US]]]),BC=new Map([["vitmatte",["VitMatteForImageMatting",iE]]]),xH=new Map([["patchtst",["PatchTSTForPrediction",rC]],["patchtsmixer",["PatchTSMixerForPrediction",aC]]]),UC=new Map([["swin2sr",["Swin2SRForImageSuperResolution",BE]]]),VC=new Map([["dpt",["DPTForDepthEstimation",VE]],["depth_anything",["DepthAnythingForDepthEstimation",jE]],["glpn",["GLPNForDepthEstimation",iS]],["sapiens",["SapiensForDepthEstimation",HE]],["depth_pro",["DepthProForDepthEstimation",JE]],["metric3d",["Metric3DForDepthEstimation",XE]],["metric3dv2",["Metric3Dv2ForDepthEstimation",ZE]]]),GC=new Map([["sapiens",["SapiensForNormalEstimation",qE]]]),jC=new Map([["vitpose",["VitPoseForPoseEstimation",WM]]]),WC=new Map([["clip",["CLIPVisionModelWithProjection",Jo]],["siglip",["SiglipVisionModel",lo]],["jina_clip",["JinaCLIPVisionModel",aa]]]),HC=[[gH,x.EncoderOnly],[_H,x.EncoderDecoder],[vH,x.DecoderOnly],[yH,x.AutoEncoder],[MC,x.EncoderOnly],[EC,x.EncoderOnly],[Ty,x.Seq2Seq],[xy,x.Seq2Seq],[My,x.DecoderOnly],[wH,x.MultiModality],[SC,x.EncoderOnly],[CC,x.EncoderOnly],[Ey,x.Vision2Seq],[$C,x.ImageTextToText],[AC,x.AudioTextToText],[IC,x.EncoderOnly],[Mc,x.EncoderOnly],[OC,x.EncoderOnly],[DC,x.EncoderOnly],[BC,x.EncoderOnly],[xH,x.EncoderOnly],[UC,x.EncoderOnly],[VC,x.EncoderOnly],[GC,x.EncoderOnly],[jC,x.EncoderOnly],[PC,x.EncoderOnly],[kC,x.EncoderOnly],[RC,x.MaskGeneration],[NC,x.EncoderOnly],[LC,x.EncoderOnly],[xC,x.Seq2Seq],[TC,x.EncoderOnly],[zC,x.EncoderOnly],[FC,x.EncoderOnly],[WC,x.EncoderOnly]];for(const[D,N]of HC)for(const[q,ve]of D.values())S.set(q,N),C.set(ve,q),$.set(q,ve);const TH=[["MusicgenForConditionalGeneration",yy,x.Musicgen],["Phi3VForCausalLM",Ua,x.Phi3V],["CLIPTextModelWithProjection",Ko,x.EncoderOnly],["SiglipTextModel",uu,x.EncoderOnly],["JinaCLIPTextModel",Xo,x.EncoderOnly],["ClapTextModelWithProjection",A2,x.EncoderOnly],["ClapAudioModelWithProjection",I2,x.EncoderOnly],["DacEncoderModel",_C,x.EncoderOnly],["DacDecoderModel",yC,x.EncoderOnly],["MimiEncoderModel",fC,x.EncoderOnly],["MimiDecoderModel",pC,x.EncoderOnly],["SnacEncoderModel",wC,x.EncoderOnly],["SnacDecoderModel",bC,x.EncoderOnly],["Gemma3nForConditionalGeneration",Fa,x.ImageAudioTextToText],["SupertonicForConditionalGeneration",oy,x.Supertonic]];for(const[D,N,q]of TH)S.set(D,q),C.set(N,D),$.set(D,N);const qC=new Map([["modnet",Mc],["birefnet",Mc],["isnet",Mc],["ben",Mc]]);for(const[D,N]of qC.entries())N.set(D,["PreTrainedModel",U]),S.set(D,x.EncoderOnly),C.set(U,D),$.set(D,U);class Sy extends qn{}fe(Sy,"MODEL_CLASS_MAPPINGS",HC.map(N=>N[0])),fe(Sy,"BASE_IF_FAIL",!0);class KC extends qn{}fe(KC,"MODEL_CLASS_MAPPINGS",[MC]);class JC extends qn{}fe(JC,"MODEL_CLASS_MAPPINGS",[EC]);class YC extends qn{}fe(YC,"MODEL_CLASS_MAPPINGS",[Ty]);class XC extends qn{}fe(XC,"MODEL_CLASS_MAPPINGS",[xy]);class QC extends qn{}fe(QC,"MODEL_CLASS_MAPPINGS",[xC]);class ZC extends qn{}fe(ZC,"MODEL_CLASS_MAPPINGS",[TC]);class e$ extends qn{}fe(e$,"MODEL_CLASS_MAPPINGS",[My]);class t$ extends qn{}fe(t$,"MODEL_CLASS_MAPPINGS",[SC]);class n$ extends qn{}fe(n$,"MODEL_CLASS_MAPPINGS",[CC]);class i$ extends qn{}fe(i$,"MODEL_CLASS_MAPPINGS",[Ey]);class r$ extends qn{}fe(r$,"MODEL_CLASS_MAPPINGS",[IC]);class s$ extends qn{}fe(s$,"MODEL_CLASS_MAPPINGS",[Mc]);class a$ extends qn{}fe(a$,"MODEL_CLASS_MAPPINGS",[DC]);class o$ extends qn{}fe(o$,"MODEL_CLASS_MAPPINGS",[OC]);class l$ extends qn{}fe(l$,"MODEL_CLASS_MAPPINGS",[PC]);class u$ extends qn{}fe(u$,"MODEL_CLASS_MAPPINGS",[kC]);class c$ extends qn{}fe(c$,"MODEL_CLASS_MAPPINGS",[RC]);class d$ extends qn{}fe(d$,"MODEL_CLASS_MAPPINGS",[NC]);class f$ extends qn{}fe(f$,"MODEL_CLASS_MAPPINGS",[LC]);class p$ extends qn{}fe(p$,"MODEL_CLASS_MAPPINGS",[zC]);class h$ extends qn{}fe(h$,"MODEL_CLASS_MAPPINGS",[FC]);class m$ extends qn{}fe(m$,"MODEL_CLASS_MAPPINGS",[bH]);class g$ extends qn{}fe(g$,"MODEL_CLASS_MAPPINGS",[BC]);class _$ extends qn{}fe(_$,"MODEL_CLASS_MAPPINGS",[UC]);class y$ extends qn{}fe(y$,"MODEL_CLASS_MAPPINGS",[VC]);class v$ extends qn{}fe(v$,"MODEL_CLASS_MAPPINGS",[GC]);class w$ extends qn{}fe(w$,"MODEL_CLASS_MAPPINGS",[jC]);class b$ extends qn{}fe(b$,"MODEL_CLASS_MAPPINGS",[WC]);class x$ extends qn{}fe(x$,"MODEL_CLASS_MAPPINGS",[$C]);class T$ extends qn{}fe(T$,"MODEL_CLASS_MAPPINGS",[AC]);class MH extends we{constructor({logits:N,past_key_values:q,encoder_outputs:ve,decoder_attentions:De=null,cross_attentions:Ae=null}){super(),this.logits=N,this.past_key_values=q,this.encoder_outputs=ve,this.decoder_attentions=De,this.cross_attentions=Ae}}class an extends we{constructor({logits:N,...q}){super(),this.logits=N;const ve=Object.values(q);ve.length>0&&(this.attentions=ve)}}class M$ extends we{constructor({logits:N,embeddings:q}){super(),this.logits=N,this.embeddings=q}}class rr extends we{constructor({logits:N}){super(),this.logits=N}}class dr extends we{constructor({logits:N}){super(),this.logits=N}}class Ar extends we{constructor({start_logits:N,end_logits:q}){super(),this.start_logits=N,this.end_logits=q}}class ll extends we{constructor({logits:N}){super(),this.logits=N}}class EH extends we{constructor({logits:N,past_key_values:q}){super(),this.logits=N,this.past_key_values=q}}class E$ extends we{constructor({alphas:N}){super(),this.alphas=N}}class S$ extends we{constructor({waveform:N,spectrogram:q}){super(),this.waveform=N,this.spectrogram=q}}},"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":(e,t,n)=>{n.r(t),n.d(t,{ASTFeatureExtractor:()=>s});var i=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var r=n("./src/utils/audio.js");class s extends i.FeatureExtractor{constructor(o){super(o);const l=this.config.sampling_rate,u=(0,r.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(l/2),l,null,"kaldi",!0);this.mel_filters=u,this.window=(0,r.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(o,l){return(0,r.spectrogram)(o,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:l,transpose:!0})}async _call(o){(0,i.validate_audio_inputs)(o,"ASTFeatureExtractor");const l=await this._extract_fbank_features(o,this.config.max_length);if(this.config.do_normalize){const u=this.std*2,c=l.data;for(let f=0;f<c.length;++f)c[f]=(c[f]-this.mean)/u}return{input_values:l.unsqueeze_(0)}}}},"./src/models/auto/feature_extraction_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoFeatureExtractor:()=>a});var i=n("./src/utils/constants.js"),r=n("./src/utils/hub.js");n("./src/base/feature_extraction_utils.js");var s=n("./src/models/feature_extractors.js");class a{static async from_pretrained(l,u={}){const c=await(0,r.getModelJSON)(l,i.FEATURE_EXTRACTOR_NAME,!0,u),f=c.feature_extractor_type,d=s[f];if(!d)throw new Error(`Unknown feature_extractor_type: '${f}'. Please report this at ${i.GITHUB_ISSUE_URL}.`);return new d(c)}}},"./src/models/auto/image_processing_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoImageProcessor:()=>o});var i=n("./src/utils/constants.js"),r=n("./src/utils/hub.js"),s=n("./src/base/image_processors_utils.js"),a=n("./src/models/image_processors.js");class o{static async from_pretrained(u,c={}){const f=await(0,r.getModelJSON)(u,i.IMAGE_PROCESSOR_NAME,!0,c),d=f.image_processor_type??f.feature_extractor_type;let h=a[d==null?void 0:d.replace(/Fast$/,"")];return h||(d!==void 0&&console.warn(`Image processor type '${d}' not found, assuming base ImageProcessor. Please report this at ${i.GITHUB_ISSUE_URL}.`),h=s.ImageProcessor),new h(f)}}},"./src/models/auto/processing_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoProcessor:()=>u});var i=n("./src/utils/constants.js"),r=n("./src/utils/hub.js"),s=n("./src/base/processing_utils.js"),a=n("./src/models/processors.js"),o=n("./src/models/image_processors.js"),l=n("./src/models/feature_extractors.js");class u{static async from_pretrained(f,d={}){const h=await(0,r.getModelJSON)(f,i.IMAGE_PROCESSOR_NAME,!0,d),{image_processor_type:m,feature_extractor_type:y,processor_class:M}=h;if(M&&a[M])return a[M].from_pretrained(f,d);if(!m&&!y)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const g={};if(m){const T=o[m.replace(/Fast$/,"")];if(!T)throw new Error(`Unknown image_processor_type: '${m}'.`);g.image_processor=new T(h)}if(y){const T=o[y];if(T)g.image_processor=new T(h);else{const x=l[y];if(!x)throw new Error(`Unknown feature_extractor_type: '${y}'.`);g.feature_extractor=new x(h)}}const _={};return new s.Processor(_,g,null)}}},"./src/models/beit/image_processing_beit.js":(e,t,n)=>{n.r(t),n.d(t,{BeitFeatureExtractor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/bit/image_processing_bit.js":(e,t,n)=>{n.r(t),n.d(t,{BitImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/chinese_clip/image_processing_chinese_clip.js":(e,t,n)=>{n.r(t),n.d(t,{ChineseCLIPFeatureExtractor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/clap/feature_extraction_clap.js":(e,t,n)=>{n.r(t),n.d(t,{ClapFeatureExtractor:()=>s});var i=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var r=n("./src/utils/audio.js");class s extends i.FeatureExtractor{constructor(o){super(o),this.mel_filters=(0,r.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,r.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,r.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(o,l,u,c){let f;const d=o.length-l;if(d>0)if(u==="rand_trunc"){const h=Math.floor(Math.random()*(d+1));o=o.subarray(h,h+l),f=await this._extract_fbank_features(o,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${u}" not implemented`);else{if(d<0){let h=new Float64Array(l);if(h.set(o),c==="repeat")for(let m=o.length;m<l;m+=o.length)h.set(o.subarray(0,Math.min(o.length,l-m)),m);else if(c==="repeatpad")for(let m=o.length;m<-d;m+=o.length)h.set(o,m);o=h}if(u==="fusion")throw new Error(`Truncation strategy "${u}" not implemented`);f=await this._extract_fbank_features(o,this.mel_filters_slaney,this.config.nb_max_samples)}return f.unsqueeze_(0)}async _extract_fbank_features(o,l,u=null){return(0,r.spectrogram)(o,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:l,log_mel:"dB",max_num_frames:u,do_pad:!1,transpose:!0})}async _call(o,{max_length:l=null}={}){return(0,i.validate_audio_inputs)(o,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(o,l??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}},"./src/models/clip/image_processing_clip.js":(e,t,n)=>{n.r(t),n.d(t,{CLIPFeatureExtractor:()=>s,CLIPImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class s extends r{}},"./src/models/convnext/image_processing_convnext.js":(e,t,n)=>{n.r(t),n.d(t,{ConvNextFeatureExtractor:()=>s,ConvNextImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{constructor(o){super(o),this.crop_pct=this.config.crop_pct??224/256}async resize(o){var u;const l=(u=this.size)==null?void 0:u.shortest_edge;if(l===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(l<384){const c=Math.floor(l/this.crop_pct),[f,d]=this.get_resize_output_image_size(o,{shortest_edge:c});o=await o.resize(f,d,{resample:this.resample}),o=await o.center_crop(l,l)}else o=await o.resize(l,l,{resample:this.resample});return o}}class s extends r{}},"./src/models/dac/feature_extraction_dac.js":(e,t,n)=>{n.r(t),n.d(t,{DacFeatureExtractor:()=>r});var i=n("./src/models/encodec/feature_extraction_encodec.js");class r extends i.EncodecFeatureExtractor{}},"./src/models/deit/image_processing_deit.js":(e,t,n)=>{n.r(t),n.d(t,{DeiTFeatureExtractor:()=>s,DeiTImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class s extends r{}},"./src/models/detr/image_processing_detr.js":(e,t,n)=>{n.r(t),n.d(t,{DetrFeatureExtractor:()=>a,DetrImageProcessor:()=>s});var i=n("./src/base/image_processors_utils.js"),r=n("./src/utils/tensor.js");class s extends i.ImageProcessor{async _call(l){const u=await super._call(l),c=[u.pixel_values.dims[0],64,64],f=(0,r.full)(c,1n);return{...u,pixel_mask:f}}post_process_object_detection(...l){return(0,i.post_process_object_detection)(...l)}post_process_panoptic_segmentation(...l){return(0,i.post_process_panoptic_segmentation)(...l)}post_process_instance_segmentation(...l){return(0,i.post_process_instance_segmentation)(...l)}}class a extends s{}},"./src/models/dinov3_vit/image_processing_dinov3_vit.js":(e,t,n)=>{n.r(t),n.d(t,{DINOv3ViTImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/donut/image_processing_donut.js":(e,t,n)=>{n.r(t),n.d(t,{DonutFeatureExtractor:()=>s,DonutImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{pad_image(o,l,u,c={}){const[f,d,h]=l;let m=this.image_mean;Array.isArray(this.image_mean)||(m=new Array(h).fill(m));let y=this.image_std;Array.isArray(y)||(y=new Array(h).fill(m));const M=m.map((g,_)=>-g/y[_]);return super.pad_image(o,l,u,{center:!0,constant_values:M,...c})}}class s extends r{}},"./src/models/dpt/image_processing_dpt.js":(e,t,n)=>{n.r(t),n.d(t,{DPTFeatureExtractor:()=>s,DPTImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class s extends r{}},"./src/models/efficientnet/image_processing_efficientnet.js":(e,t,n)=>{n.r(t),n.d(t,{EfficientNetImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{constructor(a){super(a),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(o=>o*o))}}},"./src/models/encodec/feature_extraction_encodec.js":(e,t,n)=>{n.r(t),n.d(t,{EncodecFeatureExtractor:()=>s});var i=n("./src/base/feature_extraction_utils.js"),r=n("./src/utils/tensor.js");class s extends i.FeatureExtractor{async _call(o){(0,i.validate_audio_inputs)(o,"EncodecFeatureExtractor"),o instanceof Float64Array&&(o=new Float32Array(o));const l=this.config.feature_size;if(o.length%l!==0)throw new Error(`The length of the audio data must be a multiple of the number of channels (${l}).`);const u=[1,l,o.length/l];return{input_values:new r.Tensor("float32",o,u)}}}},"./src/models/feature_extractors.js":(e,t,n)=>{n.r(t),n.d(t,{ASTFeatureExtractor:()=>i.ASTFeatureExtractor,ClapFeatureExtractor:()=>s.ClapFeatureExtractor,DacFeatureExtractor:()=>a.DacFeatureExtractor,EncodecFeatureExtractor:()=>r.EncodecFeatureExtractor,Gemma3nAudioFeatureExtractor:()=>o.Gemma3nAudioFeatureExtractor,ImageFeatureExtractor:()=>g.ImageProcessor,MoonshineFeatureExtractor:()=>l.MoonshineFeatureExtractor,ParakeetFeatureExtractor:()=>u.ParakeetFeatureExtractor,PyAnnoteFeatureExtractor:()=>c.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>f.SeamlessM4TFeatureExtractor,SnacFeatureExtractor:()=>d.SnacFeatureExtractor,SpeechT5FeatureExtractor:()=>h.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>m.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>y.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>M.WhisperFeatureExtractor});var i=n("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),r=n("./src/models/encodec/feature_extraction_encodec.js"),s=n("./src/models/clap/feature_extraction_clap.js"),a=n("./src/models/dac/feature_extraction_dac.js"),o=n("./src/models/gemma3n/feature_extraction_gemma3n.js"),l=n("./src/models/moonshine/feature_extraction_moonshine.js"),u=n("./src/models/parakeet/feature_extraction_parakeet.js"),c=n("./src/models/pyannote/feature_extraction_pyannote.js"),f=n("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),d=n("./src/models/snac/feature_extraction_snac.js"),h=n("./src/models/speecht5/feature_extraction_speecht5.js"),m=n("./src/models/wav2vec2/feature_extraction_wav2vec2.js"),y=n("./src/models/wespeaker/feature_extraction_wespeaker.js"),M=n("./src/models/whisper/feature_extraction_whisper.js"),g=n("./src/base/image_processors_utils.js")},"./src/models/florence2/processing_florence2.js":(e,t,n)=>{n.r(t),n.d(t,{Florence2Processor:()=>a});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js");class a extends i.Processor{constructor(l,u,c){super(l,u,c);const{tasks_answer_post_processing_type:f,task_prompts_without_inputs:d,task_prompts_with_input:h}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(f??{})),this.task_prompts_without_inputs=new Map(Object.entries(d??{})),this.task_prompts_with_input=new Map(Object.entries(h??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(l){typeof l=="string"&&(l=[l]);const u=[];for(const c of l)if(this.task_prompts_without_inputs.has(c))u.push(this.task_prompts_without_inputs.get(c));else{for(const[f,d]of this.task_prompts_with_input)if(c.includes(f)){u.push(d.replaceAll("{input}",c).replaceAll(f,""));break}u.length!==l.length&&u.push(c)}return u}post_process_generation(l,u,c){const f=this.tasks_answer_post_processing_type.get(u)??"pure_text";l=l.replaceAll("<s>","").replaceAll("</s>","");let d;switch(f){case"pure_text":d=l;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const h=f==="ocr"?"quad_boxes":"bboxes",m=l.matchAll(this.regexes[h]),y=[],M=[];for(const[g,_,...T]of m)y.push(_?_.trim():y.at(-1)??""),M.push(T.map((x,S)=>(Number(x)+.5)/this.size_per_bin*c[S%2]));d={labels:y,[h]:M};break;default:throw new Error(`Task "${u}" (of type "${f}") not yet implemented.`)}return{[u]:d}}async _call(l,u=null,c={}){if(!l&&!u)throw new Error("Either text or images must be provided");const f=await this.image_processor(l,c),d=u?this.tokenizer(this.construct_prompts(u),c):{};return{...f,...d}}}fe(a,"tokenizer_class",s.AutoTokenizer),fe(a,"image_processor_class",r.AutoImageProcessor)},"./src/models/gemma3n/feature_extraction_gemma3n.js":(e,t,n)=>{n.r(t),n.d(t,{Gemma3nAudioFeatureExtractor:()=>a});var i=n("./src/base/feature_extraction_utils.js"),r=n("./src/utils/tensor.js"),s=n("./src/utils/audio.js");class a extends i.FeatureExtractor{constructor(l){super(l);const{fft_length:u,feature_size:c,min_frequency:f,max_frequency:d,sampling_rate:h,frame_length:m}=this.config,y=(0,s.mel_filter_bank)(Math.floor(1+u/2),c,f,d,h,null,"htk",!1);this.mel_filters=y,this.window=(0,s.window_function)(m,"hann")}async _extract_fbank_features(l,u){return(0,s.spectrogram)(l,this.window,this.config.frame_length,this.config.hop_length,{fft_length:this.config.fft_length,center:!1,onesided:!0,preemphasis:this.config.preemphasis,preemphasis_htk_flavor:this.config.preemphasis_htk_flavor,mel_filters:this.mel_filters,log_mel:"log",mel_floor:this.config.mel_floor,remove_dc_offset:!1,transpose:!0})}async _call(l,{max_length:u=48e4,truncation:c=!0,padding:f=!0,pad_to_multiple_of:d=128}={}){if((0,i.validate_audio_inputs)(l,"Gemma3nAudioFeatureExtractor"),c&&l.length>u&&(l=l.slice(0,u)),f&&l.length%d!==0){const y=d-l.length%d,M=new Float64Array(l.length+y);M.set(l),this.config.padding_value!==0&&M.fill(this.config.padding_value,l.length),l=M}const h=await this._extract_fbank_features(l,this.config.max_length),m=(0,r.full)([1,h.dims[0]],!0);return{input_features:h.unsqueeze_(0),input_features_mask:m}}}},"./src/models/gemma3n/processing_gemma3n.js":(e,t,n)=>{n.r(t),n.d(t,{Gemma3nProcessor:()=>o});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/models/auto/feature_extraction_auto.js"),a=n("./src/tokenizers.js");n("./src/utils/image.js"),n("./src/utils/audio.js");class o extends i.Processor{constructor(u,c,f){super(u,c,f),this.audio_seq_length=this.config.audio_seq_length,this.image_seq_length=this.config.image_seq_length;const{audio_token_id:d,boa_token:h,audio_token:m,eoa_token:y,image_token_id:M,boi_token:g,image_token:_,eoi_token:T}=this.tokenizer.config;this.audio_token_id=d,this.boa_token=h,this.audio_token=m;const x=m.repeat(this.audio_seq_length);this.full_audio_sequence=`

${h}${x}${y}

`,this.image_token_id=M,this.boi_token=g,this.image_token=_;const S=_.repeat(this.image_seq_length);this.full_image_sequence=`

${g}${S}${T}

`}async _call(u,c=null,f=null,d={}){typeof u=="string"&&(u=[u]);let h;f&&(h=await this.feature_extractor(f,d),u=u.map(M=>M.replaceAll(this.audio_token,this.full_audio_sequence)));let m;return c&&(m=await this.image_processor(c,d),u=u.map(M=>M.replaceAll(this.image_token,this.full_image_sequence))),{...this.tokenizer(u,d),...m,...h}}}fe(o,"image_processor_class",r.AutoImageProcessor),fe(o,"feature_extractor_class",s.AutoFeatureExtractor),fe(o,"tokenizer_class",a.AutoTokenizer),fe(o,"uses_processor_config",!0),fe(o,"uses_chat_template_file",!0)},"./src/models/glpn/image_processing_glpn.js":(e,t,n)=>{n.r(t),n.d(t,{GLPNFeatureExtractor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/grounding_dino/image_processing_grounding_dino.js":(e,t,n)=>{n.r(t),n.d(t,{GroundingDinoImageProcessor:()=>s});var i=n("./src/base/image_processors_utils.js"),r=n("./src/utils/tensor.js");class s extends i.ImageProcessor{async _call(o){const l=await super._call(o),u=l.pixel_values.dims,c=(0,r.ones)([u[0],u[2],u[3]]);return{...l,pixel_mask:c}}}},"./src/models/grounding_dino/processing_grounding_dino.js":(e,t,n)=>{n.r(t),n.d(t,{GroundingDinoProcessor:()=>l});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js"),a=n("./src/base/image_processors_utils.js");function o(u,c){const d=u.dims.at(-1)-1,h=u.tolist();h.fill(!1,0,1),h.fill(!1,d);const m=c.tolist();return h.map((y,M)=>y?M:null).filter(y=>y!==null).map(y=>m[y])}class l extends i.Processor{async _call(c,f,d={}){const h=c?await this.image_processor(c,d):{};return{...f?this.tokenizer(f,d):{},...h}}post_process_grounded_object_detection(c,f,{box_threshold:d=.25,text_threshold:h=.25,target_sizes:m=null}={}){const{logits:y,pred_boxes:M}=c,g=y.dims[0];if(m!==null&&m.length!==g)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const _=y.dims.at(1),T=y.sigmoid(),x=T.max(-1).tolist(),S=M.tolist().map(C=>C.map(P=>(0,a.center_to_corners_format)(P))),$=[];for(let C=0;C<g;++C){const P=m!==null?m[C]:null;P!==null&&(S[C]=S[C].map(V=>V.map((te,J)=>te*P[(J+1)%2])));const O=x[C],R=[],G=[],W=[];for(let V=0;V<_;++V){const te=O[V];if(te<=d)continue;const J=S[C][V],j=T[C][V];R.push(te),W.push(J);const Y=o(j.gt(h),f[C]);G.push(Y)}$.push({scores:R,boxes:W,labels:this.batch_decode(G)})}return $}}fe(l,"tokenizer_class",s.AutoTokenizer),fe(l,"image_processor_class",r.AutoImageProcessor)},"./src/models/idefics3/image_processing_idefics3.js":(e,t,n)=>{n.r(t),n.d(t,{Idefics3ImageProcessor:()=>s});var i=n("./src/base/image_processors_utils.js"),r=n("./src/utils/tensor.js");class s extends i.ImageProcessor{constructor(o){super(o),this.do_image_splitting=o.do_image_splitting??!0,this.max_image_size=o.max_image_size}get_resize_for_vision_encoder(o,l){let[u,c]=o.dims.slice(-2);const f=c/u;return c>=u?(c=Math.ceil(c/l)*l,u=Math.floor(c/f),u=Math.ceil(u/l)*l):(u=Math.ceil(u/l)*l,c=Math.floor(u*f),c=Math.ceil(c/l)*l),{height:u,width:c}}async _call(o,{do_image_splitting:l=null,return_row_col_info:u=!1}={}){let c;if(!Array.isArray(o))c=[[o]];else{if(o.length===0||!o[0])throw new Error("No images provided.");Array.isArray(o[0])?c=o:c=[o]}let f=[],d=[],h=[];const m=[],y=[];for(const C of c){let P=await Promise.all(C.map(G=>this.preprocess(G)));m.push(...P.map(G=>G.original_size)),y.push(...P.map(G=>G.reshaped_input_size)),P.forEach(G=>G.pixel_values.unsqueeze_(0));const{longest_edge:O}=this.max_image_size;let R;if(l??this.do_image_splitting){let G=new Array(P.length),W=new Array(P.length);R=await Promise.all(P.map(async(V,te)=>{const J=this.get_resize_for_vision_encoder(V.pixel_values,O),j=await(0,r.interpolate_4d)(V.pixel_values,{size:[J.height,J.width]}),{frames:Y,num_splits_h:X,num_splits_w:ce}=await this.split_image(j,this.max_image_size);return G[te]=X,W[te]=ce,(0,r.cat)(Y,0)})),d.push(G),h.push(W)}else{const G=[O,O];R=await Promise.all(P.map(W=>(0,r.interpolate_4d)(W.pixel_values,{size:G}))),d.push(new Array(P.length).fill(0)),h.push(new Array(P.length).fill(0))}f.push((0,r.cat)(R,0))}const M=f.length,[g,_,T,x]=f[0].dims;let S,$;if(M===1)S=f[0].unsqueeze_(0),$=(0,r.full)([M,g,T,x],!0);else{const C=Math.max(...f.map(R=>R.dims.at(0)));$=(0,r.full)([M,C,T,x],!0);const P=$.data,O=C*T*x;for(let R=0;R<M;++R){const G=f[R].dims[0];if(G<C){f[R]=(0,r.cat)([f[R],(0,r.full)([C-G,_,T,x],0)],0);const W=R*O+G*T*x,V=(R+1)*O;P.fill(!1,W,V)}}S=(0,r.stack)(f,0)}return{pixel_values:S,pixel_attention_mask:$,original_sizes:m,reshaped_input_sizes:y,...u?{rows:d,cols:h}:{}}}async split_image(o,{longest_edge:l}){const u=l,c=l,f=[],[d,h]=o.dims.slice(-2);let m=0,y=0;if(d>u||h>c){m=Math.ceil(d/u),y=Math.ceil(h/c);const M=Math.ceil(d/m),g=Math.ceil(h/y);for(let x=0;x<m;++x)for(let S=0;S<y;++S){let $,C,P,O;x===m-1?(C=d-M,O=d):(C=x*M,O=(x+1)*M),S===y-1?($=h-g,P=h):($=S*g,P=(S+1)*g);const R=[C,$],G=[O,P],W=await(0,r.slice)(o,R,G,[2,3]);f.push(W)}const _=u,T=c;(d!==_||h!==T)&&(o=await(0,r.interpolate_4d)(o,{size:[_,T]}))}return f.push(o),{frames:f,num_splits_h:m,num_splits_w:y}}}},"./src/models/idefics3/processing_idefics3.js":(e,t,n)=>{n.r(t),n.d(t,{Idefics3Processor:()=>c});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js");n("./src/utils/image.js");var a=n("./src/utils/core.js");function o(f,d,h,m,y,M){let g="";for(let _=0;_<d;++_){for(let T=0;T<h;++T)g+=m+`<row_${_+1}_col_${T+1}>`+y.repeat(f);g+=`
`}return g+=`
${m}${M}`+y.repeat(f)+`${m}`,g}function l(f,d,h,m){return`${d}${m}`+h.repeat(f)+`${d}`}function u(f,d,h,m,y,M){return f===0&&d===0?l(h,m,y,M):o(h,f,d,m,y,M)}class c extends i.Processor{constructor(){super(...arguments);fe(this,"fake_image_token","<fake_token_around_image>");fe(this,"image_token","<image>");fe(this,"global_img_token","<global-img>")}async _call(h,m=null,y={}){y.return_row_col_info??(y.return_row_col_info=!0);let M;m&&(M=await this.image_processor(m,y)),Array.isArray(h)||(h=[h]);const g=M.rows??[new Array(h.length).fill(0)],_=M.cols??[new Array(h.length).fill(0)],T=this.config.image_seq_len,x=[],S=[];for(let C=0;C<h.length;++C){const P=h[C],O=g[C],R=_[C];x.push((0,a.count)(P,this.image_token));const G=O.map((te,J)=>u(te,R[J],T,this.fake_image_token,this.image_token,this.global_img_token)),W=P.split(this.image_token);if(W.length===0)throw new Error("The image token should be present in the text.");let V=W[0];for(let te=0;te<G.length;++te)V+=G[te]+W[te+1];S.push(V)}return{...this.tokenizer(S),...M}}}fe(c,"image_processor_class",r.AutoImageProcessor),fe(c,"tokenizer_class",s.AutoTokenizer),fe(c,"uses_processor_config",!0)},"./src/models/image_processors.js":(e,t,n)=>{n.r(t),n.d(t,{BeitFeatureExtractor:()=>i.BeitFeatureExtractor,BitImageProcessor:()=>r.BitImageProcessor,CLIPFeatureExtractor:()=>a.CLIPFeatureExtractor,CLIPImageProcessor:()=>a.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>s.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>o.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>o.ConvNextImageProcessor,DINOv3ViTImageProcessor:()=>c.DINOv3ViTImageProcessor,DPTFeatureExtractor:()=>d.DPTFeatureExtractor,DPTImageProcessor:()=>d.DPTImageProcessor,DeiTFeatureExtractor:()=>l.DeiTFeatureExtractor,DeiTImageProcessor:()=>l.DeiTImageProcessor,DetrFeatureExtractor:()=>u.DetrFeatureExtractor,DetrImageProcessor:()=>u.DetrImageProcessor,DonutFeatureExtractor:()=>f.DonutFeatureExtractor,DonutImageProcessor:()=>f.DonutImageProcessor,EfficientNetImageProcessor:()=>h.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>m.GLPNFeatureExtractor,GroundingDinoImageProcessor:()=>y.GroundingDinoImageProcessor,Idefics3ImageProcessor:()=>M.Idefics3ImageProcessor,JinaCLIPImageProcessor:()=>_.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>T.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>x.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>S.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>S.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>$.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>$.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>C.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>C.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>P.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>P.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>O.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>O.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>R.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>R.MobileViTImageProcessor,NougatImageProcessor:()=>G.NougatImageProcessor,OwlViTFeatureExtractor:()=>V.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>V.OwlViTImageProcessor,Owlv2ImageProcessor:()=>W.Owlv2ImageProcessor,Phi3VImageProcessor:()=>te.Phi3VImageProcessor,PixtralImageProcessor:()=>J.PixtralImageProcessor,PvtImageProcessor:()=>j.PvtImageProcessor,Qwen2VLImageProcessor:()=>Y.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>X.RTDetrImageProcessor,Sam2ImageProcessor:()=>me.Sam2ImageProcessor,Sam3ImageProcessor:()=>Q.Sam3ImageProcessor,SamImageProcessor:()=>ce.SamImageProcessor,SegformerFeatureExtractor:()=>H.SegformerFeatureExtractor,SegformerImageProcessor:()=>H.SegformerImageProcessor,SiglipImageProcessor:()=>B.SiglipImageProcessor,SmolVLMImageProcessor:()=>ee.SmolVLMImageProcessor,Swin2SRImageProcessor:()=>_e.Swin2SRImageProcessor,VLMImageProcessor:()=>g.VLMImageProcessor,ViTFeatureExtractor:()=>le.ViTFeatureExtractor,ViTImageProcessor:()=>le.ViTImageProcessor,VitMatteImageProcessor:()=>ae.VitMatteImageProcessor,VitPoseImageProcessor:()=>Ne.VitPoseImageProcessor,YolosFeatureExtractor:()=>Ye.YolosFeatureExtractor,YolosImageProcessor:()=>Ye.YolosImageProcessor});var i=n("./src/models/beit/image_processing_beit.js"),r=n("./src/models/bit/image_processing_bit.js"),s=n("./src/models/chinese_clip/image_processing_chinese_clip.js"),a=n("./src/models/clip/image_processing_clip.js"),o=n("./src/models/convnext/image_processing_convnext.js"),l=n("./src/models/deit/image_processing_deit.js"),u=n("./src/models/detr/image_processing_detr.js"),c=n("./src/models/dinov3_vit/image_processing_dinov3_vit.js"),f=n("./src/models/donut/image_processing_donut.js"),d=n("./src/models/dpt/image_processing_dpt.js"),h=n("./src/models/efficientnet/image_processing_efficientnet.js"),m=n("./src/models/glpn/image_processing_glpn.js"),y=n("./src/models/grounding_dino/image_processing_grounding_dino.js"),M=n("./src/models/idefics3/image_processing_idefics3.js"),g=n("./src/models/janus/image_processing_janus.js"),_=n("./src/models/jina_clip/image_processing_jina_clip.js"),T=n("./src/models/llava_onevision/image_processing_llava_onevision.js"),x=n("./src/models/mask2former/image_processing_mask2former.js"),S=n("./src/models/maskformer/image_processing_maskformer.js"),$=n("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),C=n("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),P=n("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),O=n("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),R=n("./src/models/mobilevit/image_processing_mobilevit.js"),G=n("./src/models/nougat/image_processing_nougat.js"),W=n("./src/models/owlv2/image_processing_owlv2.js"),V=n("./src/models/owlvit/image_processing_owlvit.js"),te=n("./src/models/phi3_v/image_processing_phi3_v.js"),J=n("./src/models/pixtral/image_processing_pixtral.js"),j=n("./src/models/pvt/image_processing_pvt.js"),Y=n("./src/models/qwen2_vl/image_processing_qwen2_vl.js"),X=n("./src/models/rt_detr/image_processing_rt_detr.js"),ce=n("./src/models/sam/image_processing_sam.js"),me=n("./src/models/sam2/image_processing_sam2.js"),Q=n("./src/models/sam3/image_processing_sam3.js"),H=n("./src/models/segformer/image_processing_segformer.js"),B=n("./src/models/siglip/image_processing_siglip.js"),ee=n("./src/models/smolvlm/image_processing_smolvlm.js"),_e=n("./src/models/swin2sr/image_processing_swin2sr.js"),le=n("./src/models/vit/image_processing_vit.js"),ae=n("./src/models/vitmatte/image_processing_vitmatte.js"),Ne=n("./src/models/vitpose/image_processing_vitpose.js"),Ye=n("./src/models/yolos/image_processing_yolos.js")},"./src/models/janus/image_processing_janus.js":(e,t,n)=>{n.r(t),n.d(t,{VLMImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{constructor(a){super({do_pad:!0,pad_size:{width:a.image_size,height:a.image_size},...a}),this.constant_values=this.config.background_color.map(o=>o*this.rescale_factor)}pad_image(a,o,l,u){return super.pad_image(a,o,l,{constant_values:this.constant_values,center:!0,...u})}}},"./src/models/janus/processing_janus.js":(e,t,n)=>{n.r(t),n.d(t,{VLChatProcessor:()=>u});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js"),a=n("./src/utils/core.js"),o=n("./src/utils/tensor.js"),l=n("./src/utils/image.js");class u extends i.Processor{constructor(f,d,h){super(f,d,h),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(f,{images:d=null,chat_template:h="default"}={}){d?Array.isArray(d)||(d=[d]):d=await Promise.all(f.filter(R=>R.images).flatMap(R=>R.images).map(R=>l.RawImage.read(R)));const m=this.tokenizer,y=m.apply_chat_template(f,{tokenize:!1,add_generation_prompt:!0,chat_template:h}),M=R=>m.encode(R,{add_special_tokens:!1}),g=y.split(this.image_tag),_=g.length-1;if(d.length!==_)throw new Error(`Number of images provided (${d.length}) does not match number of "${this.image_tag}" image tags (${_})`);const[T,x,S]=m.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let $=M(g[0]),C=new Array($.length).fill(!1);for(let R=1;R<g.length;++R){const G=new Array(this.num_image_tokens).fill(T),W=M(g[R]);$=(0,a.mergeArrays)($,[x],G,[S],W);const V=new Array(this.num_image_tokens).fill(!0);C=(0,a.mergeArrays)(C,[!1],V,[!1],new Array(W.length).fill(!1))}const P=[1,$.length],O={input_ids:new o.Tensor("int64",$,P),attention_mask:new o.Tensor("int64",new Array($.length).fill(1),P),images_seq_mask:new o.Tensor("bool",C,P),images_emb_mask:new o.Tensor("bool",new Array(_*this.num_image_tokens).fill(!0),[1,_,this.num_image_tokens])};if(d&&d.length>0){const R=await this.image_processor(d);return R.pixel_values.unsqueeze_(0),{...O,...R}}return O}}fe(u,"image_processor_class",r.AutoImageProcessor),fe(u,"tokenizer_class",s.AutoTokenizer),fe(u,"uses_processor_config",!0)},"./src/models/jina_clip/image_processing_jina_clip.js":(e,t,n)=>{n.r(t),n.d(t,{JinaCLIPImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{constructor(a){const{resize_mode:o,fill_color:l,interpolation:u,size:c,...f}=a,d=o==="squash"?{width:c,height:c}:o==="shortest"?{shortest_edge:c}:{longest_edge:c},h=u==="bicubic"?3:2;super({...f,size:d,resample:h,do_center_crop:!0,crop_size:c,do_normalize:!0})}}},"./src/models/jina_clip/processing_jina_clip.js":(e,t,n)=>{n.r(t),n.d(t,{JinaCLIPProcessor:()=>a});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js");class a extends i.Processor{async _call(l=null,u=null,c={}){if(!l&&!u)throw new Error("Either text or images must be provided");const f=l?this.tokenizer(l,c):{},d=u?await this.image_processor(u,c):{};return{...f,...d}}}fe(a,"tokenizer_class",s.AutoTokenizer),fe(a,"image_processor_class",r.AutoImageProcessor)},"./src/models/llava/processing_llava.js":(e,t,n)=>{n.r(t),n.d(t,{LlavaProcessor:()=>a});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js");class a extends i.Processor{async _call(l,u=null,c={}){const f=await this.image_processor(l,c);if(u){const[h,m]=f.pixel_values.dims.slice(-2),{image_token:y,patch_size:M,num_additional_image_tokens:g}=this.config,_=Math.floor(h/M)*Math.floor(m/M)+g;u=structuredClone(u),Array.isArray(u)||(u=[u]);for(let T=0;T<u.length;++T)u[T]=u[T].replace(y,y.repeat(_))}const d=u?this.tokenizer(u,c):{};return{...f,...d}}}fe(a,"tokenizer_class",s.AutoTokenizer),fe(a,"image_processor_class",r.AutoImageProcessor),fe(a,"uses_processor_config",!0)},"./src/models/llava_onevision/image_processing_llava_onevision.js":(e,t,n)=>{n.r(t),n.d(t,{LlavaOnevisionImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/mask2former/image_processing_mask2former.js":(e,t,n)=>{n.r(t),n.d(t,{Mask2FormerImageProcessor:()=>r});var i=n("./src/models/maskformer/image_processing_maskformer.js");class r extends i.MaskFormerImageProcessor{}},"./src/models/maskformer/image_processing_maskformer.js":(e,t,n)=>{n.r(t),n.d(t,{MaskFormerFeatureExtractor:()=>s,MaskFormerImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_panoptic_segmentation(...o){return(0,i.post_process_panoptic_segmentation)(...o)}post_process_instance_segmentation(...o){return(0,i.post_process_instance_segmentation)(...o)}}class s extends r{}},"./src/models/mgp_str/processing_mgp_str.js":(e,t,n)=>{n.r(t),n.d(t,{MgpstrProcessor:()=>l});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js"),a=n("./src/utils/maths.js");const o={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class l extends i.Processor{get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(c,f){if(!o.hasOwnProperty(f))throw new Error(`Format ${f} is not supported.`);const[d,h]=o[f],m=this[d].bind(this),[y,M]=c.dims,g=[],_=[],T=c.tolist();for(let S=0;S<y;++S){const $=T[S],C=[],P=[];for(let R=1;R<M;++R){const[G,W]=(0,a.max)((0,a.softmax)($[R]));if(P.push(G),W==h)break;C.push(W)}const O=P.length>0?P.reduce((R,G)=>R*G,1):0;_.push(C),g.push(O)}return[m(_),g]}char_decode(c){return this.char_tokenizer.batch_decode(c).map(f=>f.replaceAll(" ",""))}bpe_decode(c){return this.bpe_tokenizer.batch_decode(c)}wp_decode(c){return this.wp_tokenizer.batch_decode(c).map(f=>f.replaceAll(" ",""))}batch_decode([c,f,d]){const[h,m]=this._decode_helper(c,"char"),[y,M]=this._decode_helper(f,"bpe"),[g,_]=this._decode_helper(d,"wp"),T=[],x=[];for(let S=0;S<h.length;++S){const[$,C]=(0,a.max)([m[S],M[S],_[S]]);T.push([h[S],y[S],g[S]][C]),x.push($)}return{generated_text:T,scores:x,char_preds:h,bpe_preds:y,wp_preds:g}}static async from_pretrained(...c){const f=await super.from_pretrained(...c),d=await s.AutoTokenizer.from_pretrained("Xenova/gpt2"),h=await s.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return f.components={image_processor:f.image_processor,char_tokenizer:f.tokenizer,bpe_tokenizer:d,wp_tokenizer:h},f}async _call(c,f=null){const d=await this.image_processor(c);return f&&(d.labels=this.tokenizer(f).input_ids),d}}fe(l,"tokenizer_class",s.AutoTokenizer),fe(l,"image_processor_class",r.AutoImageProcessor)},"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV1FeatureExtractor:()=>s,MobileNetV1ImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class s extends r{}},"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV2FeatureExtractor:()=>s,MobileNetV2ImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class s extends r{}},"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV3FeatureExtractor:()=>s,MobileNetV3ImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class s extends r{}},"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV4FeatureExtractor:()=>s,MobileNetV4ImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class s extends r{}},"./src/models/mobilevit/image_processing_mobilevit.js":(e,t,n)=>{n.r(t),n.d(t,{MobileViTFeatureExtractor:()=>s,MobileViTImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class s extends r{}},"./src/models/moonshine/feature_extraction_moonshine.js":(e,t,n)=>{n.r(t),n.d(t,{MoonshineFeatureExtractor:()=>s});var i=n("./src/base/feature_extraction_utils.js"),r=n("./src/utils/tensor.js");class s extends i.FeatureExtractor{async _call(o){(0,i.validate_audio_inputs)(o,"MoonshineFeatureExtractor"),o instanceof Float64Array&&(o=new Float32Array(o));const l=[1,o.length];return{input_values:new r.Tensor("float32",o,l)}}}},"./src/models/moonshine/processing_moonshine.js":(e,t,n)=>{n.r(t),n.d(t,{MoonshineProcessor:()=>a});var i=n("./src/models/auto/feature_extraction_auto.js"),r=n("./src/tokenizers.js"),s=n("./src/base/processing_utils.js");class a extends s.Processor{async _call(l){return await this.feature_extractor(l)}}fe(a,"tokenizer_class",r.AutoTokenizer),fe(a,"feature_extractor_class",i.AutoFeatureExtractor)},"./src/models/nougat/image_processing_nougat.js":(e,t,n)=>{n.r(t),n.d(t,{NougatImageProcessor:()=>r});var i=n("./src/models/donut/image_processing_donut.js");class r extends i.DonutImageProcessor{}},"./src/models/owlv2/image_processing_owlv2.js":(e,t,n)=>{n.r(t),n.d(t,{Owlv2ImageProcessor:()=>r});var i=n("./src/models/owlvit/image_processing_owlvit.js");class r extends i.OwlViTImageProcessor{}},"./src/models/owlvit/image_processing_owlvit.js":(e,t,n)=>{n.r(t),n.d(t,{OwlViTFeatureExtractor:()=>s,OwlViTImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_object_detection(...o){return(0,i.post_process_object_detection)(...o)}}class s extends r{}},"./src/models/owlvit/processing_owlvit.js":(e,t,n)=>{n.r(t),n.d(t,{OwlViTProcessor:()=>a});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js");class a extends i.Processor{}fe(a,"tokenizer_class",s.AutoTokenizer),fe(a,"image_processor_class",r.AutoImageProcessor)},"./src/models/paligemma/processing_paligemma.js":(e,t,n)=>{n.r(t),n.d(t,{PaliGemmaProcessor:()=>l});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js");const a="<image>";function o(u,c,f,d,h){return`${d.repeat(f*h)}${c}${u}
`}class l extends i.Processor{async _call(c,f=null,d={}){f||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),f=""),Array.isArray(c)||(c=[c]),Array.isArray(f)||(f=[f]);const h=this.tokenizer.bos_token,m=this.image_processor.config.image_seq_length;let y;f.some(_=>_.includes(a))?y=f.map(_=>{const T=_.replaceAll(a,a.repeat(m)),x=T.lastIndexOf(a),S=x===-1?0:x+a.length;return T.slice(0,S)+h+T.slice(S)+`
`}):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),y=f.map(_=>o(_,h,m,a,c.length)));const M=this.tokenizer(y,d);return{...await this.image_processor(c,d),...M}}}fe(l,"tokenizer_class",s.AutoTokenizer),fe(l,"image_processor_class",r.AutoImageProcessor),fe(l,"uses_processor_config",!1)},"./src/models/parakeet/feature_extraction_parakeet.js":(e,t,n)=>{n.r(t),n.d(t,{ParakeetFeatureExtractor:()=>o});var i=n("./src/base/feature_extraction_utils.js"),r=n("./src/utils/tensor.js"),s=n("./src/utils/audio.js");const a=1e-5;class o extends i.FeatureExtractor{constructor(u){var d;super(u),(d=this.config).mel_filters??(d.mel_filters=(0,s.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,this.config.sampling_rate/2,this.config.sampling_rate,"slaney","slaney"));const c=(0,s.window_function)(this.config.win_length,"hann",{periodic:!1});this.window=new Float64Array(this.config.n_fft);const f=Math.floor((this.config.n_fft-this.config.win_length)/2);this.window.set(c,f)}async _extract_fbank_features(u){const c=this.config.preemphasis;u=new Float64Array(u);for(let d=u.length-1;d>=1;--d)u[d]-=c*u[d-1];return await(0,s.spectrogram)(u,this.window,this.window.length,this.config.hop_length,{fft_length:this.config.n_fft,power:2,mel_filters:this.config.mel_filters,log_mel:"log",mel_floor:-1/0,pad_mode:"constant",center:!0,transpose:!0,mel_offset:2**-24})}async _call(u){(0,i.validate_audio_inputs)(u,"ParakeetFeatureExtractor");const c=await this._extract_fbank_features(u),f=Math.floor((u.length+Math.floor(this.config.n_fft/2)*2-this.config.n_fft)/this.config.hop_length),d=c.data;d.fill(0,f*c.dims[1]);const[h,m]=c.dims,y=new Float64Array(m),M=new Float64Array(m);for(let T=0;T<f;++T){const x=T*m;for(let S=0;S<m;++S){const $=d[x+S];y[S]+=$,M[S]+=$*$}}const g=f>1?f-1:1;for(let T=0;T<m;++T){const x=y[T]/f,S=(M[T]-f*x*x)/g,C=1/(Math.sqrt(S)+a);for(let P=0;P<f;++P){const O=P*m+T;d[O]=(d[O]-x)*C}}const _=new BigInt64Array(h);return _.fill(1n,0,f),{input_features:c.unsqueeze_(0),attention_mask:new r.Tensor("int64",_,[1,h])}}}},"./src/models/phi3_v/image_processing_phi3_v.js":(e,t,n)=>{n.r(t),n.d(t,{Phi3VImageProcessor:()=>c});var i=n("./src/base/image_processors_utils.js"),r=n("./src/utils/tensor.js");const s=336,a=[2,3],{ceil:o,floor:l,sqrt:u}=Math;class c extends i.ImageProcessor{constructor(d){super({...d,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=d.num_crops}calc_num_image_tokens_from_image_size(d,h){const{num_img_tokens:m}=this.config;return l((l(h/s)*l(d/s)+1)*m+1+(l(h/s)+1)*u(m))}get_resize_output_image_size(d,h){const m=this._num_crops,[y,M]=d.size;let g=y/M,_=1;for(;_*Math.ceil(_/g)<=m;)_+=1;_-=1;const T=Math.floor(_*336),x=Math.floor(T/g);return[T,x]}pad_image(d,h,m,y={}){const[M,g]=h,_=s*o(M/s),T=s*o(g/s),x=[1,1,1].map((S,$)=>(S-this.image_mean[$])/this.image_std[$]);return super.pad_image(d,h,{width:T,height:_},{center:!0,constant_values:x,...y})}async _call(d,{num_crops:h=null}={}){if(this._num_crops=h??(h=this.config.num_crops),h<4||u(h)%1!==0)throw new Error("num_crops must be a square number >= 4");Array.isArray(d)||(d=[d]);const m=d.length,y=await Promise.all(d.map(C=>this.preprocess(C))),M=y.map(C=>C.original_size),g=y.map(C=>C.reshaped_input_size),_=[];for(const{pixel_values:C}of y){C.unsqueeze_(0);const[P,O]=C.dims.slice(-2),R=await(0,r.interpolate_4d)(C,{size:[s,s],mode:"bicubic"});if(h>0){const G=[],W=u(h),V=l(O/W),te=l(P/W);for(let j=0;j<W;++j)for(let Y=0;Y<W;++Y){let X,ce,me,Q;j===W-1?(ce=P-te,Q=P):(ce=j*te,Q=(j+1)*te),Y===W-1?(X=O-V,me=O):(X=Y*V,me=(Y+1)*V);const H=[ce,X],B=[Q,me],ee=await(0,r.slice)(C,H,B,a);G.push(ee)}const J=await(0,r.interpolate_4d)((0,r.cat)(G,0),{size:[s,s],mode:"bicubic"});_.push((0,r.cat)([R,J],0))}else _.push(R)}const T=(0,r.stack)(_,0),x=g.map(C=>C.map(P=>s*o(P/s))),S=new r.Tensor("int64",x.flat(),[m,2]),$=x.map(([C,P])=>this.calc_num_image_tokens_from_image_size(P,C));return{pixel_values:T,original_sizes:M,reshaped_input_sizes:g,image_sizes:S,num_img_tokens:$}}}},"./src/models/phi3_v/processing_phi3_v.js":(e,t,n)=>{n.r(t),n.d(t,{Phi3VProcessor:()=>l});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js");n("./src/utils/image.js");const a="<|image|>",o=/<\|image_\d+\|>/g;class l extends i.Processor{async _call(c,f=null,{padding:d=!0,truncation:h=!0,num_crops:m=null}={}){Array.isArray(c)||(c=[c]);let y,M;if(f){M=await this.image_processor(f,{num_crops:m});const{num_img_tokens:g}=M,_=c.map((x,S)=>x.split(o).join(a.repeat(g[S])));y=this.tokenizer(_,{padding:d,truncation:h});const T=this.tokenizer.model.convert_tokens_to_ids([a])[0];y.input_ids.map_(x=>x==T?-x:x)}else y=this.tokenizer(c);return{...y,...M}}}fe(l,"image_processor_class",r.AutoImageProcessor),fe(l,"tokenizer_class",s.AutoTokenizer)},"./src/models/pixtral/image_processing_pixtral.js":(e,t,n)=>{n.r(t),n.d(t,{PixtralImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{get_resize_output_image_size(a,o){const{longest_edge:l}=o;if(l===void 0)throw new Error("size must contain 'longest_edge'");const[u,c]=a.size,f=Math.max(u,c)/l;let d=u,h=c;f>1&&(d=Math.floor(u/f),h=Math.floor(c/f));const{patch_size:m,spatial_merge_size:y}=this.config;if(!y)throw new Error("config must contain 'spatial_merge_size'");const M=m*y,g=Math.floor((d-1)/M)+1,_=Math.floor((h-1)/M)+1;return[g*M,_*M]}}},"./src/models/pixtral/processing_pixtral.js":(e,t,n)=>{n.r(t),n.d(t,{PixtralProcessor:()=>a});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js");class a extends i.Processor{async _call(l,u=null,c={}){const f=await this.image_processor(l,c);if(u){const[h,m]=f.pixel_values.dims.slice(-2),{image_token:y,image_break_token:M,image_end_token:g,patch_size:_,spatial_merge_size:T}=this.config,x=_*T,S=Math.floor(h/x),$=Math.floor(m/x);u=structuredClone(u),Array.isArray(u)||(u=[u]);for(let C=0;C<u.length;++C){const P=y.repeat($),O=P+M,R=P+g,G=O.repeat(S-1)+R;u[C]=u[C].replace(y,G)}}const d=u?this.tokenizer(u,c):{};return{...f,...d}}}fe(a,"tokenizer_class",s.AutoTokenizer),fe(a,"image_processor_class",r.AutoImageProcessor),fe(a,"uses_processor_config",!0)},"./src/models/processors.js":(e,t,n)=>{n.r(t),n.d(t,{Florence2Processor:()=>i.Florence2Processor,Gemma3nProcessor:()=>r.Gemma3nProcessor,GroundingDinoProcessor:()=>s.GroundingDinoProcessor,Idefics3Processor:()=>a.Idefics3Processor,JinaCLIPProcessor:()=>l.JinaCLIPProcessor,LlavaProcessor:()=>u.LlavaProcessor,MgpstrProcessor:()=>c.MgpstrProcessor,MoonshineProcessor:()=>f.MoonshineProcessor,OwlViTProcessor:()=>d.OwlViTProcessor,PaliGemmaProcessor:()=>h.PaliGemmaProcessor,Phi3VProcessor:()=>m.Phi3VProcessor,PixtralProcessor:()=>y.PixtralProcessor,PyAnnoteProcessor:()=>M.PyAnnoteProcessor,Qwen2VLProcessor:()=>g.Qwen2VLProcessor,Sam2Processor:()=>T.Sam2Processor,Sam2VideoProcessor:()=>T.Sam2VideoProcessor,SamProcessor:()=>_.SamProcessor,SmolVLMProcessor:()=>x.SmolVLMProcessor,SpeechT5Processor:()=>S.SpeechT5Processor,UltravoxProcessor:()=>$.UltravoxProcessor,VLChatProcessor:()=>o.VLChatProcessor,VoxtralProcessor:()=>C.VoxtralProcessor,Wav2Vec2Processor:()=>P.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>O.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>R.WhisperProcessor});var i=n("./src/models/florence2/processing_florence2.js"),r=n("./src/models/gemma3n/processing_gemma3n.js"),s=n("./src/models/grounding_dino/processing_grounding_dino.js"),a=n("./src/models/idefics3/processing_idefics3.js"),o=n("./src/models/janus/processing_janus.js"),l=n("./src/models/jina_clip/processing_jina_clip.js"),u=n("./src/models/llava/processing_llava.js"),c=n("./src/models/mgp_str/processing_mgp_str.js"),f=n("./src/models/moonshine/processing_moonshine.js"),d=n("./src/models/owlvit/processing_owlvit.js"),h=n("./src/models/paligemma/processing_paligemma.js"),m=n("./src/models/phi3_v/processing_phi3_v.js"),y=n("./src/models/pixtral/processing_pixtral.js"),M=n("./src/models/pyannote/processing_pyannote.js"),g=n("./src/models/qwen2_vl/processing_qwen2_vl.js"),_=n("./src/models/sam/processing_sam.js"),T=n("./src/models/sam2/processing_sam2.js"),x=n("./src/models/smolvlm/processing_smolvlm.js"),S=n("./src/models/speecht5/processing_speecht5.js"),$=n("./src/models/ultravox/processing_ultravox.js"),C=n("./src/models/voxtral/processing_voxtral.js"),P=n("./src/models/wav2vec2/processing_wav2vec2.js"),O=n("./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js"),R=n("./src/models/whisper/processing_whisper.js")},"./src/models/pvt/image_processing_pvt.js":(e,t,n)=>{n.r(t),n.d(t,{PvtImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/pyannote/feature_extraction_pyannote.js":(e,t,n)=>{n.r(t),n.d(t,{PyAnnoteFeatureExtractor:()=>a});var i=n("./src/base/feature_extraction_utils.js"),r=n("./src/utils/tensor.js"),s=n("./src/utils/maths.js");class a extends i.FeatureExtractor{async _call(l){(0,i.validate_audio_inputs)(l,"PyAnnoteFeatureExtractor"),l instanceof Float64Array&&(l=new Float32Array(l));const u=[1,1,l.length];return{input_values:new r.Tensor("float32",l,u)}}samples_to_frames(l){return(l-this.config.offset)/this.config.step}post_process_speaker_diarization(l,u){const c=u/this.samples_to_frames(u)/this.config.sampling_rate,f=[];for(const d of l.tolist()){const h=[];let m=-1;for(let y=0;y<d.length;++y){const M=(0,s.softmax)(d[y]),[g,_]=(0,s.max)(M),[T,x]=[y,y+1];_!==m?(m=_,h.push({id:_,start:T,end:x,score:g})):(h.at(-1).end=x,h.at(-1).score+=g)}f.push(h.map(({id:y,start:M,end:g,score:_})=>({id:y,start:M*c,end:g*c,confidence:_/(g-M)})))}return f}}},"./src/models/pyannote/processing_pyannote.js":(e,t,n)=>{n.r(t),n.d(t,{PyAnnoteProcessor:()=>s});var i=n("./src/base/processing_utils.js"),r=n("./src/models/pyannote/feature_extraction_pyannote.js");class s extends i.Processor{async _call(o){return await this.feature_extractor(o)}post_process_speaker_diarization(...o){return this.feature_extractor.post_process_speaker_diarization(...o)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}fe(s,"feature_extractor_class",r.PyAnnoteFeatureExtractor)},"./src/models/qwen2_vl/image_processing_qwen2_vl.js":(e,t,n)=>{n.r(t),n.d(t,{Qwen2VLImageProcessor:()=>s});var i=n("./src/base/image_processors_utils.js"),r=n("./src/utils/tensor.js");class s extends i.ImageProcessor{async _call(o,...l){const{pixel_values:u,original_sizes:c,reshaped_input_sizes:f}=await super._call(o,...l);let d=u;const{temporal_patch_size:h,merge_size:m,patch_size:y}=this.config;d.dims[0]===1&&(d=(0,r.cat)(Array.from({length:h},()=>d),0));const M=d.dims[0]/h,g=d.dims[1],_=Math.floor(d.dims[2]/y),T=Math.floor(d.dims[3]/y),x=d.view(M,h,g,Math.floor(_/m),m,y,Math.floor(T/m),m,y).permute(0,3,6,4,7,2,1,5,8).view(M*_*T,g*h*y*y),S=new r.Tensor("int64",[M,_,T],[1,3]);return{pixel_values:x,image_grid_thw:S,original_sizes:c,reshaped_input_sizes:f}}}},"./src/models/qwen2_vl/processing_qwen2_vl.js":(e,t,n)=>{n.r(t),n.d(t,{Qwen2VLProcessor:()=>a});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js"),s=n("./src/tokenizers.js");n("./src/utils/image.js");class a extends i.Processor{async _call(l,u=null,...c){Array.isArray(l)||(l=[l]);let f,d;if(u&&(f=await this.image_processor(u),d=f.image_grid_thw),d){let m=this.image_processor.config.merge_size**2,y=0;const M=d.tolist();l=l.map(g=>{for(;g.includes("<|image_pad|>");){const _=Number(M[y++].reduce((T,x)=>T*x,1n));g=g.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(_/m)))}return g.replaceAll("<|placeholder|>","<|image_pad|>")})}return{...this.tokenizer(l),...f}}}fe(a,"image_processor_class",r.AutoImageProcessor),fe(a,"tokenizer_class",s.AutoTokenizer)},"./src/models/rt_detr/image_processing_rt_detr.js":(e,t,n)=>{n.r(t),n.d(t,{RTDetrImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_object_detection(...a){return(0,i.post_process_object_detection)(...a)}}},"./src/models/sam/image_processing_sam.js":(e,t,n)=>{n.r(t),n.d(t,{SamImageProcessor:()=>a});var i=n("./src/base/image_processors_utils.js"),r=n("./src/utils/core.js"),s=n("./src/utils/tensor.js");class a extends i.ImageProcessor{reshape_input_points(l,u,c,f=!1){l=structuredClone(l);let d=(0,r.calculateDimensions)(l);if(d.length===3)f||(d=[1,...d]),l=[l];else if(d.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let h=0;h<l.length;++h){const[m,y]=u[h],[M,g]=c[h],_=[g/y,M/m];for(let T=0;T<l[h].length;++T)for(let x=0;x<l[h][T].length;++x)for(let S=0;S<l[h][T][x].length;++S)l[h][T][x][S]*=_[S%2]}return new s.Tensor("float32",Float32Array.from(l.flat(1/0)),d)}add_input_labels(l,u){let c=(0,r.calculateDimensions)(l);if(c.length===2)c=[1,...c],l=[l];else if(c.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(c.some((f,d)=>f!==u.dims[d]))throw Error(`The first ${c.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new s.Tensor("int64",l.flat(1/0).map(BigInt),c)}async _call(l,{input_points:u=null,input_labels:c=null,input_boxes:f=null}={}){const d=await super._call(l);if(u&&(d.input_points=this.reshape_input_points(u,d.original_sizes,d.reshaped_input_sizes)),c){if(!d.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");d.input_labels=this.add_input_labels(c,d.input_points)}return f&&(d.input_boxes=this.reshape_input_points(f,d.original_sizes,d.reshaped_input_sizes,!0)),d}async post_process_masks(l,u,c,{mask_threshold:f=0,binarize:d=!0,pad_size:h=null}={}){const m=[];h=h??this.pad_size??this.size;const y=[h.height,h.width];for(let M=0;M<u.length;++M){const g=u[M],_=c[M];let T=await(0,s.interpolate_4d)(l[M],{mode:"bilinear",size:y});if(T=T.slice(null,null,[0,_[0]],[0,_[1]]),T=await(0,s.interpolate_4d)(T,{mode:"bilinear",size:g}),d){const x=T.data,S=new Uint8Array(x.length);for(let $=0;$<x.length;++$)x[$]>f&&(S[$]=1);T=new s.Tensor("bool",S,T.dims)}m.push(T)}return m}generate_crop_boxes(l,u,{crop_n_layers:c=0,overlap_ratio:f=512/1500,points_per_crop:d=32,crop_n_points_downscale_factor:h=1}={}){}}},"./src/models/sam/processing_sam.js":(e,t,n)=>{n.r(t),n.d(t,{SamProcessor:()=>s});var i=n("./src/base/processing_utils.js"),r=n("./src/models/auto/image_processing_auto.js");class s extends i.Processor{async _call(...o){return await this.image_processor(...o)}post_process_masks(...o){return this.image_processor.post_process_masks(...o)}reshape_input_points(...o){return this.image_processor.reshape_input_points(...o)}}fe(s,"image_processor_class",r.AutoImageProcessor)},"./src/models/sam2/image_processing_sam2.js":(e,t,n)=>{n.r(t),n.d(t,{Sam2ImageProcessor:()=>i.SamImageProcessor});var i=n("./src/models/sam/image_processing_sam.js")},"./src/models/sam2/processing_sam2.js":(e,t,n)=>{n.r(t),n.d(t,{Sam2Processor:()=>r,Sam2VideoProcessor:()=>s});var i=n("./src/models/sam/processing_sam.js");class r extends i.SamProcessor{}class s extends r{}},"./src/models/sam3/image_processing_sam3.js":(e,t,n)=>{n.r(t),n.d(t,{Sam3ImageProcessor:()=>i.Sam2ImageProcessor});var i=n("./src/models/sam2/image_processing_sam2.js")},"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":(e,t,n)=>{n.r(t),n.d(t,{SeamlessM4TFeatureExtractor:()=>a});var i=n("./src/base/feature_extraction_utils.js"),r=n("./src/utils/tensor.js"),s=n("./src/utils/audio.js");class a extends i.FeatureExtractor{constructor(l){super(l);const u=this.config.sampling_rate,c=(0,s.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(u/2),u,null,"kaldi",!0);this.mel_filters=c,this.window=(0,s.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(l,u){return l=l.map(c=>c*32768),(0,s.spectrogram)(l,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:u,transpose:!0})}async _call(l,{padding:u=!0,pad_to_multiple_of:c=2,do_normalize_per_mel_bins:f=!0,return_attention_mask:d=!0}={}){(0,i.validate_audio_inputs)(l,"SeamlessM4TFeatureExtractor");let h=await this._extract_fbank_features(l,this.config.max_length);if(f){const[S,$]=h.dims,C=h.data;for(let P=0;P<$;++P){let O=0;for(let V=0;V<S;++V)O+=C[V*$+P];const R=O/S;let G=0;for(let V=0;V<S;++V)G+=(C[V*$+P]-R)**2;G/=S-1;const W=Math.sqrt(G+1e-7);for(let V=0;V<S;++V){const te=V*$+P;C[te]=(C[te]-R)/W}}}let m;if(u){const[S,$]=h.dims,C=h.data,P=S%c;if(P>0){const O=new Float32Array($*(S+P));O.set(C),O.fill(this.config.padding_value,C.length);const R=S+P;h=new r.Tensor(h.type,O,[R,$]),d&&(m=new r.Tensor("int64",new BigInt64Array(R),[1,R]),m.data.fill(1n,0,S))}}const[y,M]=h.dims,g=this.config.stride;if(y%g!==0)throw new Error(`The number of frames (${y}) must be a multiple of the stride (${g}).`);const T=h.view(1,Math.floor(y/g),M*g),x={input_features:T};if(d){const S=T.dims[1],$=new BigInt64Array(S);if(m){const C=m.data;for(let P=1,O=0;P<y;P+=g,++O)$[O]=C[P]}else $.fill(1n);x.attention_mask=new r.Tensor("int64",$,[1,S])}return x}}},"./src/models/segformer/image_processing_segformer.js":(e,t,n)=>{n.r(t),n.d(t,{SegformerFeatureExtractor:()=>s,SegformerImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_semantic_segmentation(...o){return(0,i.post_process_semantic_segmentation)(...o)}}class s extends r{}},"./src/models/siglip/image_processing_siglip.js":(e,t,n)=>{n.r(t),n.d(t,{SiglipImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/smolvlm/image_processing_smolvlm.js":(e,t,n)=>{n.r(t),n.d(t,{SmolVLMImageProcessor:()=>i.Idefics3ImageProcessor});var i=n("./src/models/idefics3/image_processing_idefics3.js")},"./src/models/smolvlm/processing_smolvlm.js":(e,t,n)=>{n.r(t),n.d(t,{SmolVLMProcessor:()=>i.Idefics3Processor});var i=n("./src/models/idefics3/processing_idefics3.js")},"./src/models/snac/feature_extraction_snac.js":(e,t,n)=>{n.r(t),n.d(t,{SnacFeatureExtractor:()=>r});var i=n("./src/models/dac/feature_extraction_dac.js");class r extends i.DacFeatureExtractor{}},"./src/models/speecht5/feature_extraction_speecht5.js":(e,t,n)=>{n.r(t),n.d(t,{SpeechT5FeatureExtractor:()=>r});var i=n("./src/base/feature_extraction_utils.js");class r extends i.FeatureExtractor{}},"./src/models/speecht5/processing_speecht5.js":(e,t,n)=>{n.r(t),n.d(t,{SpeechT5Processor:()=>a});var i=n("./src/base/processing_utils.js"),r=n("./src/tokenizers.js"),s=n("./src/models/auto/feature_extraction_auto.js");class a extends i.Processor{async _call(l){return await this.feature_extractor(l)}}fe(a,"tokenizer_class",r.AutoTokenizer),fe(a,"feature_extractor_class",s.AutoFeatureExtractor)},"./src/models/swin2sr/image_processing_swin2sr.js":(e,t,n)=>{n.r(t),n.d(t,{Swin2SRImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{pad_image(a,o,l,u={}){const[c,f,d]=o;return super.pad_image(a,o,{width:f+(l-f%l)%l,height:c+(l-c%l)%l},{mode:"symmetric",center:!1,constant_values:-1,...u})}}},"./src/models/ultravox/processing_ultravox.js":(e,t,n)=>{n.r(t),n.d(t,{UltravoxProcessor:()=>a});var i=n("./src/models/auto/feature_extraction_auto.js"),r=n("./src/tokenizers.js"),s=n("./src/base/processing_utils.js");class a extends s.Processor{async _call(l,u=null,c={}){if(Array.isArray(l))throw new Error("Batched inputs are not supported yet.");let f={};if(u){const h=u.length,{input_features:m}=await this.feature_extractor(u,{...c,max_length:h}),y=Math.round(h/this.config.encoder_ds_factor+1e-4),M=1+Math.ceil(y/this.config.stack_factor);f.audio_token_len=[M],f.audio_values=m;const g=this.config.audio_placeholder;if(!l.includes(g))throw new Error(`The input text does not contain the image token ${g}.`);l=l.replaceAll(g,g.repeat(M))}return{...this.tokenizer(l,{add_special_tokens:!1,...c}),...f}}}fe(a,"tokenizer_class",r.AutoTokenizer),fe(a,"feature_extractor_class",i.AutoFeatureExtractor),fe(a,"uses_processor_config",!0)},"./src/models/vit/image_processing_vit.js":(e,t,n)=>{n.r(t),n.d(t,{ViTFeatureExtractor:()=>s,ViTImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class s extends r{}},"./src/models/vitmatte/image_processing_vitmatte.js":(e,t,n)=>{n.r(t),n.d(t,{VitMatteImageProcessor:()=>s});var i=n("./src/base/image_processors_utils.js"),r=n("./src/utils/tensor.js");class s extends i.ImageProcessor{async _call(o,l){Array.isArray(o)||(o=[o]),Array.isArray(l)||(l=[l]);const u=await Promise.all(o.map(d=>this.preprocess(d))),c=await Promise.all(l.map(d=>this.preprocess(d,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,r.stack)(u.map((d,h)=>(0,r.cat)([d.pixel_values,c[h].pixel_values],0)),0),original_sizes:u.map(d=>d.original_size),reshaped_input_sizes:u.map(d=>d.reshaped_input_size)}}}},"./src/models/vitpose/image_processing_vitpose.js":(e,t,n)=>{n.r(t),n.d(t,{VitPoseImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_pose_estimation(a,o,{threshold:l=null}={}){const u=a.tolist(),[c,f,d,h]=a.dims,m=[];for(let y=0;y<c;++y){const M=u[y],g=o[y],_=[];for(let T=0;T<g.length;++T){const x=g[T],S=[],$=[],C=[],P=x.at(-2)/h,O=x.at(-1)/d;for(let R=0;R<M.length;++R){let[G,W]=[0,0],V=0,te=-1/0;const J=M[R];for(let Y=0;Y<J.length;++Y){const X=J[Y];for(let ce=0;ce<X.length;++ce){const me=X[ce];V+=me,te=Math.max(te,me),G+=(ce+.5)*me,W+=Y*me}}if(l!=null&&te<l)continue;const j=[P*G/V,O*W/V];S.push(j),C.push(R),$.push(te)}_.push({bbox:x,scores:$,labels:C,keypoints:S})}m.push(_)}return m}}},"./src/models/voxtral/processing_voxtral.js":(e,t,n)=>{n.r(t),n.d(t,{VoxtralProcessor:()=>f});var i=n("./src/models/auto/feature_extraction_auto.js"),r=n("./src/tokenizers.js"),s=n("./src/base/processing_utils.js"),a=n("./src/utils/tensor.js");const o="[AUDIO]",l="[BEGIN_AUDIO]",u=375;function c(d,h){const m=[];for(let y=0;y<d.length;y+=h)m.push(d.subarray(y,Math.min(y+h,d.length)));return m}class f extends s.Processor{async _call(h,m=null,y={}){if(Array.isArray(h))throw new Error("Batched inputs are not supported yet.");const M={};if(m){if(!h.includes(o))throw new Error(`The input text does not contain the audio token ${o}.`);Array.isArray(m)||(m=[m]);const _=h.split(o),T=_.length-1;if(T!==m.length)throw new Error(`The number of audio inputs (${m.length}) does not match the number of audio tokens in the text (${T}).`);const x=this.feature_extractor.config.n_samples,S=m.map(R=>c(R,x)),$=S.map(R=>R.length),C=S.flat(),P=(await Promise.all(C.map(R=>this.feature_extractor(R,y)))).map(R=>R.input_features);M.audio_values=P.length>1?(0,a.cat)(P,0):P[0];let O=_[0];for(let R=0;R<$.length;++R){O+=l;for(let G=0;G<$[R];++G)O+=o.repeat(u);O+=_[R+1]}h=O}return{...this.tokenizer(h,{add_special_tokens:!1,...y}),...M}}}fe(f,"tokenizer_class",r.AutoTokenizer),fe(f,"feature_extractor_class",i.AutoFeatureExtractor),fe(f,"uses_processor_config",!1)},"./src/models/wav2vec2/feature_extraction_wav2vec2.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2FeatureExtractor:()=>s});var i=n("./src/base/feature_extraction_utils.js"),r=n("./src/utils/tensor.js");class s extends i.FeatureExtractor{_zero_mean_unit_var_norm(o){const u=o.reduce((f,d)=>f+d,0)/o.length,c=o.reduce((f,d)=>f+(d-u)**2,0)/o.length;return o.map(f=>(f-u)/Math.sqrt(c+1e-7))}async _call(o){(0,i.validate_audio_inputs)(o,"Wav2Vec2FeatureExtractor"),o instanceof Float64Array&&(o=new Float32Array(o));let l=o;this.config.do_normalize&&(l=this._zero_mean_unit_var_norm(l));const u=[1,l.length];return{input_values:new r.Tensor("float32",l,u),attention_mask:new r.Tensor("int64",new BigInt64Array(l.length).fill(1n),u)}}}},"./src/models/wav2vec2/processing_wav2vec2.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2Processor:()=>a});var i=n("./src/tokenizers.js"),r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/base/processing_utils.js");class a extends s.Processor{async _call(l){return await this.feature_extractor(l)}}fe(a,"tokenizer_class",i.AutoTokenizer),fe(a,"feature_extractor_class",r.AutoFeatureExtractor)},"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2ProcessorWithLM:()=>a});var i=n("./src/tokenizers.js"),r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/base/processing_utils.js");class a extends s.Processor{async _call(l){return await this.feature_extractor(l)}}fe(a,"tokenizer_class",i.AutoTokenizer),fe(a,"feature_extractor_class",r.AutoFeatureExtractor)},"./src/models/wespeaker/feature_extraction_wespeaker.js":(e,t,n)=>{n.r(t),n.d(t,{WeSpeakerFeatureExtractor:()=>s});var i=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var r=n("./src/utils/audio.js");class s extends i.FeatureExtractor{constructor(o){super(o);const l=this.config.sampling_rate,u=(0,r.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(l/2),l,null,"kaldi",!0);this.mel_filters=u,this.window=(0,r.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(o){return o=o.map(l=>l*32768),(0,r.spectrogram)(o,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(o){(0,i.validate_audio_inputs)(o,"WeSpeakerFeatureExtractor");const l=(await this._extract_fbank_features(o)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const u=l.mean(1).data,c=l.data,[f,d,h]=l.dims;for(let m=0;m<f;++m){const y=m*d*h,M=m*h;for(let g=0;g<d;++g){const _=y+g*h;for(let T=0;T<h;++T)c[_+T]-=u[M+T]}}}return{input_features:l}}}},"./src/models/whisper/common_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WHISPER_LANGUAGE_MAPPING:()=>r,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>s,whisper_language_to_code:()=>a});const i=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],r=new Map(i),s=new Map([...i.map(([o,l])=>[l,o]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function a(o){o=o.toLowerCase();let l=s.get(o);if(l===void 0){const u=o.match(/^<\|([a-z]{2})\|>$/);if(u&&(o=u[1]),r.has(o))l=o;else{const f=o.length===2?r.keys():r.values();throw new Error(`Language "${o}" is not supported. Must be one of: ${JSON.stringify(Array.from(f))}`)}}return l}},"./src/models/whisper/feature_extraction_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperFeatureExtractor:()=>a});var i=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var r=n("./src/utils/audio.js"),s=n("./src/utils/maths.js");class a extends i.FeatureExtractor{constructor(l){var u;super(l),(u=this.config).mel_filters??(u.mel_filters=(0,r.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney")),this.window=(0,r.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(l){const u=await(0,r.spectrogram)(l,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:Math.min(Math.floor(l.length/this.config.hop_length),this.config.nb_max_frames)}),c=u.data,f=(0,s.max)(c)[0];for(let d=0;d<c.length;++d)c[d]=(Math.max(c[d],f-8)+4)/4;return u}async _call(l,{max_length:u=null}={}){(0,i.validate_audio_inputs)(l,"WhisperFeatureExtractor");let c;const f=u??this.config.n_samples;return l.length>f?(l.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),c=l.slice(0,f)):(c=new Float32Array(f),c.set(l)),{input_features:(await this._extract_fbank_features(c)).unsqueeze_(0)}}}},"./src/models/whisper/generation_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperGenerationConfig:()=>r});var i=n("./src/generation/configuration_utils.js");class r extends i.GenerationConfig{constructor(){super(...arguments);fe(this,"return_timestamps",null);fe(this,"return_token_timestamps",null);fe(this,"num_frames",null);fe(this,"alignment_heads",null);fe(this,"task",null);fe(this,"language",null);fe(this,"no_timestamps_token_id",null);fe(this,"prompt_ids",null);fe(this,"is_multilingual",null);fe(this,"lang_to_id",null);fe(this,"task_to_id",null);fe(this,"max_initial_timestamp_index",1)}}},"./src/models/whisper/processing_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperProcessor:()=>a});var i=n("./src/models/auto/feature_extraction_auto.js"),r=n("./src/tokenizers.js"),s=n("./src/base/processing_utils.js");class a extends s.Processor{async _call(l){return await this.feature_extractor(l)}}fe(a,"tokenizer_class",r.AutoTokenizer),fe(a,"feature_extractor_class",i.AutoFeatureExtractor)},"./src/models/yolos/image_processing_yolos.js":(e,t,n)=>{n.r(t),n.d(t,{YolosFeatureExtractor:()=>s,YolosImageProcessor:()=>r});var i=n("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_object_detection(...o){return(0,i.post_process_object_detection)(...o)}}class s extends r{}},"./src/ops/registry.js":(e,t,n)=>{n.r(t),n.d(t,{TensorOpRegistry:()=>a});var i=n("./src/backends/onnx.js"),r=n("./src/utils/tensor.js");const s=async(o,l,u)=>{const c=await(0,i.createInferenceSession)(new Uint8Array(o),l);return async f=>{const d=(0,i.isONNXProxy)(),h=Object.fromEntries(Object.entries(f).map(([y,M])=>[y,(d?M.clone():M).ort_tensor])),m=await(0,i.runInferenceSession)(c,h);return Array.isArray(u)?u.map(y=>new r.Tensor(m[y])):new r.Tensor(m[u])}};class a{static get nearest_interpolate_4d(){return this._nearest_interpolate_4d||(this._nearest_interpolate_4d=s([8,10,18,0,58,129,1,10,41,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,18,10,4,109,111,100,101,34,7,110,101,97,114,101,115,116,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,21],this.session_options,"y")),this._nearest_interpolate_4d}static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=s([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=s([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=s([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=s([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=s([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=s([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=s([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}fe(a,"session_options",{})},"./src/pipelines.js":(e,t,n)=>{n.r(t),n.d(t,{AudioClassificationPipeline:()=>W,AutomaticSpeechRecognitionPipeline:()=>te,BackgroundRemovalPipeline:()=>X,DepthEstimationPipeline:()=>_e,DocumentQuestionAnsweringPipeline:()=>H,FeatureExtractionPipeline:()=>R,FillMaskPipeline:()=>T,ImageClassificationPipeline:()=>j,ImageFeatureExtractionPipeline:()=>G,ImageSegmentationPipeline:()=>Y,ImageToImagePipeline:()=>ee,ImageToTextPipeline:()=>J,ObjectDetectionPipeline:()=>me,Pipeline:()=>y,QuestionAnsweringPipeline:()=>_,SummarizationPipeline:()=>S,Text2TextGenerationPipeline:()=>x,TextClassificationPipeline:()=>M,TextGenerationPipeline:()=>P,TextToAudioPipeline:()=>B,TokenClassificationPipeline:()=>g,TranslationPipeline:()=>$,ZeroShotAudioClassificationPipeline:()=>V,ZeroShotClassificationPipeline:()=>O,ZeroShotImageClassificationPipeline:()=>ce,ZeroShotObjectDetectionPipeline:()=>Q,pipeline:()=>Ne});var i=n("./src/tokenizers.js"),r=n("./src/models.js"),s=n("./src/models/auto/processing_auto.js");n("./src/base/processing_utils.js");var a=n("./src/utils/generic.js"),o=n("./src/utils/core.js"),l=n("./src/utils/maths.js"),u=n("./src/utils/audio.js"),c=n("./src/utils/tensor.js"),f=n("./src/utils/image.js");async function d(ze){return Array.isArray(ze)||(ze=[ze]),await Promise.all(ze.map(ue=>f.RawImage.read(ue)))}async function h(ze,ue){return Array.isArray(ze)||(ze=[ze]),await Promise.all(ze.map(U=>typeof U=="string"||U instanceof URL?(0,u.read_audio)(U,ue):U instanceof Float64Array?new Float32Array(U):U))}function m(ze,ue){ue&&(ze=ze.map(Le=>Le|0));const[U,we,Pe,ke]=ze;return{xmin:U,ymin:we,xmax:Pe,ymax:ke}}class y extends a.Callable{constructor({task:ue,model:U,tokenizer:we=null,processor:Pe=null}){super(),this.task=ue,this.model=U,this.tokenizer=we,this.processor=Pe}async dispose(){await this.model.dispose()}}class M extends y{constructor(ue){super(ue)}async _call(ue,{top_k:U=1}={}){const we=this.tokenizer(ue,{padding:!0,truncation:!0}),Pe=await this.model(we),ke=this.model.config.problem_type==="multi_label_classification"?$e=>$e.sigmoid():$e=>new c.Tensor("float32",(0,l.softmax)($e.data),$e.dims),Le=this.model.config.id2label,Ge=[];for(const $e of Pe.logits){const et=ke($e),Ce=await(0,c.topk)(et,U),He=Ce[0].tolist(),Z=Ce[1].tolist().map((he,ye)=>({label:Le?Le[he]:`LABEL_${he}`,score:He[ye]}));U===1?Ge.push(...Z):Ge.push(Z)}return Array.isArray(ue)||U===1?Ge:Ge[0]}}class g extends y{constructor(ue){super(ue)}async _call(ue,{ignore_labels:U=["O"]}={}){const we=Array.isArray(ue),Pe=this.tokenizer(we?ue:[ue],{padding:!0,truncation:!0}),Le=(await this.model(Pe)).logits,Ge=this.model.config.id2label,$e=[];for(let et=0;et<Le.dims[0];++et){const Ce=Pe.input_ids[et],He=Le[et],at=[];for(let Z=0;Z<He.dims[0];++Z){const he=He[Z],ye=(0,l.max)(he.data)[1],Ke=Ge?Ge[ye]:`LABEL_${ye}`;if(U.includes(Ke))continue;const Be=this.tokenizer.decode([Ce[Z].item()],{skip_special_tokens:!0});if(Be==="")continue;const Se=(0,l.softmax)(he.data);at.push({entity:Ke,score:Se[ye],index:Z,word:Be})}$e.push(at)}return we?$e:$e[0]}}class _ extends y{constructor(ue){super(ue)}async _call(ue,U,{top_k:we=1}={}){const Pe=this.tokenizer(ue,{text_pair:U,padding:!0,truncation:!0}),{start_logits:ke,end_logits:Le}=await this.model(Pe),Ge=Pe.input_ids.tolist(),$e=Pe.attention_mask.tolist(),et=this.tokenizer.all_special_ids,Ce=[];for(let He=0;He<ke.dims[0];++He){const at=Ge[He],Z=at.findIndex(Oe=>Oe==this.tokenizer.sep_token_id);$e[He].map((Oe,ct)=>Oe==1&&(ct===0||ct>Z&&et.findIndex(bt=>bt==at[ct])===-1));const he=ke[He].tolist(),ye=Le[He].tolist();for(let Oe=1;Oe<he.length;++Oe)($e[He]==0||Oe<=Z||et.findIndex(ct=>ct==at[Oe])!==-1)&&(he[Oe]=-1/0,ye[Oe]=-1/0);const Ke=(0,l.softmax)(he).map((Oe,ct)=>[Oe,ct]),Be=(0,l.softmax)(ye).map((Oe,ct)=>[Oe,ct]);Ke[0][0]=0,Be[0][0]=0;const Se=(0,o.product)(Ke,Be).filter(Oe=>Oe[0][1]<=Oe[1][1]).map(Oe=>[Oe[0][1],Oe[1][1],Oe[0][0]*Oe[1][0]]).sort((Oe,ct)=>ct[2]-Oe[2]);for(let Oe=0;Oe<Math.min(Se.length,we);++Oe){const[ct,bt,Ct]=Se[Oe],Et=at.slice(ct,bt+1),hn=this.tokenizer.decode(Et,{skip_special_tokens:!0});Ce.push({answer:hn,score:Ct})}}return we===1?Ce[0]:Ce}}class T extends y{constructor(ue){super(ue)}async _call(ue,{top_k:U=5}={}){const we=this.tokenizer(ue,{padding:!0,truncation:!0}),{logits:Pe}=await this.model(we),ke=[],Le=we.input_ids.tolist();for(let Ge=0;Ge<Le.length;++Ge){const $e=Le[Ge],et=$e.findIndex(he=>he==this.tokenizer.mask_token_id);if(et===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const Ce=Pe[Ge][et],He=await(0,c.topk)(new c.Tensor("float32",(0,l.softmax)(Ce.data),Ce.dims),U),at=He[0].tolist(),Z=He[1].tolist();ke.push(Z.map((he,ye)=>{const Ke=$e.slice();return Ke[et]=he,{score:at[ye],token:Number(he),token_str:this.tokenizer.decode([he]),sequence:this.tokenizer.decode(Ke,{skip_special_tokens:!0})}}))}return Array.isArray(ue)?ke:ke[0]}}class x extends y{constructor(U){super(U);fe(this,"_key","generated_text")}async _call(U,we={}){Array.isArray(U)||(U=[U]),this.model.config.prefix&&(U=U.map(et=>this.model.config.prefix+et));const Pe=this.model.config.task_specific_params;Pe&&Pe[this.task]&&Pe[this.task].prefix&&(U=U.map(et=>Pe[this.task].prefix+et));const ke=this.tokenizer,Le={padding:!0,truncation:!0};let Ge;this instanceof $&&"_build_translation_inputs"in ke?Ge=ke._build_translation_inputs(U,Le,we):Ge=ke(U,Le);const $e=await this.model.generate({...Ge,...we});return ke.batch_decode($e,{skip_special_tokens:!0}).map(et=>({[this._key]:et}))}}class S extends x{constructor(U){super(U);fe(this,"_key","summary_text")}}class $ extends x{constructor(U){super(U);fe(this,"_key","translation_text")}}function C(ze){return Array.isArray(ze)&&ze.every(ue=>"role"in ue&&"content"in ue)}class P extends y{constructor(ue){super(ue)}async _call(ue,U={}){let we=!1,Pe=!1,ke=U.add_special_tokens??(this.tokenizer.add_bos_token||this.tokenizer.add_eos_token)??!1,Le;if(typeof ue=="string")Le=ue=[ue];else if(Array.isArray(ue)&&ue.every(Z=>typeof Z=="string"))we=!0,Le=ue;else{if(C(ue))ue=[ue];else if(Array.isArray(ue)&&ue.every(C))we=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");Pe=!0,Le=ue.map(Z=>this.tokenizer.apply_chat_template(Z,{tokenize:!1,add_generation_prompt:!0})),ke=!1}const Ge=Pe?!1:U.return_full_text??!0;this.tokenizer.padding_side="left";const $e=this.tokenizer(Le,{add_special_tokens:ke,padding:!0,truncation:!0}),et=await this.model.generate({...$e,...U}),Ce=this.tokenizer.batch_decode(et,{skip_special_tokens:!0});let He;!Ge&&$e.input_ids.dims.at(-1)>0&&(He=this.tokenizer.batch_decode($e.input_ids,{skip_special_tokens:!0}).map(Z=>Z.length));const at=Array.from({length:ue.length},Z=>[]);for(let Z=0;Z<Ce.length;++Z){const he=Math.floor(Z/et.dims[0]*ue.length);He&&(Ce[Z]=Ce[Z].slice(He[he])),at[he].push({generated_text:Pe?[...ue[he],{role:"assistant",content:Ce[Z]}]:Ce[Z]})}return!we&&at.length===1?at[0]:at}}class O extends y{constructor(ue){super(ue),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([U,we])=>[U.toLowerCase(),we])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(ue,U,{hypothesis_template:we="This example is {}.",multi_label:Pe=!1}={}){const ke=Array.isArray(ue);ke||(ue=[ue]),Array.isArray(U)||(U=[U]);const Le=U.map(et=>we.replace("{}",et)),Ge=Pe||U.length===1,$e=[];for(const et of ue){const Ce=[];for(const Z of Le){const he=this.tokenizer(et,{text_pair:Z,padding:!0,truncation:!0}),ye=await this.model(he);Ge?Ce.push([ye.logits.data[this.contradiction_id],ye.logits.data[this.entailment_id]]):Ce.push(ye.logits.data[this.entailment_id])}const at=(Ge?Ce.map(Z=>(0,l.softmax)(Z)[1]):(0,l.softmax)(Ce)).map((Z,he)=>[Z,he]).sort((Z,he)=>he[0]-Z[0]);$e.push({sequence:et,labels:at.map(Z=>U[Z[1]]),scores:at.map(Z=>Z[0])})}return ke?$e:$e[0]}}class R extends y{constructor(ue){super(ue)}async _call(ue,{pooling:U="none",normalize:we=!1,quantize:Pe=!1,precision:ke="binary"}={}){const Le=this.tokenizer(ue,{padding:!0,truncation:!0}),Ge=await this.model(Le);let $e=Ge.last_hidden_state??Ge.logits??Ge.token_embeddings;switch(U){case"none":break;case"mean":$e=(0,c.mean_pooling)($e,Le.attention_mask);break;case"first_token":case"cls":$e=$e.slice(null,0);break;case"last_token":case"eos":$e=$e.slice(null,-1);break;default:throw Error(`Pooling method '${U}' not supported.`)}return we&&($e=$e.normalize(2,-1)),Pe&&($e=(0,c.quantize_embeddings)($e,ke)),$e}}class G extends y{constructor(ue){super(ue)}async _call(ue,{pool:U=null}={}){const we=await d(ue),{pixel_values:Pe}=await this.processor(we),ke=await this.model({pixel_values:Pe});let Le;if(U){if(!("pooler_output"in ke))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");Le=ke.pooler_output}else Le=ke.last_hidden_state??ke.logits??ke.image_embeds;return Le}}class W extends y{constructor(ue){super(ue)}async _call(ue,{top_k:U=5}={}){const we=this.processor.feature_extractor.config.sampling_rate,Pe=await h(ue,we),ke=this.model.config.id2label,Le=[];for(const Ge of Pe){const $e=await this.processor(Ge),Ce=(await this.model($e)).logits[0],He=await(0,c.topk)(new c.Tensor("float32",(0,l.softmax)(Ce.data),Ce.dims),U),at=He[0].tolist(),he=He[1].tolist().map((ye,Ke)=>({label:ke?ke[ye]:`LABEL_${ye}`,score:at[Ke]}));Le.push(he)}return Array.isArray(ue)?Le:Le[0]}}class V extends y{constructor(ue){super(ue)}async _call(ue,U,{hypothesis_template:we="This is a sound of {}."}={}){const Pe=!Array.isArray(ue);Pe&&(ue=[ue]);const ke=U.map(Ce=>we.replace("{}",Ce)),Le=this.tokenizer(ke,{padding:!0,truncation:!0}),Ge=this.processor.feature_extractor.config.sampling_rate,$e=await h(ue,Ge),et=[];for(const Ce of $e){const He=await this.processor(Ce),at=await this.model({...Le,...He}),Z=(0,l.softmax)(at.logits_per_audio.data);et.push([...Z].map((he,ye)=>({score:he,label:U[ye]})))}return Pe?et[0]:et}}class te extends y{constructor(ue){super(ue)}async _call(ue,U={}){switch(this.model.config.model_type){case"whisper":case"lite-whisper":return this._call_whisper(ue,U);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":case"parakeet_ctc":return this._call_wav2vec2(ue,U);case"moonshine":return this._call_moonshine(ue,U);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(ue,U){U.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),U.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const we=!Array.isArray(ue);we&&(ue=[ue]);const Pe=this.processor.feature_extractor.config.sampling_rate,ke=await h(ue,Pe),Le=[];for(const Ge of ke){const $e=await this.processor(Ge),Ce=(await this.model($e)).logits[0],He=[];for(const Z of Ce)He.push((0,l.max)(Z.data)[1]);const at=this.tokenizer.decode(He,{skip_special_tokens:!0}).trim();Le.push({text:at})}return we?Le[0]:Le}async _call_whisper(ue,U){const we=U.return_timestamps??!1,Pe=U.chunk_length_s??0,ke=U.force_full_sequences??!1;let Le=U.stride_length_s??null;const Ge={...U};we==="word"&&(Ge.return_token_timestamps=!0,Ge.return_timestamps=!1);const $e=!Array.isArray(ue);$e&&(ue=[ue]);const et=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,Ce=this.processor.feature_extractor.config.hop_length,He=this.processor.feature_extractor.config.sampling_rate,at=await h(ue,He),Z=[];for(const he of at){let ye=[];if(Pe>0){if(Le===null)Le=Pe/6;else if(Pe<=Le)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const Se=He*Pe,Oe=He*Le,ct=Se-2*Oe;let bt=0;for(;;){const Ct=bt+Se,Et=he.subarray(bt,Ct),hn=await this.processor(Et),En=bt===0,Kt=Ct>=he.length;if(ye.push({stride:[Et.length,En?0:Oe,Kt?0:Oe],input_features:hn.input_features,is_last:Kt}),Kt)break;bt+=ct}}else ye=[{stride:[he.length,0,0],input_features:(await this.processor(he)).input_features,is_last:!0}];for(const Se of ye){Ge.num_frames=Math.floor(Se.stride[0]/Ce);const Oe=await this.model.generate({inputs:Se.input_features,...Ge});we==="word"?(Se.tokens=Oe.sequences.tolist()[0],Se.token_timestamps=Oe.token_timestamps.tolist()[0].map(ct=>(0,l.round)(ct,2))):Se.tokens=Oe[0].tolist(),Se.stride=Se.stride.map(ct=>ct/He)}const[Ke,Be]=this.tokenizer._decode_asr(ye,{time_precision:et,return_timestamps:we,force_full_sequences:ke});Z.push({text:Ke,...Be})}return $e?Z[0]:Z}async _call_moonshine(ue,U){const we=!Array.isArray(ue);we&&(ue=[ue]);const Pe=this.processor.feature_extractor.config.sampling_rate,ke=await h(ue,Pe),Le=[];for(const Ge of ke){const $e=await this.processor(Ge),et=Math.floor(Ge.length/Pe)*6,Ce=await this.model.generate({max_new_tokens:et,...U,...$e}),He=this.processor.batch_decode(Ce,{skip_special_tokens:!0})[0];Le.push({text:He})}return we?Le[0]:Le}}class J extends y{constructor(ue){super(ue)}async _call(ue,U={}){const we=Array.isArray(ue),Pe=await d(ue),{pixel_values:ke}=await this.processor(Pe),Le=[];for(const Ge of ke){Ge.dims=[1,...Ge.dims];const $e=await this.model.generate({inputs:Ge,...U}),et=this.tokenizer.batch_decode($e,{skip_special_tokens:!0}).map(Ce=>({generated_text:Ce.trim()}));Le.push(et)}return we?Le:Le[0]}}class j extends y{constructor(ue){super(ue)}async _call(ue,{top_k:U=5}={}){const we=await d(ue),{pixel_values:Pe}=await this.processor(we),ke=await this.model({pixel_values:Pe}),Le=this.model.config.id2label,Ge=[];for(const $e of ke.logits){const et=await(0,c.topk)(new c.Tensor("float32",(0,l.softmax)($e.data),$e.dims),U),Ce=et[0].tolist(),at=et[1].tolist().map((Z,he)=>({label:Le?Le[Z]:`LABEL_${Z}`,score:Ce[he]}));Ge.push(at)}return Array.isArray(ue)?Ge:Ge[0]}}class Y extends y{constructor(ue){super(ue),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(ue,{threshold:U=.5,mask_threshold:we=.5,overlap_mask_area_threshold:Pe=.8,label_ids_to_fuse:ke=null,target_sizes:Le=null,subtask:Ge=null}={}){if(Array.isArray(ue)&&ue.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const et=await d(ue),Ce=et.map(Se=>[Se.height,Se.width]),He=await this.processor(et),{inputNames:at,outputNames:Z}=this.model.sessions.model;if(!at.includes("pixel_values")){if(at.length!==1)throw Error(`Expected a single input name, but got ${at.length} inputs: ${at}.`);const Se=at[0];if(Se in He)throw Error(`Input name ${Se} already exists in the inputs.`);He[Se]=He.pixel_values}const he=await this.model(He);let ye=null;if(Ge!==null)ye=this.subtasks_mapping[Ge];else if(this.processor.image_processor){for(const[Se,Oe]of Object.entries(this.subtasks_mapping))if(Oe in this.processor.image_processor){ye=this.processor.image_processor[Oe].bind(this.processor.image_processor),Ge=Se;break}}const Ke=this.model.config.id2label,Be=[];if(Ge)if(Ge==="panoptic"||Ge==="instance"){const Se=ye(he,U,we,Pe,ke,Le??Ce)[0],Oe=Se.segmentation;for(const ct of Se.segments_info){const bt=new Uint8ClampedArray(Oe.data.length);for(let Et=0;Et<Oe.data.length;++Et)Oe.data[Et]===ct.id&&(bt[Et]=255);const Ct=new f.RawImage(bt,Oe.dims[1],Oe.dims[0],1);Be.push({score:ct.score,label:Ke[ct.label_id],mask:Ct})}}else if(Ge==="semantic"){const{segmentation:Se,labels:Oe}=ye(he,Le??Ce)[0];for(const ct of Oe){const bt=new Uint8ClampedArray(Se.data.length);for(let Et=0;Et<Se.data.length;++Et)Se.data[Et]===ct&&(bt[Et]=255);const Ct=new f.RawImage(bt,Se.dims[1],Se.dims[0],1);Be.push({score:null,label:Ke[ct],mask:Ct})}}else throw Error(`Subtask ${Ge} not supported.`);else{const Oe=he[Z[0]];for(let ct=0;ct<Ce.length;++ct){const bt=Ce[ct],Ct=Oe[ct];Ct.data.some(hn=>hn<-1e-5||hn>1+1e-5)&&Ct.sigmoid_();const Et=await f.RawImage.fromTensor(Ct.mul_(255).to("uint8")).resize(bt[1],bt[0]);Be.push({label:null,score:null,mask:Et})}}return Be}}class X extends Y{constructor(ue){super(ue)}async _call(ue,U={}){if(Array.isArray(ue)&&ue.length!==1)throw Error("Background removal pipeline currently only supports a batch size of 1.");const Pe=await d(ue),ke=await super._call(ue,U);return Pe.map((Ge,$e)=>{const et=Ge.clone();return et.putAlpha(ke[$e].mask),et})}}class ce extends y{constructor(ue){super(ue)}async _call(ue,U,{hypothesis_template:we="This is a photo of {}"}={}){const Pe=Array.isArray(ue),ke=await d(ue),Le=U.map(at=>we.replace("{}",at)),Ge=this.tokenizer(Le,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:$e}=await this.processor(ke),et=await this.model({...Ge,pixel_values:$e}),Ce=this.model.config.model_type==="siglip"?at=>at.sigmoid().data:at=>(0,l.softmax)(at.data),He=[];for(const at of et.logits_per_image){const he=[...Ce(at)].map((ye,Ke)=>({score:ye,label:U[Ke]}));he.sort((ye,Ke)=>Ke.score-ye.score),He.push(he)}return Pe?He:He[0]}}class me extends y{constructor(ue){super(ue)}async _call(ue,{threshold:U=.9,percentage:we=!1}={}){const Pe=Array.isArray(ue);if(Pe&&ue.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const ke=await d(ue),Le=we?null:ke.map(Z=>[Z.height,Z.width]),{pixel_values:Ge,pixel_mask:$e}=await this.processor(ke),et=await this.model({pixel_values:Ge,pixel_mask:$e}),Ce=this.processor.image_processor.post_process_object_detection(et,U,Le),He=this.model.config.id2label,at=Ce.map(Z=>Z.boxes.map((he,ye)=>({score:Z.scores[ye],label:He[Z.classes[ye]],box:m(he,!we)})));return Pe?at:at[0]}}class Q extends y{constructor(ue){super(ue)}async _call(ue,U,{threshold:we=.1,top_k:Pe=null,percentage:ke=!1}={}){const Le=Array.isArray(ue),Ge=await d(ue),$e=this.tokenizer(U,{padding:!0,truncation:!0}),et=await this.processor(Ge),Ce=[];for(let He=0;He<Ge.length;++He){const at=Ge[He],Z=ke?null:[[at.height,at.width]],he=et.pixel_values[He].unsqueeze_(0),ye=await this.model({...$e,pixel_values:he});let Ke;if("post_process_grounded_object_detection"in this.processor){const Be=this.processor.post_process_grounded_object_detection(ye,$e.input_ids,{box_threshold:we,text_threshold:we,target_sizes:Z})[0];Ke=Be.boxes.map((Se,Oe)=>({score:Be.scores[Oe],label:Be.labels[Oe],box:m(Se,!ke)}))}else{const Be=this.processor.image_processor.post_process_object_detection(ye,we,Z,!0)[0];Ke=Be.boxes.map((Se,Oe)=>({score:Be.scores[Oe],label:U[Be.classes[Oe]],box:m(Se,!ke)}))}Ke.sort((Be,Se)=>Se.score-Be.score),Pe!==null&&(Ke=Ke.slice(0,Pe)),Ce.push(Ke)}return Le?Ce:Ce[0]}}class H extends y{constructor(ue){super(ue)}async _call(ue,U,we={}){const Pe=(await d(ue))[0],{pixel_values:ke}=await this.processor(Pe),Le=`<s_docvqa><s_question>${U}</s_question><s_answer>`,Ge=this.tokenizer(Le,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,$e=await this.model.generate({inputs:ke,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:Ge,...we}),Ce=this.tokenizer.batch_decode($e)[0].match(/<s_answer>(.*?)<\/s_answer>/);let He=null;return Ce&&Ce.length>=2&&(He=Ce[1].trim()),[{answer:He}]}}class B extends y{constructor(U){super(U);fe(this,"DEFAULT_VOCODER_ID","Xenova/speecht5_hifigan");this.vocoder=U.vocoder??null}async _prepare_speaker_embeddings(U){if((typeof U=="string"||U instanceof URL)&&(U=new Float32Array(await(await fetch(U)).arrayBuffer())),U instanceof Float32Array)U=new c.Tensor("float32",U,[U.length]);else if(!(U instanceof c.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");return U}async _call(U,{speaker_embeddings:we=null,num_inference_steps:Pe,speed:ke}={}){return this.processor?this._call_text_to_spectrogram(U,{speaker_embeddings:we}):this.model.config.model_type==="supertonic"?this._call_supertonic(U,{speaker_embeddings:we,num_inference_steps:Pe,speed:ke}):this._call_text_to_waveform(U)}async _call_supertonic(U,{speaker_embeddings:we,num_inference_steps:Pe,speed:ke}){if(!we)throw new Error("Speaker embeddings must be provided for Supertonic models.");we=await this._prepare_speaker_embeddings(we);const{sampling_rate:Le,style_dim:Ge}=this.model.config;we=we.view(1,-1,Ge);const $e=this.tokenizer(U,{padding:!0,truncation:!0}),{waveform:et}=await this.model.generate_speech({...$e,style:we,num_inference_steps:Pe,speed:ke});return new u.RawAudio(et.data,Le)}async _call_text_to_waveform(U){const we=this.tokenizer(U,{padding:!0,truncation:!0}),{waveform:Pe}=await this.model(we),ke=this.model.config.sampling_rate;return new u.RawAudio(Pe.data,ke)}async _call_text_to_spectrogram(U,{speaker_embeddings:we}){this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await r.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"}));const{input_ids:Pe}=this.tokenizer(U,{padding:!0,truncation:!0});we=await this._prepare_speaker_embeddings(we),we=we.view(1,-1);const{waveform:ke}=await this.model.generate_speech(Pe,we,{vocoder:this.vocoder}),Le=this.processor.feature_extractor.config.sampling_rate;return new u.RawAudio(ke.data,Le)}}class ee extends y{constructor(ue){super(ue)}async _call(ue){const U=await d(ue),we=await this.processor(U),Pe=await this.model(we),ke=[];for(const Le of Pe.reconstruction){const Ge=Le.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");ke.push(f.RawImage.fromTensor(Ge))}return ke.length>1?ke:ke[0]}}class _e extends y{constructor(ue){super(ue)}async _call(ue){const U=await d(ue),we=await this.processor(U),{predicted_depth:Pe}=await this.model(we),ke=[];for(let Le=0;Le<U.length;++Le){const Ge=Pe[Le],[$e,et]=Ge.dims.slice(-2),[Ce,He]=U[Le].size,at=(await(0,c.interpolate_4d)(Ge.view(1,1,$e,et),{size:[He,Ce],mode:"bilinear"})).view(He,Ce),Z=at.min().item(),he=at.max().item(),ye=at.sub(Z).div_(he-Z).mul_(255).to("uint8").unsqueeze(0),Ke=f.RawImage.fromTensor(ye);ke.push({predicted_depth:at,depth:Ke})}return ke.length>1?ke:ke[0]}}const le=Object.freeze({"text-classification":{tokenizer:i.AutoTokenizer,pipeline:M,model:r.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:i.AutoTokenizer,pipeline:g,model:r.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:i.AutoTokenizer,pipeline:_,model:r.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:i.AutoTokenizer,pipeline:T,model:r.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:i.AutoTokenizer,pipeline:S,model:r.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:i.AutoTokenizer,pipeline:$,model:r.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:i.AutoTokenizer,pipeline:x,model:r.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:i.AutoTokenizer,pipeline:P,model:r.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:i.AutoTokenizer,pipeline:O,model:r.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:W,model:r.AutoModelForAudioClassification,processor:s.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:i.AutoTokenizer,pipeline:V,model:r.AutoModel,processor:s.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:i.AutoTokenizer,pipeline:te,model:[r.AutoModelForSpeechSeq2Seq,r.AutoModelForCTC],processor:s.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:i.AutoTokenizer,pipeline:B,model:[r.AutoModelForTextToWaveform,r.AutoModelForTextToSpectrogram],processor:[s.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:i.AutoTokenizer,pipeline:J,model:r.AutoModelForVision2Seq,processor:s.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:j,model:r.AutoModelForImageClassification,processor:s.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:Y,model:[r.AutoModelForImageSegmentation,r.AutoModelForSemanticSegmentation,r.AutoModelForUniversalSegmentation],processor:s.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"background-removal":{pipeline:X,model:[r.AutoModelForImageSegmentation,r.AutoModelForSemanticSegmentation,r.AutoModelForUniversalSegmentation],processor:s.AutoProcessor,default:{model:"Xenova/modnet"},type:"image"},"zero-shot-image-classification":{tokenizer:i.AutoTokenizer,pipeline:ce,model:r.AutoModel,processor:s.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:me,model:r.AutoModelForObjectDetection,processor:s.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:i.AutoTokenizer,pipeline:Q,model:r.AutoModelForZeroShotObjectDetection,processor:s.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:i.AutoTokenizer,pipeline:H,model:r.AutoModelForDocumentQuestionAnswering,processor:s.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:ee,model:r.AutoModelForImageToImage,processor:s.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:_e,model:r.AutoModelForDepthEstimation,processor:s.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:i.AutoTokenizer,pipeline:R,model:r.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:s.AutoProcessor,pipeline:G,model:[r.AutoModelForImageFeatureExtraction,r.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),ae=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function Ne(ze,ue=null,{progress_callback:U=null,config:we=null,cache_dir:Pe=null,local_files_only:ke=!1,revision:Le="main",device:Ge=null,dtype:$e=null,subfolder:et="onnx",use_external_data_format:Ce=null,model_file_name:He=null,session_options:at={}}={}){ze=ae[ze]??ze;const Z=le[ze.split("_",1)[0]];if(!Z)throw Error(`Unsupported pipeline: ${ze}. Must be one of [${Object.keys(le)}]`);ue||(ue=Z.default.model,console.log(`No model specified. Using default model: "${ue}".`));const he={progress_callback:U,config:we,cache_dir:Pe,local_files_only:ke,revision:Le,device:Ge,dtype:$e,subfolder:et,use_external_data_format:Ce,model_file_name:He,session_options:at},ye=new Map([["tokenizer",Z.tokenizer],["model",Z.model],["processor",Z.processor]]),Ke=await Ye(ye,ue,he);Ke.task=ze,(0,o.dispatchCallback)(U,{status:"ready",task:ze,model:ue});const Be=Z.pipeline;return new Be(Ke)}async function Ye(ze,ue,U){const we=Object.create(null),Pe=[];for(const[ke,Le]of ze.entries()){if(!Le)continue;let Ge;Array.isArray(Le)?Ge=new Promise(async($e,et)=>{var He,at;let Ce;for(const Z of Le){if(Z===null){$e(null);return}try{$e(await Z.from_pretrained(ue,U));return}catch(he){if((He=he.message)!=null&&He.includes("Unsupported model type"))Ce=he;else if((at=he.message)!=null&&at.includes("Could not locate file"))Ce=he;else{et(he);return}}}et(Ce)}):Ge=Le.from_pretrained(ue,U),we[ke]=Ge,Pe.push(Ge)}await Promise.all(Pe);for(const[ke,Le]of Object.entries(we))we[ke]=await Le;return we}},"./src/tokenizers.js":(e,t,n)=>{n.r(t),n.d(t,{AlbertTokenizer:()=>Wi,AutoTokenizer:()=>ia,BartTokenizer:()=>mt,BertTokenizer:()=>ji,BlenderbotSmallTokenizer:()=>lt,BlenderbotTokenizer:()=>ot,BloomTokenizer:()=>St,CLIPTokenizer:()=>ci,CamembertTokenizer:()=>de,CodeGenTokenizer:()=>Mi,CodeLlamaTokenizer:()=>Wn,CohereTokenizer:()=>Yr,ConvBertTokenizer:()=>oe,DebertaTokenizer:()=>Xt,DebertaV2Tokenizer:()=>nr,DistilBertTokenizer:()=>re,ElectraTokenizer:()=>Ue,EsmTokenizer:()=>Pt,FalconTokenizer:()=>Je,GPT2Tokenizer:()=>$t,GPTNeoXTokenizer:()=>qt,GemmaTokenizer:()=>An,Grok1Tokenizer:()=>zn,HerbertTokenizer:()=>L,LlamaTokenizer:()=>vn,M2M100Tokenizer:()=>In,MBart50Tokenizer:()=>It,MBartTokenizer:()=>Ht,MPNetTokenizer:()=>Bn,MarianTokenizer:()=>Cr,MgpstrTokenizer:()=>ls,MobileBertTokenizer:()=>Sn,NllbTokenizer:()=>Un,NougatTokenizer:()=>mn,PreTrainedTokenizer:()=>xt,Qwen2Tokenizer:()=>kt,RoFormerTokenizer:()=>K,RobertaTokenizer:()=>Zt,SiglipTokenizer:()=>Xi,SpeechT5Tokenizer:()=>wt,SqueezeBertTokenizer:()=>Ii,T5Tokenizer:()=>_t,TokenizerModel:()=>G,VitsTokenizer:()=>os,Wav2Vec2CTCTokenizer:()=>Hi,WhisperTokenizer:()=>ir,XLMRobertaTokenizer:()=>ei,XLMTokenizer:()=>xe,is_chinese_char:()=>T});var i=n("./src/utils/generic.js"),r=n("./src/utils/core.js"),s=n("./src/utils/hub.js"),a=n("./src/utils/maths.js"),o=n("./src/utils/tensor.js"),l=n("./src/utils/data-structures.js"),u=n("./node_modules/@huggingface/jinja/dist/index.js"),c=n("./src/models/whisper/common_whisper.js");async function f(Ee,z){const ne=await Promise.all([(0,s.getModelJSON)(Ee,"tokenizer.json",!0,z),(0,s.getModelJSON)(Ee,"tokenizer_config.json",!0,z)]);return z.legacy!==null&&(ne[1].legacy=z.legacy),ne}function d(Ee,z){const ne=[];let pe=0;for(const be of Ee.matchAll(z)){const Me=be[0];pe<be.index&&ne.push(Ee.slice(pe,be.index)),Me.length>0&&ne.push(Me),pe=be.index+Me.length}return pe<Ee.length&&ne.push(Ee.slice(pe)),ne}function h(Ee,z=!0){if(Ee.Regex!==void 0){let ne=Ee.Regex.replace(/\\([#&~])/g,"$1");for(const[pe,be]of O)ne=ne.replaceAll(pe,be);return new RegExp(ne,"gu")}else if(Ee.String!==void 0){const ne=(0,r.escapeRegExp)(Ee.String);return new RegExp(z?ne:`(${ne})`,"gu")}else return console.warn("Unknown pattern type:",Ee),null}function m(Ee){return new Map(Object.entries(Ee))}function y(Ee){const z=Ee.dims;switch(z.length){case 1:return Ee.tolist();case 2:if(z[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return Ee.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${z.length}.`)}}function M(Ee){return Ee.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function g(Ee){return Ee.replace(new RegExp("\\p{M}","gu"),"")}function _(Ee){return g(Ee.toLowerCase())}function T(Ee){return Ee>=19968&&Ee<=40959||Ee>=13312&&Ee<=19903||Ee>=131072&&Ee<=173791||Ee>=173824&&Ee<=177983||Ee>=177984&&Ee<=178207||Ee>=178208&&Ee<=183983||Ee>=63744&&Ee<=64255||Ee>=194560&&Ee<=195103}function x(Ee,z,ne){const pe=[];let be=0;for(;be<Ee.length;){if(pe.push(Ee[be]),(z.get(Ee[be])??ne)!==ne){++be;continue}for(;++be<Ee.length&&(z.get(Ee[be])??ne)===ne;)z.get(pe.at(-1))!==ne&&(pe[pe.length-1]+=Ee[be])}return pe}function S(Ee){return Ee.match(/\S+/g)||[]}const $="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",C=new RegExp(`^[${$}]+$`,"gu"),P=".,!?",O=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],["(?i:[sdmt]|ll|ve|re)","(?:[sS]|[dD]|[mM]|[tT]|[lL][lL]|[vV][eE]|[rR][eE])"],["[^\\r\\n\\p{L}\\p{N}]?+","[^\\r\\n\\p{L}\\p{N}]?"],["[^\\s\\p{L}\\p{N}]++","[^\\s\\p{L}\\p{N}]+"],[` ?[^(\\s|[${P}])]+`,` ?[^\\s${P}]+`]]);class R{constructor(z){this.content=z.content,this.id=z.id,this.single_word=z.single_word??!1,this.lstrip=z.lstrip??!1,this.rstrip=z.rstrip??!1,this.special=z.special??!1,this.normalized=z.normalized??null}}class G extends i.Callable{constructor(z){super(),this.config=z,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(z,...ne){switch(z.type){case"WordPiece":return new W(z);case"Unigram":return new V(z,...ne);case"BPE":return new j(z);default:if(z.vocab)return Array.isArray(z.vocab)?new V(z,...ne):Object.hasOwn(z,"continuing_subword_prefix")&&Object.hasOwn(z,"unk_token")?Object.hasOwn(z,"merges")?new j(z):new W(z):new Y(z,...ne);throw new Error(`Unknown TokenizerModel type: ${z.type}`)}}_call(z){return z=this.encode(z),this.fuse_unk&&(z=x(z,this.tokens_to_ids,this.unk_token_id)),z}encode(z){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(z){return z.map(ne=>this.tokens_to_ids.get(ne)??this.unk_token_id)}convert_ids_to_tokens(z){return z.map(ne=>this.vocab[ne]??this.unk_token)}}class W extends G{constructor(z){super(z),this.tokens_to_ids=m(z.vocab),this.unk_token_id=this.tokens_to_ids.get(z.unk_token),this.unk_token=z.unk_token,this.max_input_chars_per_word=z.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[ne,pe]of this.tokens_to_ids)this.vocab[pe]=ne}encode(z){const ne=[];for(const pe of z){const be=[...pe];if(be.length>this.max_input_chars_per_word){ne.push(this.unk_token);continue}let Me=!1,Fe=0;const ut=[];for(;Fe<be.length;){let yt=be.length,gt=null;for(;Fe<yt;){let Mt=be.slice(Fe,yt).join("");if(Fe>0&&(Mt=this.config.continuing_subword_prefix+Mt),this.tokens_to_ids.has(Mt)){gt=Mt;break}--yt}if(gt===null){Me=!0;break}ut.push(gt),Fe=yt}Me?ne.push(this.unk_token):ne.push(...ut)}return ne}}class V extends G{constructor(z,ne){super(z);const pe=z.vocab.length;this.vocab=new Array(pe),this.scores=new Array(pe);for(let be=0;be<pe;++be)[this.vocab[be],this.scores[be]]=z.vocab[be];this.unk_token_id=z.unk_id,this.unk_token=this.vocab[z.unk_id],this.tokens_to_ids=new Map(this.vocab.map((be,Me)=>[be,Me])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=ne.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,a.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new l.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(z){const ne=z.chars,pe=1;let be=0;for(;be<ne.length;){let Me=!1;const Fe=ne.slice(be).join(""),ut=this.trie.commonPrefixSearch(Fe);for(const yt of ut){const gt=this.tokens_to_ids.get(yt),Mt=this.scores[gt],Wt=(0,r.len)(yt);z.insert(be,Wt,Mt,gt),!Me&&Wt===pe&&(Me=!0)}Me||z.insert(be,pe,this.unk_score,this.unk_token_id),be+=pe}}tokenize(z){const ne=new l.TokenLattice(z,this.bos_token_id,this.eos_token_id);return this.populateNodes(ne),ne.tokens()}encode(z){const ne=[];for(const pe of z){const be=this.tokenize(pe);ne.push(...be)}return ne}}const te=(()=>{const Ee=[...Array.from({length:94},(be,Me)=>Me+33),...Array.from({length:12},(be,Me)=>Me+161),...Array.from({length:82},(be,Me)=>Me+174)],z=Ee.slice();let ne=0;for(let be=0;be<256;++be)Ee.includes(be)||(Ee.push(be),z.push(256+ne),ne+=1);const pe=z.map(be=>String.fromCharCode(be));return Object.fromEntries(Ee.map((be,Me)=>[be,pe[Me]]))})(),J=(0,r.reverseDictionary)(te);class j extends G{constructor(z){super(z),this.tokens_to_ids=m(z.vocab),this.unk_token_id=this.tokens_to_ids.get(z.unk_token),this.unk_token=z.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[pe,be]of this.tokens_to_ids)this.vocab[be]=pe;const ne=Array.isArray(z.merges[0]);this.merges=ne?z.merges:z.merges.map(pe=>pe.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((pe,be)=>[JSON.stringify(pe),be])),this.end_of_word_suffix=z.end_of_word_suffix,this.continuing_subword_suffix=z.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.max_length_to_cache=256,this.cache_capacity=1e4,this.cache=new l.LRUCache(this.cache_capacity)}clear_cache(){this.cache.clear()}bpe(z){if(z.length===0)return[];const ne=this.cache.get(z);if(ne!==void 0)return ne;const pe=Array.from(z);this.end_of_word_suffix&&(pe[pe.length-1]+=this.end_of_word_suffix);let be=[];if(pe.length>1){const Me=new l.PriorityQueue((yt,gt)=>yt.score<gt.score);let Fe={token:pe[0],bias:0,prev:null,next:null},ut=Fe;for(let yt=1;yt<pe.length;++yt){const gt={bias:yt/pe.length,token:pe[yt],prev:ut,next:null};ut.next=gt,this._add_node(Me,ut),ut=gt}for(;!Me.isEmpty();){const yt=Me.pop();if(yt.deleted||!yt.next||yt.next.deleted)continue;if(yt.deleted=!0,yt.next.deleted=!0,yt.prev){const Mt={...yt.prev};yt.prev.deleted=!0,yt.prev=Mt,Mt.prev?Mt.prev.next=Mt:Fe=Mt}const gt={token:yt.token+yt.next.token,bias:yt.bias,prev:yt.prev,next:yt.next.next};gt.prev?(gt.prev.next=gt,this._add_node(Me,gt.prev)):Fe=gt,gt.next&&(gt.next.prev=gt,this._add_node(Me,gt))}for(let yt=Fe;yt!==null;yt=yt.next)be.push(yt.token)}else be=pe;if(this.continuing_subword_suffix)for(let Me=0;Me<be.length-1;++Me)be[Me]+=this.continuing_subword_suffix;return z.length<this.max_length_to_cache&&this.cache.put(z,be),be}_add_node(z,ne){const pe=this.bpe_ranks.get(JSON.stringify([ne.token,ne.next.token]));pe!==void 0&&(ne.score=pe+ne.bias,z.push(ne))}encode(z){const ne=[];for(const pe of z){if(this.ignore_merges&&this.tokens_to_ids.has(pe)){ne.push(pe);continue}const be=this.bpe(pe);for(const Me of be)if(this.tokens_to_ids.has(Me))ne.push(Me);else if(this.byte_fallback){const Fe=Array.from(this.text_encoder.encode(Me)).map(ut=>`<0x${ut.toString(16).toUpperCase().padStart(2,"0")}>`);Fe.every(ut=>this.tokens_to_ids.has(ut))?ne.push(...Fe):ne.push(this.unk_token)}else ne.push(this.unk_token)}return ne}}class Y extends G{constructor(z,ne){super(z),this.tokens_to_ids=m(ne.target_lang?z.vocab[ne.target_lang]:z.vocab),this.bos_token=ne.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=ne.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=ne.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=ne.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[pe,be]of this.tokens_to_ids)this.vocab[be]=pe}encode(z){return z}}class X extends i.Callable{constructor(z){super(),this.config=z}static fromConfig(z){if(z===null)return null;switch(z.type){case"BertNormalizer":return new ze(z);case"Precompiled":return new Kt(z);case"Sequence":return new Ye(z);case"Replace":return new ce(z);case"NFC":return new Q(z);case"NFD":return new H(z);case"NFKC":return new B(z);case"NFKD":return new ee(z);case"Strip":return new _e(z);case"StripAccents":return new le(z);case"Lowercase":return new ae(z);case"Prepend":return new Ne(z);default:throw new Error(`Unknown Normalizer type: ${z.type}`)}}normalize(z){throw Error("normalize should be implemented in subclass.")}_call(z){return this.normalize(z)}}class ce extends X{normalize(z){const ne=h(this.config.pattern);return ne===null?z:z.replaceAll(ne,this.config.content)}}class me extends X{constructor(){super(...arguments);fe(this,"form")}normalize(ne){return ne=ne.normalize(this.form),ne}}class Q extends me{constructor(){super(...arguments);fe(this,"form","NFC")}}class H extends me{constructor(){super(...arguments);fe(this,"form","NFD")}}class B extends me{constructor(){super(...arguments);fe(this,"form","NFKC")}}class ee extends me{constructor(){super(...arguments);fe(this,"form","NFKD")}}class _e extends X{normalize(z){return this.config.strip_left&&this.config.strip_right?z=z.trim():(this.config.strip_left&&(z=z.trimStart()),this.config.strip_right&&(z=z.trimEnd())),z}}class le extends X{normalize(z){return z=g(z),z}}class ae extends X{normalize(z){return z=z.toLowerCase(),z}}class Ne extends X{normalize(z){return z=this.config.prepend+z,z}}class Ye extends X{constructor(z){super(z),this.normalizers=z.normalizers.map(ne=>X.fromConfig(ne))}normalize(z){return this.normalizers.reduce((ne,pe)=>pe.normalize(ne),z)}}class ze extends X{_tokenize_chinese_chars(z){const ne=[];for(let pe=0;pe<z.length;++pe){const be=z[pe],Me=be.charCodeAt(0);T(Me)?(ne.push(" "),ne.push(be),ne.push(" ")):ne.push(be)}return ne.join("")}stripAccents(z){return z.normalize("NFD").replace(new RegExp("\\p{Mn}","gu"),"")}_is_control(z){switch(z){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(z)}}_clean_text(z){const ne=[];for(const pe of z){const be=pe.charCodeAt(0);be===0||be===65533||this._is_control(pe)||(/^\s$/.test(pe)?ne.push(" "):ne.push(pe))}return ne.join("")}normalize(z){return this.config.clean_text&&(z=this._clean_text(z)),this.config.handle_chinese_chars&&(z=this._tokenize_chinese_chars(z)),this.config.lowercase?(z=z.toLowerCase(),this.config.strip_accents!==!1&&(z=this.stripAccents(z))):this.config.strip_accents&&(z=this.stripAccents(z)),z}}class ue extends i.Callable{static fromConfig(z){if(z===null)return null;switch(z.type){case"BertPreTokenizer":return new U(z);case"Sequence":return new yi(z);case"Whitespace":return new Ji(z);case"WhitespaceSplit":return new tr(z);case"Metaspace":return new hn(z);case"ByteLevel":return new we(z);case"Split":return new Pe(z);case"Punctuation":return new ke(z);case"Digits":return new Le(z);case"Replace":return new Ti(z);case"FixedLength":return new Yn(z);default:throw new Error(`Unknown PreTokenizer type: ${z.type}`)}}pre_tokenize_text(z,ne){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(z,ne){return(Array.isArray(z)?z.map(pe=>this.pre_tokenize_text(pe,ne)):this.pre_tokenize_text(z,ne)).flat()}_call(z,ne){return this.pre_tokenize(z,ne)}}class U extends ue{constructor(z){super(),this.pattern=new RegExp(`[^\\s${$}]+|[${$}]`,"gu")}pre_tokenize_text(z,ne){return z.trim().match(this.pattern)||[]}}class we extends ue{constructor(z){super(),this.config=z,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=te,this.text_encoder=new TextEncoder}pre_tokenize_text(z,ne){return this.add_prefix_space&&!z.startsWith(" ")&&(z=" "+z),(this.use_regex?z.match(this.pattern)||[]:[z]).map(be=>Array.from(this.text_encoder.encode(be),Me=>this.byte_encoder[Me]).join(""))}}class Pe extends ue{constructor(z){super(),this.config=z,this.pattern=h(this.config.pattern,this.config.invert)}pre_tokenize_text(z,ne){var pe;return this.pattern===null?[]:this.config.invert?z.match(this.pattern)||[]:((pe=this.config.behavior)==null?void 0:pe.toLowerCase())==="removed"?z.split(this.pattern).filter(be=>be):d(z,this.pattern)}}class ke extends ue{constructor(z){super(),this.config=z,this.pattern=new RegExp(`[^${$}]+|[${$}]+`,"gu")}pre_tokenize_text(z,ne){return z.match(this.pattern)||[]}}class Le extends ue{constructor(z){super(),this.config=z;const ne=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(ne,"gu")}pre_tokenize_text(z,ne){return z.match(this.pattern)||[]}}class Ge extends i.Callable{constructor(z){super(),this.config=z}static fromConfig(z){if(z===null)return null;switch(z.type){case"TemplateProcessing":return new Ce(z);case"ByteLevel":return new He(z);case"RobertaProcessing":return new et(z);case"BertProcessing":return new $e(z);case"Sequence":return new at(z);default:throw new Error(`Unknown PostProcessor type: ${z.type}`)}}post_process(z,...ne){throw Error("post_process should be implemented in subclass.")}_call(z,...ne){return this.post_process(z,...ne)}}class $e extends Ge{constructor(z){super(z),this.cls=z.cls[0],this.sep=z.sep[0]}post_process(z,ne=null,{add_special_tokens:pe=!0}={}){pe&&(z=(0,r.mergeArrays)([this.cls],z,[this.sep]));let be=new Array(z.length).fill(0);if(ne!==null){const Me=pe&&this instanceof et?[this.sep]:[],Fe=pe?[this.sep]:[];z=(0,r.mergeArrays)(z,Me,ne,Fe),be=(0,r.mergeArrays)(be,new Array(ne.length+Me.length+Fe.length).fill(1))}return{tokens:z,token_type_ids:be}}}class et extends $e{}class Ce extends Ge{constructor(z){super(z),this.single=z.single,this.pair=z.pair}post_process(z,ne=null,{add_special_tokens:pe=!0}={}){const be=ne===null?this.single:this.pair;let Me=[],Fe=[];for(const ut of be)"SpecialToken"in ut?pe&&(Me.push(ut.SpecialToken.id),Fe.push(ut.SpecialToken.type_id)):"Sequence"in ut&&(ut.Sequence.id==="A"?(Me=(0,r.mergeArrays)(Me,z),Fe=(0,r.mergeArrays)(Fe,new Array(z.length).fill(ut.Sequence.type_id))):ut.Sequence.id==="B"&&(Me=(0,r.mergeArrays)(Me,ne),Fe=(0,r.mergeArrays)(Fe,new Array(ne.length).fill(ut.Sequence.type_id))));return{tokens:Me,token_type_ids:Fe}}}class He extends Ge{post_process(z,ne=null){return ne&&(z=(0,r.mergeArrays)(z,ne)),{tokens:z}}}class at extends Ge{constructor(z){super(z),this.processors=z.processors.map(ne=>Ge.fromConfig(ne))}post_process(z,ne=null,pe={}){let be;for(const Me of this.processors)if(Me instanceof He)z=Me.post_process(z).tokens,ne&&(ne=Me.post_process(ne).tokens);else{const Fe=Me.post_process(z,ne,pe);z=Fe.tokens,be=Fe.token_type_ids}return{tokens:z,token_type_ids:be}}}class Z extends i.Callable{constructor(z){super(),this.config=z,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=z.trim_offsets}static fromConfig(z){if(z===null)return null;switch(z.type){case"WordPiece":return new Se(z);case"Metaspace":return new En(z);case"ByteLevel":return new Oe(z);case"Replace":return new he(z);case"ByteFallback":return new ye(z);case"Fuse":return new Ke(z);case"Strip":return new Be(z);case"Sequence":return new bt(z);case"CTC":return new ct(z);case"BPEDecoder":return new Ct(z);default:throw new Error(`Unknown Decoder type: ${z.type}`)}}_call(z){return this.decode(z)}decode(z){return this.decode_chain(z).join("")}decode_chain(z){throw Error("`decode_chain` should be implemented in subclass.")}}class he extends Z{decode_chain(z){const ne=h(this.config.pattern);return ne===null?z:z.map(pe=>pe.replaceAll(ne,this.config.content))}}class ye extends Z{constructor(z){super(z),this.text_decoder=new TextDecoder}decode_chain(z){const ne=[];let pe=[];for(const be of z){let Me=null;if(be.length===6&&be.startsWith("<0x")&&be.endsWith(">")){const Fe=parseInt(be.slice(3,5),16);isNaN(Fe)||(Me=Fe)}if(Me!==null)pe.push(Me);else{if(pe.length>0){const Fe=this.text_decoder.decode(Uint8Array.from(pe));ne.push(Fe),pe=[]}ne.push(be)}}if(pe.length>0){const be=this.text_decoder.decode(Uint8Array.from(pe));ne.push(be),pe=[]}return ne}}class Ke extends Z{decode_chain(z){return[z.join("")]}}class Be extends Z{constructor(z){super(z),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(z){return z.map(ne=>{let pe=0;for(let Me=0;Me<this.start&&ne[Me]===this.content;++Me){pe=Me+1;continue}let be=ne.length;for(let Me=0;Me<this.stop;++Me){const Fe=ne.length-Me-1;if(ne[Fe]===this.content){be=Fe;continue}else break}return ne.slice(pe,be)})}}class Se extends Z{constructor(z){super(z),this.cleanup=z.cleanup}decode_chain(z){return z.map((ne,pe)=>(pe!==0&&(ne.startsWith(this.config.prefix)?ne=ne.replace(this.config.prefix,""):ne=" "+ne),this.cleanup&&(ne=M(ne)),ne))}}class Oe extends Z{constructor(z){super(z),this.byte_decoder=J,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(z){const ne=z.join(""),pe=new Uint8Array([...ne].map(Me=>this.byte_decoder[Me]));return this.text_decoder.decode(pe)}decode_chain(z){const ne=[];let pe=[];for(const be of z)this.added_tokens.find(Me=>Me.content===be)!==void 0?(pe.length>0&&(ne.push(this.convert_tokens_to_string(pe)),pe=[]),ne.push(be)):pe.push(be);return pe.length>0&&ne.push(this.convert_tokens_to_string(pe)),ne}}class ct extends Z{constructor(z){super(z),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(z){if(z.length===0)return"";const ne=[z[0]];for(let Me=1;Me<z.length;++Me)z[Me]!==ne.at(-1)&&ne.push(z[Me]);let be=ne.filter(Me=>Me!==this.pad_token).join("");return this.cleanup&&(be=M(be).replaceAll(this.word_delimiter_token," ").trim()),be}decode_chain(z){return[this.convert_tokens_to_string(z)]}}class bt extends Z{constructor(z){super(z),this.decoders=z.decoders.map(ne=>Z.fromConfig(ne))}decode_chain(z){return this.decoders.reduce((ne,pe)=>pe.decode_chain(ne),z)}}class Ct extends Z{constructor(z){super(z),this.suffix=this.config.suffix}decode_chain(z){return z.map((ne,pe)=>ne.replaceAll(this.suffix,pe===z.length-1?"":" "))}}class Et extends Z{decode_chain(z){let ne="";for(let pe=1;pe<z.length;pe+=2)ne+=z[pe];return[ne]}}class hn extends ue{constructor(z){super(),this.replacement=z.replacement,this.strRep=z.str_rep||this.replacement,this.prepend_scheme=z.prepend_scheme??"always"}pre_tokenize_text(z,{section_index:ne=void 0}={}){let pe=z.replaceAll(" ",this.strRep);return!pe.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&ne===0)&&(pe=this.strRep+pe),[pe]}}class En extends Z{constructor(z){super(z),this.replacement=z.replacement}decode_chain(z){const ne=[];for(let pe=0;pe<z.length;++pe){let be=z[pe].replaceAll(this.replacement," ");pe==0&&be.startsWith(" ")&&(be=be.substring(1)),ne.push(be)}return ne}}class Kt extends X{constructor(z){super(z),this.charsmap=z.precompiled_charsmap}normalize(z){return z=z.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),z=z.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),z.includes("")?z=z.split("").map(pe=>pe.normalize("NFKC")).join(""):z=z.normalize("NFKC"),z}}class yi extends ue{constructor(z){super(),this.tokenizers=z.pretokenizers.map(ne=>ue.fromConfig(ne))}pre_tokenize_text(z,ne){return this.tokenizers.reduce((pe,be)=>be.pre_tokenize(pe,ne),[z])}}class Ji extends ue{constructor(z){super()}pre_tokenize_text(z,ne){return z.match(/\w+|[^\w\s]+/g)||[]}}class tr extends ue{constructor(z){super()}pre_tokenize_text(z,ne){return S(z)}}class Ti extends ue{constructor(z){super(),this.config=z,this.pattern=h(this.config.pattern),this.content=this.config.content}pre_tokenize_text(z,ne){return this.pattern===null?[z]:[z.replaceAll(this.pattern,this.config.content)]}}class Yn extends ue{constructor(z){super(),this._length=z.length}pre_tokenize_text(z,ne){const pe=[];for(let be=0;be<z.length;be+=this._length)pe.push(z.slice(be,be+this._length));return pe}}const $n=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function Yi(Ee,z,ne,pe){for(const be of Object.keys(Ee)){const Me=z-Ee[be].length,Fe=ne(be),ut=new Array(Me).fill(Fe);Ee[be]=pe==="right"?(0,r.mergeArrays)(Ee[be],ut):(0,r.mergeArrays)(ut,Ee[be])}}function Gi(Ee,z){for(const ne of Object.keys(Ee))Ee[ne].length=z}class xt extends i.Callable{constructor(ne,pe){super();fe(this,"return_token_type_ids",!1);fe(this,"padding_side","right");this.config=pe,this.normalizer=X.fromConfig(ne.normalizer),this.pre_tokenizer=ue.fromConfig(ne.pre_tokenizer),this.model=G.fromConfig(ne.model,pe),this.post_processor=Ge.fromConfig(ne.post_processor),this.decoder=Z.fromConfig(ne.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const be of ne.added_tokens){const Me=new R(be);this.added_tokens.push(Me),this.model.tokens_to_ids.set(Me.content,Me.id),this.model.vocab[Me.id]=Me.content,Me.special&&(this.special_tokens.push(Me.content),this.all_special_ids.push(Me.id))}if(this.additional_special_tokens=pe.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_splitter=new l.DictionarySplitter(this.added_tokens.map(be=>be.content)),this.added_tokens_map=new Map(this.added_tokens.map(be=>[be.content,be])),this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=pe.model_max_length,this.remove_space=pe.remove_space,this.clean_up_tokenization_spaces=pe.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=pe.do_lowercase_and_remove_accent??!1,pe.padding_side&&(this.padding_side=pe.padding_side),this.add_bos_token=pe.add_bos_token,this.add_eos_token=pe.add_eos_token,this.legacy=!1,this.chat_template=pe.chat_template??null,Array.isArray(this.chat_template)){const be=Object.create(null);for(const{name:Me,template:Fe}of this.chat_template){if(typeof Me!="string"||typeof Fe!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');be[Me]=Fe}this.chat_template=be}this._compiled_template_cache=new Map}getToken(...ne){for(const pe of ne){const be=this.config[pe];if(be)if(typeof be=="object"){if(be.__type==="AddedToken")return be.content;throw Error(`Unknown token: ${be}`)}else return be}return null}static async from_pretrained(ne,{progress_callback:pe=null,config:be=null,cache_dir:Me=null,local_files_only:Fe=!1,revision:ut="main",legacy:yt=null}={}){const gt=await f(ne,{progress_callback:pe,config:be,cache_dir:Me,local_files_only:Fe,revision:ut,legacy:yt});return new this(...gt)}_call(ne,{text_pair:pe=null,add_special_tokens:be=!0,padding:Me=!1,truncation:Fe=null,max_length:ut=null,return_tensor:yt=!0,return_token_type_ids:gt=null}={}){const Mt=Array.isArray(ne);let Wt;if(Mt){if(ne.length===0)throw Error("text array must be non-empty");if(pe!==null){if(Array.isArray(pe)){if(ne.length!==pe.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");Wt=ne.map((Tn,Pn)=>this._encode_plus(Tn,{text_pair:pe[Pn],add_special_tokens:be,return_token_type_ids:gt}))}else Wt=ne.map(Tn=>this._encode_plus(Tn,{add_special_tokens:be,return_token_type_ids:gt}))}else{if(ne==null)throw Error("text may not be null or undefined");if(Array.isArray(pe))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");Wt=[this._encode_plus(ne,{text_pair:pe,add_special_tokens:be,return_token_type_ids:gt})]}if(ut===null?ut=this.model_max_length:Fe===null&&(Me===!0?(console.warn("`max_length` is ignored when `padding: true` and there is no truncation strategy. To pad to max length, use `padding: 'max_length'`."),ut=this.model_max_length):Me===!1&&(console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation: true` to explicitly truncate examples to max length."),Fe=!0)),Me===!0&&(ut=Math.min((0,a.max)(Wt.map(Tn=>Tn.input_ids.length))[0],ut??1/0)),ut=Math.min(ut,this.model_max_length??1/0),Me||Fe)for(let Tn=0;Tn<Wt.length;++Tn)Wt[Tn].input_ids.length!==ut&&(Wt[Tn].input_ids.length>ut?Fe&&Gi(Wt[Tn],ut):Me&&Yi(Wt[Tn],ut,Pn=>Pn==="input_ids"?this.pad_token_id:0,this.padding_side));const Cn={};if(yt){if(!(Me&&Fe)&&Wt.some(Pn=>{var wn;for(const Hn of Object.keys(Pn))if(Pn[Hn].length!==((wn=Wt[0][Hn])==null?void 0:wn.length))return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const Tn=[Wt.length,Wt[0].input_ids.length];for(const Pn of Object.keys(Wt[0]))Cn[Pn]=new o.Tensor("int64",BigInt64Array.from(Wt.flatMap(wn=>wn[Pn]).map(BigInt)),Tn)}else{for(const Tn of Object.keys(Wt[0]))Cn[Tn]=Wt.map(Pn=>Pn[Tn]);if(!Mt)for(const Tn of Object.keys(Cn))Cn[Tn]=Cn[Tn][0]}return Cn}_encode_text(ne){if(ne===null)return null;const pe=this.added_tokens_splitter.split(ne);for(let Me=0;Me<pe.length;++Me){const Fe=this.added_tokens_map.get(pe[Me]);Fe&&(Fe.lstrip&&Me>0&&(pe[Me-1]=pe[Me-1].trimEnd()),Fe.rstrip&&Me<pe.length-1&&(pe[Me+1]=pe[Me+1].trimStart()))}return pe.flatMap((Me,Fe)=>{if(Me.length===0)return[];if(this.added_tokens_map.has(Me))return[Me];if(this.remove_space===!0&&(Me=Me.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(Me=_(Me)),this.normalizer!==null&&(Me=this.normalizer(Me)),Me.length===0)return[];const ut=this.pre_tokenizer!==null?this.pre_tokenizer(Me,{section_index:Fe}):[Me];return this.model(ut)})}_encode_plus(ne,{text_pair:pe=null,add_special_tokens:be=!0,return_token_type_ids:Me=null}={}){const{tokens:Fe,token_type_ids:ut}=this._tokenize_helper(ne,{pair:pe,add_special_tokens:be}),yt=this.model.convert_tokens_to_ids(Fe),gt={input_ids:yt,attention_mask:new Array(yt.length).fill(1)};return(Me??this.return_token_type_ids)&&ut&&(gt.token_type_ids=ut),gt}_tokenize_helper(ne,{pair:pe=null,add_special_tokens:be=!1}={}){const Me=this._encode_text(ne),Fe=this._encode_text(pe);return this.post_processor?this.post_processor(Me,Fe,{add_special_tokens:be}):{tokens:(0,r.mergeArrays)(Me??[],Fe??[])}}tokenize(ne,{pair:pe=null,add_special_tokens:be=!1}={}){return this._tokenize_helper(ne,{pair:pe,add_special_tokens:be}).tokens}encode(ne,{text_pair:pe=null,add_special_tokens:be=!0,return_token_type_ids:Me=null}={}){return this._encode_plus(ne,{text_pair:pe,add_special_tokens:be,return_token_type_ids:Me}).input_ids}batch_decode(ne,pe={}){return ne instanceof o.Tensor&&(ne=ne.tolist()),ne.map(be=>this.decode(be,pe))}decode(ne,pe={}){if(ne instanceof o.Tensor&&(ne=y(ne)),!Array.isArray(ne)||ne.length===0||!(0,r.isIntegralNumber)(ne[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(ne,pe)}decode_single(ne,{skip_special_tokens:pe=!1,clean_up_tokenization_spaces:be=null}){let Me=this.model.convert_ids_to_tokens(ne);pe&&(Me=Me.filter(ut=>!this.special_tokens.includes(ut)));let Fe=this.decoder?this.decoder(Me):Me.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(Fe=Fe.replaceAll(this.decoder.end_of_word_suffix," "),pe&&(Fe=Fe.trim())),(be??this.clean_up_tokenization_spaces)&&(Fe=M(Fe)),Fe}get_chat_template({chat_template:ne=null,tools:pe=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const be=this.chat_template;if(ne!==null&&Object.hasOwn(be,ne))ne=be[ne];else if(ne===null)if(pe!==null&&"tool_use"in be)ne=be.tool_use;else if("default"in be)ne=be.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(be).sort()}.`)}else if(ne===null)if(this.chat_template)ne=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return ne}apply_chat_template(ne,{tools:pe=null,documents:be=null,chat_template:Me=null,add_generation_prompt:Fe=!1,tokenize:ut=!0,padding:yt=!1,truncation:gt=!1,max_length:Mt=null,return_tensor:Wt=!0,return_dict:Cn=!1,tokenizer_kwargs:Tn={},...Pn}={}){if(Me=this.get_chat_template({chat_template:Me,tools:pe}),typeof Me!="string")throw Error(`chat_template must be a string, but got ${typeof Me}`);let wn=this._compiled_template_cache.get(Me);wn===void 0&&(wn=new u.Template(Me),this._compiled_template_cache.set(Me,wn));const Hn=Object.create(null);for(const oi of $n){const Si=this.getToken(oi);Si&&(Hn[oi]=Si)}const Ei=wn.render({messages:ne,add_generation_prompt:Fe,tools:pe,documents:be,...Hn,...Pn});if(ut){const oi=this._call(Ei,{add_special_tokens:!1,padding:yt,truncation:gt,max_length:Mt,return_tensor:Wt,...Tn});return Cn?oi:oi.input_ids}return Ei}}class ji extends xt{constructor(){super(...arguments);fe(this,"return_token_type_ids",!0)}}class Wi extends xt{constructor(){super(...arguments);fe(this,"return_token_type_ids",!0)}}class Sn extends xt{constructor(){super(...arguments);fe(this,"return_token_type_ids",!0)}}class Ii extends xt{constructor(){super(...arguments);fe(this,"return_token_type_ids",!0)}}class Xt extends xt{constructor(){super(...arguments);fe(this,"return_token_type_ids",!0)}}class nr extends xt{constructor(){super(...arguments);fe(this,"return_token_type_ids",!0)}}class L extends xt{constructor(){super(...arguments);fe(this,"return_token_type_ids",!0)}}class oe extends xt{constructor(){super(...arguments);fe(this,"return_token_type_ids",!0)}}class K extends xt{constructor(){super(...arguments);fe(this,"return_token_type_ids",!0)}}class re extends xt{}class de extends xt{}class xe extends xt{constructor(ne,pe){super(ne,pe);fe(this,"return_token_type_ids",!0);console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class Ue extends xt{constructor(){super(...arguments);fe(this,"return_token_type_ids",!0)}}class _t extends xt{}class $t extends xt{}class mt extends xt{}class Ht extends xt{constructor(z,ne){super(z,ne),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(pe=>this.languageRegex.test(pe)),this.lang_to_token=pe=>pe}_build_translation_inputs(z,ne,pe){return ni(this,z,ne,pe)}}class It extends Ht{}class Zt extends xt{}class St extends xt{}const tn="";class vn extends xt{constructor(ne,pe){super(ne,pe);fe(this,"padding_side","left");this.legacy=pe.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new hn({replacement:tn,prepend_scheme:"first"}))}_encode_text(ne){if(ne===null)return null;if(this.legacy||ne.length===0)return super._encode_text(ne);let pe=super._encode_text(tn+ne.replaceAll(tn," "));return pe.length>1&&pe[0]===tn&&this.special_tokens.includes(pe[1])&&(pe=pe.slice(1)),pe}}class Wn extends xt{}class ei extends xt{}class Bn extends xt{}class Je extends xt{}class qt extends xt{}class Pt extends xt{}class kt extends xt{}class An extends xt{}class zn extends xt{}function ni(Ee,z,ne,pe){if(!("language_codes"in Ee)||!Array.isArray(Ee.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in Ee)||!(Ee.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in Ee)||typeof Ee.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const be=pe.src_lang,Me=pe.tgt_lang;if(!Ee.language_codes.includes(Me))throw new Error(`Target language code "${Me}" is not valid. Must be one of: {${Ee.language_codes.join(", ")}}`);if(be!==void 0){if(!Ee.language_codes.includes(be))throw new Error(`Source language code "${be}" is not valid. Must be one of: {${Ee.language_codes.join(", ")}}`);for(const Fe of Ee.post_processor.config.single)if("SpecialToken"in Fe&&Ee.languageRegex.test(Fe.SpecialToken.id)){Fe.SpecialToken.id=Ee.lang_to_token(be);break}}return pe.forced_bos_token_id=Ee.model.convert_tokens_to_ids([Ee.lang_to_token(Me)])[0],Ee._call(z,ne)}class Un extends xt{constructor(z,ne){super(z,ne),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(pe=>this.languageRegex.test(pe)),this.lang_to_token=pe=>pe}_build_translation_inputs(z,ne,pe){return ni(this,z,ne,pe)}}class In extends xt{constructor(z,ne){super(z,ne),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(pe=>this.languageRegex.test(pe)).map(pe=>pe.slice(2,-2)),this.lang_to_token=pe=>`__${pe}__`}_build_translation_inputs(z,ne,pe){return ni(this,z,ne,pe)}}class ir extends xt{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(z,{return_timestamps:ne=!1,return_language:pe=!1,time_precision:be=null,force_full_sequences:Me=!0}={}){if(be===null)throw Error("Must specify time_precision");let Fe=null;const ut=ne==="word";function yt(){return{language:Fe,timestamp:[null,null],text:""}}const gt=[];let Mt=yt(),Wt=0;const Cn=this.timestamp_begin,Pn=Cn+1500;let wn=[],Hn=[],Ei=!1,oi=null;const Si=new Set(this.all_special_ids);for(const tt of z){const it=tt.tokens,Ve=ut?tt.token_timestamps:null;let vt=null,Gt=Cn;if("stride"in tt){const[Mn,Dn,li]=tt.stride;if(Wt-=Dn,oi=Mn-li,Dn&&(Gt=Dn/be+Cn),li)for(let Vn=it.length-1;Vn>=0;--Vn){const Bi=Number(it[Vn]);if(Bi>=Cn){if(vt!==null&&(Bi-Cn)*be<oi)break;vt=Bi}}}let rn=[],kn=[];for(let Mn=0;Mn<it.length;++Mn){const Dn=Number(it[Mn]);if(Si.has(Dn)){const li=this.decode([Dn]),Vn=c.WHISPER_LANGUAGE_MAPPING.get(li.slice(2,-2));if(Vn!==void 0){if(Fe!==null&&Vn!==Fe&&!ne){wn.push(rn);const Bi=this.findLongestCommonSequence(wn)[0],$r=this.decode(Bi);Mt.text=$r,gt.push(Mt),wn=[],rn=[],Mt=yt()}Fe=Mt.language=Vn}}else if(Dn>=Cn&&Dn<=Pn){const li=(Dn-Cn)*be+Wt,Vn=(0,a.round)(li,2);if(vt!==null&&Dn>=vt)Ei=!0;else if(Ei||wn.length>0&&Dn<Gt)Ei=!1;else if(Mt.timestamp[0]===null)Mt.timestamp[0]=Vn;else if(Vn!==Mt.timestamp[0]){Mt.timestamp[1]=Vn,wn.push(rn),ut&&Hn.push(kn);const[Bi,$r]=this.findLongestCommonSequence(wn,Hn),yr=this.decode(Bi);Mt.text=yr,ut&&(Mt.words=this.collateWordTimestamps(Bi,$r,Fe)),gt.push(Mt),wn=[],rn=[],Hn=[],kn=[],Mt=yt()}}else if(rn.push(Dn),ut){let li=(0,a.round)(Ve[Mn]+Wt,2),Vn;if(Mn+1<Ve.length){Vn=(0,a.round)(Ve[Mn+1]+Wt,2);const Bi=this.decode([Dn]);C.test(Bi)&&(Vn=(0,a.round)(Math.min(li+be,Vn),2))}else Vn=null;kn.push([li,Vn])}}if("stride"in tt){const[Mn,Dn,li]=tt.stride;Wt+=Mn-li}rn.length>0?(wn.push(rn),ut&&Hn.push(kn)):wn.every(Mn=>Mn.length===0)&&(Mt=yt(),wn=[],rn=[],Hn=[],kn=[])}if(wn.length>0){if(Me&&ne)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[tt,it]=this.findLongestCommonSequence(wn,Hn),Ve=this.decode(tt);Mt.text=Ve,ut&&(Mt.words=this.collateWordTimestamps(tt,it,Fe)),gt.push(Mt)}let Pi=Object.create(null);const _r=gt.map(tt=>tt.text).join("");if(ne||pe){for(let tt=0;tt<gt.length;++tt){const it=gt[tt];ne||delete it.timestamp,pe||delete it.language}if(ut){const tt=[];for(const it of gt)for(const Ve of it.words)tt.push(Ve);Pi={chunks:tt}}else Pi={chunks:gt}}return[_r,Pi]}findLongestCommonSequence(z,ne=null){let pe=z[0],be=pe.length,Me=[];const Fe=Array.isArray(ne)&&ne.length>0;let ut=Fe?[]:null,yt=Fe?ne[0]:null;for(let gt=1;gt<z.length;++gt){const Mt=z[gt];let Wt=0,Cn=[be,be,0,0];const Tn=Mt.length;for(let Pi=1;Pi<be+Tn;++Pi){const _r=Math.max(0,be-Pi),tt=Math.min(be,be+Tn-Pi),it=pe.slice(_r,tt),Ve=Math.max(0,Pi-be),vt=Math.min(Tn,Pi),Gt=Mt.slice(Ve,vt);if(it.length!==Gt.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let rn;Fe?rn=it.filter((Dn,li)=>Dn===Gt[li]&&yt[_r+li]<=ne[gt][Ve+li]).length:rn=it.filter((Dn,li)=>Dn===Gt[li]).length;const kn=Pi/1e4,Mn=rn/Pi+kn;rn>1&&Mn>Wt&&(Wt=Mn,Cn=[_r,tt,Ve,vt])}const[Pn,wn,Hn,Ei]=Cn,oi=Math.floor((wn+Pn)/2),Si=Math.floor((Ei+Hn)/2);Me.push(...pe.slice(0,oi)),pe=Mt.slice(Si),be=pe.length,Fe&&(ut.push(...yt.slice(0,oi)),yt=ne[gt].slice(Si))}return Me.push(...pe),Fe?(ut.push(...yt),[Me,ut]):[Me,[]]}collateWordTimestamps(z,ne,pe){const[be,Me,Fe]=this.combineTokensIntoWords(z,pe),ut=[];for(let yt=0;yt<be.length;++yt){const gt=Fe[yt];ut.push({text:be[yt],timestamp:[ne[gt.at(0)][0],ne[gt.at(-1)][1]]})}return ut}combineTokensIntoWords(z,ne,pe=`"'([{-`,be=`"'.,!?:)]}`){ne=ne??"english";let Me,Fe,ut;return["chinese","japanese","thai","lao","myanmar"].includes(ne)?[Me,Fe,ut]=this.splitTokensOnUnicode(z):[Me,Fe,ut]=this.splitTokensOnSpaces(z),this.mergePunctuations(Me,Fe,ut,pe,be)}decode(z,ne){let pe;return ne!=null&&ne.decode_with_timestamps?(z instanceof o.Tensor&&(z=y(z)),pe=this.decodeWithTimestamps(z,ne)):pe=super.decode(z,ne),pe}decodeWithTimestamps(z,ne){const pe=(ne==null?void 0:ne.time_precision)??.02,be=Array.from(this.all_special_ids).at(-1)+1;let Me=[[]];for(let Fe of z)if(Fe=Number(Fe),Fe>=be){const ut=((Fe-be)*pe).toFixed(2);Me.push(`<|${ut}|>`),Me.push([])}else Me[Me.length-1].push(Fe);return Me=Me.map(Fe=>typeof Fe=="string"?Fe:super.decode(Fe,ne)),Me.join("")}splitTokensOnUnicode(z){const ne=this.decode(z,{decode_with_timestamps:!0}),pe="",be=[],Me=[],Fe=[];let ut=[],yt=[],gt=0;for(let Mt=0;Mt<z.length;++Mt){const Wt=z[Mt];ut.push(Wt),yt.push(Mt);const Cn=this.decode(ut,{decode_with_timestamps:!0});(!Cn.includes(pe)||ne[gt+Cn.indexOf(pe)]===pe)&&(be.push(Cn),Me.push(ut),Fe.push(yt),ut=[],yt=[],gt+=Cn.length)}return[be,Me,Fe]}splitTokensOnSpaces(z){const[ne,pe,be]=this.splitTokensOnUnicode(z),Me=[],Fe=[],ut=[],yt=new RegExp(`^[${$}]$`,"gu");for(let gt=0;gt<ne.length;++gt){const Mt=ne[gt],Wt=pe[gt],Cn=be[gt],Tn=Wt[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),Pn=Mt.startsWith(" "),wn=Mt.trim(),Hn=yt.test(wn);if(Tn||Pn||Hn||Me.length===0)Me.push(Mt),Fe.push(Wt),ut.push(Cn);else{const Ei=Me.length-1;Me[Ei]+=Mt,Fe[Ei].push(...Wt),ut[Ei].push(...Cn)}}return[Me,Fe,ut]}mergePunctuations(z,ne,pe,be,Me){const Fe=structuredClone(z),ut=structuredClone(ne),yt=structuredClone(pe);let gt=Fe.length-2,Mt=Fe.length-1;for(;gt>=0;)Fe[gt].startsWith(" ")&&be.includes(Fe[gt].trim())?(Fe[Mt]=Fe[gt]+Fe[Mt],ut[Mt]=(0,r.mergeArrays)(ut[gt],ut[Mt]),yt[Mt]=(0,r.mergeArrays)(yt[gt],yt[Mt]),Fe[gt]="",ut[gt]=[],yt[gt]=[]):Mt=gt,--gt;for(gt=0,Mt=1;Mt<Fe.length;)!Fe[gt].endsWith(" ")&&Me.includes(Fe[Mt])?(Fe[gt]+=Fe[Mt],ut[gt]=(0,r.mergeArrays)(ut[gt],ut[Mt]),yt[gt]=(0,r.mergeArrays)(yt[gt],yt[Mt]),Fe[Mt]="",ut[Mt]=[],yt[Mt]=[]):gt=Mt,++Mt;return[Fe.filter(Wt=>Wt),ut.filter(Wt=>Wt.length>0),yt.filter(Wt=>Wt.length>0)]}}class Mi extends xt{}class ci extends xt{}class Xi extends xt{}class Cr extends xt{constructor(z,ne){super(z,ne),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(pe=>this.languageRegex.test(pe)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(z){if(z===null)return null;const[ne,...pe]=z.trim().split(this.languageRegex);if(pe.length===0)return super._encode_text(ne);if(pe.length===2){const[be,Me]=pe;return this.supported_language_codes.includes(be)||console.warn(`Unsupported language code "${be}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,r.mergeArrays)([be],super._encode_text(Me))}}}class Hi extends xt{}class ot extends xt{}class lt extends xt{}class wt extends xt{}class mn extends xt{}class os extends xt{constructor(z,ne){super(z,ne),this.decoder=new Et({})}}class Yr extends xt{}class ls extends xt{}class ia{static async from_pretrained(z,{progress_callback:ne=null,config:pe=null,cache_dir:be=null,local_files_only:Me=!1,revision:Fe="main",legacy:ut=null}={}){var Cn;const[yt,gt]=await f(z,{progress_callback:ne,config:pe,cache_dir:be,local_files_only:Me,revision:Fe,legacy:ut}),Mt=((Cn=gt.tokenizer_class)==null?void 0:Cn.replace(/Fast$/,""))??"PreTrainedTokenizer";let Wt=this.TOKENIZER_CLASS_MAPPING[Mt];return Wt||(console.warn(`Unknown tokenizer class "${Mt}", attempting to construct from base class.`),Wt=xt),new Wt(yt,gt)}}fe(ia,"TOKENIZER_CLASS_MAPPING",{T5Tokenizer:_t,DistilBertTokenizer:re,CamembertTokenizer:de,DebertaTokenizer:Xt,DebertaV2Tokenizer:nr,BertTokenizer:ji,HerbertTokenizer:L,ConvBertTokenizer:oe,RoFormerTokenizer:K,XLMTokenizer:xe,ElectraTokenizer:Ue,MobileBertTokenizer:Sn,SqueezeBertTokenizer:Ii,AlbertTokenizer:Wi,GPT2Tokenizer:$t,BartTokenizer:mt,MBartTokenizer:Ht,MBart50Tokenizer:It,RobertaTokenizer:Zt,WhisperTokenizer:ir,CodeGenTokenizer:Mi,CLIPTokenizer:ci,SiglipTokenizer:Xi,MarianTokenizer:Cr,BloomTokenizer:St,NllbTokenizer:Un,M2M100Tokenizer:In,LlamaTokenizer:vn,CodeLlamaTokenizer:Wn,XLMRobertaTokenizer:ei,MPNetTokenizer:Bn,FalconTokenizer:Je,GPTNeoXTokenizer:qt,EsmTokenizer:Pt,Wav2Vec2CTCTokenizer:Hi,BlenderbotTokenizer:ot,BlenderbotSmallTokenizer:lt,SpeechT5Tokenizer:wt,NougatTokenizer:mn,VitsTokenizer:os,Qwen2Tokenizer:kt,GemmaTokenizer:An,Grok1Tokenizer:zn,CohereTokenizer:Yr,MgpstrTokenizer:ls,PreTrainedTokenizer:xt})},"./src/utils/audio.js":(e,t,n)=>{n.r(t),n.d(t,{RawAudio:()=>W,hamming:()=>d,hanning:()=>f,mel_filter_bank:()=>T,read_audio:()=>u,spectrogram:()=>P,window_function:()=>O});var i=n("./src/utils/hub.js"),r=n("./src/utils/maths.js"),s=n("./src/utils/core.js"),a=n("./src/env.js"),o=n("./src/utils/tensor.js"),l=n("?7992");async function u(V,te){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const J=await(await(0,i.getFile)(V)).arrayBuffer(),j=new AudioContext({sampleRate:te});typeof te>"u"&&console.warn(`No sampling rate provided, using default of ${j.sampleRate}Hz.`);const Y=await j.decodeAudioData(J);let X;if(Y.numberOfChannels===2){const ce=Math.sqrt(2),me=Y.getChannelData(0),Q=Y.getChannelData(1);X=new Float32Array(me.length);for(let H=0;H<Y.length;++H)X[H]=ce*(me[H]+Q[H])/2}else X=Y.getChannelData(0);return X}function c(V,te){if(V<1)return new Float64Array;if(V===1)return new Float64Array([1]);const J=1-te,j=2*Math.PI/(V-1),Y=new Float64Array(V);for(let X=0;X<V;++X)Y[X]=te-J*Math.cos(X*j);return Y}function f(V){return c(V,.5)}function d(V){return c(V,.54)}const h={htk:V=>2595*Math.log10(1+V/700),kaldi:V=>1127*Math.log(1+V/700),slaney:(V,te=1e3,J=15,j=27/Math.log(6.4))=>V>=te?J+Math.log(V/te)*j:3*V/200};function m(V,te="htk"){const J=h[te];if(!J)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof V=="number"?J(V):V.map(j=>J(j))}const y={htk:V=>700*(10**(V/2595)-1),kaldi:V=>700*(Math.exp(V/1127)-1),slaney:(V,te=1e3,J=15,j=Math.log(6.4)/27)=>V>=J?te*Math.exp(j*(V-J)):200*V/3};function M(V,te="htk"){const J=y[te];if(!J)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof V=="number"?J(V):V.map(j=>J(j))}function g(V,te){const J=Float64Array.from({length:te.length-1},(ce,me)=>te[me+1]-te[me]),j=Array.from({length:V.length},()=>new Array(te.length));for(let ce=0;ce<V.length;++ce){const me=j[ce];for(let Q=0;Q<te.length;++Q)me[Q]=te[Q]-V[ce]}const Y=te.length-2,X=Array.from({length:Y},()=>new Array(V.length));for(let ce=0;ce<V.length;++ce){const me=j[ce];for(let Q=0;Q<Y;++Q){const H=-me[Q]/J[Q],B=me[Q+2]/J[Q+1];X[Q][ce]=Math.max(0,Math.min(H,B))}}return X}function _(V,te,J){const j=(te-V)/(J-1);return Float64Array.from({length:J},(Y,X)=>V+j*X)}function T(V,te,J,j,Y,X=null,ce="htk",me=!1){if(X!==null&&X!=="slaney")throw new Error('norm must be one of null or "slaney"');if(V<2)throw new Error(`Require num_frequency_bins: ${V} >= 2`);if(J>j)throw new Error(`Require min_frequency: ${J} <= max_frequency: ${j}`);const Q=m(J,ce),H=m(j,ce),B=_(Q,H,te+2);let ee=M(B,ce),_e;if(me){const ae=Y/((V-1)*2);_e=m(Float64Array.from({length:V},(Ne,Ye)=>Ye*ae),ce),ee=B}else _e=_(0,Math.floor(Y/2),V);const le=g(_e,ee);if(X!==null&&X==="slaney")for(let ae=0;ae<te;++ae){const Ne=le[ae],Ye=2/(ee[ae+2]-ee[ae]);for(let ze=0;ze<V;++ze)Ne[ze]*=Ye}return le}function x(V,te,J){const j=new V.constructor(V.length+te+J),Y=V.length-1;for(let X=0;X<V.length;++X)j[te+X]=V[X];for(let X=1;X<=te;++X)j[te-X]=V[(0,s.calculateReflectOffset)(X,Y)];for(let X=1;X<=J;++X)j[Y+te+X]=V[(0,s.calculateReflectOffset)(Y-X,Y)];return j}function S(V,te,J,j,Y){if(J<=0)throw new Error("reference must be greater than zero");if(j<=0)throw new Error("min_value must be greater than zero");J=Math.max(j,J);const X=Math.log10(J);for(let ce=0;ce<V.length;++ce)V[ce]=te*Math.log10(Math.max(j,V[ce])-X);if(Y!==null){if(Y<=0)throw new Error("db_range must be greater than zero");const ce=(0,r.max)(V)[0]-Y;for(let me=0;me<V.length;++me)V[me]=Math.max(V[me],ce)}return V}function $(V,te=1,J=1e-5,j=null){return S(V,20,te,J,j)}function C(V,te=1,J=1e-10,j=null){return S(V,10,te,J,j)}async function P(V,te,J,j,{fft_length:Y=null,power:X=1,center:ce=!0,pad_mode:me="reflect",onesided:Q=!0,preemphasis:H=null,preemphasis_htk_flavor:B=!0,mel_filters:ee=null,mel_floor:_e=1e-10,log_mel:le=null,reference:ae=1,min_value:Ne=1e-10,db_range:Ye=null,remove_dc_offset:ze=null,min_num_frames:ue=null,max_num_frames:U=null,do_pad:we=!0,transpose:Pe=!1,mel_offset:ke=0}={}){const Le=te.length;if(Y===null&&(Y=J),J>Y)throw Error(`frame_length (${J}) may not be larger than fft_length (${Y})`);if(Le!==J)throw new Error(`Length of the window (${Le}) must equal frame_length (${J})`);if(j<=0)throw new Error("hop_length must be greater than zero");if(X===null&&ee!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(!B)throw new Error("`preemphasis_htk_flavor=false` is not currently supported.");if(ce)switch(me){case"reflect":{const Se=Math.floor((Y-1)/2)+1;V=x(V,Se,Se);break}case"constant":{const Se=Math.floor(Y/2),Oe=new V.constructor(V.length+2*Se);Oe.set(V,Se),V=Oe;break}default:throw new Error(`pad_mode="${me}" not implemented yet.`)}let Ge=Math.floor(1+Math.floor((V.length-J)/j));ue!==null&&Ge<ue&&(Ge=ue);const $e=Q?Math.floor(Y/2)+1:Y;let et=Ge,Ce=Ge;U!==null&&(U>Ge?we&&(Ce=U):Ce=et=U);const He=new r.FFT(Y),at=new Float64Array(Y),Z=new Float64Array(He.outputBufferSize),he=new Float32Array($e*Ce);for(let Se=0;Se<et;++Se){const Oe=Se*j,ct=Math.min(V.length-Oe,J);ct!==J&&at.fill(0,0,J);for(let bt=0;bt<ct;++bt)at[bt]=V[Oe+bt];if(ze){let bt=0;for(let Et=0;Et<ct;++Et)bt+=at[Et];const Ct=bt/ct;for(let Et=0;Et<ct;++Et)at[Et]-=Ct}if(H!==null){for(let bt=ct-1;bt>=1;--bt)at[bt]-=H*at[bt-1];at[0]*=1-H}for(let bt=0;bt<te.length;++bt)at[bt]*=te[bt];He.realTransform(Z,at);for(let bt=0;bt<$e;++bt){const Ct=bt<<1;he[bt*Ce+Se]=Z[Ct]**2+Z[Ct+1]**2}}if(X!==null&&X!==2){const Se=X/2;for(let Oe=0;Oe<he.length;++Oe)he[Oe]**=Se}const ye=ee.length;let Ke=await(0,o.matmul)(new o.Tensor("float32",ee.flat(),[ye,$e]),new o.Tensor("float32",he,[$e,Ce]));Pe&&(Ke=Ke.transpose(1,0));const Be=Ke.data;for(let Se=0;Se<Be.length;++Se)Be[Se]=ke+Math.max(_e,Be[Se]);if(X!==null&&le!==null){const Se=Math.min(Be.length,et*ye);switch(le){case"log":for(let Oe=0;Oe<Se;++Oe)Be[Oe]=Math.log(Be[Oe]);break;case"log10":for(let Oe=0;Oe<Se;++Oe)Be[Oe]=Math.log10(Be[Oe]);break;case"dB":if(X===1)$(Be,ae,Ne,Ye);else if(X===2)C(Be,ae,Ne,Ye);else throw new Error(`Cannot use log_mel option '${le}' with power ${X}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${le}'`)}}return Ke}function O(V,te,{periodic:J=!0,frame_length:j=null,center:Y=!0}={}){const X=J?V+1:V;let ce;switch(te){case"boxcar":ce=new Float64Array(X).fill(1);break;case"hann":case"hann_window":ce=f(X);break;case"hamming":ce=d(X);break;case"povey":ce=f(X).map(me=>Math.pow(me,.85));break;default:throw new Error(`Unknown window type ${te}.`)}if(J&&(ce=ce.subarray(0,V)),j===null)return ce;if(V>j)throw new Error(`Length of the window (${V}) may not be larger than frame_length (${j})`);return ce}function R(V,te){let J=44;const j=new ArrayBuffer(J+V.length*4),Y=new DataView(j);G(Y,0,"RIFF"),Y.setUint32(4,36+V.length*4,!0),G(Y,8,"WAVE"),G(Y,12,"fmt "),Y.setUint32(16,16,!0),Y.setUint16(20,3,!0),Y.setUint16(22,1,!0),Y.setUint32(24,te,!0),Y.setUint32(28,te*4,!0),Y.setUint16(32,4,!0),Y.setUint16(34,32,!0),G(Y,36,"data"),Y.setUint32(40,V.length*4,!0);for(let X=0;X<V.length;++X,J+=4)Y.setFloat32(J,V[X],!0);return j}function G(V,te,J){for(let j=0;j<J.length;++j)V.setUint8(te+j,J.charCodeAt(j))}class W{constructor(te,J){this.audio=te,this.sampling_rate=J}toWav(){return R(this.audio,this.sampling_rate)}toBlob(){const te=this.toWav();return new Blob([te],{type:"audio/wav"})}async save(te){let J;if(a.apis.IS_BROWSER_ENV){if(a.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save a file from a Web Worker.");J=s.saveBlob}else if(a.apis.IS_FS_AVAILABLE)J=async(j,Y)=>{let X=await Y.arrayBuffer();l.writeFileSync(j,Buffer.from(X))};else throw new Error("Unable to save because filesystem is disabled in this environment.");await J(te,this.toBlob())}}},"./src/utils/constants.js":(e,t,n)=>{n.r(t),n.d(t,{CHAT_TEMPLATE_NAME:()=>l,CONFIG_NAME:()=>r,FEATURE_EXTRACTOR_NAME:()=>s,GENERATION_CONFIG_NAME:()=>u,GITHUB_ISSUE_URL:()=>i,IMAGE_PROCESSOR_NAME:()=>a,PROCESSOR_NAME:()=>o});const i="https://github.com/huggingface/transformers.js/issues/new/choose",r="config.json",s="preprocessor_config.json",a=s,o="processor_config.json",l="chat_template.jinja",u="generation_config.json"},"./src/utils/core.js":(e,t,n)=>{n.r(t),n.d(t,{calculateDimensions:()=>u,calculateReflectOffset:()=>h,count:()=>g,dispatchCallback:()=>i,escapeRegExp:()=>s,isIntegralNumber:()=>o,isNullishDimension:()=>l,isTypedArray:()=>a,len:()=>M,mergeArrays:()=>f,pick:()=>y,pop:()=>c,product:()=>d,reverseDictionary:()=>r,saveBlob:()=>m});function i(_,T){_&&_(T)}function r(_){return Object.fromEntries(Object.entries(_).map(([T,x])=>[x,T]))}function s(_){return _.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function a(_){var T,x,S;return((S=(x=(T=_==null?void 0:_.prototype)==null?void 0:T.__proto__)==null?void 0:x.constructor)==null?void 0:S.name)==="TypedArray"}function o(_){return Number.isInteger(_)||typeof _=="bigint"}function l(_){return _==null||_===-1}function u(_){const T=[];let x=_;for(;Array.isArray(x);)T.push(x.length),x=x[0];return T}function c(_,T,x=void 0){const S=_[T];if(S!==void 0)return delete _[T],S;if(x===void 0)throw Error(`Key ${T} does not exist in object.`);return x}function f(..._){return Array.prototype.concat.apply([],_)}function d(..._){return _.reduce((T,x)=>T.flatMap(S=>x.map($=>[S,$])))}function h(_,T){return Math.abs((_+T)%(2*T)-T)}function m(_,T){const x=URL.createObjectURL(T),S=document.createElement("a");S.href=x,S.download=_,S.click(),S.remove(),URL.revokeObjectURL(x)}function y(_,T){return Object.assign({},...T.map(x=>{if(_[x]!==void 0)return{[x]:_[x]}}))}function M(_){let T=0;for(const x of _)++T;return T}function g(_,T){let x=0;for(const S of _)S===T&&++x;return x}},"./src/utils/data-structures.js":(e,t,n)=>{n.r(t),n.d(t,{CharTrie:()=>r,DictionarySplitter:()=>l,LRUCache:()=>u,PriorityQueue:()=>i,TokenLattice:()=>a});class i{constructor(f=(h,m)=>h>m,d=1/0){this._heap=[],this._comparator=f,this._maxSize=d}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...f){return this.extend(f)}extend(f){for(const d of f)if(this.size<this._maxSize)this._heap.push(d),this._siftUp();else{const h=this._smallest();this._comparator(d,this._heap[h])&&(this._heap[h]=d,this._siftUpFrom(h))}return this.size}pop(){const f=this.peek(),d=this.size-1;return d>0&&this._swap(0,d),this._heap.pop(),this._siftDown(),f}replace(f){const d=this.peek();return this._heap[0]=f,this._siftDown(),d}_parent(f){return(f+1>>>1)-1}_left(f){return(f<<1)+1}_right(f){return f+1<<1}_greater(f,d){return this._comparator(this._heap[f],this._heap[d])}_swap(f,d){const h=this._heap[f];this._heap[f]=this._heap[d],this._heap[d]=h}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(f){for(;f>0&&this._greater(f,this._parent(f));)this._swap(f,this._parent(f)),f=this._parent(f)}_siftDown(){let f=0;for(;this._left(f)<this.size&&this._greater(this._left(f),f)||this._right(f)<this.size&&this._greater(this._right(f),f);){const d=this._right(f)<this.size&&this._greater(this._right(f),this._left(f))?this._right(f):this._left(f);this._swap(f,d),f=d}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class r{constructor(){this.root=s.default()}extend(f){for(const d of f)this.push(d)}push(f){let d=this.root;for(const h of f){let m=d.children.get(h);m===void 0&&(m=s.default(),d.children.set(h,m)),d=m}d.isLeaf=!0}*commonPrefixSearch(f){let d=this.root;if(d===void 0)return;let h="";for(const m of f){if(h+=m,d=d.children.get(m),d===void 0)return;d.isLeaf&&(yield h)}}}class s{constructor(f,d){this.isLeaf=f,this.children=d}static default(){return new s(!1,new Map)}}class a{constructor(f,d,h){this.chars=Array.from(f),this.len=this.chars.length,this.bosTokenId=d,this.eosTokenId=h,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const m=new o(this.bosTokenId,0,0,0,0),y=new o(this.eosTokenId,1,this.len,0,0);this.nodes.push(m.clone()),this.nodes.push(y.clone()),this.beginNodes[this.len].push(y),this.endNodes[0].push(m)}insert(f,d,h,m){const y=this.nodes.length,M=new o(m,y,f,d,h);this.beginNodes[f].push(M),this.endNodes[f+d].push(M),this.nodes.push(M)}viterbi(){const f=this.len;let d=0;for(;d<=f;){if(this.beginNodes[d].length==0)return[];for(let g of this.beginNodes[d]){g.prev=null;let _=0,T=null;for(let x of this.endNodes[d]){const S=x.backtraceScore+g.score;(T===null||S>_)&&(T=x.clone(),_=S)}if(T!==null)g.prev=T,g.backtraceScore=_;else return[]}++d}const h=[],y=this.beginNodes[f][0].prev;if(y===null)return[];let M=y.clone();for(;M.prev!==null;)h.push(M.clone()),M=M.clone().prev.clone();return h.reverse(),h}piece(f){return this.chars.slice(f.pos,f.pos+f.length).join("")}tokens(){return this.viterbi().map(d=>this.piece(d))}tokenIds(){return this.viterbi().map(d=>d.tokenId)}}class o{constructor(f,d,h,m,y){this.tokenId=f,this.nodeId=d,this.pos=h,this.length=m,this.score=y,this.prev=null,this.backtraceScore=0}clone(){const f=new o(this.tokenId,this.nodeId,this.pos,this.length,this.score);return f.prev=this.prev,f.backtraceScore=this.backtraceScore,f}}class l{constructor(f){this.trie=this._buildTrie(f)}_buildTrie(f){var h;const d=Object.create(null);for(const m of f){let y=d;for(let M=0;M<m.length;++M)y=y[h=m[M]]??(y[h]=Object.create(null));y.end=m}return d}split(f){const d=[],h=f.length;let m=0,y=0;for(;y<h;){let M=this.trie,g=null,_=y;for(;_<h&&(M=M[f[_]]);)M.end&&(g=M.end),++_;g?(y>m&&d.push(f.slice(m,y)),d.push(g),y+=g.length,m=y):++y}return m<h&&d.push(f.slice(m)),d}}class u{constructor(f){this.capacity=f,this.cache=new Map}get(f){if(!this.cache.has(f))return;const d=this.cache.get(f);return this.cache.delete(f),this.cache.set(f,d),d}put(f,d){this.cache.has(f)&&this.cache.delete(f),this.cache.set(f,d),this.cache.size>this.capacity&&this.cache.delete(this.cache.keys().next().value)}clear(){this.cache.clear()}}},"./src/utils/devices.js":(e,t,n)=>{n.r(t),n.d(t,{DEVICE_TYPES:()=>i});const i=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(e,t,n)=>{n.r(t),n.d(t,{DATA_TYPES:()=>a,DEFAULT_DEVICE_DTYPE_MAPPING:()=>o,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>l,isWebGpuFp16Supported:()=>s});var i=n("./src/env.js"),r=n("./src/utils/devices.js");const s=function(){let u;return async function(){if(u===void 0)if(!i.apis.IS_WEBGPU_AVAILABLE)u=!1;else try{u=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{u=!1}return u}}(),a=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),o=Object.freeze({[r.DEVICE_TYPES.wasm]:a.q8}),l=Object.freeze({[a.fp32]:"",[a.fp16]:"_fp16",[a.int8]:"_int8",[a.uint8]:"_uint8",[a.q8]:"_quantized",[a.q4]:"_q4",[a.q4f16]:"_q4f16",[a.bnb4]:"_bnb4"})},"./src/utils/generic.js":(e,t,n)=>{n.r(t),n.d(t,{Callable:()=>i});const i=class{constructor(){let r=function(...s){return r._call(...s)};return Object.setPrototypeOf(r,new.target.prototype)}_call(...r){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(e,t,n)=>{n.r(t),n.d(t,{MAX_EXTERNAL_DATA_CHUNKS:()=>o,getFile:()=>h,getModelFile:()=>_,getModelJSON:()=>x,getModelText:()=>T});var i=n("?7992"),r=n("?5af5"),s=n("./src/env.js"),a=n("./src/utils/core.js");const o=100,l={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class u{constructor(P){if(this.filePath=P,this.headers=new Headers,this.exists=i.existsSync(P),this.exists){this.status=200,this.statusText="OK";let O=i.statSync(P);this.headers.set("content-length",O.size.toString()),this.updateContentType();const R=i.createReadStream(P);this.body=new ReadableStream({start(G){R.on("data",W=>G.enqueue(W)),R.on("end",()=>G.close()),R.on("error",W=>G.error(W))},cancel(){R.destroy()}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const P=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",l[P]??"application/octet-stream")}clone(){let P=new u(this.filePath);return P.exists=this.exists,P.status=this.status,P.statusText=this.statusText,P.headers=new Headers(this.headers),P}async arrayBuffer(){return(await i.promises.readFile(this.filePath)).buffer}async blob(){const P=await i.promises.readFile(this.filePath);return new Blob([P],{type:this.headers.get("content-type")})}async text(){return await i.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function c(C,P=null,O=null){let R;try{R=new URL(C)}catch{return!1}return!(P&&!P.includes(R.protocol)||O&&!O.includes(R.hostname))}const f=/^(\b[\w\-.]+\b\/)?\b[\w\-.]{1,96}\b$/;function d(C){return!(!f.test(C)||C.includes("..")||C.includes("--")||C.endsWith(".git")||C.endsWith(".ipynb"))}async function h(C){var P;if(s.env.useFS&&!c(C,["http:","https:","blob:"]))return new u(C instanceof URL?C.protocol==="file:"?C.pathname:C.toString():C);if(typeof process<"u"&&((P=process==null?void 0:process.release)==null?void 0:P.name)==="node"){const O=!!(wo!=null&&wo.TESTING_REMOTELY),R=s.env.version,G=new Headers;if(G.set("User-Agent",`transformers.js/${R}; is_ci/${O};`),c(C,["http:","https:"],["huggingface.co","hf.co"])){const V=(wo==null?void 0:wo.HF_TOKEN)??(wo==null?void 0:wo.HF_ACCESS_TOKEN);V&&G.set("Authorization",`Bearer ${V}`)}return fetch(C,{headers:G})}else return fetch(C)}const m={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function y(C,P,O){if(!O)return null;const R=m[C]??`Error (${C}) occurred while trying to load file`;throw Error(`${R}: "${P}".`)}class M{constructor(P){this.path=P}async match(P){let O=r.join(this.path,P),R=new u(O);if(R.exists)return R}async put(P,O,R=void 0){let G=r.join(this.path,P);try{const W=O.headers.get("Content-Length"),V=parseInt(W??"0");let te=0;await i.promises.mkdir(r.dirname(G),{recursive:!0});const J=i.createWriteStream(G),j=O.body.getReader();for(;;){const{done:Y,value:X}=await j.read();if(Y)break;await new Promise((me,Q)=>{J.write(X,H=>{if(H){Q(H);return}me()})}),te+=X.length;const ce=V?te/V*100:0;R==null||R({progress:ce,loaded:te,total:V})}J.close()}catch(W){try{await i.promises.unlink(G)}catch{}throw W}}}async function g(C,...P){for(let O of P)try{let R=await C.match(O);if(R)return R}catch{continue}}async function _(C,P,O=!0,R={},G=!1){if(!s.env.allowLocalModels){if(R.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!s.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,a.dispatchCallback)(R.progress_callback,{status:"initiate",name:C,file:P});let W;if(!W&&s.env.useCustomCache){if(!s.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!s.env.customCache.match||!s.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");W=s.env.customCache}if(!W&&s.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{W=await caches.open("transformers-cache")}catch(_e){console.warn("An error occurred while opening the browser cache:",_e)}}if(!W&&s.env.useFSCache){if(!s.apis.IS_FS_AVAILABLE)throw Error("File System Cache is not available in this environment.");W=new M(R.cache_dir??s.env.cacheDir)}const V=R.revision??"main",te=$(C,P),J=d(C),j=J?$(s.env.localModelPath,te):te,Y=$(s.env.remoteHost,s.env.remotePathTemplate.replaceAll("{model}",C).replaceAll("{revision}",encodeURIComponent(V)),P);let X;const ce=W instanceof M?V==="main"?te:$(C,V,P):Y;let me=!1,Q;W&&(Q=await g(W,j,ce));const H=Q!==void 0;if(Q===void 0){if(s.env.allowLocalModels)if(c(te,["http:","https:"])){if(R.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${te}.`);if(!s.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${te}.`)}else try{Q=await h(j),X=j}catch(le){console.warn(`Unable to load from local path "${j}": "${le}"`)}if(Q===void 0||Q.status===404){if(R.local_files_only||!s.env.allowRemoteModels){if(O)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${j}".`);return null}if(!J)throw Error(`Local file missing at "${j}" and download aborted due to invalid model ID "${C}".`);if(Q=await h(Y),Q.status!==200)return y(Q.status,Y,O);X=ce}me=W&&typeof Response<"u"&&Q instanceof Response&&Q.status===200}(0,a.dispatchCallback)(R.progress_callback,{status:"download",name:C,file:P});let B;if(!(s.apis.IS_NODE_ENV&&G)){let _e;R.progress_callback?H&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(_e=new Uint8Array(await Q.arrayBuffer()),(0,a.dispatchCallback)(R.progress_callback,{status:"progress",name:C,file:P,progress:100,loaded:_e.length,total:_e.length})):_e=await S(Q,le=>{(0,a.dispatchCallback)(R.progress_callback,{status:"progress",name:C,file:P,...le})}):_e=new Uint8Array(await Q.arrayBuffer()),B=_e}if(me&&X&&await W.match(X)===void 0)if(B)await W.put(X,new Response(B,{headers:Q.headers})).catch(_e=>{console.warn(`Unable to add response to browser cache: ${_e}.`)});else{const _e=R.progress_callback?le=>(0,a.dispatchCallback)(R.progress_callback,{status:"progress",name:C,file:P,...le}):void 0;await W.put(X,Q,_e)}if((0,a.dispatchCallback)(R.progress_callback,{status:"done",name:C,file:P}),B){if(!s.apis.IS_NODE_ENV&&G)throw new Error("Cannot return path in a browser environment.");return B}if(Q instanceof u)return Q.filePath;const ee=await(W==null?void 0:W.match(X));if(ee instanceof u)return ee.filePath;if(ee instanceof Response)return new Uint8Array(await ee.arrayBuffer());if(typeof ee=="string")return ee;throw new Error("Unable to get model file path or buffer.")}async function T(C,P,O=!0,R={}){const G=await _(C,P,O,R,!1);return G===null?null:new TextDecoder("utf-8").decode(G)}async function x(C,P,O=!0,R={}){const G=await T(C,P,O,R);return G===null?{}:JSON.parse(G)}async function S(C,P){const O=C.headers.get("Content-Length");O===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let R=parseInt(O??"0"),G=new Uint8Array(R),W=0;const V=C.body.getReader();async function te(){const{done:J,value:j}=await V.read();if(J)return;const Y=W+j.length;if(Y>R){R=Y;const ce=new Uint8Array(R);ce.set(G),G=ce}G.set(j,W),W=Y;const X=W/R*100;return P({progress:X,loaded:W,total:R}),te()}return await te(),G}function $(...C){return C=C.map((P,O)=>(O&&(P=P.replace(new RegExp("^/"),"")),O!==C.length-1&&(P=P.replace(new RegExp("/$"),"")),P)),C.join("/")}},"./src/utils/image.js":(e,t,n)=>{n.r(t),n.d(t,{RawImage:()=>m,load_image:()=>y});var i=n("./src/utils/core.js"),r=n("./src/utils/hub.js"),s=n("./src/env.js"),a=n("./src/utils/tensor.js"),o=n("?2b25");let l,u,c;const f=s.apis.IS_BROWSER_ENV||s.apis.IS_WEBWORKER_ENV;if(f)l=(M,g)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(M,g)},c=self.createImageBitmap,u=self.ImageData;else if(o)c=async M=>{const _=(await M.metadata()).channels,{data:T,info:x}=await M.rotate().raw().toBuffer({resolveWithObject:!0}),S=new m(new Uint8ClampedArray(T),x.width,x.height,x.channels);return _!==void 0&&_!==x.channels&&S.convert(_),S};else throw new Error("Unable to load image processing library.");const d={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},h=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class m{constructor(g,_,T,x){this.data=g,this.width=_,this.height=T,this.channels=x}get size(){return[this.width,this.height]}static async read(g){if(g instanceof m)return g;if(typeof g=="string"||g instanceof URL)return await this.fromURL(g);if(g instanceof Blob)return await this.fromBlob(g);if(typeof HTMLCanvasElement<"u"&&g instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&g instanceof OffscreenCanvas)return this.fromCanvas(g);throw new Error(`Unsupported input type: ${typeof g}`)}static fromCanvas(g){if(!f)throw new Error("fromCanvas() is only supported in browser environments.");const T=g.getContext("2d").getImageData(0,0,g.width,g.height).data;return new m(T,g.width,g.height,4)}static async fromURL(g){const _=await(0,r.getFile)(g);if(_.status!==200)throw new Error(`Unable to read image from "${g}" (${_.status} ${_.statusText})`);const T=await _.blob();return this.fromBlob(T)}static async fromBlob(g){if(f){const _=await c(g),T=l(_.width,_.height).getContext("2d");return T.drawImage(_,0,0),new this(T.getImageData(0,0,_.width,_.height).data,_.width,_.height,4)}else{const _=o(await g.arrayBuffer());return await c(_)}}static fromTensor(g,_="CHW"){if(g.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${g.dims.length} dimensions.`);if(_==="CHW")g=g.transpose(1,2,0);else if(_!=="HWC")throw new Error(`Unsupported channel format: ${_}`);if(!(g.data instanceof Uint8ClampedArray||g.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${g.type}`);switch(g.dims[2]){case 1:case 2:case 3:case 4:return new m(g.data,g.dims[1],g.dims[0],g.dims[2]);default:throw new Error(`Unsupported number of channels: ${g.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const g=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let _=0,T=0;_<this.data.length;_+=this.channels){const x=this.data[_],S=this.data[_+1],$=this.data[_+2];g[T++]=Math.round(.2989*x+.587*S+.114*$)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(g,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const g=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let _=0,T=0;_<this.data.length;++_)g[T++]=this.data[_],g[T++]=this.data[_],g[T++]=this.data[_];break;case 4:for(let _=0,T=0;_<this.data.length;_+=4)g[T++]=this.data[_],g[T++]=this.data[_+1],g[T++]=this.data[_+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(g,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const g=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let _=0,T=0;_<this.data.length;++_)g[T++]=this.data[_],g[T++]=this.data[_],g[T++]=this.data[_],g[T++]=255;break;case 3:for(let _=0,T=0;_<this.data.length;_+=3)g[T++]=this.data[_],g[T++]=this.data[_+1],g[T++]=this.data[_+2],g[T++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(g,this.width,this.height,4)}putAlpha(g){if(g.width!==this.width||g.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${g.width}x${g.height}`);if(g.channels!==1)throw new Error(`Expected mask to have 1 channel, but got ${g.channels}`);const _=this.data,T=g.data,x=this.width*this.height;if(this.channels===3){const S=new Uint8ClampedArray(x*4);for(let $=0,C=0,P=0;$<x;++$)S[P++]=_[C++],S[P++]=_[C++],S[P++]=_[C++],S[P++]=T[$];return this._update(S,this.width,this.height,4)}else if(this.channels===4){for(let S=0;S<x;++S)_[4*S+3]=T[S];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(g,_,{resample:T=2}={}){if(this.width===g&&this.height===_)return this;let x=d[T]??T;const S=(0,i.isNullishDimension)(g),$=(0,i.isNullishDimension)(_);if(S&&$)return this;if(S?g=_/this.height*this.width:$&&(_=g/this.width*this.height),f){const C=this.channels,P=this.toCanvas(),O=l(g,_).getContext("2d");return O.drawImage(P,0,0,g,_),new m(O.getImageData(0,0,g,_).data,g,_,4).convert(C)}else{let C=this.toSharp();switch(x){case"box":case"hamming":(x==="box"||x==="hamming")&&(console.warn(`Resampling method ${x} is not yet supported. Using bilinear instead.`),x="bilinear");case"nearest":case"bilinear":case"bicubic":C=C.affine([g/this.width,0,0,_/this.height],{interpolator:x});break;case"lanczos":C=C.resize({width:g,height:_,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${x} is not supported.`)}return await c(C)}}async pad([g,_,T,x]){if(g=Math.max(g,0),_=Math.max(_,0),T=Math.max(T,0),x=Math.max(x,0),g===0&&_===0&&T===0&&x===0)return this;if(f){const S=this.channels,$=this.toCanvas(),C=this.width+g+_,P=this.height+T+x,O=l(C,P).getContext("2d");return O.drawImage($,0,0,this.width,this.height,g,T,this.width,this.height),new m(O.getImageData(0,0,C,P).data,C,P,4).convert(S)}else{const S=this.toSharp().extend({left:g,right:_,top:T,bottom:x});return await c(S)}}async crop([g,_,T,x]){if(g=Math.max(g,0),_=Math.max(_,0),T=Math.min(T,this.width-1),x=Math.min(x,this.height-1),g===0&&_===0&&T===this.width-1&&x===this.height-1)return this;const S=T-g+1,$=x-_+1;if(f){const C=this.channels,P=this.toCanvas(),O=l(S,$).getContext("2d");return O.drawImage(P,g,_,S,$,0,0,S,$),new m(O.getImageData(0,0,S,$).data,S,$,4).convert(C)}else{const C=this.toSharp().extract({left:g,top:_,width:S,height:$});return await c(C)}}async center_crop(g,_){if(this.width===g&&this.height===_)return this;const T=(this.width-g)/2,x=(this.height-_)/2;if(f){const S=this.channels,$=this.toCanvas(),C=l(g,_).getContext("2d");let P=0,O=0,R=0,G=0;return T>=0?P=T:R=-T,x>=0?O=x:G=-x,C.drawImage($,P,O,g,_,R,G,g,_),new m(C.getImageData(0,0,g,_).data,g,_,4).convert(S)}else{let S=this.toSharp();if(T>=0&&x>=0)S=S.extract({left:Math.floor(T),top:Math.floor(x),width:g,height:_});else if(T<=0&&x<=0){const $=Math.floor(-x),C=Math.floor(-T);S=S.extend({top:$,left:C,right:g-this.width-C,bottom:_-this.height-$})}else{let $=[0,0],C=0;x<0?($[0]=Math.floor(-x),$[1]=_-this.height-$[0]):C=Math.floor(x);let P=[0,0],O=0;T<0?(P[0]=Math.floor(-T),P[1]=g-this.width-P[0]):O=Math.floor(T),S=S.extend({top:$[0],bottom:$[1],left:P[0],right:P[1]}).extract({left:O,top:C,width:g,height:_})}return await c(S)}}async toBlob(g="image/png",_=1){if(!f)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:g,quality:_})}toTensor(g="CHW"){let _=new a.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(g!=="HWC")if(g==="CHW")_=_.permute(2,0,1);else throw new Error(`Unsupported channel format: ${g}`);return _}toCanvas(){if(!f)throw new Error("toCanvas() is only supported in browser environments.");const g=this.clone().rgba(),_=l(g.width,g.height),T=new u(g.data,g.width,g.height);return _.getContext("2d").putImageData(T,0,0),_}split(){const{data:g,width:_,height:T,channels:x}=this,S=g.constructor,$=g.length/x,C=Array.from({length:x},()=>new S($));for(let P=0;P<$;++P){const O=x*P;for(let R=0;R<x;++R)C[R][P]=g[O+R]}return C.map(P=>new m(P,_,T,1))}_update(g,_,T,x=null){return this.data=g,this.width=_,this.height=T,x!==null&&(this.channels=x),this}clone(){return new m(this.data.slice(),this.width,this.height,this.channels)}convert(g){if(this.channels===g)return this;switch(g){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(g){if(f){if(s.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const _=g.split(".").pop().toLowerCase(),T=h.get(_)??"image/png",x=await this.toBlob(T);(0,i.saveBlob)(g,x)}else{if(s.apis.IS_FS_AVAILABLE)return await this.toSharp().toFile(g);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(f)throw new Error("toSharp() is only supported in server-side environments.");return o(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const y=m.read.bind(m)},"./src/utils/maths.js":(e,t,n)=>{n.r(t),n.d(t,{FFT:()=>y,bankers_round:()=>_,cos_sim:()=>l,dot:()=>o,dynamic_time_warping:()=>T,interpolate_data:()=>i,log_softmax:()=>a,magnitude:()=>u,max:()=>f,medianFilter:()=>M,min:()=>c,permute_data:()=>r,round:()=>g,softmax:()=>s});function i(x,[S,$,C],[P,O],R="bilinear",G=!1){const W=O/C,V=P/$,te=new x.constructor(P*O*S),J=$*C,j=P*O;for(let Y=0;Y<P;++Y)for(let X=0;X<O;++X){const ce=Y*O+X,me=(X+.5)/W-.5,Q=(Y+.5)/V-.5;let H=Math.floor(me),B=Math.floor(Q);const ee=Math.min(H+1,C-1),_e=Math.min(B+1,$-1);H=Math.max(H,0),B=Math.max(B,0);const le=me-H,ae=Q-B,Ne=(1-le)*(1-ae),Ye=le*(1-ae),ze=(1-le)*ae,ue=le*ae,U=B*C,we=_e*C,Pe=U+H,ke=U+ee,Le=we+H,Ge=we+ee;for(let $e=0;$e<S;++$e){const et=$e*J;te[$e*j+ce]=Ne*x[et+Pe]+Ye*x[et+ke]+ze*x[et+Le]+ue*x[et+Ge]}}return te}function r(x,S,$){const C=new Array($.length),P=new Array($.length);for(let G=$.length-1,W=1;G>=0;--G)P[G]=W,C[G]=S[$[G]],W*=C[G];const O=$.map((G,W)=>P[$.indexOf(W)]),R=new x.constructor(x.length);for(let G=0;G<x.length;++G){let W=0;for(let V=S.length-1,te=G;V>=0;--V)W+=te%S[V]*O[V],te=Math.floor(te/S[V]);R[W]=x[G]}return[R,C]}function s(x){const S=f(x)[0],$=x.map(O=>Math.exp(O-S)),C=$.reduce((O,R)=>O+R,0);return $.map(O=>O/C)}function a(x){const S=f(x)[0];let $=0;for(let O=0;O<x.length;++O)$+=Math.exp(x[O]-S);const C=Math.log($);return x.map(O=>O-S-C)}function o(x,S){let $=0;for(let C=0;C<x.length;++C)$+=x[C]*S[C];return $}function l(x,S){const $=o(x,S),C=u(x),P=u(S);return $/(C*P)}function u(x){return Math.sqrt(x.reduce((S,$)=>S+$*$,0))}function c(x){if(x.length===0)throw Error("Array must not be empty");let S=x[0],$=0;for(let C=1;C<x.length;++C)x[C]<S&&(S=x[C],$=C);return[S,$]}function f(x){if(x.length===0)throw Error("Array must not be empty");let S=x[0],$=0;for(let C=1;C<x.length;++C)x[C]>S&&(S=x[C],$=C);return[S,$]}function d(x){return x>0&&(x&x-1)===0}class h{constructor(S){if(this.size=S|0,this.size<=1||!d(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=S<<1,this.table=new Float64Array(this.size*2);for(let C=0;C<this.table.length;C+=2){const P=Math.PI*C/this.size;this.table[C]=Math.cos(P),this.table[C+1]=-Math.sin(P)}let $=0;for(let C=1;this.size>C;C<<=1)++$;this._width=$%2===0?$-1:$,this._bitrev=new Int32Array(1<<this._width);for(let C=0;C<this._bitrev.length;++C){this._bitrev[C]=0;for(let P=0;P<this._width;P+=2){const O=this._width-P-2;this._bitrev[C]|=(C>>>P&3)<<O}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(S,$){const C=$||new Array(S.length>>>1);for(let P=0;P<S.length;P+=2)C[P>>>1]=S[P];return C}toComplexArray(S,$){const C=$||this.createComplexArray();for(let P=0;P<C.length;P+=2)C[P]=S[P>>>1],C[P+1]=0;return C}transform(S,$){if(S===$)throw new Error("Input and output buffers must be different");this._transform4(S,$,1)}realTransform(S,$){if(S===$)throw new Error("Input and output buffers must be different");this._realTransform4(S,$,1)}inverseTransform(S,$){if(S===$)throw new Error("Input and output buffers must be different");this._transform4(S,$,-1);for(let C=0;C<S.length;++C)S[C]/=this.size}_transform4(S,$,C){const P=this._csize;let R=1<<this._width,G=P/R<<1,W,V;const te=this._bitrev;if(G===4)for(W=0,V=0;W<P;W+=G,++V){const j=te[V];this._singleTransform2($,S,W,j,R)}else for(W=0,V=0;W<P;W+=G,++V){const j=te[V];this._singleTransform4($,S,W,j,R,C)}const J=this.table;for(R>>=2;R>=2;R>>=2){G=P/R<<1;const j=G>>>2;for(W=0;W<P;W+=G){const Y=W+j-1;for(let X=W,ce=0;X<Y;X+=2,ce+=R){const me=X,Q=me+j,H=Q+j,B=H+j,ee=S[me],_e=S[me+1],le=S[Q],ae=S[Q+1],Ne=S[H],Ye=S[H+1],ze=S[B],ue=S[B+1],U=J[ce],we=C*J[ce+1],Pe=le*U-ae*we,ke=le*we+ae*U,Le=J[2*ce],Ge=C*J[2*ce+1],$e=Ne*Le-Ye*Ge,et=Ne*Ge+Ye*Le,Ce=J[3*ce],He=C*J[3*ce+1],at=ze*Ce-ue*He,Z=ze*He+ue*Ce,he=ee+$e,ye=_e+et,Ke=ee-$e,Be=_e-et,Se=Pe+at,Oe=ke+Z,ct=C*(Pe-at),bt=C*(ke-Z);S[me]=he+Se,S[me+1]=ye+Oe,S[Q]=Ke+bt,S[Q+1]=Be-ct,S[H]=he-Se,S[H+1]=ye-Oe,S[B]=Ke-bt,S[B+1]=Be+ct}}}}_singleTransform2(S,$,C,P,O){const R=S[P],G=S[P+1],W=S[P+O],V=S[P+O+1];$[C]=R+W,$[C+1]=G+V,$[C+2]=R-W,$[C+3]=G-V}_singleTransform4(S,$,C,P,O,R){const G=O*2,W=O*3,V=S[P],te=S[P+1],J=S[P+O],j=S[P+O+1],Y=S[P+G],X=S[P+G+1],ce=S[P+W],me=S[P+W+1],Q=V+Y,H=te+X,B=V-Y,ee=te-X,_e=J+ce,le=j+me,ae=R*(J-ce),Ne=R*(j-me);$[C]=Q+_e,$[C+1]=H+le,$[C+2]=B+Ne,$[C+3]=ee-ae,$[C+4]=Q-_e,$[C+5]=H-le,$[C+6]=B-Ne,$[C+7]=ee+ae}_realTransform4(S,$,C){const P=this._csize;let R=1<<this._width,G=P/R<<1,W,V;const te=this._bitrev;if(G===4)for(W=0,V=0;W<P;W+=G,++V){const Y=te[V];this._singleRealTransform2($,S,W,Y>>>1,R>>>1)}else for(W=0,V=0;W<P;W+=G,++V){const Y=te[V];this._singleRealTransform4($,S,W,Y>>>1,R>>>1,C)}const J=this.table;for(R>>=2;R>=2;R>>=2){G=P/R<<1;const Y=G>>>1,X=Y>>>1,ce=X>>>1;for(W=0;W<P;W+=G)for(let me=0,Q=0;me<=ce;me+=2,Q+=R){const H=W+me,B=H+X,ee=B+X,_e=ee+X,le=S[H],ae=S[H+1],Ne=S[B],Ye=S[B+1],ze=S[ee],ue=S[ee+1],U=S[_e],we=S[_e+1],Pe=le,ke=ae,Le=J[Q],Ge=C*J[Q+1],$e=Ne*Le-Ye*Ge,et=Ne*Ge+Ye*Le,Ce=J[2*Q],He=C*J[2*Q+1],at=ze*Ce-ue*He,Z=ze*He+ue*Ce,he=J[3*Q],ye=C*J[3*Q+1],Ke=U*he-we*ye,Be=U*ye+we*he,Se=Pe+at,Oe=ke+Z,ct=Pe-at,bt=ke-Z,Ct=$e+Ke,Et=et+Be,hn=C*($e-Ke),En=C*(et-Be);if(S[H]=Se+Ct,S[H+1]=Oe+Et,S[B]=ct+En,S[B+1]=bt-hn,me===0){S[ee]=Se-Ct,S[ee+1]=Oe-Et;continue}if(me===ce)continue;const Kt=W+X-me,yi=W+Y-me;S[Kt]=ct-C*En,S[Kt+1]=-bt-C*hn,S[yi]=Se-C*Ct,S[yi+1]=-Oe+C*Et}}const j=P>>>1;for(let Y=2;Y<j;Y+=2)S[P-Y]=S[Y],S[P-Y+1]=-S[Y+1]}_singleRealTransform2(S,$,C,P,O){const R=S[P],G=S[P+O];$[C]=R+G,$[C+1]=0,$[C+2]=R-G,$[C+3]=0}_singleRealTransform4(S,$,C,P,O,R){const G=O*2,W=O*3,V=S[P],te=S[P+O],J=S[P+G],j=S[P+W],Y=V+J,X=V-J,ce=te+j,me=R*(te-j);$[C]=Y+ce,$[C+1]=0,$[C+2]=X,$[C+3]=-me,$[C+4]=Y-ce,$[C+5]=0,$[C+6]=X,$[C+7]=me}}class m{constructor(S){const $=2*(S-1),C=2*(2*S-1),P=2**Math.ceil(Math.log2(C));this.bufferSize=P,this._a=$;const O=new Float64Array(C),R=new Float64Array(P);this._chirpBuffer=new Float64Array(P),this._buffer1=new Float64Array(P),this._buffer2=new Float64Array(P),this._outBuffer1=new Float64Array(P),this._outBuffer2=new Float64Array(P);const G=-2*Math.PI/S,W=Math.cos(G),V=Math.sin(G);for(let te=0;te<C>>1;++te){const J=(te+1-S)**2/2,j=Math.sqrt(W**2+V**2)**J,Y=J*Math.atan2(V,W),X=2*te;O[X]=j*Math.cos(Y),O[X+1]=j*Math.sin(Y),R[X]=O[X],R[X+1]=-O[X+1]}this._slicedChirpBuffer=O.subarray($,C),this._f=new h(P>>1),this._f.transform(this._chirpBuffer,R)}_transform(S,$,C){const P=this._buffer1,O=this._buffer2,R=this._outBuffer1,G=this._outBuffer2,W=this._chirpBuffer,V=this._slicedChirpBuffer,te=this._a;if(C)for(let J=0;J<V.length;J+=2){const j=J+1,Y=J>>1,X=$[Y];P[J]=X*V[J],P[j]=X*V[j]}else for(let J=0;J<V.length;J+=2){const j=J+1;P[J]=$[J]*V[J]-$[j]*V[j],P[j]=$[J]*V[j]+$[j]*V[J]}this._f.transform(R,P);for(let J=0;J<W.length;J+=2){const j=J+1;O[J]=R[J]*W[J]-R[j]*W[j],O[j]=R[J]*W[j]+R[j]*W[J]}this._f.inverseTransform(G,O);for(let J=0;J<G.length;J+=2){const j=G[J+te],Y=G[J+te+1],X=V[J],ce=V[J+1];S[J]=j*X-Y*ce,S[J+1]=j*ce+Y*X}}transform(S,$){this._transform(S,$,!1)}realTransform(S,$){this._transform(S,$,!0)}}class y{constructor(S){this.fft_length=S,this.isPowerOfTwo=d(S),this.isPowerOfTwo?(this.fft=new h(S),this.outputBufferSize=2*S):(this.fft=new m(S),this.outputBufferSize=this.fft.bufferSize)}realTransform(S,$){this.fft.realTransform(S,$)}transform(S,$){this.fft.transform(S,$)}}function M(x,S){if(S%2===0||S<=0)throw new Error("Window size must be a positive odd number");const $=new x.constructor(x.length),C=new x.constructor(S),P=Math.floor(S/2);for(let O=0;O<x.length;++O){let R=0;for(let G=-P;G<=P;++G){let W=O+G;W<0?W=Math.abs(W):W>=x.length&&(W=2*(x.length-1)-W),C[R++]=x[W]}C.sort(),$[O]=C[P]}return $}function g(x,S){const $=Math.pow(10,S);return Math.round(x*$)/$}function _(x){const S=Math.round(x);return Math.abs(x)%1===.5?S%2===0?S:S-1:S}function T(x){const S=x.length,$=x[0].length,C=[S+1,$+1],P=Array.from({length:C[0]},()=>Array(C[1]).fill(1/0));P[0][0]=0;const O=Array.from({length:C[0]},()=>Array(C[1]).fill(-1));for(let te=1;te<C[1];++te)for(let J=1;J<C[0];++J){const j=P[J-1][te-1],Y=P[J-1][te],X=P[J][te-1];let ce,me;j<Y&&j<X?(ce=j,me=0):Y<j&&Y<X?(ce=Y,me=1):(ce=X,me=2),P[J][te]=x[J-1][te-1]+ce,O[J][te]=me}for(let te=0;te<C[1];++te)O[0][te]=2;for(let te=0;te<C[0];++te)O[te][0]=1;let R=S,G=$,W=[],V=[];for(;R>0||G>0;)switch(W.push(R-1),V.push(G-1),O[R][G]){case 0:--R,--G;break;case 1:--R;break;case 2:--G;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${R}, ${G}]. Please file a bug report.`)}return W.reverse(),V.reverse(),[W,V]}},"./src/utils/tensor.js":(e,t,n)=>{n.r(t),n.d(t,{DataTypeMap:()=>a,Tensor:()=>o,cat:()=>$,full:()=>V,full_like:()=>te,interpolate:()=>c,interpolate_4d:()=>f,layer_norm:()=>_,matmul:()=>d,mean:()=>R,mean_pooling:()=>g,ones:()=>J,ones_like:()=>j,permute:()=>u,quantize_embeddings:()=>Q,rand:()=>ce,randn:()=>me,rfft:()=>h,slice:()=>M,stack:()=>C,std_mean:()=>O,topk:()=>m,zeros:()=>Y,zeros_like:()=>X});var i=n("./src/utils/maths.js"),r=n("./src/backends/onnx.js"),s=n("./src/ops/registry.js");const a=Object.freeze({float32:Float32Array,float16:typeof Float16Array<"u"?Float16Array:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class o{constructor(...B){fe(this,"ort_tensor");return(0,r.isONNXTensor)(B[0])?this.ort_tensor=B[0]:this.ort_tensor=new r.Tensor(B[0],B[1],B[2]),new Proxy(this,{get:(ee,_e)=>{if(typeof _e=="string"){let le=Number(_e);if(Number.isInteger(le))return ee._getitem(le)}return ee[_e]},set:(ee,_e,le)=>ee[_e]=le})}get dims(){return this.ort_tensor.dims}set dims(B){this.ort_tensor.dims=B}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[B,...ee]=this.dims;if(ee.length>0){const _e=ee.reduce((le,ae)=>le*ae);for(let le=0;le<B;++le)yield this._subarray(le,_e,ee)}else yield*this.data}_getitem(B){const[ee,..._e]=this.dims;if(B=S(B,ee),_e.length>0){const le=_e.reduce((ae,Ne)=>ae*Ne);return this._subarray(B,le,_e)}else return new o(this.type,[this.data[B]],_e)}indexOf(B){const ee=this.data;for(let _e=0;_e<ee.length;++_e)if(ee[_e]==B)return _e;return-1}_subarray(B,ee,_e){const le=B*ee,ae=(B+1)*ee,Ne="subarray"in this.data?this.data.subarray(le,ae):this.data.slice(le,ae);return new o(this.type,Ne,_e)}item(){const B=this.data;if(B.length!==1)throw new Error(`a Tensor with ${B.length} elements cannot be converted to Scalar`);return B[0]}tolist(){return l(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const B=this.data;for(let ee=0;ee<B.length;++ee)B[ee]=1/(1+Math.exp(-B[ee]));return this}map(B){return this.clone().map_(B)}map_(B){const ee=this.data;for(let _e=0;_e<ee.length;++_e)ee[_e]=B(ee[_e],_e,ee);return this}mul(B){return this.clone().mul_(B)}mul_(B){const ee=this.data;for(let _e=0;_e<ee.length;++_e)ee[_e]*=B;return this}div(B){return this.clone().div_(B)}div_(B){const ee=this.data;for(let _e=0;_e<ee.length;++_e)ee[_e]/=B;return this}add(B){return this.clone().add_(B)}add_(B){const ee=this.data;for(let _e=0;_e<ee.length;++_e)ee[_e]+=B;return this}sub(B){return this.clone().sub_(B)}sub_(B){const ee=this.data;for(let _e=0;_e<ee.length;++_e)ee[_e]-=B;return this}clone(){return new o(this.type,this.data.slice(),this.dims.slice())}slice(...B){const ee=[],_e=[];for(let U=0;U<this.dims.length;++U){let we=B[U];if(we==null)_e.push([0,this.dims[U]]),ee.push(this.dims[U]);else if(typeof we=="number")we=S(we,this.dims[U],U),_e.push([we,we+1]);else if(Array.isArray(we)&&we.length===2){let[Pe,ke]=we;if(Pe=Pe===null?0:S(Pe,this.dims[U],U,!1),ke=ke===null?this.dims[U]:S(ke,this.dims[U],U,!1),Pe>ke)throw new Error(`Invalid slice: ${we}`);const Le=[Math.max(Pe,0),Math.min(ke,this.dims[U])];_e.push(Le),ee.push(Le[1]-Le[0])}else throw new Error(`Invalid slice: ${we}`)}const le=_e.map(([U,we])=>we-U),ae=le.reduce((U,we)=>U*we),Ne=this.data,Ye=new Ne.constructor(ae),ze=this.stride();let ue=!0;for(let U=1;U<le.length;++U)if(_e[U][0]!==0||_e[U][1]!==this.dims[U]){ue=!1;break}if(ue){const U=_e[0][0]*ze[0],we=_e[0][1]*ze[0];if(ArrayBuffer.isView(Ne))Ye.set(Ne.subarray(U,we));else if(Array.isArray(Ne)){const Pe=Ne.slice(U,we);for(let ke=0;ke<Pe.length;++ke)Ye[ke]=Pe[ke]}else throw new Error("Unsupported data type for slicing")}else for(let U=0;U<ae;++U){let we=0;for(let Pe=le.length-1,ke=U;Pe>=0;--Pe){const Le=le[Pe];we+=(ke%Le+_e[Pe][0])*ze[Pe],ke=Math.floor(ke/Le)}Ye[U]=Ne[we]}return new o(this.type,Ye,ee)}permute(...B){return u(this,B)}transpose(...B){return this.permute(...B)}sum(B=null,ee=!1){return this.norm(1,B,ee)}norm(B="fro",ee=null,_e=!1){if(B==="fro")B=2;else if(typeof B=="string")throw Error(`Unsupported norm: ${B}`);const le=this.data,ae=(ue,U)=>ue+U**B;if(ee===null){const ue=le.reduce(ae,0)**(1/B);return new o(this.type,[ue],[])}const[Ne,Ye,ze]=P(ae,this,ee,_e);if(B!==1)for(let ue=0;ue<Ye.length;++ue)Ye[ue]=Ye[ue]**(1/B);return new o(Ne,Ye,ze)}normalize_(B=2,ee=1){ee=S(ee,this.dims.length);const _e=this.norm(B,ee,!0),le=this.data,ae=_e.data;for(let Ne=0;Ne<le.length;++Ne){let Ye=0;for(let ze=this.dims.length-1,ue=Ne,U=1;ze>=0;--ze){const we=this.dims[ze];if(ze!==ee){const Pe=ue%we;Ye+=Pe*U,U*=this.dims[ze]}ue=Math.floor(ue/we)}le[Ne]/=ae[Ye]}return this}normalize(B=2,ee=1){return this.clone().normalize_(B,ee)}stride(){return G(this.dims)}squeeze(B=null){return new o(this.type,this.data,T(this.dims,B))}squeeze_(B=null){return this.dims=T(this.dims,B),this}unsqueeze(B=null){return new o(this.type,this.data,x(this.dims,B))}unsqueeze_(B=null){return this.dims=x(this.dims,B),this}flatten_(B=0,ee=-1){ee=(ee+this.dims.length)%this.dims.length;let _e=this.dims.slice(0,B),le=this.dims.slice(B,ee+1),ae=this.dims.slice(ee+1);return this.dims=[..._e,le.reduce((Ne,Ye)=>Ne*Ye,1),...ae],this}flatten(B=0,ee=-1){return this.clone().flatten_(B,ee)}view(...B){let ee=-1;for(let le=0;le<B.length;++le)if(B[le]===-1){if(ee!==-1)throw new Error("Only one dimension can be inferred");ee=le}const _e=this.data;if(ee!==-1){const le=B.reduce((ae,Ne,Ye)=>Ye!==ee?ae*Ne:ae,1);B[ee]=_e.length/le}return new o(this.type,_e,B)}neg_(){const B=this.data;for(let ee=0;ee<B.length;++ee)B[ee]=-B[ee];return this}neg(){return this.clone().neg_()}gt(B){const ee=new Uint8Array(this.data.length),_e=this.data;for(let le=0;le<_e.length;++le)ee[le]=_e[le]>B?1:0;return new o("bool",ee,this.dims)}lt(B){const ee=new Uint8Array(this.data.length),_e=this.data;for(let le=0;le<_e.length;++le)ee[le]=_e[le]<B?1:0;return new o("bool",ee,this.dims)}clamp_(B,ee){const _e=this.data;for(let le=0;le<_e.length;++le)_e[le]=Math.min(Math.max(_e[le],B),ee);return this}clamp(B,ee){return this.clone().clamp_(B,ee)}round_(){const B=this.data;for(let ee=0;ee<B.length;++ee)B[ee]=Math.round(B[ee]);return this}round(){return this.clone().round_()}mean(B=null,ee=!1){return R(this,B,ee)}min(B=null,ee=!1){if(B===null){const Ne=(0,i.min)(this.data)[0];return new o(this.type,[Ne],[])}const[_e,le,ae]=P((Ne,Ye)=>Math.min(Ne,Ye),this,B,ee,1/0);return new o(_e,le,ae)}max(B=null,ee=!1){if(B===null){const Ne=(0,i.max)(this.data)[0];return new o(this.type,[Ne],[])}const[_e,le,ae]=P((Ne,Ye)=>Math.max(Ne,Ye),this,B,ee,-1/0);return new o(_e,le,ae)}argmin(B=null,ee=!1){if(B!==null)throw new Error("`dim !== null` not yet implemented.");const _e=(0,i.min)(this.data)[1];return new o("int64",[BigInt(_e)],[])}argmax(B=null,ee=!1){if(B!==null)throw new Error("`dim !== null` not yet implemented.");const _e=(0,i.max)(this.data)[1];return new o("int64",[BigInt(_e)],[])}to(B){if(this.type===B)return this;if(!a.hasOwnProperty(B))throw new Error(`Unsupported type: ${B}`);let ee;const _e=["int64","uint64"].includes(this.type),le=["int64","uint64"].includes(B);return _e&&!le?ee=Number:!_e&&le&&(["float16","float32","float64"].includes(this.type)?ee=ae=>BigInt(Math.floor(ae)):ee=BigInt),new o(B,a[B].from(this.data,ee),this.dims)}}function l(H,B){const ee=H.length,_e=B.reduce((ae,Ne)=>ae*Ne);if(ee!==_e)throw Error(`cannot reshape array of size ${ee} into shape (${B})`);let le=H;for(let ae=B.length-1;ae>=0;ae--)le=le.reduce((Ne,Ye)=>{let ze=Ne[Ne.length-1];return ze.length<B[ae]?ze.push(Ye):Ne.push([Ye]),Ne},[[]]);return le[0]}function u(H,B){const[ee,_e]=(0,i.permute_data)(H.data,H.dims,B);return new o(H.type,ee,_e)}function c(H,[B,ee],_e="bilinear",le=!1){const ae=H.dims.at(-3)??1,Ne=H.dims.at(-2),Ye=H.dims.at(-1);let ze=(0,i.interpolate_data)(H.data,[ae,Ne,Ye],[B,ee],_e,le);return new o(H.type,ze,[ae,B,ee])}async function f(H,{size:B=null,mode:ee="bilinear"}={}){if(H.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!B)throw new Error("`interpolate_4d` requires a `size` argument.");let _e;if(B.length===2)_e=[...H.dims.slice(0,2),...B];else if(B.length===3)_e=[H.dims[0],...B];else if(B.length===4)_e=B;else throw new Error("`size` must be of length 2, 3, or 4.");let le;if(ee==="nearest")le=await s.TensorOpRegistry.nearest_interpolate_4d;else if(ee==="bilinear")le=await s.TensorOpRegistry.bilinear_interpolate_4d;else if(ee==="bicubic")le=await s.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${ee}`);const ae=new o("int64",new BigInt64Array(_e.map(BigInt)),[_e.length]);return await le({x:H,s:ae})}async function d(H,B){return await(await s.TensorOpRegistry.matmul)({a:H,b:B})}async function h(H,B){return await(await s.TensorOpRegistry.rfft)({x:H,a:B})}async function m(H,B){const ee=await s.TensorOpRegistry.top_k;return B==null?B=H.dims.at(-1):B=Math.min(B,H.dims.at(-1)),await ee({x:H,k:new o("int64",[BigInt(B)],[1])})}const y=H=>new o("int64",H,[H.length]);async function M(H,B,ee,_e,le){return await(await s.TensorOpRegistry.slice)({x:H,s:y(B),e:y(ee),a:y(_e),t:y(le??new Array(_e.length).fill(1))})}function g(H,B){const ee=H.data,_e=B.data,le=[H.dims[0],H.dims[2]],ae=new ee.constructor(le[0]*le[1]),[Ne,Ye,ze]=H.dims;let ue=0;for(let U=0;U<Ne;++U){const we=U*ze*Ye;for(let Pe=0;Pe<ze;++Pe){let ke=0,Le=0;const Ge=U*Ye,$e=we+Pe;for(let Ce=0;Ce<Ye;++Ce){const He=Number(_e[Ge+Ce]);Le+=He,ke+=ee[$e+Ce*ze]*He}const et=ke/Le;ae[ue++]=et}}return new o(H.type,ae,le)}function _(H,B,{eps:ee=1e-5}={}){if(H.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[_e,le]=H.dims;if(B.length!==1&&B[0]!==le)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[ae,Ne]=O(H,1,0,!0),Ye=ae.data,ze=Ne.data,ue=H.data,U=new ue.constructor(ue.length);for(let we=0;we<_e;++we){const Pe=we*le;for(let ke=0;ke<le;++ke){const Le=Pe+ke;U[Le]=(ue[Le]-ze[we])/(Ye[we]+ee)}}return new o(H.type,U,H.dims)}function T(H,B){return H=H.slice(),B===null?H=H.filter(ee=>ee!==1):typeof B=="number"?H[B]===1&&H.splice(B,1):Array.isArray(B)&&(H=H.filter((ee,_e)=>ee!==1||!B.includes(_e))),H}function x(H,B){return B=S(B,H.length+1),H=H.slice(),H.splice(B,0,1),H}function S(H,B,ee=null,_e=!0){if(H<-B||H>=B){if(_e)throw new Error(`IndexError: index ${H} is out of bounds for dimension${ee===null?"":" "+ee} with size ${B}`);return H<-B?0:B}return H<0&&(H=(H%B+B)%B),H}function $(H,B=0){B=S(B,H[0].dims.length);const ee=H[0].dims.slice();ee[B]=H.reduce((Ne,Ye)=>Ne+Ye.dims[B],0);const _e=ee.reduce((Ne,Ye)=>Ne*Ye,1),le=new H[0].data.constructor(_e),ae=H[0].type;if(B===0){let Ne=0;for(const Ye of H){const ze=Ye.data;le.set(ze,Ne),Ne+=ze.length}}else{let Ne=0;for(let Ye=0;Ye<H.length;++Ye){const{data:ze,dims:ue}=H[Ye];for(let U=0;U<ze.length;++U){let we=0;for(let Pe=ue.length-1,ke=U,Le=1;Pe>=0;--Pe){const Ge=ue[Pe];let $e=ke%Ge;Pe===B&&($e+=Ne),we+=$e*Le,Le*=ee[Pe],ke=Math.floor(ke/Ge)}le[we]=ze[U]}Ne+=ue[B]}}return new o(ae,le,ee)}function C(H,B=0){return $(H.map(ee=>ee.unsqueeze(B)),B)}function P(H,B,ee=null,_e=!1,le=null){const ae=B.data,Ne=B.dims;ee=S(ee,Ne.length);const Ye=Ne.slice();Ye[ee]=1;const ze=new ae.constructor(ae.length/Ne[ee]);le!==null&&ze.fill(le);for(let ue=0;ue<ae.length;++ue){let U=0;for(let we=Ne.length-1,Pe=ue,ke=1;we>=0;--we){const Le=Ne[we];if(we!==ee){const Ge=Pe%Le;U+=Ge*ke,ke*=Ye[we]}Pe=Math.floor(Pe/Le)}ze[U]=H(ze[U],ae[ue],ue,U)}return _e||Ye.splice(ee,1),[B.type,ze,Ye]}function O(H,B=null,ee=1,_e=!1){const le=H.data,ae=H.dims;if(B===null){const ke=le.reduce((et,Ce)=>et+Ce,0)/le.length,Le=Math.sqrt(le.reduce((et,Ce)=>et+(Ce-ke)**2,0)/(le.length-ee)),Ge=new o(H.type,[ke],[]);return[new o(H.type,[Le],[]),Ge]}B=S(B,ae.length);const Ne=R(H,B,_e),Ye=Ne.data,[ze,ue,U]=P((Pe,ke,Le,Ge)=>Pe+(ke-Ye[Ge])**2,H,B,_e);for(let Pe=0;Pe<ue.length;++Pe)ue[Pe]=Math.sqrt(ue[Pe]/(ae[B]-ee));return[new o(ze,ue,U),Ne]}function R(H,B=null,ee=!1){const _e=H.dims,le=H.data;if(B===null){const ze=le.reduce((ue,U)=>ue+U,0);return new o(H.type,[ze/le.length],[])}B=S(B,_e.length);const[ae,Ne,Ye]=P((ze,ue)=>ze+ue,H,B,ee);if(_e[B]!==1)for(let ze=0;ze<Ne.length;++ze)Ne[ze]/=_e[B];return new o(ae,Ne,Ye)}function G(H){const B=new Array(H.length);for(let ee=H.length-1,_e=1;ee>=0;--ee)B[ee]=_e,_e*=H[ee];return B}function W(H,B,ee,_e){const le=H.reduce((ae,Ne)=>ae*Ne,1);return new o(ee,new _e(le).fill(B),H)}function V(H,B){let ee,_e;if(typeof B=="number")ee="float32",_e=Float32Array;else if(typeof B=="bigint")ee="int64",_e=BigInt64Array;else if(typeof B=="boolean")ee="bool",_e=Uint8Array;else throw new Error(`Unsupported data type: ${typeof B}`);return W(H,B,ee,_e)}function te(H,B){return V(H.dims,B)}function J(H){return W(H,1n,"int64",BigInt64Array)}function j(H){return J(H.dims)}function Y(H){return W(H,0n,"int64",BigInt64Array)}function X(H){return Y(H.dims)}function ce(H){const B=H.reduce((ee,_e)=>ee*_e,1);return new o("float32",Float32Array.from({length:B},()=>Math.random()),H)}function me(H){const B=H.reduce((_e,le)=>_e*le,1);function ee(){const _e=1-Math.random(),le=1-Math.random();return Math.sqrt(-2*Math.log(_e))*Math.cos(2*Math.PI*le)}return new o("float32",Float32Array.from({length:B},()=>ee()),H)}function Q(H,B){if(H.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(H.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(B))throw new Error("The precision must be either 'binary' or 'ubinary'");const ee=B==="binary",_e=ee?"int8":"uint8",le=ee?Int8Array:Uint8Array,ae=H.data,Ne=new le(ae.length/8);for(let Ye=0;Ye<ae.length;++Ye){const ze=ae[Ye]>0?1:0,ue=Math.floor(Ye/8),U=Ye%8;Ne[ue]|=ze<<7-U,ee&&U===0&&(Ne[ue]-=128)}return new o(_e,Ne,[H.dims[0],H.dims[1]/8])}},"./src/utils/video.js":(e,t,n)=>{n.r(t),n.d(t,{RawVideo:()=>a,RawVideoFrame:()=>s,load_video:()=>o});var i=n("./src/utils/image.js"),r=n("./src/env.js");class s{constructor(u,c){this.image=u,this.timestamp=c}}class a{constructor(u,c){u.length>0&&u[0]instanceof i.RawImage&&(u=u.map((f,d)=>new s(f,(d+1)/(u.length+1)*c))),this.frames=u,this.duration=c}get width(){return this.frames[0].image.width}get height(){return this.frames[0].image.height}get fps(){return this.frames.length/this.duration}}async function o(l,{num_frames:u=null,fps:c=null}={}){if(!r.apis.IS_BROWSER_ENV)throw new Error("`load_video` is currently only supported in browser environments.");if(u==null&&c==null)throw new Error("Either num_frames or fps must be provided.");const f=[],d=document.createElement("video");if(d.crossOrigin="anonymous",d.muted=!0,typeof l=="string")d.src=l;else if(l instanceof Blob)d.src=URL.createObjectURL(l);else if(l instanceof HTMLVideoElement)d.src=l.src;else throw new Error("Invalid URL or video element provided.");if(await new Promise(T=>d.onloadedmetadata=T),d.seekable.start(0)===d.seekable.end(0)){const x=await(await fetch(d.src)).blob();d.src=URL.createObjectURL(x),await new Promise(S=>d.onloadedmetadata=S)}const h=d.duration;let m,y;u!=null?(m=u,y=u===1?0:h/(u-1)):(y=1/c,m=Math.floor(h/y));let M=[];for(let T=0;T<m;++T)M.push(u===1?h/2:T*y);const g=document.createElement("canvas");g.width=d.videoWidth,g.height=d.videoHeight;const _=g.getContext("2d",{willReadFrequently:!0});for(const T of M){d.currentTime=T,await new Promise(C=>{d.onseeked=C}),_.drawImage(d,0,0,g.width,g.height);const x=_.getImageData(0,0,g.width,g.height),S=new i.RawImage(x.data,g.width,g.height,4),$=new s(S,T);f.push($)}return d.remove(),new a(f,h)}}},SO={};function Xn(e){var t=SO[e];if(t!==void 0)return t.exports;var n=SO[e]={exports:{}};return kie[e](n,n.exports,Xn),n.exports}(()=>{var e=Object.getPrototypeOf?n=>Object.getPrototypeOf(n):n=>n.__proto__,t;Xn.t=function(n,i){if(i&1&&(n=this(n)),i&8||typeof n=="object"&&n&&(i&4&&n.__esModule||i&16&&typeof n.then=="function"))return n;var r=Object.create(null);Xn.r(r);var s={};t=t||[null,e({}),e([]),e(e)];for(var a=i&2&&n;typeof a=="object"&&!~t.indexOf(a);a=e(a))Object.getOwnPropertyNames(a).forEach(o=>s[o]=()=>n[o]);return s.default=()=>n,Xn.d(r,s),r}})();Xn.d=(e,t)=>{for(var n in t)Xn.o(t,n)&&!Xn.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})};Xn.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);Xn.r=e=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var A={};(()=>{/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/Xn.r(A),Xn.d(A,{ASTFeatureExtractor:()=>f.ASTFeatureExtractor,ASTForAudioClassification:()=>n.ASTForAudioClassification,ASTModel:()=>n.ASTModel,ASTPreTrainedModel:()=>n.ASTPreTrainedModel,AlbertForMaskedLM:()=>n.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>n.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>n.AlbertForSequenceClassification,AlbertModel:()=>n.AlbertModel,AlbertPreTrainedModel:()=>n.AlbertPreTrainedModel,AlbertTokenizer:()=>i.AlbertTokenizer,ArceeForCausalLM:()=>n.ArceeForCausalLM,ArceeModel:()=>n.ArceeModel,ArceePreTrainedModel:()=>n.ArceePreTrainedModel,AudioClassificationPipeline:()=>t.AudioClassificationPipeline,AutoConfig:()=>r.AutoConfig,AutoFeatureExtractor:()=>d.AutoFeatureExtractor,AutoImageProcessor:()=>y.AutoImageProcessor,AutoModel:()=>n.AutoModel,AutoModelForAudioClassification:()=>n.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>n.AutoModelForAudioFrameClassification,AutoModelForAudioTextToText:()=>n.AutoModelForAudioTextToText,AutoModelForCTC:()=>n.AutoModelForCTC,AutoModelForCausalLM:()=>n.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>n.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>n.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>n.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>n.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>n.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>n.AutoModelForImageSegmentation,AutoModelForImageTextToText:()=>n.AutoModelForImageTextToText,AutoModelForImageToImage:()=>n.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>n.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>n.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>n.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>n.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>n.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>n.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>n.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>n.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>n.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>n.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>n.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>n.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>n.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>n.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>n.AutoModelForVision2Seq,AutoModelForXVector:()=>n.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>n.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>_.AutoProcessor,AutoTokenizer:()=>i.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>t.AutomaticSpeechRecognitionPipeline,BackgroundRemovalPipeline:()=>t.BackgroundRemovalPipeline,BartForConditionalGeneration:()=>n.BartForConditionalGeneration,BartForSequenceClassification:()=>n.BartForSequenceClassification,BartModel:()=>n.BartModel,BartPretrainedModel:()=>n.BartPretrainedModel,BartTokenizer:()=>i.BartTokenizer,BaseModelOutput:()=>n.BaseModelOutput,BaseStreamer:()=>T.BaseStreamer,BeitFeatureExtractor:()=>m.BeitFeatureExtractor,BeitForImageClassification:()=>n.BeitForImageClassification,BeitModel:()=>n.BeitModel,BeitPreTrainedModel:()=>n.BeitPreTrainedModel,BertForMaskedLM:()=>n.BertForMaskedLM,BertForQuestionAnswering:()=>n.BertForQuestionAnswering,BertForSequenceClassification:()=>n.BertForSequenceClassification,BertForTokenClassification:()=>n.BertForTokenClassification,BertModel:()=>n.BertModel,BertPreTrainedModel:()=>n.BertPreTrainedModel,BertTokenizer:()=>i.BertTokenizer,BitImageProcessor:()=>m.BitImageProcessor,BlenderbotForConditionalGeneration:()=>n.BlenderbotForConditionalGeneration,BlenderbotModel:()=>n.BlenderbotModel,BlenderbotPreTrainedModel:()=>n.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>n.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>n.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>n.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>i.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>i.BlenderbotTokenizer,BloomForCausalLM:()=>n.BloomForCausalLM,BloomModel:()=>n.BloomModel,BloomPreTrainedModel:()=>n.BloomPreTrainedModel,BloomTokenizer:()=>i.BloomTokenizer,CLIPFeatureExtractor:()=>m.CLIPFeatureExtractor,CLIPImageProcessor:()=>m.CLIPImageProcessor,CLIPModel:()=>n.CLIPModel,CLIPPreTrainedModel:()=>n.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>n.CLIPSegForImageSegmentation,CLIPSegModel:()=>n.CLIPSegModel,CLIPSegPreTrainedModel:()=>n.CLIPSegPreTrainedModel,CLIPTextModel:()=>n.CLIPTextModel,CLIPTextModelWithProjection:()=>n.CLIPTextModelWithProjection,CLIPTokenizer:()=>i.CLIPTokenizer,CLIPVisionModel:()=>n.CLIPVisionModel,CLIPVisionModelWithProjection:()=>n.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>n.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>n.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>n.CamembertForSequenceClassification,CamembertForTokenClassification:()=>n.CamembertForTokenClassification,CamembertModel:()=>n.CamembertModel,CamembertPreTrainedModel:()=>n.CamembertPreTrainedModel,CamembertTokenizer:()=>i.CamembertTokenizer,CausalLMOutput:()=>n.CausalLMOutput,CausalLMOutputWithPast:()=>n.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>m.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>n.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>n.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>n.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>f.ClapFeatureExtractor,ClapModel:()=>n.ClapModel,ClapPreTrainedModel:()=>n.ClapPreTrainedModel,ClapTextModelWithProjection:()=>n.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>S.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>n.CodeGenForCausalLM,CodeGenModel:()=>n.CodeGenModel,CodeGenPreTrainedModel:()=>n.CodeGenPreTrainedModel,CodeGenTokenizer:()=>i.CodeGenTokenizer,CodeLlamaTokenizer:()=>i.CodeLlamaTokenizer,CohereForCausalLM:()=>n.CohereForCausalLM,CohereModel:()=>n.CohereModel,CoherePreTrainedModel:()=>n.CoherePreTrainedModel,CohereTokenizer:()=>i.CohereTokenizer,ConvBertForMaskedLM:()=>n.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>n.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>n.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>n.ConvBertForTokenClassification,ConvBertModel:()=>n.ConvBertModel,ConvBertPreTrainedModel:()=>n.ConvBertPreTrainedModel,ConvBertTokenizer:()=>i.ConvBertTokenizer,ConvNextFeatureExtractor:()=>m.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>n.ConvNextForImageClassification,ConvNextImageProcessor:()=>m.ConvNextImageProcessor,ConvNextModel:()=>n.ConvNextModel,ConvNextPreTrainedModel:()=>n.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>n.ConvNextV2ForImageClassification,ConvNextV2Model:()=>n.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>n.ConvNextV2PreTrainedModel,DFineForObjectDetection:()=>n.DFineForObjectDetection,DFineModel:()=>n.DFineModel,DFinePreTrainedModel:()=>n.DFinePreTrainedModel,DINOv3ConvNextModel:()=>n.DINOv3ConvNextModel,DINOv3ConvNextPreTrainedModel:()=>n.DINOv3ConvNextPreTrainedModel,DINOv3ViTImageProcessor:()=>m.DINOv3ViTImageProcessor,DINOv3ViTModel:()=>n.DINOv3ViTModel,DINOv3ViTPreTrainedModel:()=>n.DINOv3ViTPreTrainedModel,DPTFeatureExtractor:()=>m.DPTFeatureExtractor,DPTForDepthEstimation:()=>n.DPTForDepthEstimation,DPTImageProcessor:()=>m.DPTImageProcessor,DPTModel:()=>n.DPTModel,DPTPreTrainedModel:()=>n.DPTPreTrainedModel,DacDecoderModel:()=>n.DacDecoderModel,DacDecoderOutput:()=>n.DacDecoderOutput,DacEncoderModel:()=>n.DacEncoderModel,DacEncoderOutput:()=>n.DacEncoderOutput,DacFeatureExtractor:()=>f.DacFeatureExtractor,DacModel:()=>n.DacModel,DacPreTrainedModel:()=>n.DacPreTrainedModel,DataTypeMap:()=>l.DataTypeMap,DebertaForMaskedLM:()=>n.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>n.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>n.DebertaForSequenceClassification,DebertaForTokenClassification:()=>n.DebertaForTokenClassification,DebertaModel:()=>n.DebertaModel,DebertaPreTrainedModel:()=>n.DebertaPreTrainedModel,DebertaTokenizer:()=>i.DebertaTokenizer,DebertaV2ForMaskedLM:()=>n.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>n.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>n.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>n.DebertaV2ForTokenClassification,DebertaV2Model:()=>n.DebertaV2Model,DebertaV2PreTrainedModel:()=>n.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>i.DebertaV2Tokenizer,DecisionTransformerModel:()=>n.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>n.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>m.DeiTFeatureExtractor,DeiTForImageClassification:()=>n.DeiTForImageClassification,DeiTImageProcessor:()=>m.DeiTImageProcessor,DeiTModel:()=>n.DeiTModel,DeiTPreTrainedModel:()=>n.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>n.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>n.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>t.DepthEstimationPipeline,DepthProForDepthEstimation:()=>n.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>n.DepthProPreTrainedModel,DetrFeatureExtractor:()=>m.DetrFeatureExtractor,DetrForObjectDetection:()=>n.DetrForObjectDetection,DetrForSegmentation:()=>n.DetrForSegmentation,DetrImageProcessor:()=>m.DetrImageProcessor,DetrModel:()=>n.DetrModel,DetrObjectDetectionOutput:()=>n.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>n.DetrPreTrainedModel,DetrSegmentationOutput:()=>n.DetrSegmentationOutput,Dinov2ForImageClassification:()=>n.Dinov2ForImageClassification,Dinov2Model:()=>n.Dinov2Model,Dinov2PreTrainedModel:()=>n.Dinov2PreTrainedModel,Dinov2WithRegistersForImageClassification:()=>n.Dinov2WithRegistersForImageClassification,Dinov2WithRegistersModel:()=>n.Dinov2WithRegistersModel,Dinov2WithRegistersPreTrainedModel:()=>n.Dinov2WithRegistersPreTrainedModel,DistilBertForMaskedLM:()=>n.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>n.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>n.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>n.DistilBertForTokenClassification,DistilBertModel:()=>n.DistilBertModel,DistilBertPreTrainedModel:()=>n.DistilBertPreTrainedModel,DistilBertTokenizer:()=>i.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>t.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>m.DonutFeatureExtractor,DonutImageProcessor:()=>m.DonutImageProcessor,DonutSwinModel:()=>n.DonutSwinModel,DonutSwinPreTrainedModel:()=>n.DonutSwinPreTrainedModel,EdgeTamModel:()=>n.EdgeTamModel,EfficientNetForImageClassification:()=>n.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>m.EfficientNetImageProcessor,EfficientNetModel:()=>n.EfficientNetModel,EfficientNetPreTrainedModel:()=>n.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>n.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>n.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>n.ElectraForSequenceClassification,ElectraForTokenClassification:()=>n.ElectraForTokenClassification,ElectraModel:()=>n.ElectraModel,ElectraPreTrainedModel:()=>n.ElectraPreTrainedModel,ElectraTokenizer:()=>i.ElectraTokenizer,EncodecFeatureExtractor:()=>f.EncodecFeatureExtractor,EosTokenCriteria:()=>x.EosTokenCriteria,Ernie4_5ForCausalLM:()=>n.Ernie4_5ForCausalLM,Ernie4_5Model:()=>n.Ernie4_5Model,Ernie4_5PreTrainedModel:()=>n.Ernie4_5PreTrainedModel,EsmForMaskedLM:()=>n.EsmForMaskedLM,EsmForSequenceClassification:()=>n.EsmForSequenceClassification,EsmForTokenClassification:()=>n.EsmForTokenClassification,EsmModel:()=>n.EsmModel,EsmPreTrainedModel:()=>n.EsmPreTrainedModel,EsmTokenizer:()=>i.EsmTokenizer,ExaoneForCausalLM:()=>n.ExaoneForCausalLM,ExaoneModel:()=>n.ExaoneModel,ExaonePreTrainedModel:()=>n.ExaonePreTrainedModel,FFT:()=>u.FFT,FalconForCausalLM:()=>n.FalconForCausalLM,FalconModel:()=>n.FalconModel,FalconPreTrainedModel:()=>n.FalconPreTrainedModel,FalconTokenizer:()=>i.FalconTokenizer,FastViTForImageClassification:()=>n.FastViTForImageClassification,FastViTModel:()=>n.FastViTModel,FastViTPreTrainedModel:()=>n.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>t.FeatureExtractionPipeline,FeatureExtractor:()=>c.FeatureExtractor,FillMaskPipeline:()=>t.FillMaskPipeline,Florence2ForConditionalGeneration:()=>n.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>n.Florence2PreTrainedModel,Florence2Processor:()=>g.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>S.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>S.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>m.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>n.GLPNForDepthEstimation,GLPNModel:()=>n.GLPNModel,GLPNPreTrainedModel:()=>n.GLPNPreTrainedModel,GPT2LMHeadModel:()=>n.GPT2LMHeadModel,GPT2Model:()=>n.GPT2Model,GPT2PreTrainedModel:()=>n.GPT2PreTrainedModel,GPT2Tokenizer:()=>i.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>n.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>n.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>n.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>n.GPTJForCausalLM,GPTJModel:()=>n.GPTJModel,GPTJPreTrainedModel:()=>n.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>n.GPTNeoForCausalLM,GPTNeoModel:()=>n.GPTNeoModel,GPTNeoPreTrainedModel:()=>n.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>n.GPTNeoXForCausalLM,GPTNeoXModel:()=>n.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>n.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>i.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>n.Gemma2ForCausalLM,Gemma2Model:()=>n.Gemma2Model,Gemma2PreTrainedModel:()=>n.Gemma2PreTrainedModel,Gemma3ForCausalLM:()=>n.Gemma3ForCausalLM,Gemma3Model:()=>n.Gemma3Model,Gemma3PreTrainedModel:()=>n.Gemma3PreTrainedModel,Gemma3nAudioFeatureExtractor:()=>f.Gemma3nAudioFeatureExtractor,Gemma3nForConditionalGeneration:()=>n.Gemma3nForConditionalGeneration,Gemma3nPreTrainedModel:()=>n.Gemma3nPreTrainedModel,Gemma3nProcessor:()=>g.Gemma3nProcessor,GemmaForCausalLM:()=>n.GemmaForCausalLM,GemmaModel:()=>n.GemmaModel,GemmaPreTrainedModel:()=>n.GemmaPreTrainedModel,GemmaTokenizer:()=>i.GemmaTokenizer,GlmForCausalLM:()=>n.GlmForCausalLM,GlmModel:()=>n.GlmModel,GlmPreTrainedModel:()=>n.GlmPreTrainedModel,GraniteForCausalLM:()=>n.GraniteForCausalLM,GraniteModel:()=>n.GraniteModel,GraniteMoeHybridForCausalLM:()=>n.GraniteMoeHybridForCausalLM,GraniteMoeHybridModel:()=>n.GraniteMoeHybridModel,GraniteMoeHybridPreTrainedModel:()=>n.GraniteMoeHybridPreTrainedModel,GranitePreTrainedModel:()=>n.GranitePreTrainedModel,Grok1Tokenizer:()=>i.Grok1Tokenizer,GroundingDinoForObjectDetection:()=>n.GroundingDinoForObjectDetection,GroundingDinoImageProcessor:()=>m.GroundingDinoImageProcessor,GroundingDinoPreTrainedModel:()=>n.GroundingDinoPreTrainedModel,GroundingDinoProcessor:()=>g.GroundingDinoProcessor,GroupViTModel:()=>n.GroupViTModel,GroupViTPreTrainedModel:()=>n.GroupViTPreTrainedModel,HeliumForCausalLM:()=>n.HeliumForCausalLM,HeliumModel:()=>n.HeliumModel,HeliumPreTrainedModel:()=>n.HeliumPreTrainedModel,HerbertTokenizer:()=>i.HerbertTokenizer,HieraForImageClassification:()=>n.HieraForImageClassification,HieraModel:()=>n.HieraModel,HieraPreTrainedModel:()=>n.HieraPreTrainedModel,HubertForCTC:()=>n.HubertForCTC,HubertForSequenceClassification:()=>n.HubertForSequenceClassification,HubertModel:()=>n.HubertModel,HubertPreTrainedModel:()=>n.HubertPreTrainedModel,IJepaForImageClassification:()=>n.IJepaForImageClassification,IJepaModel:()=>n.IJepaModel,IJepaPreTrainedModel:()=>n.IJepaPreTrainedModel,Idefics3ForConditionalGeneration:()=>n.Idefics3ForConditionalGeneration,Idefics3ImageProcessor:()=>m.Idefics3ImageProcessor,Idefics3PreTrainedModel:()=>n.Idefics3PreTrainedModel,Idefics3Processor:()=>g.Idefics3Processor,ImageClassificationPipeline:()=>t.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>t.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>f.ImageFeatureExtractor,ImageMattingOutput:()=>n.ImageMattingOutput,ImageProcessor:()=>h.ImageProcessor,ImageSegmentationPipeline:()=>t.ImageSegmentationPipeline,ImageToImagePipeline:()=>t.ImageToImagePipeline,ImageToTextPipeline:()=>t.ImageToTextPipeline,InterruptableStoppingCriteria:()=>x.InterruptableStoppingCriteria,JAISLMHeadModel:()=>n.JAISLMHeadModel,JAISModel:()=>n.JAISModel,JAISPreTrainedModel:()=>n.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>m.JinaCLIPImageProcessor,JinaCLIPModel:()=>n.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>n.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>g.JinaCLIPProcessor,JinaCLIPTextModel:()=>n.JinaCLIPTextModel,JinaCLIPVisionModel:()=>n.JinaCLIPVisionModel,Lfm2ForCausalLM:()=>n.Lfm2ForCausalLM,Lfm2Model:()=>n.Lfm2Model,Lfm2PreTrainedModel:()=>n.Lfm2PreTrainedModel,LiteWhisperForConditionalGeneration:()=>n.LiteWhisperForConditionalGeneration,Llama4ForCausalLM:()=>n.Llama4ForCausalLM,Llama4PreTrainedModel:()=>n.Llama4PreTrainedModel,LlamaForCausalLM:()=>n.LlamaForCausalLM,LlamaModel:()=>n.LlamaModel,LlamaPreTrainedModel:()=>n.LlamaPreTrainedModel,LlamaTokenizer:()=>i.LlamaTokenizer,LlavaForConditionalGeneration:()=>n.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>n.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>m.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>n.LlavaPreTrainedModel,LlavaProcessor:()=>g.LlavaProcessor,LlavaQwen2ForCausalLM:()=>n.LlavaQwen2ForCausalLM,LogitsProcessor:()=>S.LogitsProcessor,LogitsProcessorList:()=>S.LogitsProcessorList,LogitsWarper:()=>S.LogitsWarper,LongT5ForConditionalGeneration:()=>n.LongT5ForConditionalGeneration,LongT5Model:()=>n.LongT5Model,LongT5PreTrainedModel:()=>n.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>n.M2M100ForConditionalGeneration,M2M100Model:()=>n.M2M100Model,M2M100PreTrainedModel:()=>n.M2M100PreTrainedModel,M2M100Tokenizer:()=>i.M2M100Tokenizer,MBart50Tokenizer:()=>i.MBart50Tokenizer,MBartForCausalLM:()=>n.MBartForCausalLM,MBartForConditionalGeneration:()=>n.MBartForConditionalGeneration,MBartForSequenceClassification:()=>n.MBartForSequenceClassification,MBartModel:()=>n.MBartModel,MBartPreTrainedModel:()=>n.MBartPreTrainedModel,MBartTokenizer:()=>i.MBartTokenizer,MPNetForMaskedLM:()=>n.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>n.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>n.MPNetForSequenceClassification,MPNetForTokenClassification:()=>n.MPNetForTokenClassification,MPNetModel:()=>n.MPNetModel,MPNetPreTrainedModel:()=>n.MPNetPreTrainedModel,MPNetTokenizer:()=>i.MPNetTokenizer,MT5ForConditionalGeneration:()=>n.MT5ForConditionalGeneration,MT5Model:()=>n.MT5Model,MT5PreTrainedModel:()=>n.MT5PreTrainedModel,MarianMTModel:()=>n.MarianMTModel,MarianModel:()=>n.MarianModel,MarianPreTrainedModel:()=>n.MarianPreTrainedModel,MarianTokenizer:()=>i.MarianTokenizer,Mask2FormerImageProcessor:()=>m.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>m.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>n.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>m.MaskFormerImageProcessor,MaskFormerModel:()=>n.MaskFormerModel,MaskFormerPreTrainedModel:()=>n.MaskFormerPreTrainedModel,MaskedLMOutput:()=>n.MaskedLMOutput,MaxLengthCriteria:()=>x.MaxLengthCriteria,Metric3DForDepthEstimation:()=>n.Metric3DForDepthEstimation,Metric3DPreTrainedModel:()=>n.Metric3DPreTrainedModel,Metric3Dv2ForDepthEstimation:()=>n.Metric3Dv2ForDepthEstimation,Metric3Dv2PreTrainedModel:()=>n.Metric3Dv2PreTrainedModel,MgpstrForSceneTextRecognition:()=>n.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>n.MgpstrModelOutput,MgpstrPreTrainedModel:()=>n.MgpstrPreTrainedModel,MgpstrProcessor:()=>g.MgpstrProcessor,MgpstrTokenizer:()=>i.MgpstrTokenizer,MimiDecoderModel:()=>n.MimiDecoderModel,MimiDecoderOutput:()=>n.MimiDecoderOutput,MimiEncoderModel:()=>n.MimiEncoderModel,MimiEncoderOutput:()=>n.MimiEncoderOutput,MimiModel:()=>n.MimiModel,MimiPreTrainedModel:()=>n.MimiPreTrainedModel,MinLengthLogitsProcessor:()=>S.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>S.MinNewTokensLengthLogitsProcessor,Ministral3ForCausalLM:()=>n.Ministral3ForCausalLM,Ministral3Model:()=>n.Ministral3Model,Ministral3PreTrainedModel:()=>n.Ministral3PreTrainedModel,MinistralForCausalLM:()=>n.MinistralForCausalLM,MinistralModel:()=>n.MinistralModel,MinistralPreTrainedModel:()=>n.MinistralPreTrainedModel,Mistral3ForConditionalGeneration:()=>n.Mistral3ForConditionalGeneration,MistralForCausalLM:()=>n.MistralForCausalLM,MistralModel:()=>n.MistralModel,MistralPreTrainedModel:()=>n.MistralPreTrainedModel,MobileBertForMaskedLM:()=>n.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>n.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>n.MobileBertForSequenceClassification,MobileBertModel:()=>n.MobileBertModel,MobileBertPreTrainedModel:()=>n.MobileBertPreTrainedModel,MobileBertTokenizer:()=>i.MobileBertTokenizer,MobileLLMForCausalLM:()=>n.MobileLLMForCausalLM,MobileLLMModel:()=>n.MobileLLMModel,MobileLLMPreTrainedModel:()=>n.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>m.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>n.MobileNetV1ForImageClassification,MobileNetV1ForSemanticSegmentation:()=>n.MobileNetV1ForSemanticSegmentation,MobileNetV1ImageProcessor:()=>m.MobileNetV1ImageProcessor,MobileNetV1Model:()=>n.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>n.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>m.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>n.MobileNetV2ForImageClassification,MobileNetV2ForSemanticSegmentation:()=>n.MobileNetV2ForSemanticSegmentation,MobileNetV2ImageProcessor:()=>m.MobileNetV2ImageProcessor,MobileNetV2Model:()=>n.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>n.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>m.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>n.MobileNetV3ForImageClassification,MobileNetV3ForSemanticSegmentation:()=>n.MobileNetV3ForSemanticSegmentation,MobileNetV3ImageProcessor:()=>m.MobileNetV3ImageProcessor,MobileNetV3Model:()=>n.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>n.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>m.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>n.MobileNetV4ForImageClassification,MobileNetV4ForSemanticSegmentation:()=>n.MobileNetV4ForSemanticSegmentation,MobileNetV4ImageProcessor:()=>m.MobileNetV4ImageProcessor,MobileNetV4Model:()=>n.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>n.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>m.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>n.MobileViTForImageClassification,MobileViTImageProcessor:()=>m.MobileViTImageProcessor,MobileViTModel:()=>n.MobileViTModel,MobileViTPreTrainedModel:()=>n.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>n.MobileViTV2ForImageClassification,MobileViTV2Model:()=>n.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>n.MobileViTV2PreTrainedModel,ModelOutput:()=>n.ModelOutput,ModernBertDecoderForCausalLM:()=>n.ModernBertDecoderForCausalLM,ModernBertDecoderModel:()=>n.ModernBertDecoderModel,ModernBertDecoderPreTrainedModel:()=>n.ModernBertDecoderPreTrainedModel,ModernBertForMaskedLM:()=>n.ModernBertForMaskedLM,ModernBertForSequenceClassification:()=>n.ModernBertForSequenceClassification,ModernBertForTokenClassification:()=>n.ModernBertForTokenClassification,ModernBertModel:()=>n.ModernBertModel,ModernBertPreTrainedModel:()=>n.ModernBertPreTrainedModel,Moondream1ForConditionalGeneration:()=>n.Moondream1ForConditionalGeneration,MoonshineFeatureExtractor:()=>f.MoonshineFeatureExtractor,MoonshineForConditionalGeneration:()=>n.MoonshineForConditionalGeneration,MoonshineModel:()=>n.MoonshineModel,MoonshinePreTrainedModel:()=>n.MoonshinePreTrainedModel,MoonshineProcessor:()=>g.MoonshineProcessor,MptForCausalLM:()=>n.MptForCausalLM,MptModel:()=>n.MptModel,MptPreTrainedModel:()=>n.MptPreTrainedModel,MultiModalityCausalLM:()=>n.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>n.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>n.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>n.MusicgenForConditionalGeneration,MusicgenModel:()=>n.MusicgenModel,MusicgenPreTrainedModel:()=>n.MusicgenPreTrainedModel,NanoChatForCausalLM:()=>n.NanoChatForCausalLM,NanoChatModel:()=>n.NanoChatModel,NanoChatPreTrainedModel:()=>n.NanoChatPreTrainedModel,NeoBertForMaskedLM:()=>n.NeoBertForMaskedLM,NeoBertForQuestionAnswering:()=>n.NeoBertForQuestionAnswering,NeoBertForSequenceClassification:()=>n.NeoBertForSequenceClassification,NeoBertForTokenClassification:()=>n.NeoBertForTokenClassification,NeoBertModel:()=>n.NeoBertModel,NeoBertPreTrainedModel:()=>n.NeoBertPreTrainedModel,NllbTokenizer:()=>i.NllbTokenizer,NoBadWordsLogitsProcessor:()=>S.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>S.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>n.NomicBertModel,NomicBertPreTrainedModel:()=>n.NomicBertPreTrainedModel,NougatImageProcessor:()=>m.NougatImageProcessor,NougatTokenizer:()=>i.NougatTokenizer,OPTForCausalLM:()=>n.OPTForCausalLM,OPTModel:()=>n.OPTModel,OPTPreTrainedModel:()=>n.OPTPreTrainedModel,ObjectDetectionPipeline:()=>t.ObjectDetectionPipeline,Olmo2ForCausalLM:()=>n.Olmo2ForCausalLM,Olmo2Model:()=>n.Olmo2Model,Olmo2PreTrainedModel:()=>n.Olmo2PreTrainedModel,OlmoForCausalLM:()=>n.OlmoForCausalLM,OlmoModel:()=>n.OlmoModel,OlmoPreTrainedModel:()=>n.OlmoPreTrainedModel,OpenELMForCausalLM:()=>n.OpenELMForCausalLM,OpenELMModel:()=>n.OpenELMModel,OpenELMPreTrainedModel:()=>n.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>m.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>n.OwlViTForObjectDetection,OwlViTImageProcessor:()=>m.OwlViTImageProcessor,OwlViTModel:()=>n.OwlViTModel,OwlViTPreTrainedModel:()=>n.OwlViTPreTrainedModel,OwlViTProcessor:()=>g.OwlViTProcessor,Owlv2ForObjectDetection:()=>n.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>m.Owlv2ImageProcessor,Owlv2Model:()=>n.Owlv2Model,Owlv2PreTrainedModel:()=>n.Owlv2PreTrainedModel,PaliGemmaForConditionalGeneration:()=>n.PaliGemmaForConditionalGeneration,PaliGemmaPreTrainedModel:()=>n.PaliGemmaPreTrainedModel,PaliGemmaProcessor:()=>g.PaliGemmaProcessor,ParakeetFeatureExtractor:()=>f.ParakeetFeatureExtractor,ParakeetForCTC:()=>n.ParakeetForCTC,ParakeetPreTrainedModel:()=>n.ParakeetPreTrainedModel,PatchTSMixerForPrediction:()=>n.PatchTSMixerForPrediction,PatchTSMixerModel:()=>n.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>n.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>n.PatchTSTForPrediction,PatchTSTModel:()=>n.PatchTSTModel,PatchTSTPreTrainedModel:()=>n.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>n.Phi3ForCausalLM,Phi3Model:()=>n.Phi3Model,Phi3PreTrainedModel:()=>n.Phi3PreTrainedModel,Phi3VForCausalLM:()=>n.Phi3VForCausalLM,Phi3VImageProcessor:()=>m.Phi3VImageProcessor,Phi3VPreTrainedModel:()=>n.Phi3VPreTrainedModel,Phi3VProcessor:()=>g.Phi3VProcessor,PhiForCausalLM:()=>n.PhiForCausalLM,PhiModel:()=>n.PhiModel,PhiPreTrainedModel:()=>n.PhiPreTrainedModel,Pipeline:()=>t.Pipeline,PixtralImageProcessor:()=>m.PixtralImageProcessor,PixtralProcessor:()=>g.PixtralProcessor,PreTrainedModel:()=>n.PreTrainedModel,PreTrainedTokenizer:()=>i.PreTrainedTokenizer,PretrainedConfig:()=>r.PretrainedConfig,PretrainedMixin:()=>n.PretrainedMixin,Processor:()=>M.Processor,PvtForImageClassification:()=>n.PvtForImageClassification,PvtImageProcessor:()=>m.PvtImageProcessor,PvtModel:()=>n.PvtModel,PvtPreTrainedModel:()=>n.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>f.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>n.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>n.PyAnnoteModel,PyAnnotePreTrainedModel:()=>n.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>g.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>n.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>t.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>n.Qwen2ForCausalLM,Qwen2Model:()=>n.Qwen2Model,Qwen2PreTrainedModel:()=>n.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>i.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>n.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>m.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>n.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>g.Qwen2VLProcessor,Qwen3ForCausalLM:()=>n.Qwen3ForCausalLM,Qwen3Model:()=>n.Qwen3Model,Qwen3PreTrainedModel:()=>n.Qwen3PreTrainedModel,RFDetrForObjectDetection:()=>n.RFDetrForObjectDetection,RFDetrModel:()=>n.RFDetrModel,RFDetrObjectDetectionOutput:()=>n.RFDetrObjectDetectionOutput,RFDetrPreTrainedModel:()=>n.RFDetrPreTrainedModel,RTDetrForObjectDetection:()=>n.RTDetrForObjectDetection,RTDetrImageProcessor:()=>m.RTDetrImageProcessor,RTDetrModel:()=>n.RTDetrModel,RTDetrObjectDetectionOutput:()=>n.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>n.RTDetrPreTrainedModel,RTDetrV2ForObjectDetection:()=>n.RTDetrV2ForObjectDetection,RTDetrV2Model:()=>n.RTDetrV2Model,RTDetrV2ObjectDetectionOutput:()=>n.RTDetrV2ObjectDetectionOutput,RTDetrV2PreTrainedModel:()=>n.RTDetrV2PreTrainedModel,RawAudio:()=>s.RawAudio,RawImage:()=>a.RawImage,RawVideo:()=>o.RawVideo,RawVideoFrame:()=>o.RawVideoFrame,RepetitionPenaltyLogitsProcessor:()=>S.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>n.ResNetForImageClassification,ResNetModel:()=>n.ResNetModel,ResNetPreTrainedModel:()=>n.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>n.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>n.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>n.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>n.RoFormerForTokenClassification,RoFormerModel:()=>n.RoFormerModel,RoFormerPreTrainedModel:()=>n.RoFormerPreTrainedModel,RoFormerTokenizer:()=>i.RoFormerTokenizer,RobertaForMaskedLM:()=>n.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>n.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>n.RobertaForSequenceClassification,RobertaForTokenClassification:()=>n.RobertaForTokenClassification,RobertaModel:()=>n.RobertaModel,RobertaPreTrainedModel:()=>n.RobertaPreTrainedModel,RobertaTokenizer:()=>i.RobertaTokenizer,Sam2ImageProcessor:()=>m.Sam2ImageProcessor,Sam2ImageSegmentationOutput:()=>n.Sam2ImageSegmentationOutput,Sam2Model:()=>n.Sam2Model,Sam2PreTrainedModel:()=>n.Sam2PreTrainedModel,Sam2Processor:()=>g.Sam2Processor,Sam2VideoProcessor:()=>g.Sam2VideoProcessor,Sam3ImageProcessor:()=>m.Sam3ImageProcessor,Sam3TrackerModel:()=>n.Sam3TrackerModel,SamImageProcessor:()=>m.SamImageProcessor,SamImageSegmentationOutput:()=>n.SamImageSegmentationOutput,SamModel:()=>n.SamModel,SamPreTrainedModel:()=>n.SamPreTrainedModel,SamProcessor:()=>g.SamProcessor,SapiensForDepthEstimation:()=>n.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>n.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>n.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>n.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>f.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>m.SegformerFeatureExtractor,SegformerForImageClassification:()=>n.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>n.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>m.SegformerImageProcessor,SegformerModel:()=>n.SegformerModel,SegformerPreTrainedModel:()=>n.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>n.Seq2SeqLMOutput,SequenceClassifierOutput:()=>n.SequenceClassifierOutput,SiglipImageProcessor:()=>m.SiglipImageProcessor,SiglipModel:()=>n.SiglipModel,SiglipPreTrainedModel:()=>n.SiglipPreTrainedModel,SiglipTextModel:()=>n.SiglipTextModel,SiglipTokenizer:()=>i.SiglipTokenizer,SiglipVisionModel:()=>n.SiglipVisionModel,SmolLM3ForCausalLM:()=>n.SmolLM3ForCausalLM,SmolLM3Model:()=>n.SmolLM3Model,SmolLM3PreTrainedModel:()=>n.SmolLM3PreTrainedModel,SmolVLMForConditionalGeneration:()=>n.SmolVLMForConditionalGeneration,SmolVLMImageProcessor:()=>m.SmolVLMImageProcessor,SmolVLMProcessor:()=>g.SmolVLMProcessor,SnacDecoderModel:()=>n.SnacDecoderModel,SnacEncoderModel:()=>n.SnacEncoderModel,SnacFeatureExtractor:()=>f.SnacFeatureExtractor,SnacModel:()=>n.SnacModel,SnacPreTrainedModel:()=>n.SnacPreTrainedModel,SpeechT5FeatureExtractor:()=>f.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>n.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>n.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>n.SpeechT5HifiGan,SpeechT5Model:()=>n.SpeechT5Model,SpeechT5PreTrainedModel:()=>n.SpeechT5PreTrainedModel,SpeechT5Processor:()=>g.SpeechT5Processor,SpeechT5Tokenizer:()=>i.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>n.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>n.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>n.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>n.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>n.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>i.SqueezeBertTokenizer,StableLmForCausalLM:()=>n.StableLmForCausalLM,StableLmModel:()=>n.StableLmModel,StableLmPreTrainedModel:()=>n.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>n.Starcoder2ForCausalLM,Starcoder2Model:()=>n.Starcoder2Model,Starcoder2PreTrainedModel:()=>n.Starcoder2PreTrainedModel,StoppingCriteria:()=>x.StoppingCriteria,StoppingCriteriaList:()=>x.StoppingCriteriaList,StyleTextToSpeech2Model:()=>n.StyleTextToSpeech2Model,StyleTextToSpeech2PreTrainedModel:()=>n.StyleTextToSpeech2PreTrainedModel,SummarizationPipeline:()=>t.SummarizationPipeline,SupertonicForConditionalGeneration:()=>n.SupertonicForConditionalGeneration,SupertonicPreTrainedModel:()=>n.SupertonicPreTrainedModel,SuppressTokensAtBeginLogitsProcessor:()=>S.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>n.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>m.Swin2SRImageProcessor,Swin2SRModel:()=>n.Swin2SRModel,Swin2SRPreTrainedModel:()=>n.Swin2SRPreTrainedModel,SwinForImageClassification:()=>n.SwinForImageClassification,SwinForSemanticSegmentation:()=>n.SwinForSemanticSegmentation,SwinModel:()=>n.SwinModel,SwinPreTrainedModel:()=>n.SwinPreTrainedModel,T5ForConditionalGeneration:()=>n.T5ForConditionalGeneration,T5Model:()=>n.T5Model,T5PreTrainedModel:()=>n.T5PreTrainedModel,T5Tokenizer:()=>i.T5Tokenizer,TableTransformerForObjectDetection:()=>n.TableTransformerForObjectDetection,TableTransformerModel:()=>n.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>n.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>n.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>S.TemperatureLogitsWarper,Tensor:()=>l.Tensor,Text2TextGenerationPipeline:()=>t.Text2TextGenerationPipeline,TextClassificationPipeline:()=>t.TextClassificationPipeline,TextGenerationPipeline:()=>t.TextGenerationPipeline,TextStreamer:()=>T.TextStreamer,TextToAudioPipeline:()=>t.TextToAudioPipeline,TokenClassificationPipeline:()=>t.TokenClassificationPipeline,TokenClassifierOutput:()=>n.TokenClassifierOutput,TokenizerModel:()=>i.TokenizerModel,TopKLogitsWarper:()=>S.TopKLogitsWarper,TopPLogitsWarper:()=>S.TopPLogitsWarper,TrOCRForCausalLM:()=>n.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>n.TrOCRPreTrainedModel,TranslationPipeline:()=>t.TranslationPipeline,UltravoxModel:()=>n.UltravoxModel,UltravoxPreTrainedModel:()=>n.UltravoxPreTrainedModel,UltravoxProcessor:()=>g.UltravoxProcessor,UniSpeechForCTC:()=>n.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>n.UniSpeechForSequenceClassification,UniSpeechModel:()=>n.UniSpeechModel,UniSpeechPreTrainedModel:()=>n.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>n.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>n.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>n.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>n.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>n.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>g.VLChatProcessor,VLMImageProcessor:()=>m.VLMImageProcessor,VaultGemmaForCausalLM:()=>n.VaultGemmaForCausalLM,VaultGemmaModel:()=>n.VaultGemmaModel,VaultGemmaPreTrainedModel:()=>n.VaultGemmaPreTrainedModel,ViTFeatureExtractor:()=>m.ViTFeatureExtractor,ViTForImageClassification:()=>n.ViTForImageClassification,ViTImageProcessor:()=>m.ViTImageProcessor,ViTMAEModel:()=>n.ViTMAEModel,ViTMAEPreTrainedModel:()=>n.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>n.ViTMSNForImageClassification,ViTMSNModel:()=>n.ViTMSNModel,ViTMSNPreTrainedModel:()=>n.ViTMSNPreTrainedModel,ViTModel:()=>n.ViTModel,ViTPreTrainedModel:()=>n.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>n.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>n.VitMatteForImageMatting,VitMatteImageProcessor:()=>m.VitMatteImageProcessor,VitMattePreTrainedModel:()=>n.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>n.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>m.VitPoseImageProcessor,VitPosePreTrainedModel:()=>n.VitPosePreTrainedModel,VitsModel:()=>n.VitsModel,VitsModelOutput:()=>n.VitsModelOutput,VitsPreTrainedModel:()=>n.VitsPreTrainedModel,VitsTokenizer:()=>i.VitsTokenizer,VoxtralForConditionalGeneration:()=>n.VoxtralForConditionalGeneration,VoxtralProcessor:()=>g.VoxtralProcessor,Wav2Vec2BertForCTC:()=>n.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>n.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>n.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>n.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>i.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>f.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>n.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>n.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>n.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>n.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>n.Wav2Vec2PreTrainedModel,Wav2Vec2Processor:()=>g.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>g.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>n.WavLMForAudioFrameClassification,WavLMForCTC:()=>n.WavLMForCTC,WavLMForSequenceClassification:()=>n.WavLMForSequenceClassification,WavLMForXVector:()=>n.WavLMForXVector,WavLMModel:()=>n.WavLMModel,WavLMPreTrainedModel:()=>n.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>f.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>n.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>n.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>f.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>n.WhisperForConditionalGeneration,WhisperModel:()=>n.WhisperModel,WhisperPreTrainedModel:()=>n.WhisperPreTrainedModel,WhisperProcessor:()=>g.WhisperProcessor,WhisperTextStreamer:()=>T.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>S.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>i.WhisperTokenizer,XLMForQuestionAnswering:()=>n.XLMForQuestionAnswering,XLMForSequenceClassification:()=>n.XLMForSequenceClassification,XLMForTokenClassification:()=>n.XLMForTokenClassification,XLMModel:()=>n.XLMModel,XLMPreTrainedModel:()=>n.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>n.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>n.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>n.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>n.XLMRobertaForTokenClassification,XLMRobertaModel:()=>n.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>n.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>i.XLMRobertaTokenizer,XLMTokenizer:()=>i.XLMTokenizer,XLMWithLMHeadModel:()=>n.XLMWithLMHeadModel,XVectorOutput:()=>n.XVectorOutput,YolosFeatureExtractor:()=>m.YolosFeatureExtractor,YolosForObjectDetection:()=>n.YolosForObjectDetection,YolosImageProcessor:()=>m.YolosImageProcessor,YolosModel:()=>n.YolosModel,YolosObjectDetectionOutput:()=>n.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>n.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>t.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>t.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>t.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>t.ZeroShotObjectDetectionPipeline,bankers_round:()=>u.bankers_round,cat:()=>l.cat,cos_sim:()=>u.cos_sim,dot:()=>u.dot,dynamic_time_warping:()=>u.dynamic_time_warping,env:()=>e.env,full:()=>l.full,full_like:()=>l.full_like,getCacheShapes:()=>r.getCacheShapes,hamming:()=>s.hamming,hanning:()=>s.hanning,interpolate:()=>l.interpolate,interpolate_4d:()=>l.interpolate_4d,interpolate_data:()=>u.interpolate_data,is_chinese_char:()=>i.is_chinese_char,layer_norm:()=>l.layer_norm,load_image:()=>a.load_image,load_video:()=>o.load_video,log_softmax:()=>u.log_softmax,magnitude:()=>u.magnitude,matmul:()=>l.matmul,max:()=>u.max,mean:()=>l.mean,mean_pooling:()=>l.mean_pooling,medianFilter:()=>u.medianFilter,mel_filter_bank:()=>s.mel_filter_bank,min:()=>u.min,ones:()=>l.ones,ones_like:()=>l.ones_like,permute:()=>l.permute,permute_data:()=>u.permute_data,pipeline:()=>t.pipeline,quantize_embeddings:()=>l.quantize_embeddings,rand:()=>l.rand,randn:()=>l.randn,read_audio:()=>s.read_audio,rfft:()=>l.rfft,round:()=>u.round,slice:()=>l.slice,softmax:()=>u.softmax,spectrogram:()=>s.spectrogram,stack:()=>l.stack,std_mean:()=>l.std_mean,topk:()=>l.topk,window_function:()=>s.window_function,zeros:()=>l.zeros,zeros_like:()=>l.zeros_like});var e=Xn("./src/env.js"),t=Xn("./src/pipelines.js"),n=Xn("./src/models.js"),i=Xn("./src/tokenizers.js"),r=Xn("./src/configs.js"),s=Xn("./src/utils/audio.js"),a=Xn("./src/utils/image.js"),o=Xn("./src/utils/video.js"),l=Xn("./src/utils/tensor.js"),u=Xn("./src/utils/maths.js"),c=Xn("./src/base/feature_extraction_utils.js"),f=Xn("./src/models/feature_extractors.js"),d=Xn("./src/models/auto/feature_extraction_auto.js"),h=Xn("./src/base/image_processors_utils.js"),m=Xn("./src/models/image_processors.js"),y=Xn("./src/models/auto/image_processing_auto.js"),M=Xn("./src/base/processing_utils.js"),g=Xn("./src/models/processors.js"),_=Xn("./src/models/auto/processing_auto.js"),T=Xn("./src/generation/streamers.js"),x=Xn("./src/generation/stopping_criteria.js"),S=Xn("./src/generation/logits_process.js")})();A.ASTFeatureExtractor;A.ASTForAudioClassification;A.ASTModel;A.ASTPreTrainedModel;A.AlbertForMaskedLM;A.AlbertForQuestionAnswering;A.AlbertForSequenceClassification;A.AlbertModel;A.AlbertPreTrainedModel;A.AlbertTokenizer;A.ArceeForCausalLM;A.ArceeModel;A.ArceePreTrainedModel;A.AudioClassificationPipeline;A.AutoConfig;A.AutoFeatureExtractor;A.AutoImageProcessor;A.AutoModel;A.AutoModelForAudioClassification;A.AutoModelForAudioFrameClassification;A.AutoModelForAudioTextToText;A.AutoModelForCTC;A.AutoModelForCausalLM;A.AutoModelForDepthEstimation;A.AutoModelForDocumentQuestionAnswering;A.AutoModelForImageClassification;A.AutoModelForImageFeatureExtraction;A.AutoModelForImageMatting;A.AutoModelForImageSegmentation;A.AutoModelForImageTextToText;A.AutoModelForImageToImage;A.AutoModelForMaskGeneration;A.AutoModelForMaskedLM;A.AutoModelForNormalEstimation;A.AutoModelForObjectDetection;A.AutoModelForPoseEstimation;A.AutoModelForQuestionAnswering;A.AutoModelForSemanticSegmentation;A.AutoModelForSeq2SeqLM;A.AutoModelForSequenceClassification;A.AutoModelForSpeechSeq2Seq;A.AutoModelForTextToSpectrogram;A.AutoModelForTextToWaveform;A.AutoModelForTokenClassification;A.AutoModelForUniversalSegmentation;A.AutoModelForVision2Seq;A.AutoModelForXVector;A.AutoModelForZeroShotObjectDetection;A.AutoProcessor;A.AutoTokenizer;A.AutomaticSpeechRecognitionPipeline;A.BackgroundRemovalPipeline;A.BartForConditionalGeneration;A.BartForSequenceClassification;A.BartModel;A.BartPretrainedModel;A.BartTokenizer;A.BaseModelOutput;A.BaseStreamer;A.BeitFeatureExtractor;A.BeitForImageClassification;A.BeitModel;A.BeitPreTrainedModel;A.BertForMaskedLM;A.BertForQuestionAnswering;A.BertForSequenceClassification;A.BertForTokenClassification;A.BertModel;A.BertPreTrainedModel;A.BertTokenizer;A.BitImageProcessor;A.BlenderbotForConditionalGeneration;A.BlenderbotModel;A.BlenderbotPreTrainedModel;A.BlenderbotSmallForConditionalGeneration;A.BlenderbotSmallModel;A.BlenderbotSmallPreTrainedModel;A.BlenderbotSmallTokenizer;A.BlenderbotTokenizer;A.BloomForCausalLM;A.BloomModel;A.BloomPreTrainedModel;A.BloomTokenizer;A.CLIPFeatureExtractor;A.CLIPImageProcessor;A.CLIPModel;A.CLIPPreTrainedModel;A.CLIPSegForImageSegmentation;A.CLIPSegModel;A.CLIPSegPreTrainedModel;A.CLIPTextModel;A.CLIPTextModelWithProjection;A.CLIPTokenizer;A.CLIPVisionModel;A.CLIPVisionModelWithProjection;A.CamembertForMaskedLM;A.CamembertForQuestionAnswering;A.CamembertForSequenceClassification;A.CamembertForTokenClassification;A.CamembertModel;A.CamembertPreTrainedModel;A.CamembertTokenizer;A.CausalLMOutput;A.CausalLMOutputWithPast;A.ChineseCLIPFeatureExtractor;A.ChineseCLIPModel;A.ChineseCLIPPreTrainedModel;A.ClapAudioModelWithProjection;A.ClapFeatureExtractor;A.ClapModel;A.ClapPreTrainedModel;A.ClapTextModelWithProjection;A.ClassifierFreeGuidanceLogitsProcessor;A.CodeGenForCausalLM;A.CodeGenModel;A.CodeGenPreTrainedModel;A.CodeGenTokenizer;A.CodeLlamaTokenizer;A.CohereForCausalLM;A.CohereModel;A.CoherePreTrainedModel;A.CohereTokenizer;A.ConvBertForMaskedLM;A.ConvBertForQuestionAnswering;A.ConvBertForSequenceClassification;A.ConvBertForTokenClassification;A.ConvBertModel;A.ConvBertPreTrainedModel;A.ConvBertTokenizer;A.ConvNextFeatureExtractor;A.ConvNextForImageClassification;A.ConvNextImageProcessor;A.ConvNextModel;A.ConvNextPreTrainedModel;A.ConvNextV2ForImageClassification;A.ConvNextV2Model;A.ConvNextV2PreTrainedModel;A.DFineForObjectDetection;A.DFineModel;A.DFinePreTrainedModel;A.DINOv3ConvNextModel;A.DINOv3ConvNextPreTrainedModel;A.DINOv3ViTImageProcessor;A.DINOv3ViTModel;A.DINOv3ViTPreTrainedModel;A.DPTFeatureExtractor;A.DPTForDepthEstimation;A.DPTImageProcessor;A.DPTModel;A.DPTPreTrainedModel;A.DacDecoderModel;A.DacDecoderOutput;A.DacEncoderModel;A.DacEncoderOutput;A.DacFeatureExtractor;A.DacModel;A.DacPreTrainedModel;A.DataTypeMap;A.DebertaForMaskedLM;A.DebertaForQuestionAnswering;A.DebertaForSequenceClassification;A.DebertaForTokenClassification;A.DebertaModel;A.DebertaPreTrainedModel;A.DebertaTokenizer;A.DebertaV2ForMaskedLM;A.DebertaV2ForQuestionAnswering;A.DebertaV2ForSequenceClassification;A.DebertaV2ForTokenClassification;A.DebertaV2Model;A.DebertaV2PreTrainedModel;A.DebertaV2Tokenizer;A.DecisionTransformerModel;A.DecisionTransformerPreTrainedModel;A.DeiTFeatureExtractor;A.DeiTForImageClassification;A.DeiTImageProcessor;A.DeiTModel;A.DeiTPreTrainedModel;A.DepthAnythingForDepthEstimation;A.DepthAnythingPreTrainedModel;A.DepthEstimationPipeline;A.DepthProForDepthEstimation;A.DepthProPreTrainedModel;A.DetrFeatureExtractor;A.DetrForObjectDetection;A.DetrForSegmentation;A.DetrImageProcessor;A.DetrModel;A.DetrObjectDetectionOutput;A.DetrPreTrainedModel;A.DetrSegmentationOutput;A.Dinov2ForImageClassification;A.Dinov2Model;A.Dinov2PreTrainedModel;A.Dinov2WithRegistersForImageClassification;A.Dinov2WithRegistersModel;A.Dinov2WithRegistersPreTrainedModel;A.DistilBertForMaskedLM;A.DistilBertForQuestionAnswering;A.DistilBertForSequenceClassification;A.DistilBertForTokenClassification;A.DistilBertModel;A.DistilBertPreTrainedModel;A.DistilBertTokenizer;A.DocumentQuestionAnsweringPipeline;A.DonutFeatureExtractor;A.DonutImageProcessor;A.DonutSwinModel;A.DonutSwinPreTrainedModel;A.EdgeTamModel;A.EfficientNetForImageClassification;A.EfficientNetImageProcessor;A.EfficientNetModel;A.EfficientNetPreTrainedModel;A.ElectraForMaskedLM;A.ElectraForQuestionAnswering;A.ElectraForSequenceClassification;A.ElectraForTokenClassification;A.ElectraModel;A.ElectraPreTrainedModel;A.ElectraTokenizer;A.EncodecFeatureExtractor;A.EosTokenCriteria;A.Ernie4_5ForCausalLM;A.Ernie4_5Model;A.Ernie4_5PreTrainedModel;A.EsmForMaskedLM;A.EsmForSequenceClassification;A.EsmForTokenClassification;A.EsmModel;A.EsmPreTrainedModel;A.EsmTokenizer;A.ExaoneForCausalLM;A.ExaoneModel;A.ExaonePreTrainedModel;A.FFT;A.FalconForCausalLM;A.FalconModel;A.FalconPreTrainedModel;A.FalconTokenizer;A.FastViTForImageClassification;A.FastViTModel;A.FastViTPreTrainedModel;A.FeatureExtractionPipeline;A.FeatureExtractor;A.FillMaskPipeline;A.Florence2ForConditionalGeneration;A.Florence2PreTrainedModel;A.Florence2Processor;A.ForcedBOSTokenLogitsProcessor;A.ForcedEOSTokenLogitsProcessor;A.GLPNFeatureExtractor;A.GLPNForDepthEstimation;A.GLPNModel;A.GLPNPreTrainedModel;A.GPT2LMHeadModel;A.GPT2Model;A.GPT2PreTrainedModel;A.GPT2Tokenizer;A.GPTBigCodeForCausalLM;A.GPTBigCodeModel;A.GPTBigCodePreTrainedModel;A.GPTJForCausalLM;A.GPTJModel;A.GPTJPreTrainedModel;A.GPTNeoForCausalLM;A.GPTNeoModel;A.GPTNeoPreTrainedModel;A.GPTNeoXForCausalLM;A.GPTNeoXModel;A.GPTNeoXPreTrainedModel;A.GPTNeoXTokenizer;A.Gemma2ForCausalLM;A.Gemma2Model;A.Gemma2PreTrainedModel;A.Gemma3ForCausalLM;A.Gemma3Model;A.Gemma3PreTrainedModel;A.Gemma3nAudioFeatureExtractor;A.Gemma3nForConditionalGeneration;A.Gemma3nPreTrainedModel;A.Gemma3nProcessor;A.GemmaForCausalLM;A.GemmaModel;A.GemmaPreTrainedModel;A.GemmaTokenizer;A.GlmForCausalLM;A.GlmModel;A.GlmPreTrainedModel;A.GraniteForCausalLM;A.GraniteModel;A.GraniteMoeHybridForCausalLM;A.GraniteMoeHybridModel;A.GraniteMoeHybridPreTrainedModel;A.GranitePreTrainedModel;A.Grok1Tokenizer;A.GroundingDinoForObjectDetection;A.GroundingDinoImageProcessor;A.GroundingDinoPreTrainedModel;A.GroundingDinoProcessor;A.GroupViTModel;A.GroupViTPreTrainedModel;A.HeliumForCausalLM;A.HeliumModel;A.HeliumPreTrainedModel;A.HerbertTokenizer;A.HieraForImageClassification;A.HieraModel;A.HieraPreTrainedModel;A.HubertForCTC;A.HubertForSequenceClassification;A.HubertModel;A.HubertPreTrainedModel;A.IJepaForImageClassification;A.IJepaModel;A.IJepaPreTrainedModel;A.Idefics3ForConditionalGeneration;A.Idefics3ImageProcessor;A.Idefics3PreTrainedModel;A.Idefics3Processor;A.ImageClassificationPipeline;A.ImageFeatureExtractionPipeline;A.ImageFeatureExtractor;A.ImageMattingOutput;A.ImageProcessor;A.ImageSegmentationPipeline;A.ImageToImagePipeline;A.ImageToTextPipeline;A.InterruptableStoppingCriteria;A.JAISLMHeadModel;A.JAISModel;A.JAISPreTrainedModel;A.JinaCLIPImageProcessor;A.JinaCLIPModel;A.JinaCLIPPreTrainedModel;A.JinaCLIPProcessor;A.JinaCLIPTextModel;A.JinaCLIPVisionModel;A.Lfm2ForCausalLM;A.Lfm2Model;A.Lfm2PreTrainedModel;A.LiteWhisperForConditionalGeneration;A.Llama4ForCausalLM;A.Llama4PreTrainedModel;A.LlamaForCausalLM;A.LlamaModel;A.LlamaPreTrainedModel;A.LlamaTokenizer;A.LlavaForConditionalGeneration;A.LlavaOnevisionForConditionalGeneration;A.LlavaOnevisionImageProcessor;A.LlavaPreTrainedModel;A.LlavaProcessor;A.LlavaQwen2ForCausalLM;A.LogitsProcessor;A.LogitsProcessorList;A.LogitsWarper;A.LongT5ForConditionalGeneration;A.LongT5Model;A.LongT5PreTrainedModel;A.M2M100ForConditionalGeneration;A.M2M100Model;A.M2M100PreTrainedModel;A.M2M100Tokenizer;A.MBart50Tokenizer;A.MBartForCausalLM;A.MBartForConditionalGeneration;A.MBartForSequenceClassification;A.MBartModel;A.MBartPreTrainedModel;A.MBartTokenizer;A.MPNetForMaskedLM;A.MPNetForQuestionAnswering;A.MPNetForSequenceClassification;A.MPNetForTokenClassification;A.MPNetModel;A.MPNetPreTrainedModel;A.MPNetTokenizer;A.MT5ForConditionalGeneration;A.MT5Model;A.MT5PreTrainedModel;A.MarianMTModel;A.MarianModel;A.MarianPreTrainedModel;A.MarianTokenizer;A.Mask2FormerImageProcessor;A.MaskFormerFeatureExtractor;A.MaskFormerForInstanceSegmentation;A.MaskFormerImageProcessor;A.MaskFormerModel;A.MaskFormerPreTrainedModel;A.MaskedLMOutput;A.MaxLengthCriteria;A.Metric3DForDepthEstimation;A.Metric3DPreTrainedModel;A.Metric3Dv2ForDepthEstimation;A.Metric3Dv2PreTrainedModel;A.MgpstrForSceneTextRecognition;A.MgpstrModelOutput;A.MgpstrPreTrainedModel;A.MgpstrProcessor;A.MgpstrTokenizer;A.MimiDecoderModel;A.MimiDecoderOutput;A.MimiEncoderModel;A.MimiEncoderOutput;A.MimiModel;A.MimiPreTrainedModel;A.MinLengthLogitsProcessor;A.MinNewTokensLengthLogitsProcessor;A.Ministral3ForCausalLM;A.Ministral3Model;A.Ministral3PreTrainedModel;A.MinistralForCausalLM;A.MinistralModel;A.MinistralPreTrainedModel;A.Mistral3ForConditionalGeneration;A.MistralForCausalLM;A.MistralModel;A.MistralPreTrainedModel;A.MobileBertForMaskedLM;A.MobileBertForQuestionAnswering;A.MobileBertForSequenceClassification;A.MobileBertModel;A.MobileBertPreTrainedModel;A.MobileBertTokenizer;A.MobileLLMForCausalLM;A.MobileLLMModel;A.MobileLLMPreTrainedModel;A.MobileNetV1FeatureExtractor;A.MobileNetV1ForImageClassification;A.MobileNetV1ForSemanticSegmentation;A.MobileNetV1ImageProcessor;A.MobileNetV1Model;A.MobileNetV1PreTrainedModel;A.MobileNetV2FeatureExtractor;A.MobileNetV2ForImageClassification;A.MobileNetV2ForSemanticSegmentation;A.MobileNetV2ImageProcessor;A.MobileNetV2Model;A.MobileNetV2PreTrainedModel;A.MobileNetV3FeatureExtractor;A.MobileNetV3ForImageClassification;A.MobileNetV3ForSemanticSegmentation;A.MobileNetV3ImageProcessor;A.MobileNetV3Model;A.MobileNetV3PreTrainedModel;A.MobileNetV4FeatureExtractor;A.MobileNetV4ForImageClassification;A.MobileNetV4ForSemanticSegmentation;A.MobileNetV4ImageProcessor;A.MobileNetV4Model;A.MobileNetV4PreTrainedModel;A.MobileViTFeatureExtractor;A.MobileViTForImageClassification;A.MobileViTImageProcessor;A.MobileViTModel;A.MobileViTPreTrainedModel;A.MobileViTV2ForImageClassification;A.MobileViTV2Model;A.MobileViTV2PreTrainedModel;A.ModelOutput;A.ModernBertDecoderForCausalLM;A.ModernBertDecoderModel;A.ModernBertDecoderPreTrainedModel;A.ModernBertForMaskedLM;A.ModernBertForSequenceClassification;A.ModernBertForTokenClassification;A.ModernBertModel;A.ModernBertPreTrainedModel;A.Moondream1ForConditionalGeneration;A.MoonshineFeatureExtractor;A.MoonshineForConditionalGeneration;A.MoonshineModel;A.MoonshinePreTrainedModel;A.MoonshineProcessor;A.MptForCausalLM;A.MptModel;A.MptPreTrainedModel;A.MultiModalityCausalLM;A.MultiModalityPreTrainedModel;A.MusicgenForCausalLM;A.MusicgenForConditionalGeneration;A.MusicgenModel;A.MusicgenPreTrainedModel;A.NanoChatForCausalLM;A.NanoChatModel;A.NanoChatPreTrainedModel;A.NeoBertForMaskedLM;A.NeoBertForQuestionAnswering;A.NeoBertForSequenceClassification;A.NeoBertForTokenClassification;A.NeoBertModel;A.NeoBertPreTrainedModel;A.NllbTokenizer;A.NoBadWordsLogitsProcessor;A.NoRepeatNGramLogitsProcessor;A.NomicBertModel;A.NomicBertPreTrainedModel;A.NougatImageProcessor;A.NougatTokenizer;A.OPTForCausalLM;A.OPTModel;A.OPTPreTrainedModel;A.ObjectDetectionPipeline;A.Olmo2ForCausalLM;A.Olmo2Model;A.Olmo2PreTrainedModel;A.OlmoForCausalLM;A.OlmoModel;A.OlmoPreTrainedModel;A.OpenELMForCausalLM;A.OpenELMModel;A.OpenELMPreTrainedModel;A.OwlViTFeatureExtractor;A.OwlViTForObjectDetection;A.OwlViTImageProcessor;A.OwlViTModel;A.OwlViTPreTrainedModel;A.OwlViTProcessor;A.Owlv2ForObjectDetection;A.Owlv2ImageProcessor;A.Owlv2Model;A.Owlv2PreTrainedModel;A.PaliGemmaForConditionalGeneration;A.PaliGemmaPreTrainedModel;A.PaliGemmaProcessor;A.ParakeetFeatureExtractor;A.ParakeetForCTC;A.ParakeetPreTrainedModel;A.PatchTSMixerForPrediction;A.PatchTSMixerModel;A.PatchTSMixerPreTrainedModel;A.PatchTSTForPrediction;A.PatchTSTModel;A.PatchTSTPreTrainedModel;A.Phi3ForCausalLM;A.Phi3Model;A.Phi3PreTrainedModel;A.Phi3VForCausalLM;A.Phi3VImageProcessor;A.Phi3VPreTrainedModel;A.Phi3VProcessor;A.PhiForCausalLM;A.PhiModel;A.PhiPreTrainedModel;A.Pipeline;A.PixtralImageProcessor;A.PixtralProcessor;A.PreTrainedModel;A.PreTrainedTokenizer;A.PretrainedConfig;A.PretrainedMixin;A.Processor;A.PvtForImageClassification;A.PvtImageProcessor;A.PvtModel;A.PvtPreTrainedModel;A.PyAnnoteFeatureExtractor;A.PyAnnoteForAudioFrameClassification;A.PyAnnoteModel;A.PyAnnotePreTrainedModel;A.PyAnnoteProcessor;A.QuestionAnsweringModelOutput;A.QuestionAnsweringPipeline;A.Qwen2ForCausalLM;A.Qwen2Model;A.Qwen2PreTrainedModel;A.Qwen2Tokenizer;A.Qwen2VLForConditionalGeneration;A.Qwen2VLImageProcessor;A.Qwen2VLPreTrainedModel;A.Qwen2VLProcessor;A.Qwen3ForCausalLM;A.Qwen3Model;A.Qwen3PreTrainedModel;A.RFDetrForObjectDetection;A.RFDetrModel;A.RFDetrObjectDetectionOutput;A.RFDetrPreTrainedModel;A.RTDetrForObjectDetection;A.RTDetrImageProcessor;A.RTDetrModel;A.RTDetrObjectDetectionOutput;A.RTDetrPreTrainedModel;A.RTDetrV2ForObjectDetection;A.RTDetrV2Model;A.RTDetrV2ObjectDetectionOutput;A.RTDetrV2PreTrainedModel;A.RawAudio;A.RawImage;A.RawVideo;A.RawVideoFrame;A.RepetitionPenaltyLogitsProcessor;A.ResNetForImageClassification;A.ResNetModel;A.ResNetPreTrainedModel;A.RoFormerForMaskedLM;A.RoFormerForQuestionAnswering;A.RoFormerForSequenceClassification;A.RoFormerForTokenClassification;A.RoFormerModel;A.RoFormerPreTrainedModel;A.RoFormerTokenizer;A.RobertaForMaskedLM;A.RobertaForQuestionAnswering;A.RobertaForSequenceClassification;A.RobertaForTokenClassification;A.RobertaModel;A.RobertaPreTrainedModel;A.RobertaTokenizer;A.Sam2ImageProcessor;A.Sam2ImageSegmentationOutput;A.Sam2Model;A.Sam2PreTrainedModel;A.Sam2Processor;A.Sam2VideoProcessor;A.Sam3ImageProcessor;A.Sam3TrackerModel;A.SamImageProcessor;A.SamImageSegmentationOutput;A.SamModel;A.SamPreTrainedModel;A.SamProcessor;A.SapiensForDepthEstimation;A.SapiensForNormalEstimation;A.SapiensForSemanticSegmentation;A.SapiensPreTrainedModel;A.SeamlessM4TFeatureExtractor;A.SegformerFeatureExtractor;A.SegformerForImageClassification;A.SegformerForSemanticSegmentation;A.SegformerImageProcessor;A.SegformerModel;A.SegformerPreTrainedModel;A.Seq2SeqLMOutput;A.SequenceClassifierOutput;A.SiglipImageProcessor;A.SiglipModel;A.SiglipPreTrainedModel;A.SiglipTextModel;A.SiglipTokenizer;A.SiglipVisionModel;A.SmolLM3ForCausalLM;A.SmolLM3Model;A.SmolLM3PreTrainedModel;A.SmolVLMForConditionalGeneration;A.SmolVLMImageProcessor;A.SmolVLMProcessor;A.SnacDecoderModel;A.SnacEncoderModel;A.SnacFeatureExtractor;A.SnacModel;A.SnacPreTrainedModel;A.SpeechT5FeatureExtractor;A.SpeechT5ForSpeechToText;A.SpeechT5ForTextToSpeech;A.SpeechT5HifiGan;A.SpeechT5Model;A.SpeechT5PreTrainedModel;A.SpeechT5Processor;A.SpeechT5Tokenizer;A.SqueezeBertForMaskedLM;A.SqueezeBertForQuestionAnswering;A.SqueezeBertForSequenceClassification;A.SqueezeBertModel;A.SqueezeBertPreTrainedModel;A.SqueezeBertTokenizer;A.StableLmForCausalLM;A.StableLmModel;A.StableLmPreTrainedModel;A.Starcoder2ForCausalLM;A.Starcoder2Model;A.Starcoder2PreTrainedModel;A.StoppingCriteria;A.StoppingCriteriaList;A.StyleTextToSpeech2Model;A.StyleTextToSpeech2PreTrainedModel;A.SummarizationPipeline;A.SupertonicForConditionalGeneration;A.SupertonicPreTrainedModel;A.SuppressTokensAtBeginLogitsProcessor;A.Swin2SRForImageSuperResolution;A.Swin2SRImageProcessor;A.Swin2SRModel;A.Swin2SRPreTrainedModel;A.SwinForImageClassification;A.SwinForSemanticSegmentation;A.SwinModel;A.SwinPreTrainedModel;A.T5ForConditionalGeneration;A.T5Model;A.T5PreTrainedModel;A.T5Tokenizer;A.TableTransformerForObjectDetection;A.TableTransformerModel;A.TableTransformerObjectDetectionOutput;A.TableTransformerPreTrainedModel;A.TemperatureLogitsWarper;A.Tensor;A.Text2TextGenerationPipeline;A.TextClassificationPipeline;A.TextGenerationPipeline;A.TextStreamer;A.TextToAudioPipeline;A.TokenClassificationPipeline;A.TokenClassifierOutput;A.TokenizerModel;A.TopKLogitsWarper;A.TopPLogitsWarper;A.TrOCRForCausalLM;A.TrOCRPreTrainedModel;A.TranslationPipeline;A.UltravoxModel;A.UltravoxPreTrainedModel;A.UltravoxProcessor;A.UniSpeechForCTC;A.UniSpeechForSequenceClassification;A.UniSpeechModel;A.UniSpeechPreTrainedModel;A.UniSpeechSatForAudioFrameClassification;A.UniSpeechSatForCTC;A.UniSpeechSatForSequenceClassification;A.UniSpeechSatModel;A.UniSpeechSatPreTrainedModel;A.VLChatProcessor;A.VLMImageProcessor;A.VaultGemmaForCausalLM;A.VaultGemmaModel;A.VaultGemmaPreTrainedModel;A.ViTFeatureExtractor;A.ViTForImageClassification;A.ViTImageProcessor;A.ViTMAEModel;A.ViTMAEPreTrainedModel;A.ViTMSNForImageClassification;A.ViTMSNModel;A.ViTMSNPreTrainedModel;A.ViTModel;A.ViTPreTrainedModel;A.VisionEncoderDecoderModel;A.VitMatteForImageMatting;A.VitMatteImageProcessor;A.VitMattePreTrainedModel;A.VitPoseForPoseEstimation;A.VitPoseImageProcessor;A.VitPosePreTrainedModel;A.VitsModel;A.VitsModelOutput;A.VitsPreTrainedModel;A.VitsTokenizer;A.VoxtralForConditionalGeneration;A.VoxtralProcessor;A.Wav2Vec2BertForCTC;A.Wav2Vec2BertForSequenceClassification;A.Wav2Vec2BertModel;A.Wav2Vec2BertPreTrainedModel;A.Wav2Vec2CTCTokenizer;A.Wav2Vec2FeatureExtractor;A.Wav2Vec2ForAudioFrameClassification;A.Wav2Vec2ForCTC;A.Wav2Vec2ForSequenceClassification;A.Wav2Vec2Model;A.Wav2Vec2PreTrainedModel;A.Wav2Vec2Processor;A.Wav2Vec2ProcessorWithLM;A.WavLMForAudioFrameClassification;A.WavLMForCTC;A.WavLMForSequenceClassification;A.WavLMForXVector;A.WavLMModel;A.WavLMPreTrainedModel;A.WeSpeakerFeatureExtractor;A.WeSpeakerResNetModel;A.WeSpeakerResNetPreTrainedModel;A.WhisperFeatureExtractor;A.WhisperForConditionalGeneration;A.WhisperModel;A.WhisperPreTrainedModel;A.WhisperProcessor;A.WhisperTextStreamer;A.WhisperTimeStampLogitsProcessor;A.WhisperTokenizer;A.XLMForQuestionAnswering;A.XLMForSequenceClassification;A.XLMForTokenClassification;A.XLMModel;A.XLMPreTrainedModel;A.XLMRobertaForMaskedLM;A.XLMRobertaForQuestionAnswering;A.XLMRobertaForSequenceClassification;A.XLMRobertaForTokenClassification;A.XLMRobertaModel;A.XLMRobertaPreTrainedModel;A.XLMRobertaTokenizer;A.XLMTokenizer;A.XLMWithLMHeadModel;A.XVectorOutput;A.YolosFeatureExtractor;A.YolosForObjectDetection;A.YolosImageProcessor;A.YolosModel;A.YolosObjectDetectionOutput;A.YolosPreTrainedModel;A.ZeroShotAudioClassificationPipeline;A.ZeroShotClassificationPipeline;A.ZeroShotImageClassificationPipeline;A.ZeroShotObjectDetectionPipeline;A.bankers_round;A.cat;A.cos_sim;A.dot;A.dynamic_time_warping;var pT=A.env;A.full;A.full_like;A.getCacheShapes;A.hamming;A.hanning;A.interpolate;A.interpolate_4d;A.interpolate_data;A.is_chinese_char;A.layer_norm;A.load_image;A.load_video;A.log_softmax;A.magnitude;A.matmul;A.max;A.mean;A.mean_pooling;A.medianFilter;A.mel_filter_bank;A.min;A.ones;A.ones_like;A.permute;A.permute_data;A.pipeline;A.quantize_embeddings;A.rand;A.randn;A.read_audio;A.rfft;A.round;A.slice;A.softmax;A.spectrogram;A.stack;A.std_mean;A.topk;A.window_function;A.zeros;A.zeros_like;const hT="transformers-cache";pT.backends.onnx.executionProviders=["webgpu","wasm"];pT.useBrowserCache=!0;pT.cacheDir=hT;const CO=async e=>{if(!("caches"in window))return!1;try{const t=await caches.open(hT),n=`https://huggingface.co/${e}/resolve/main/config.json`;return!!await t.match(n)}catch(t){return console.error(`Error checking ASR cache status for ${e}:`,t),!1}},Die=async()=>{if("caches"in window)try{await caches.delete(hT),console.log("ASR model cache cleared successfully.")}catch(e){throw console.error("Error clearing ASR model cache:",e),e}},Uh=async(e,t={})=>{const{noiseSuppression:n=!1,gain:i=1}=t,r=window.AudioContext||window.webkitAudioContext,s=window.OfflineAudioContext||window.webkitOfflineAudioContext;if(!r)throw new Error("Your browser does not support the Web Audio API, which is required for transcription.");const a=await e.arrayBuffer(),o=new r,l=await o.decodeAudioData(a);let u;if(l.numberOfChannels>1){u=new Float32Array(l.length);for(let M=0;M<l.length;M++){let g=0;for(let _=0;_<l.numberOfChannels;_++)g+=l.getChannelData(_)[M];u[M]=g/l.numberOfChannels}}else u=l.getChannelData(0);const c=16e3,f=o.createBuffer(1,u.length,l.sampleRate);f.copyToChannel(u,0);const d=new s(1,Math.ceil(f.duration*c),c),h=d.createBufferSource();h.buffer=f;let m=h;if(n){const M=d.createBiquadFilter();M.type="highpass",M.frequency.value=100,m.connect(M),m=M}if(i&&i!==1){const M=d.createGain();M.gain.value=i,m.connect(M),m=M}m.connect(d.destination),h.start();const y=await d.startRendering();return await o.close(),y.getChannelData(0)},$O=window.SpeechRecognition||window.webkitSpeechRecognition,Oie=({onResult:e,onError:t,onStart:n,onEnd:i})=>{const[r,s]=Ie.useState(!1),a=Ie.useRef(null),o=Ie.useRef(!1);Ie.useEffect(()=>{if(!$O){console.warn("Web Speech API is not supported by this browser.");return}const c=new $O;return c.continuous=!0,c.interimResults=!0,c.onstart=()=>{s(!0),n()},c.onend=()=>{if(o.current)try{c.start()}catch{s(!1),i()}else s(!1),i()},c.onerror=f=>{o.current=!1,f.error!=="no-speech"&&f.error!=="aborted"&&t(f.error)},c.onresult=f=>{let d="",h="";for(let m=f.resultIndex;m<f.results.length;++m)f.results[m].isFinal?h+=f.results[m][0].transcript:d+=f.results[m][0].transcript;h?e(h,!0):d&&e(d,!1)},a.current=c,()=>{o.current=!1,c.stop()}},[e,t,n,i]);const l=Ie.useCallback(c=>{if(a.current&&!r)try{a.current.lang=c,o.current=!0,a.current.start()}catch(f){console.error("Could not start speech recognition:",f),t("Failed to start recognition.")}},[r,t]),u=Ie.useCallback(()=>{a.current&&r&&(o.current=!1,a.current.stop())},[r]);return Ie.useMemo(()=>({isListening:r,startRecognition:l,stopRecognition:u}),[r,l,u])};var Rie=Object.defineProperty,Nie=(e,t,n)=>t in e?Rie(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,AO=(e,t,n)=>Nie(e,typeof t!="symbol"?t+"":t,n);let m8=(e,t)=>new OffscreenCanvas(e,t);function Np(e,t){return m8(e,t)}function Lie(e){m8=e}function IO(e){return e>0?Math.floor(e):Math.ceil(e)}function id(e,t,n){return Math.max(t,Math.min(e,n))}function mT(e,t,n,i,r="high"){return zie(e,t,n,i,r).getImageData(0,0,t,n)}function zie(e,t,n,i,r="high"){const s=ec(e),a=Np(t,n).getContext("2d");return a.imageSmoothingEnabled=r!==!1,r&&(a.imageSmoothingQuality=r),i==="fill"?a.scale(Math.min(t/e.width,1),Math.min(n/e.height,1)):a.scale(t/e.width,n/e.height),a.drawImage(s,0,0),a}function ec(e,t,n){const i=Np(t||e.width,n||e.height);return i.getContext("2d").putImageData(e,0,0),i}function gT(e,t,n){const i=e.data,r=[],s=[],a=[];let o=0,l=0;for(let u=0;u<i.length;u+=4)a[l]||(a[l]=[]),s[l]||(s[l]=[]),r[l]||(r[l]=[]),r[l][o]=(i[u]/255-t[0])/n[0],s[l][o]=(i[u+1]/255-t[1])/n[1],a[l][o]=(i[u+2]/255-t[2])/n[2],o++,o===e.width&&(o=0,l++);return[a,s,r]}let g8=class{constructor(t){AO(this,"tl",[]),AO(this,"name"),this.name=t}l(t){const n=performance.now();this.tl.push({t,n});const i=[];for(let s=1;s<this.tl.length;s++){const a=this.tl[s].n-this.tl[s-1].n,o=this.tl[s-1].t,l=i.find(u=>u.n===o);l?(l.c++,l.d+=a):i.push({d:a,n:o,c:1})}const r=[];for(const s of i){const a=s.c>1?`${s.n}x${s.c}`:s.n;r.push(`${a} ${s.d}`)}r.push(this.tl.at(-1).t),console.log(`${this.name} ${i.map(s=>s.d).reduce((s,a)=>s+a,0)}ms: `,r.join(" "))}};async function Fie(e,t,n,i,r,s){const{transposedData:a,image:o}=Bie(e,r,s),l=(await Uie(a,o,t,n))[0].data,u=l.reduce((f,d)=>Math.max(f,d)),c=l.findIndex(f=>f===u);return i[c]}function Bie(e,t,n){const i=mT(e,t,n);return{transposedData:gT(i,[.485,.456,.406],[.229,.224,.225]),image:i}}async function Uie(e,t,n,i){const r=e.flat(Number.POSITIVE_INFINITY),s=Float32Array.from(r),a=new n.Tensor("float32",s,[1,3,t.height,t.width]),o={};o[i.inputNames[0]]=a;const l=await i.run(o);return Object.values(l)}function Vie(e){if(e.length===0)throw new Error("Empty contour");const t=Gie([...e]);let n=Number.POSITIVE_INFINITY;const i={center:{x:0,y:0},size:{width:0,height:0},angle:0};for(let r=0;r<t.length;r++){const s=t[r],a=t[(r+1)%t.length],o={x:a.x-s.x,y:a.y-s.y},l=Math.hypot(o.x,o.y),[u,c]=[o.x/l,o.y/l];let f=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,h=Number.POSITIVE_INFINITY,m=Number.NEGATIVE_INFINITY;for(const M of t){const g=(M.x-s.x)*u+(M.y-s.y)*c;f=Math.min(f,g),d=Math.max(d,g);const _=-(M.x-s.x)*c+(M.y-s.y)*u;h=Math.min(h,_),m=Math.max(m,_)}const y=(d-f)*(m-h);if(y<n){n=y;const M=(f+d)/2,g=(h+m)/2;i.center={x:s.x+u*M-c*g,y:s.y+c*M+u*g},i.size={width:d-f,height:m-h},i.angle=Math.atan2(c,u)*(180/Math.PI)}}return i.size.width<i.size.height&&([i.size.width,i.size.height]=[i.size.height,i.size.width],i.angle+=90),i.angle=(i.angle%180+180)%180,i}function Gie(e){e.sort((i,r)=>i.x-r.x||i.y-r.y);const t=[];for(const i of e){for(;t.length>=2&&PO(t[t.length-2],t[t.length-1],i)<=0;)t.pop();t.push(i)}const n=[];for(let i=e.length-1;i>=0;i--){const r=e[i];for(;n.length>=2&&PO(n[n.length-2],n[n.length-1],r)<=0;)n.pop();n.push(r)}return t.slice(0,-1).concat(n.slice(0,-1))}function PO(e,t,n){return(t.x-e.x)*(n.y-e.y)-(t.y-e.y)*(n.x-e.x)}function jie(e,t,n="CHAIN_APPROX_SIMPLE"){const i=e.length,r=i>0?e[0].length:0,s=Array.from({length:i},()=>new Array(r).fill(!1));for(let a=0;a<i;a++)for(let o=0;o<r;o++)if(e[a][o]!==0&&!s[a][o]&&_8(e,o,a)){const l=Wie(e,s,o,a,n==="CHAIN_APPROX_SIMPLE");t.push(l)}}function _8(e,t,n){return e[n][t]!==0&&(n>0&&e[n-1][t]===0||n<e.length-1&&e[n+1][t]===0||t>0&&e[n][t-1]===0||t<e[0].length-1&&e[n][t+1]===0)}function Wie(e,t,n,i,r){const s=[];let a={x:n,y:i},o={x:n-1,y:i};const l=new Map,u=new Map;function c(y){return y.x+y.y*e[0].length}function f(y){const M=Math.floor(y/e[0].length);return{x:y%e[0].length,y:M}}function d(y,M){const g=c(y),_=c(M),T=wv(M.x-y.x,M.y-y.y),x=wv(y.x-M.x,y.y-M.y),S=l.get(g)??[],$=l.get(_)??[];l.set(g,[...S,T]),l.set(_,[...$,x])}function h(y){const M=c(a);o=a,a={x:a.x+wg[y].dx,y:a.y+wg[y].dy},d(o,a);const g=(u.get(M)??[]).filter(_=>_!==y);g.length>0?u.set(M,g):u.delete(M)}l.set(c(a),[wv(-1,0)]);let m=0;do{s.push(a),t[a.y][a.x]=!0;const y=Hie(e,l,a);if(y.length===0){if(u.size===0)break;const[M,g]=Array.from(u.entries()).at(0),_=g[0];a=f(M),h(_)}if(y.length>=1){const M=c(a);u.set(M,y);const g=y[0];h(g)}m++}while(m<1e9);return r?qie(s):s}const wg=[{dx:1,dy:0},{dx:1,dy:-1},{dx:0,dy:-1},{dx:-1,dy:-1},{dx:-1,dy:0},{dx:-1,dy:1},{dx:0,dy:1},{dx:1,dy:1}];function Hie(e,t,n){function i(a){return a.x+a.y*e[0].length}const r=t.get(i(n))??[],s=[];for(const[a,{dx:o,dy:l}]of wg.entries()){if(r.includes(a))continue;const u=n.x+o,c=n.y+l;u>=0&&u<e[0].length&&c>=0&&c<e.length&&_8(e,u,c)&&s.push(a)}return s}function wv(e,t){const n=wg.findIndex(({dx:i,dy:r})=>e===i&&t===r);return n===-1?0:n}function qie(e){if(e.length<3)return[...e];const t=[e[0]];for(let n=1;n<e.length-1;n++){const i=t[t.length-1],r=e[n],s=e[n+1];Kie(i,r,s)||t.push(r)}return t.push(e[e.length-1]),t}function Kie(e,t,n){return(t.x-e.x)*(n.y-t.y)===(t.y-e.y)*(n.x-t.x)}const Wu=new g8("t"),_l=new g8("af_det");let Za=!1,_T=!1;function yp(e,t){var n;const i=document.createElement("canvas");i.width=e.width,i.height=e.height,i.getContext("2d").drawImage(e,0,0),t&&(i.id=t);try{(n=document==null?void 0:document.body)==null||n.append(i)}catch{}}let s_=(e,t,n)=>new ImageData(e,t,n);function Us(...e){_T&&console.log(...e)}function Jie(...e){_T&&console.log(e.map(t=>`%c${t}`).join(""),...e.map(t=>`color: ${t}`))}async function Yie(e){Xie(e);const t={det:"det"in e?e.det:{input:e.detPath,ratio:e.detRatio,on:async i=>{e.onDet&&e.onDet(i),e.onProgress&&e.onProgress("det",1,1)}},rec:"rec"in e?e.rec:{input:e.recPath,decodeDic:e.dic,imgh:e.imgh,on:async(i,r,s)=>{e.onRec&&e.onRec(i,{text:r.map(a=>a[0].t).join(""),mean:r.map(a=>a[0].mean).reduce((a,o)=>a+o,0)/r.length}),e.onProgress&&e.onProgress("rec",s,i+1)}},docCls:"rec"in e?e.docCls:e.docClsPath?{input:e.docClsPath}:void 0,analyzeLayout:"rec"in e?e.analyzeLayout:{columnsTip:e.columnsTip,docDirs:e.docDirs},...e};return await Zie(t)}function Xie(e){Za=!!e.dev,_T=Za||!!e.log,Za||(Wu.l=()=>{},_l.l=()=>{}),e.canvas&&Lie(e.canvas),e.imageData&&(s_=e.imageData)}async function Qie(e){let t;if(typeof window>"u"){const n=e;if(!n.data||!n.width||!n.height)throw new Error("invalid image data");return n}if(typeof e=="string"?(t=new Image,t.src=e,await new Promise(n=>{t.onload=n})):t=e,t instanceof HTMLImageElement){const n=Np(t.naturalWidth,t.naturalHeight).getContext("2d");if(!n)throw new Error("canvas context is null");n.drawImage(t,0,0),t=n.getImageData(0,0,t.naturalWidth,t.naturalHeight)}if(t instanceof HTMLCanvasElement){const n=t.getContext("2d");if(!n)throw new Error("canvas context is null");t=n.getImageData(0,0,t.width,t.height)}return t}function yT(){try{Np(1,1),s_(new Uint8ClampedArray(4),1,1)}catch(e){throw console.log("nodejs need set canvas, please use setOCREnv to set canvas and imageData"),e}}async function Zie(e){yT();const t={ort:e.ort,ortOption:e.ortOption},n=e.docCls?await ere({...e.docCls,...t}):void 0,i=await tre({...e.det,...t}),r=await nre({...e.rec,...t});return{ocr:async s=>{let a=await Qie(s),o=0;n&&(o=await n.docCls(a),Us("dir",o),a=v8(a,360-o));const l=await i.det(a),u=await r.rec(l),c=vre(u,e.analyzeLayout);return Us(u,c),Wu.l("end"),{src:u,...c,docDir:o}},det:i.det,rec:r.rec,recRaw:r.rawRec}}function vT(e,t,n){return e.InferenceSession.create(t,n)}async function ere(e){const t=await vT(e.ort,e.input,e.ortOption);return{docCls:async n=>Fie(n,e.ort,t,[0,90,180,270],224,224)}}async function tre(e){yT();let t=1;const n=await vT(e.ort,e.input,e.ortOption);e.ratio!==void 0&&(t=e.ratio);async function i(r){var s;const a=r;if(Za){const m=ec(a);yp(m)}Wu.l("pre_det");const{data:o,width:l,height:u}=sre(a,t),{transposedData:c,image:f}=o;Wu.l("det");const d=await ire(c,f,n,e.ort);Wu.l("aft_det");const h=are({data:d.data,width:d.dims[3],height:d.dims[2]},l,u,a);return(s=e==null?void 0:e.on)==null||s.call(e,h),h}return{det:i}}async function nre(e){var t;yT();let n=48;const i=await vT(e.ort,e.input,e.ortOption),r=e.decodeDic.split(/\r\n|\r|\n/)||[];r.at(-1)===""?r[r.length-1]=" ":r.push(" "),e.imgh&&(n=e.imgh);const s=((t=e.optimize)==null?void 0:t.space)===void 0?!0:e.optimize.space;async function a(l,u){var c,f,d;const h=[];Wu.l("bf_rec");const m=_re(l,n),y=(u==null?void 0:u.topK)||((c=e.multiChar)==null?void 0:c.topK)||2,M=(u==null?void 0:u.threshold)||((f=e.multiChar)==null?void 0:f.threshold)||1e-5;for(const[g,_]of m.entries()){const{b:T,imgH:x,imgW:S}=_,$=await rre(T,x,S,i,e.ort),C=yre($,r,{topK:y,threshold:M})[0];h.push({text:C,box:l[g].box,style:l[g].style}),(d=e==null?void 0:e.on)==null||d.call(e,g,C,l.length)}return Wu.l("rec_end"),h}async function o(l){const u=[],c=await a(l,{topK:2,threshold:1e-5});for(const f of c){const d=f.text.map(y=>s&&y[0].t===""&&y[1].t===" "&&y[1].mean>.001?y[1]:y[0]),h=d.map(y=>y.t).join("").trim(),m=d.map(y=>y.mean).reduce((y,M)=>y+M,0)/d.length;m<.5||u.push({text:h,mean:m,box:f.box,style:f.style})}return u}return{rec:o,rawRec:a}}async function ire(e,t,n,i){const r=Float32Array.from(e.flat(3)),s=new i.Tensor("float32",r,[1,3,t.height,t.width]),a={};return a[n.inputNames[0]]=s,(await n.run(a))[n.outputNames[0]]}async function rre(e,t,n,i,r){const s=Float32Array.from(e.flat(3)),a=new r.Tensor("float32",s,[1,3,t,n]),o={};return o[i.inputNames[0]]=a,(await i.run(o))[i.outputNames[0]]}function sre(e,t){const n=Math.max(Math.round(e.height*t/32)*32,32),i=Math.max(Math.round(e.width*t/32)*32,32);if(Za){const a=ec(e);yp(a)}const r=mT(e,i,n,"fill"),s=gT(r,[.485,.456,.406],[.229,.224,.225]);if(Us(r),Za){const a=ec(r);yp(a)}return{data:{transposedData:s,image:r},width:i,height:n}}function are(e,t,n,i){_l.l("");const r=Math.min(i.width,t),s=Math.min(i.height,n),{data:a,width:o,height:l}=e,u=new Uint8Array(o*l);for(let h=0;h<a.length;h++){const m=a[h]>.3?255:0;u[h]=m}if(Za){const h=new Uint8ClampedArray(o*l*4);for(let M=0;M<a.length;M++){const g=M*4,_=a[M]>.3?255:0;h[g]=h[g+1]=h[g+2]=_,h[g+3]=255,u[M]=_}const m=s_(h,o,l),y=ec(m);yp(y,"det_ru")}_l.l("edge");const c=[],f=[];for(let h=0;h<l;h++)f.push(Array.from(u.slice(h*o,h*o+o)));const d=[];if(jie(f,d),Za){const h=document.querySelector("#det_ru").getContext("2d");for(const m of d){h.moveTo(m[0].x,m[0].y);for(const y of m)h.lineTo(y.x,y.y);h.strokeStyle="red",h.closePath(),h.stroke()}}for(let h=0;h<d.length;h++){_l.l("get_box");const m=3,y=d[h],{points:M,sside:g}=dre(y);if(g<m)continue;const _=ure(M),T=_.points;if(_.sside<m+2)continue;const x=i.width/r,S=i.height/s;for(let V=0;V<T.length;V++)T[V][0]*=x,T[V][1]*=S;_l.l("order");const $=fre(T);for(const V of $)V[0]=id(Math.round(V[0]),0,i.width),V[1]=id(Math.round(V[1]),0,i.height);const C=IO(kO($[0],$[1])),P=IO(kO($[0],$[3]));if(C<=3||P<=3)continue;wre(T,"","red","det_ru"),_l.l("crop");const O=pre(i,T);_l.l("match best");const{bg:R,text:G}=hre(O),W=gre(T,O,G);c.push({box:W,img:O,style:{bg:R,text:G}})}return _l.l("e"),Us(c),c}function ore(e){let t=-1;const n=e.length;let i,r=e[n-1],s=0;for(;++t<n;)i=r,r=e[t],s+=i[1]*r[0]-i[0]*r[1];return s/2}function lre(e){let t=-1;const n=e.length;let i=e[n-1],r,s,a=i[0],o=i[1],l=0;for(;++t<n;)r=a,s=o,i=e[t],a=i[0],o=i[1],r-=a,s-=o,l+=Math.hypot(r,s);return l}function ure(e){const t=Math.abs(ore(e)),n=lre(e),i=t*1.5/n,r=[];for(const[l,u]of e.entries()){const c=e.at((l-1)%4),f=e.at((l+1)%4),d=u[0]-c[0],h=u[1]-c[1],m=Math.sqrt(d**2+h**2),y=d/m*i,M=h/m*i,g=u[0]-f[0],_=u[1]-f[1],T=Math.sqrt(g**2+_**2),x=g/T*i,S=_/T*i;r.push([u[0]+y+x,u[1]+M+S])}const s=[r[0][0]-r[1][0],r[0][1]-r[1][1]],a=[r[2][0]-r[1][0],r[2][1]-r[1][1]],o=s[0]*a[1]-s[1]*a[0];return{points:r,sside:Math.abs(o)}}function cre(e,t,n){const i=t.width,r=t.height,s=n*Math.PI/180,a=Math.cos(s),o=Math.sin(s),l=e.x,u=e.y,c=i*.5,f=r*.5,d=[],h=l-c*a+f*o,m=u-c*o-f*a;d.push([h,m]);const y=l+c*a+f*o,M=u+c*o-f*a;d.push([y,M]);const g=l+c*a-f*o,_=u+c*o+f*a;d.push([g,_]);const T=l-c*a-f*o,x=u-c*o+f*a;return d.push([T,x]),d}function dre(e){const t=Vie(e),n=Array.from(cre(t.center,t.size,t.angle)).sort((u,c)=>u[0]-c[0]);let i=0,r=1,s=2,a=3;n[1][1]>n[0][1]?(i=0,a=1):(i=1,a=0),n[3][1]>n[2][1]?(r=2,s=3):(r=3,s=2);const o=[n[i],n[r],n[s],n[a]],l=Math.min(t.size.height,t.size.width);return{points:o,sside:l}}function kO(e,t){return Math.sqrt((e[0]-t[0])**2+(e[1]-t[1])**2)}function fre(e){const t=[[0,0],[0,0],[0,0],[0,0]],n=e.map(s=>s[0]+s[1]);t[0]=e[n.indexOf(Math.min(...n))],t[2]=e[n.indexOf(Math.max(...n))];const i=e.filter(s=>s!==t[0]&&s!==t[2]),r=i[1].map((s,a)=>s-i[0][a]);return t[1]=i[r.indexOf(Math.min(...r))],t[3]=i[r.indexOf(Math.max(...r))],t}function pre(e,t){const[n,i,r,s]=t.map($=>({x:$[0],y:$[1]})),a=Math.sqrt((i.x-n.x)**2+(i.y-n.y)**2),o=Math.sqrt((s.x-n.x)**2+(s.y-n.y)**2),l=i.x-n.x,u=i.y-n.y,c=s.x-n.x,f=s.y-n.y,d=l*f-c*u;if(d===0)throw new Error("");const h=a*f/d,m=-c*a/d,y=-o*u/d,M=l*o/d,g=-h*n.x-m*n.y,_=-y*n.x-M*n.y,T=ec(e),x=Np(Math.ceil(a),Math.ceil(o)),S=x.getContext("2d");return S.setTransform(h,y,m,M,g,_),S.drawImage(T,0,0),S.resetTransform(),S.getImageData(0,0,x.width,x.height)}function hre(e){var t,n;const i=new Map,r=e.data;for(let c=0;c<r.length;c+=4){if(c/4%e.width>e.height*4)continue;const f=r[c],d=r[c+1],h=r[c+2],m=[f,d,h].join(",");i.set(m,(i.get(m)||0)+1)}const s=mre(i,20).map(c=>({el:c.el.split(",").map(Number),count:c.count})),a=((t=s.at(0))==null?void 0:t.el)||[255,255,255],o=((n=s.at(1))==null?void 0:n.el)||[0,0,0];let l=o;const u=100;if(Sm(o,a)<u){const c=s.slice(1).filter(f=>Sm(f.el,a)>50);c.length>0&&(l=[0,1,2].map(f=>Math.round(y8(c.map(d=>[d.el[f],d.count]))))),(c.length===0||Sm(l,a)<u)&&(l=a.map(f=>255-f)),Jie(`rgb(${l.join(",")})`)}return{bg:a,text:l,textEdge:o}}function Sm(e,t){const n=e,i=t;return Math.sqrt((n[0]-i[0])**2+(n[1]-i[1])**2+(n[2]-i[2])**2)}function mre(e,t=1){let n=[];return e.forEach((i,r)=>{n.length===0?n.push({el:r,count:i}):(n.length<t?n.push({el:r,count:i}):n.find(s=>s.count<=i)&&n.push({el:r,count:i}),n.sort((s,a)=>a.count-s.count),n.length>t&&(n=n.slice(0,t)))}),n}function gre(e,t,n){let i=0,r=t.height,s=0,a=t.width;function o(d){return Sm(d,n)<200}e:for(let d=i;d<t.height;d++)for(let h=0;h<t.width;h++){const m=Vh(t,h,d);if(o(m)){i=d;break e}}e:for(let d=r-1;d>=0;d--)for(let h=0;h<t.width;h++){const m=Vh(t,h,d);if(o(m)){r=d;break e}}e:for(let d=s;d<t.width;d++)for(let h=i;h<=r;h++){const m=Vh(t,d,h);if(o(m)){s=d;break e}}e:for(let d=a-1;d>=0;d--)for(let h=i;h<=r;h++){const m=Vh(t,d,h);if(o(m)){a=d;break e}}const l=id(i-1,0,4),u=id(t.height-r-1,0,4),c=id(s-1,0,4),f=id(t.width-a-1,0,4);return[[e[0][0]+c,e[0][1]+l],[e[1][0]-f,e[1][1]+l],[e[2][0]-f,e[2][1]-u],[e[3][0]+c,e[3][1]-u]]}function Vh(e,t,n){const i=(n*e.width+t)*4;return Array.from(e.data.slice(i,i+4))}function _re(e,t){const n=[];function i(r){const s=Math.floor(t*(r.width/r.height)),a=mT(r,s,t,void 0,!1);return Za&&yp(ec(a,s,t)),{data:a,w:s,h:t}}for(const r of e){let s=r.img;s.width<s.height&&(s=v8(s,-90));const a=i(s);n.push({b:gT(a.data,[.5,.5,.5],[.5,.5,.5]),imgH:a.h,imgW:a.w})}return Us(n),n}function yre(e,t,n){const i=e.dims[2],r=[];let s=e.dims[0]-1;const a=n.topK,o=n.threshold;function l(c){return t.at(c-1)??""}for(let c=0;c<e.data.length;c+=i*e.dims[1]){const f=[];for(let d=c;d<c+i*e.dims[1];d+=i){const h=e.data.slice(d,d+i),m=[];for(let y=0;y<h.length;y++){const M=h[y];if(!(M<o)){if(!(m.length===a&&M<=m.at(-1).v)){const g=m.findIndex(_=>_.v>M);g===-1?m.unshift({t:y,v:M}):m.splice(g+1,0,{t:y,v:M})}m.length>a&&m.pop()}}f.push(m)}r[s]=u(f),s--}function u(c){const f=[];for(let d=0;d<c.length;d++)c[d][0].t!==0&&(d>0&&c[d-1][0].t===c[d][0].t||f.push(c[d].map(h=>({t:l(h.t),mean:h.v}))));return f}return r}function vre(e,t){var n;Us(e);const i=(t==null?void 0:t.docDirs)??[{block:"tb",inline:"lr"},{block:"rl",inline:"tb"}],r={block:"tb",inline:"lr"},s={inline:[1,0],block:[0,1]},a={inline:[1,0],block:[0,1]};if(e.length===0)return{columns:[],parragraphs:[],readingDir:r,angle:{reading:{inline:0,block:90},angle:0}};const o=[{box:[[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY],[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],[Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY]],type:"none"}],l=0;function u(Z){const he=f.center(Z);for(let ye=o.length-1;ye>=0;ye--){const Ke=o[ye].box;if(he[0]>=Ke[0][0]&&he[0]<=Ke[1][0]&&he[1]>=Ke[0][1]&&he[1]<=Ke[3][1])return ye}return l}const c={center:(Z,he)=>[(Z[0]+he[0])/2,(Z[1]+he[1])/2],disByV:(Z,he,ye)=>Math.abs(ye==="block"?d.dotMup(Z,a.block)-d.dotMup(he,a.block):d.dotMup(Z,a.inline)-d.dotMup(he,a.inline)),compare:(Z,he,ye)=>ye==="block"?d.dotMup(Z,a.block)-d.dotMup(he,a.block):d.dotMup(Z,a.inline)-d.dotMup(he,a.inline),toInline:Z=>d.dotMup(Z,a.inline),toBlock:Z=>d.dotMup(Z,a.block)},f={inlineStart:Z=>c.center(Z[0],Z[3]),inlineEnd:Z=>c.center(Z[1],Z[2]),blockStart:Z=>c.center(Z[0],Z[1]),blockEnd:Z=>c.center(Z[2],Z[3]),inlineSize:Z=>Z[1][0]-Z[0][0],blockSize:Z=>Z[3][1]-Z[0][1],inlineStartDis:(Z,he)=>c.disByV(Z[0],he[0],"inline"),inlineEndDis:(Z,he)=>c.disByV(Z[1],he[1],"inline"),blockGap:(Z,he)=>c.disByV(Z[0],he[3],"block"),inlineCenter:Z=>(Z[2][0]+Z[0][0])/2,blockCenter:Z=>(Z[2][1]+Z[0][1])/2,inlineStartCenter:Z=>f.inlineStart(Z),center:Z=>c.center(Z[0],Z[2])},d={fromPonts:(Z,he)=>[Z[0]-he[0],Z[1]-he[1]],dotMup:(Z,he)=>Z[0]*he[0]+Z[1]*he[1],numMup:(Z,he)=>[Z[0]*he,Z[1]*he],add:(Z,he)=>[Z[0]+he[0],Z[1]+he[1]]};function h(Z){let he=0,ye=0;const Ke=[];for(const[Be,Se]of Z.entries()){const Oe=Se>180?Se-180:Se,ct=Oe-180,bt=Be===0?Oe:Math.abs(ct-he)<Math.abs(Oe-he)?ct:Oe;Ke.push(bt),he=(he*ye+bt)/(ye+1),ye++}return{av:he,l:Ke}}function m(Z,he){return Math.abs(Z-he)<45||Math.abs(Z-(he-180))<45||Math.abs(Z-180-he)<45}function y(Z){Z.sort((ye,Ke)=>ye-Ke);const he=Math.floor(Z.length/2);return Z.length%2===0?(Z[he-1]+Z[he])/2:Z[he]}function M(Z){return Z==="lr"||Z==="rl"?"x":"y"}function g(Z,he){let ye=Number.POSITIVE_INFINITY,Ke=-1;for(let Be=0;Be<Z.length;Be++){const Se=he(Z[Be]);Se<ye&&(ye=Se,Ke=Be)}return Z[Ke]}const _={lr:[1,0],rl:[-1,0],tb:[0,1],bt:[0,-1]};function T(Z,he){const ye=_[Z.inline],Ke=_[Z.block],Be=_[he.inline],Se=_[he.block],Oe=[d.dotMup(Be,ye),d.dotMup(Be,Ke)],ct=[d.dotMup(Se,ye),d.dotMup(Se,Ke)];return bt=>[d.dotMup(bt,Oe),d.dotMup(bt,ct)]}function x(Z,he){const ye=T(Z,he);return{b:Ke=>{for(const Be of Ke){const[Se,Oe]=ye(Be);Be[0]=Se,Be[1]=Oe}},p:ye}}function S(Z){return he=>{const ye=[[0,0],[0,0],[0,0],[0,0]];for(let Ke=0;Ke<Z.length;Ke++)ye[Ke]=he[Z[Ke]];return ye}}function $(Z,he){return Math.sqrt((Z[0]-he[0])**2+(Z[1]-he[1])**2)}function C(Z){const he=Z.flatMap(Ct=>Ct.map(Et=>Et)),ye=Math.min(...he.map(Ct=>d.dotMup(Ct,a.inline))),Ke=Math.max(...he.map(Ct=>d.dotMup(Ct,a.inline))),Be=Math.min(...he.map(Ct=>d.dotMup(Ct,a.block))),Se=Math.max(...he.map(Ct=>d.dotMup(Ct,a.block))),Oe=d.add(d.numMup(a.inline,ye),d.numMup(a.block,Be)),ct=d.numMup(a.inline,Ke-ye),bt=d.numMup(a.block,Se-Be);return[Oe,d.add(Oe,ct),d.add(d.add(Oe,ct),bt),d.add(Oe,bt)]}function P(Z){let he=null,ye=Number.POSITIVE_INFINITY;for(const bt in ue){const Ct=ue[bt].src.at(-1);if(!Ct)continue;const Et=$(Z.box[0],Ct.box[0]);Et<ye&&(he=Number(bt),ye=Et)}if(he===null){ue.push({src:[Z]});return}const Ke=ue[he].src.at(-1),Be=f.inlineSize(Z.box),Se=f.inlineSize(Ke.box),Oe=Math.min(Be,Se),ct=f.blockSize(Z.box);if(!((f.inlineStartDis(Z.box,Ke.box)<3*ct||f.inlineEndDis(Z.box,Ke.box)<3*ct||c.disByV(f.center(Z.box),f.center(Ke.box),"inline")<Oe*.4)&&f.blockGap(Z.box,Ke.box)<ct*1.1)){ue.push({src:[Z]});return}ue[he].src.push(Z)}function O(Z){var he,ye;const Ke=new RegExp("\\p{Ideographic}","u"),Be=/[]/,Se={box:C(Z.map(Oe=>Oe.box)),text:"",mean:y8(Z.map(Oe=>[Oe.mean,Oe.text.length])),style:Z[0].style};for(const Oe of Z){const ct=Se.text.at(-1);ct&&(!ct.match(Ke)&&!ct.match(Be)||!((he=Oe.text.at(0))!=null&&he.match(Ke))&&!((ye=Oe.text.at(0))!=null&&ye.match(Be)))&&(Se.text+=" "),Se.text+=Oe.text}return Se}function R(Z){Z.sort((he,ye)=>{const Ke=he.src.at(0)?f.blockSize(he.src.at(0).box):2;return c.disByV(f.blockStart(he.outerBox),f.blockStart(ye.outerBox),"block")<Ke?c.compare(f.inlineStart(he.outerBox),f.inlineStart(ye.outerBox),"inline"):c.compare(f.blockStart(he.outerBox),f.blockStart(ye.outerBox),"block")})}if(t!=null&&t.columnsTip)for(const Z of t.columnsTip)o.push(structuredClone(Z));const G={inline:0,block:90},W=e.map(Z=>{const he=Z.box,ye=he[1][0]-he[0][0],Ke=he[3][1]-he[0][1];let Be={x:0,y:0};if(ye<Ke){const Se=d.fromPonts(c.center(he[2],he[3]),c.center(he[0],he[1]));Be={x:Se[0],y:Se[1]}}else{const Se=d.fromPonts(c.center(he[1],he[2]),c.center(he[0],he[3]));Be={x:Se[0],y:Se[1]}}return Cm(Math.atan2(Be.y,Be.x)*(180/Math.PI))}),V=h(W),te=W.filter(Z=>m(Z,V.av)),J=y(te),j=y(te.map(Z=>Math.abs(Z-J))),Y=te.filter(Z=>Math.abs((Z-J)/(j*1.4826))<2),X=Cm(h(Y).av);Us("dir0",W,V,te,Y,X);const ce=Cm(X+90),me=m(X,0)?"x":"y",Q=m(ce,90)?"y":"x",H=i.find(Z=>me===M(Z.inline)&&Q===M(Z.block))??i.at(0);H&&(r.block=H.block,r.inline=H.inline);const B={lr:0,rl:180,tb:90,bt:270};G.inline=g([X,X-360,X-180,X+180],Z=>Math.abs(Z-B[r.inline])),G.block=g([ce,ce-360,ce-180,ce+180],Z=>Math.abs(Z-B[r.block])),s.inline=[Math.cos(G.inline*(Math.PI/180)),Math.sin(G.inline*(Math.PI/180))],s.block=[Math.cos(G.block*(Math.PI/180)),Math.sin(G.block*(Math.PI/180))],Us("dir",r,G,s,X,ce);const ee=[[r.inline[0],r.block[0]],[r.inline[1],r.block[0]],[r.inline[1],r.block[1]],[r.inline[0],r.block[1]]].map(([Z,he])=>({lt:0,rt:1,rb:2,lb:3})[Z==="l"||Z==="r"?Z+he:he+Z]),_e=x({inline:"lr",block:"tb"},r),le=S(ee),ae=e.map(Z=>{const he=le(Z.box);return _e.b(he),{...Z,box:he}});for(const Z of o)Z.box=le(Z.box),_e.b(Z.box);a.inline=_e.p(s.inline),a.block=_e.p(s.block),Us("",a);const Ne=ae.sort((Z,he)=>c.compare(f.blockStart(Z.box),f.blockStart(he.box),"block")),Ye=[];for(const Z of Ne){const he=u(Z.box),ye=(n=Ye.at(-1))==null?void 0:n.line.at(-1);if(!ye){Ye.push({line:[{src:Z,colId:he}]});continue}const Ke=f.center(Z.box),Be=f.center(ye.src.box);if(c.disByV(Ke,Be,"block")<.5*f.blockSize(Z.box)){const Se=Ye.at(-1);Se?Se.line.push({src:Z,colId:he}):Ye.push({line:[{src:Z,colId:he}]})}else Ye.push({line:[{src:Z,colId:he}]})}const ze=[];for(const Z of Ye){if(Z.line.length===1){ze.push({src:Z.line[0].src,colId:Z.line[0].colId});continue}const he=bv(Z.line.map(Ke=>f.blockSize(Ke.src.box)));Z.line.sort((Ke,Be)=>c.compare(f.inlineStart(Ke.src.box),f.inlineStart(Be.src.box),"inline"));let ye=Z.line.at(0);for(const Ke of Z.line.slice(1)){const Be=f.inlineEnd(ye.src.box),Se=f.inlineStart(Ke.src.box);o[Ke.colId].type==="table"||Ke.colId!==ye.colId||c.toInline(Se)-c.toInline(Be)>he?(ze.push({...ye}),ye=Ke):(ye.src.text+=Ke.src.text,ye.src.mean=(ye.src.mean+Ke.src.mean)/2,ye.src.box=C([ye.src.box,Ke.src.box]))}ze.push({...ye})}const ue=[],U=[],we=[];for(const Z of ze)if(Z.colId===l)U.push(Z);else{const he=we.find(ye=>ye.colId===Z.colId);he?he.src.push(Z.src):we.push({src:[Z.src],type:o[Z.colId].type,colId:Z.colId})}U.sort((Z,he)=>c.compare(f.blockStart(Z.src.box),f.blockStart(he.src.box),"block"));for(const Z of U)P(Z.src);const Pe=[];for(const[Z,he]of ue.entries()){const ye=he.src,Ke=C(ye.map(ct=>ct.box)),Be=f.blockCenter(Ke),Se=f.inlineSize(Ke);if(Z===0){Pe.push({smallCol:[{src:ye,outerBox:Ke,x:Be,w:Se}]});continue}const Oe=Pe.find(ct=>{const bt=ct.smallCol.at(-1),Ct=f.blockSize(ye.at(0).box);return f.inlineStartDis(bt.outerBox,Ke)<3*Ct&&f.inlineEndDis(bt.outerBox,Ke)<3*Ct&&f.blockGap(Ke,bt.outerBox)<Ct*2.1});Oe?Oe.smallCol.push({src:ye,outerBox:Ke,x:Be,w:Se}):Pe.push({smallCol:[{src:ye,outerBox:Ke,x:Be,w:Se}]})}for(const Z of Pe)Z.smallCol.sort((he,ye)=>c.compare(f.blockStart(he.outerBox),f.blockStart(ye.outerBox),"block"));for(const Z of we)Z.src.sort((he,ye)=>c.compare(f.blockStart(he.box),f.blockStart(ye.box),"block"));const ke=[];for(const Z of Pe){const he=C(Z.smallCol.map(Ke=>Ke.outerBox)),ye=Z.smallCol.flatMap(Ke=>Ke.src);ke.push({src:ye,outerBox:he,type:"none"})}R(ke);const Le=[];for(const Z of ke){const he=Le.at(-1);if(!he){Le.push(Z);continue}if(he.type!=="none"){Le.push(Z);continue}const ye=he.outerBox,Ke=f.blockSize(Z.src[0].box);he.src.length===1&&f.inlineStartDis(ye,Z.outerBox)<3*Ke||Z.src.length===1&&f.inlineStartDis(ye,Z.outerBox)<3*Ke||f.inlineStartDis(ye,Z.outerBox)<3*Ke&&f.inlineEndDis(ye,Z.outerBox)<3*Ke?(he.src.push(...Z.src),he.outerBox=C(he.src.map(Be=>Be.box))):Le.push(Z)}let Ge=!1;const $e=[];for(const Z of Le){const he=$e.at(-1),ye={...Z,reCal:!1};if(!he){$e.push(ye);continue}const Ke=f.blockSize(ye.src.at(0).box);c.compare(f.blockEnd(ye.outerBox),f.blockEnd(he.outerBox),"block")<0&&(f.inlineStartDis(he.outerBox,ye.outerBox)<3*Ke||f.inlineEndDis(he.outerBox,ye.outerBox)<3*Ke)?(he.src.push(...ye.src),he.reCal=!0,Ge=!0):$e.push(ye)}for(const Z of $e)Z.reCal&&(Z.src.sort((he,ye)=>c.compare(f.blockStart(he.box),f.blockStart(ye.box),"block")),Z.outerBox=C(Z.src.map(he=>he.box)));we.length&&(Ge=!0);for(const Z of we){const he=C(Z.src.map(Ke=>Ke.box)),ye=Z.src;$e.push({src:ye,outerBox:he,type:Z.type,reCal:!1})}Ge&&R($e);const et=x(r,{inline:"lr",block:"tb"}),Ce=$e.map(Z=>{const he=Z.src,ye=[];if(Z.type==="auto"||Z.type==="none"){const Se={};for(let Et=1;Et<he.length;Et++){const hn=he[Et-1].box,En=he[Et].box,Kt=c.disByV(f.center(En),f.center(hn),"block");Se[Kt]||(Se[Kt]=0),Se[Kt]++}const Oe=bv(he.map(Et=>f.blockSize(Et.box))),ct=[[]];for(const Et of Object.keys(Se).map(hn=>Number(hn)).sort()){const hn=ct.at(-1),En=hn.at(-1);En!==void 0?Math.abs(En-Et)<Oe*.5?hn.push(Et):ct.push([]):hn.push(Et)}const bt=ct.map(Et=>bv(Et)).sort((Et,hn)=>Et-hn).at(0)||0;Us("d",Se,ct,bt),ye.push([he[0]]);let Ct=he[0];for(let Et=1;Et<he.length;Et++){const hn=d.add(d.add(f.inlineStartCenter(Ct.box),d.numMup(a.block,bt)),d.numMup(a.inline,-f.inlineStartDis(Ct.box,Z.outerBox))),En=f.inlineStartCenter(he[Et].box),Kt=f.blockSize(he[Et].box);if(f.inlineEndDis(Ct.box,Z.outerBox)>2*Kt||$(hn,En)>Kt*.5)ye.push([he[Et]]);else{const yi=ye.at(-1);yi?yi.push(he[Et]):ye.push([he[Et]])}Ct=he[Et]}}else(Z.type==="table"||Z.type==="raw"||Z.type==="raw-blank")&&ye.push(he);for(const Se of he)et.b(Se.box);et.b(Z.outerBox);const Ke=[];for(const[Se,Oe]of ee.entries())Ke[Oe]=Se;const Be=S(Ke);for(const Se of he)Se.box=Be(Se.box);return Z.outerBox=Be(Z.outerBox),Us(ye),{src:he,outerBox:Z.outerBox,parragraphs:ye.map(Se=>({src:Se,parse:O(Se)}))}}),He=Ce.flatMap(Z=>Z.parragraphs.map(he=>he.parse));let at=0;return r.inline==="lr"&&(at=G.inline),r.inline==="rl"&&(at=G.inline-180),r.block==="lr"&&(at=G.block),r.block==="rl"&&(at=G.block-180),Us("angle",at),{columns:Ce,parragraphs:He,readingDir:r,angle:{reading:G,angle:at}}}function bv(e){return e.reduce((t,n)=>t+n,0)/e.length}function y8(e){const t=e.map(i=>i[1]).reduce((i,r)=>i+r,0);let n=0;for(const i of e)n+=i[0]*i[1]/t;return n}function Cm(e){return(e%360+360)%360}function v8(e,t){const n=Cm(t);if(n===0)return e;if(![90,180,270].includes(n))throw new Error("90");const i=new Uint8ClampedArray(e.height*e.width*4);for(let a=0;a<e.height;a++)for(let o=0;o<e.width;o++){const l=a*e.width+o,u=n===90?o*e.height+(e.height-a-1):n===180?e.width-o-1+(e.height-a-1)*e.width:(e.width-o-1)*e.height+a;i.set(e.data.slice(l*4,l*4+4),u*4)}const r=n===90||n===270?e.height:e.width,s=n===90||n===270?e.width:e.height;return s_(i,r,s)}function wre(e,t="",n,i,r){if(!Za)return;const s=document.querySelector(`#${i}`).getContext("2d");s.beginPath(),s.strokeStyle=n,s.moveTo(e[0][0],e[0][1]),s.lineTo(e[1][0],e[1][1]),s.lineTo(e[2][0],e[2][1]),s.lineTo(e[3][0],e[3][1]),s.lineTo(e[0][0],e[0][1]),s.stroke(),s.strokeStyle="black",s.strokeText(t,e[0][0],e[0][1])}/*!
 * ONNX Runtime Web v1.23.2
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var wT=Object.defineProperty,bre=Object.getOwnPropertyDescriptor,xre=Object.getOwnPropertyNames,Tre=Object.prototype.hasOwnProperty,Mre=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),ft=(e,t)=>()=>(e&&(t=e(e=0)),t),Vd=(e,t)=>{for(var n in t)wT(e,n,{get:t[n],enumerable:!0})},Ere=(e,t,n,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of xre(t))!Tre.call(e,r)&&r!==n&&wT(e,r,{get:()=>t[r],enumerable:!(i=bre(t,r))||i.enumerable});return e},vp=e=>Ere(wT({},"__esModule",{value:!0}),e),ff,hl,Lu,DO,w8,b8=ft(()=>{ff=new Map,hl=[],Lu=(e,t,n)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let i=ff.get(e);if(i===void 0)ff.set(e,{backend:t,priority:n});else{if(i.priority>n)return;if(i.priority===n&&i.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let r=hl.indexOf(e);r!==-1&&hl.splice(r,1);for(let s=0;s<hl.length;s++)if(ff.get(hl[s]).priority<=n){hl.splice(s,0,e);return}hl.push(e)}return}throw new TypeError("not a valid backend")},DO=async e=>{let t=ff.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(i){return n||(t.error=`${i}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},w8=async e=>{let t=e.executionProviders||[],n=t.map(l=>typeof l=="string"?l:l.name),i=n.length===0?hl:n,r,s=[],a=new Set;for(let l of i){let u=await DO(l);typeof u=="string"?s.push({name:l,err:u}):(r||(r=u),r===u&&a.add(l))}if(!r)throw new Error(`no available backend found. ERR: ${s.map(l=>`[${l.name}] ${l.err}`).join(", ")}`);for(let{name:l,err:u}of s)n.includes(l)&&console.warn(`removing requested execution provider "${l}" from session options because it is not available: ${u}`);let o=t.filter(l=>a.has(typeof l=="string"?l:l.name));return[r,new Proxy(e,{get:(l,u)=>u==="executionProviders"?o:Reflect.get(l,u)})]}}),Sre=ft(()=>{b8()}),x8,Cre=ft(()=>{x8="1.23.2"}),xv,wr,T8=ft(()=>{Cre(),xv="warning",wr={wasm:{},webgl:{},webgpu:{},versions:{common:x8},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);xv=e}},get logLevel(){return xv}},Object.defineProperty(wr,"logLevel",{enumerable:!0})}),bi,$re=ft(()=>{T8(),bi=wr}),M8,E8,Are=ft(()=>{M8=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let i=n.getContext("2d");if(i!=null){let r,s;(t==null?void 0:t.tensorLayout)!==void 0&&t.tensorLayout==="NHWC"?(r=e.dims[2],s=e.dims[3]):(r=e.dims[3],s=e.dims[2]);let a=(t==null?void 0:t.format)!==void 0?t.format:"RGB",o=t==null?void 0:t.norm,l,u;o===void 0||o.mean===void 0?l=[255,255,255,255]:typeof o.mean=="number"?l=[o.mean,o.mean,o.mean,o.mean]:(l=[o.mean[0],o.mean[1],o.mean[2],0],o.mean[3]!==void 0&&(l[3]=o.mean[3])),o===void 0||o.bias===void 0?u=[0,0,0,0]:typeof o.bias=="number"?u=[o.bias,o.bias,o.bias,o.bias]:(u=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(u[3]=o.bias[3]));let c=s*r,f=0,d=c,h=c*2,m=-1;a==="RGBA"?(f=0,d=c,h=c*2,m=c*3):a==="RGB"?(f=0,d=c,h=c*2):a==="RBG"&&(f=0,h=c,d=c*2);for(let y=0;y<s;y++)for(let M=0;M<r;M++){let g=(e.data[f++]-u[0])*l[0],_=(e.data[d++]-u[1])*l[1],T=(e.data[h++]-u[2])*l[2],x=m===-1?255:(e.data[m++]-u[3])*l[3];i.fillStyle="rgba("+g+","+_+","+T+","+x+")",i.fillRect(M,y,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},E8=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),i;if(n!=null){let r,s,a;(t==null?void 0:t.tensorLayout)!==void 0&&t.tensorLayout==="NHWC"?(r=e.dims[2],s=e.dims[1],a=e.dims[3]):(r=e.dims[3],s=e.dims[2],a=e.dims[1]);let o=t!==void 0&&t.format!==void 0?t.format:"RGB",l=t==null?void 0:t.norm,u,c;l===void 0||l.mean===void 0?u=[255,255,255,255]:typeof l.mean=="number"?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(u[3]=l.mean[3])),l===void 0||l.bias===void 0?c=[0,0,0,0]:typeof l.bias=="number"?c=[l.bias,l.bias,l.bias,l.bias]:(c=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(c[3]=l.bias[3]));let f=s*r;if(t!==void 0&&(t.format!==void 0&&a===4&&t.format!=="RGBA"||a===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,h=0,m=1,y=2,M=3,g=0,_=f,T=f*2,x=-1;o==="RGBA"?(g=0,_=f,T=f*2,x=f*3):o==="RGB"?(g=0,_=f,T=f*2):o==="RBG"&&(g=0,T=f,_=f*2),i=n.createImageData(r,s);for(let S=0;S<s*r;h+=d,m+=d,y+=d,M+=d,S++)i.data[h]=(e.data[g++]-c[0])*u[0],i.data[m]=(e.data[_++]-c[1])*u[1],i.data[y]=(e.data[T++]-c[2])*u[2],i.data[M]=x===-1?255:(e.data[x++]-c[3])*u[3]}else throw new Error("Can not access image data");return i}}),Gh,S8,C8,$8,A8,I8,Ire=ft(()=>{bT(),Gh=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:i}=t,r=t.norm??{mean:255,bias:0},s,a;typeof r.mean=="number"?s=[r.mean,r.mean,r.mean,r.mean]:s=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?a=[r.bias,r.bias,r.bias,r.bias]:a=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];let o=t.format!==void 0?t.format:"RGBA",l=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",u=n*i,c=l==="RGBA"?new Float32Array(u*4):new Float32Array(u*3),f=4,d=0,h=1,m=2,y=3,M=0,g=u,_=u*2,T=-1;o==="RGB"&&(f=3,d=0,h=1,m=2,y=-1),l==="RGBA"?T=u*3:l==="RBG"?(M=0,_=u,g=u*2):l==="BGR"&&(_=0,g=u,M=u*2);for(let x=0;x<u;x++,d+=f,m+=f,h+=f,y+=f)c[M++]=(e[d]+a[0])/s[0],c[g++]=(e[h]+a[1])/s[1],c[_++]=(e[m]+a[2])/s[2],T!==-1&&y!==-1&&(c[T++]=(e[y]+a[3])/s[3]);return l==="RGBA"?new _s("float32",c,[1,4,n,i]):new _s("float32",c,[1,3,n,i])},S8=async(e,t)=>{let n=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,i=typeof ImageData<"u"&&e instanceof ImageData,r=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,s=typeof e=="string",a,o=t??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=c=>typeof HTMLCanvasElement<"u"&&c instanceof HTMLCanvasElement||c instanceof OffscreenCanvas?c.getContext("2d"):null;if(n){let c=l();c.width=e.width,c.height=e.height;let f=u(c);if(f!=null){let d=e.height,h=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(d=t.resizedHeight,h=t.resizedWidth),t!==void 0){if(o=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=d,o.width=h}else o.tensorFormat="RGBA",o.height=d,o.width=h;f.drawImage(e,0,0),a=f.getImageData(0,0,h,d).data}else throw new Error("Can not access image data")}else if(i){let c,f;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(c=t.resizedHeight,f=t.resizedWidth):(c=e.height,f=e.width),t!==void 0&&(o=t),o.format="RGBA",o.height=c,o.width=f,t!==void 0){let d=l();d.width=f,d.height=c;let h=u(d);if(h!=null)h.putImageData(e,0,0),a=h.getImageData(0,0,f,c).data;else throw new Error("Can not access image data")}else a=e.data}else if(r){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let c=l();c.width=e.width,c.height=e.height;let f=u(c);if(f!=null){let d=e.height,h=e.width;return f.drawImage(e,0,0,h,d),a=f.getImageData(0,0,h,d).data,o.height=d,o.width=h,Gh(a,o)}else throw new Error("Can not access image data")}else{if(s)return new Promise((c,f)=>{let d=l(),h=u(d);if(!e||!h)return f();let m=new Image;m.crossOrigin="Anonymous",m.src=e,m.onload=()=>{d.width=m.width,d.height=m.height,h.drawImage(m,0,0,d.width,d.height);let y=h.getImageData(0,0,d.width,d.height);o.height=d.height,o.width=d.width,c(Gh(y.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(a!==void 0)return Gh(a,o);throw new Error("Input data provided is not supported - aborted tensor creation")},C8=(e,t)=>{let{width:n,height:i,download:r,dispose:s}=t,a=[1,i,n,4];return new _s({location:"texture",type:"float32",texture:e,dims:a,download:r,dispose:s})},$8=(e,t)=>{let{dataType:n,dims:i,download:r,dispose:s}=t;return new _s({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:i,download:r,dispose:s})},A8=(e,t)=>{let{dataType:n,dims:i,download:r,dispose:s}=t;return new _s({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:i,download:r,dispose:s})},I8=(e,t,n)=>new _s({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})}),ku,Of,Tv,P8,Pre=ft(()=>{ku=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Of=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Tv=!1,P8=()=>{if(!Tv){Tv=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,i=typeof n<"u"&&n.from;e&&(ku.set("int64",BigInt64Array),Of.set(BigInt64Array,"int64")),t&&(ku.set("uint64",BigUint64Array),Of.set(BigUint64Array,"uint64")),i?(ku.set("float16",n),Of.set(n,"float16")):ku.set("float16",Uint16Array)}}}),k8,D8,kre=ft(()=>{bT(),k8=e=>{let t=1;for(let n=0;n<e.length;n++){let i=e[n];if(typeof i!="number"||!Number.isSafeInteger(i))throw new TypeError(`dims[${n}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${i}`);t*=i}return t},D8=(e,t)=>{switch(e.location){case"cpu":return new _s(e.type,e.data,t);case"cpu-pinned":return new _s({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new _s({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new _s({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new _s({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),_s,bT=ft(()=>{Are(),Ire(),Pre(),kre(),_s=class{constructor(e,t,n){P8();let i,r;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,i=e.type,r=e.dims,e.location){case"cpu-pinned":{let a=ku.get(i);if(!a)throw new TypeError(`unsupported type "${i}" to create tensor from pinned buffer`);if(!(e.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=e.data;break}case"texture":{if(i!=="float32")throw new TypeError(`unsupported type "${i}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint8"&&i!=="bool"&&i!=="uint4"&&i!=="int4")throw new TypeError(`unsupported type "${i}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint64"&&i!=="int8"&&i!=="uint8"&&i!=="bool"&&i!=="uint4"&&i!=="int4")throw new TypeError(`unsupported type "${i}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,o;if(typeof e=="string")if(i=e,o=n,e==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");a=t}else{let l=ku.get(e);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if(e==="float16"&&l===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${l.name} as data.`);e==="uint64"||e==="int64"?a=l.from(t,BigInt):a=l.from(t)}else if(t instanceof l)a=t;else if(t instanceof Uint8ClampedArray)if(e==="uint8")a=Uint8Array.from(t);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(e==="float16"&&t instanceof Uint16Array&&l!==Uint16Array)a=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw new TypeError(`A ${i} tensor's data must be type of ${l}`)}else if(o=t,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof e[0];if(l==="string")i="string",a=e;else if(l==="boolean")i="bool",a=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else if(e instanceof Uint8ClampedArray)i="uint8",a=Uint8Array.from(e);else{let l=Of.get(e.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);i=l,a=e}if(o===void 0)o=[a.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");r=o,this.cpuData=a,this.dataLocation="cpu"}let s=k8(r);if(this.cpuData&&s!==this.cpuData.length&&!((i==="uint4"||i==="int4")&&Math.ceil(s/2)===this.cpuData.length))throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=i,this.dims=r,this.size=s}static async fromImage(e,t){return S8(e,t)}static fromTexture(e,t){return C8(e,t)}static fromGpuBuffer(e,t){return $8(e,t)}static fromMLTensor(e,t){return A8(e,t)}static fromPinnedBuffer(e,t,n){return I8(e,t,n)}toDataURL(e){return M8(this,e)}toImageData(e){return E8(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return D8(this,e)}}}),Ea,O8=ft(()=>{bT(),Ea=_s}),wp,Mv,Pa,Zs,zl,Fl,R8=ft(()=>{T8(),wp=(e,t)=>{(typeof wr.trace>"u"?!wr.wasm.trace:!wr.trace)||console.timeStamp(`${e}::ORT::${t}`)},Mv=(e,t)=>{var r;let n=((r=new Error().stack)==null?void 0:r.split(/\r\n|\r|\n/g))||[],i=!1;for(let s=0;s<n.length;s++){if(i&&!n[s].includes("TRACE_FUNC")){let a=`FUNC_${e}::${n[s].trim().split(" ")[1]}`;t&&(a+=`::${t}`),wp("CPU",a);return}n[s].includes("TRACE_FUNC")&&(i=!0)}},Pa=e=>{(typeof wr.trace>"u"?!wr.wasm.trace:!wr.trace)||Mv("BEGIN",e)},Zs=e=>{(typeof wr.trace>"u"?!wr.wasm.trace:!wr.trace)||Mv("END",e)},zl=e=>{(typeof wr.trace>"u"?!wr.wasm.trace:!wr.trace)||console.time(`ORT::${e}`)},Fl=e=>{(typeof wr.trace>"u"?!wr.wasm.trace:!wr.trace)||console.timeEnd(`ORT::${e}`)}}),N8,Dre=ft(()=>{b8(),O8(),R8(),N8=class L8{constructor(t){this.handler=t}async run(t,n,i){Pa(),zl("InferenceSession.run");let r={},s={};if(typeof t!="object"||t===null||t instanceof Ea||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof Ea)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let u of n){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);r[u]=null}if(typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,c=Object.getOwnPropertyNames(n);for(let f of this.outputNames)if(c.indexOf(f)!==-1){let d=n[f];(d===null||d instanceof Ea)&&(u=!0,a=!1,r[f]=d)}if(u){if(typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else s=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of this.inputNames)if(typeof t[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(a)for(let u of this.outputNames)r[u]=null;let o=await this.handler.run(t,r,s),l={};for(let u in o)if(Object.hasOwnProperty.call(o,u)){let c=o[u];c instanceof Ea?l[u]=c:l[u]=new Ea(c.type,c.data,c.dims)}return Fl("InferenceSession.run"),Zs(),l}async release(){return this.handler.dispose()}static async create(t,n,i,r){Pa(),zl("InferenceSession.create");let s,a={};if(typeof t=="string"){if(s=t,typeof n=="object"&&n!==null)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(s=t,typeof n=="object"&&n!==null)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let c=t,f=0,d=t.byteLength;if(typeof n=="object"&&n!==null)a=n;else if(typeof n=="number"){if(f=n,!Number.isSafeInteger(f))throw new RangeError("'byteOffset' must be an integer.");if(f<0||f>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(d=t.byteLength-f,typeof i=="number"){if(d=i,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||f+d>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-f}].`);if(typeof r=="object"&&r!==null)a=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof i<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(c,f,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[o,l]=await w8(a),u=await o.createInferenceSessionHandler(s,l);return Fl("InferenceSession.create"),Zs(),new L8(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),xT,Ore=ft(()=>{Dre(),xT=N8}),Rre=ft(()=>{}),Nre=ft(()=>{}),Lre=ft(()=>{}),zre=ft(()=>{}),z8={};Vd(z8,{InferenceSession:()=>xT,TRACE:()=>wp,TRACE_EVENT_BEGIN:()=>zl,TRACE_EVENT_END:()=>Fl,TRACE_FUNC_BEGIN:()=>Pa,TRACE_FUNC_END:()=>Zs,Tensor:()=>Ea,env:()=>bi,registerBackend:()=>Lu});var na=ft(()=>{Sre(),$re(),Ore(),O8(),Rre(),Nre(),R8(),Lre(),zre()}),TT=ft(()=>{}),F8={};Vd(F8,{default:()=>B8});var Ev,Sv,B8,Fre=ft(()=>{var e;W5(),pc(),MT(),Ev="ort-wasm-proxy-worker",Sv=((e=globalThis.self)==null?void 0:e.name)===Ev,Sv&&(self.onmessage=t=>{let{type:n,in:i}=t.data;try{switch(n){case"init-wasm":ET(i.wasm).then(()=>{VT(i).then(()=>{postMessage({type:n})},r=>{postMessage({type:n,err:r})})},r=>{postMessage({type:n,err:r})});break;case"init-ep":{let{epName:r,env:s}=i;GT(s,r).then(()=>{postMessage({type:n})},a=>{postMessage({type:n,err:a})});break}case"copy-from":{let{buffer:r}=i,s=Cg(r);postMessage({type:n,out:s});break}case"create":{let{model:r,options:s}=i;jT(r,s).then(a=>{postMessage({type:n,out:a})},a=>{postMessage({type:n,err:a})});break}case"release":WT(i),postMessage({type:n});break;case"run":{let{sessionId:r,inputIndices:s,inputs:a,outputIndices:o,options:l}=i;HT(r,s,a,o,new Array(o.length).fill(null),l).then(u=>{u.some(c=>c[3]!=="cpu")?postMessage({type:n,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:n,out:u},KT([...a,...u]))},u=>{postMessage({type:n,err:u})});break}case"end-profiling":qT(i),postMessage({type:n});break;default:}}catch(r){postMessage({type:n,err:r})}}),B8=Sv?null:t=>new Worker(t??ps,{type:"module",name:Ev})}),U8={};Vd(U8,{default:()=>V8});var Cv,V8,OO,Bre=ft(()=>{var e,t;Cv=async function(n={}){var ho;var i,r,s=n,a=new Promise((p,v)=>{i=p,r=v}),o=typeof window=="object",l=typeof WorkerGlobalScope<"u",u=l&&((ho=self.name)==null?void 0:ho.startsWith("em-pthread"));s.mountExternalData=(p,v)=>{p.startsWith("./")&&(p=p.substring(2)),(s.Fb||(s.Fb=new Map)).set(p,v)},s.unmountExternalData=()=>{delete s.Fb};var c=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,qc:!0}).buffer.constructor;let f=p=>async(...v)=>{var E;try{if(s.Gb)throw Error("Session already started");let I=s.Gb={ec:v[0],errors:[]},k=await p(...v);if(s.Gb!==I)throw Error("Session mismatch");(E=s.Kb)==null||E.flush();let F=I.errors;if(0<F.length){let ie=await Promise.all(F);if(ie=ie.filter(ge=>ge),0<ie.length)throw Error(ie.join(`
`))}return k}finally{s.Gb=null}};s.jsepInit=(p,v)=>{if(p==="webgpu"){[s.Kb,s.Vb,s.Zb,s.Lb,s.Yb,s.Ab,s.$b,s.bc,s.Wb,s.Xb,s.ac]=v;let E=s.Kb;s.jsepRegisterBuffer=(I,k,F,ie)=>E.registerBuffer(I,k,F,ie),s.jsepGetBuffer=I=>E.getBuffer(I),s.jsepCreateDownloader=(I,k,F)=>E.createDownloader(I,k,F),s.jsepOnCreateSession=I=>{E.onCreateSession(I)},s.jsepOnReleaseSession=I=>{E.onReleaseSession(I)},s.jsepOnRunStart=I=>E.onRunStart(I),s.cc=(I,k)=>{E.upload(I,k)}}else if(p==="webnn"){let E=v[0];[s.oc,s.Ob,s.webnnEnsureTensor,s.Pb,s.webnnDownloadTensor,s.nc,s.webnnEnableTraceEvent]=v.slice(1),s.webnnReleaseTensorId=s.Ob,s.webnnUploadTensor=s.Pb,s.webnnRegisterMLContext=s.nc,s.webnnOnRunStart=I=>E.onRunStart(I),s.webnnOnRunEnd=E.onRunEnd.bind(E),s.webnnOnReleaseSession=I=>{E.onReleaseSession(I)},s.webnnCreateMLTensorDownloader=(I,k)=>E.createMLTensorDownloader(I,k),s.webnnRegisterMLTensor=(I,k,F,ie)=>E.registerMLTensor(I,k,F,ie),s.webnnCreateMLContext=I=>E.createMLContext(I),s.webnnRegisterMLConstant=(I,k,F,ie,ge,Te)=>E.registerMLConstant(I,k,F,ie,ge,s.Fb,Te),s.webnnRegisterGraphInput=E.registerGraphInput.bind(E),s.webnnIsGraphInput=E.isGraphInput.bind(E),s.webnnRegisterGraphOutput=E.registerGraphOutput.bind(E),s.webnnIsGraphOutput=E.isGraphOutput.bind(E),s.webnnCreateTemporaryTensor=E.createTemporaryTensor.bind(E),s.webnnIsGraphInputOutputTypeSupported=E.isGraphInputOutputTypeSupported.bind(E)}};let d=()=>{let p=(v,E,I)=>(...k)=>{let F=Hn,ie=E==null?void 0:E();k=v(...k);let ge=E==null?void 0:E();return ie!==ge&&(v=ge,I(ie),E=I=null),Hn!=F?new Promise((Te,Re)=>{tt={resolve:Te,reject:Re}}):k};(()=>{for(let v of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])s[v]=p(s[v],()=>s[v],E=>s[v]=E)})(),f!==void 0&&(s._OrtRun=f(s._OrtRun),s._OrtRunWithBinding=f(s._OrtRunWithBinding)),d=void 0};s.asyncInit=()=>{d==null||d()};var h,m,y=(p,v)=>{throw v},M=import.meta.url,g="";if(o||l){try{g=new URL(".",M).href}catch{}l&&(m=p=>{var v=new XMLHttpRequest;return v.open("GET",p,!1),v.responseType="arraybuffer",v.send(null),new Uint8Array(v.response)}),h=async p=>{if(H(p))return new Promise((E,I)=>{var k=new XMLHttpRequest;k.open("GET",p,!0),k.responseType="arraybuffer",k.onload=()=>{k.status==200||k.status==0&&k.response?E(k.response):I(k.status)},k.onerror=I,k.send(null)});var v=await fetch(p,{credentials:"same-origin"});if(v.ok)return v.arrayBuffer();throw Error(v.status+" : "+v.url)}}var _,T,x,S,$,C,P,O,R,G,W,V,te,J,j,Y=console.log.bind(console),X=console.error.bind(console),ce=Y,me=X,Q=!1,H=p=>p.startsWith("file://");function B(){return T.buffer!=$.buffer&&U(),$}function ee(){return T.buffer!=$.buffer&&U(),C}function _e(){return T.buffer!=$.buffer&&U(),P}function le(){return T.buffer!=$.buffer&&U(),O}function ae(){return T.buffer!=$.buffer&&U(),R}function Ne(){return T.buffer!=$.buffer&&U(),G}function Ye(){return T.buffer!=$.buffer&&U(),W}function ze(){return T.buffer!=$.buffer&&U(),J}if(u){let p=function(v){try{var E=v.data,I=E.Db;if(I==="load"){let k=[];self.onmessage=F=>k.push(F),self.startWorker=()=>{postMessage({Db:"loaded"});for(let F of k)p(F);self.onmessage=p};for(let F of E.Sb)s[F]&&!s[F].proxy||(s[F]=(...ie)=>{postMessage({Db:"callHandler",Rb:F,args:ie})},F=="print"&&(ce=s[F]),F=="printErr"&&(me=s[F]));T=E.kc,U(),j(E.lc)}else if(I==="run"){yi(E.Bb),Va(E.Bb,0,0,1,0,0),hn(),ne(E.Bb),ue||(Xo(),ue=!0);try{Ji(E.hc,E.Jb)}catch(k){if(k!="unwind")throw k}}else E.target!=="setimmediate"&&(I==="checkMailbox"?ue&&pe():I&&(me(`worker: received unknown command ${I}`),me(E)))}catch(k){throw co(),k}};var ue=!1;self.onunhandledrejection=v=>{throw v.reason||v},self.onmessage=p}function U(){var p=T.buffer;s.HEAP8=$=new Int8Array(p),P=new Int16Array(p),s.HEAPU8=C=new Uint8Array(p),O=new Uint16Array(p),s.HEAP32=R=new Int32Array(p),s.HEAPU32=G=new Uint32Array(p),W=new Float32Array(p),J=new Float64Array(p),V=new BigInt64Array(p),te=new BigUint64Array(p)}function we(){u?startWorker(s):Xe.Da()}var Pe,ke=0,Le=null;function Ge(){if(--ke==0&&Le){var p=Le;Le=null,p()}}function $e(p){throw me(p="Aborted("+p+")"),Q=!0,p=new WebAssembly.RuntimeError(p+". Build with -sASSERTIONS for more info."),r(p),p}function et(){return{a:{L:Ft,Aa:uo,b:Ti,$:$n,A:ji,pa:Wi,X:Sn,Z:Ii,qa:Xt,na:nr,ga:L,ma:oe,J:K,Y:re,V:de,oa:xe,W:Ue,va:$t,E:vn,Q:ei,O:ni,D:In,v:ir,s:Mi,P:Cr,z:ls,R:ia,ja:Ee,T:be,aa:Fe,M:ut,F:yt,ia:ne,sa:gt,r:Cn,Ca:Tn,w:vt,o:rn,m:Dn,c:qt,Ba:li,n:Bi,j:$s,u:As,p:us,f:Is,t:Ps,l:Rr,e:ks,k:Ds,h:Os,g:Rs,d:Ra,da:Br,ea:eu,fa:tu,ba:no,ca:nu,N:Wo,xa:ra,ua:Ho,i:su,C:io,G:ro,ta:mc,x:gc,ra:_c,U:yc,q:jo,y:vc,K:wc,S:bc,za:Fa,ya:Ba,ka:Ua,la:Xr,_:Se,B:qo,I:lu,ha:Ko,H:Jo,a:T,wa:Ke}}}class Ce{constructor(v){fe(this,"name","ExitStatus");this.message=`Program terminated with exit(${v})`,this.status=v}}var He=p=>{p.terminate(),p.onmessage=()=>{}},at=[],Z=p=>{Oe.length==0&&(Kt(),En(Oe[0]));var v=Oe.pop();if(!v)return 6;ct.push(v),Ct[p.Bb]=v,v.Bb=p.Bb;var E={Db:"run",hc:p.fc,Jb:p.Jb,Bb:p.Bb};return v.postMessage(E,p.Nb),0},he=0,ye=(p,v,...E)=>{for(var I=2*E.length,k=la(),F=Ga(8*I),ie=F>>>3,ge=0;ge<E.length;ge++){var Te=E[ge];typeof Te=="bigint"?(V[ie+2*ge]=1n,V[ie+2*ge+1]=Te):(V[ie+2*ge]=0n,ze()[ie+2*ge+1>>>0]=Te)}return p=Qo(p,0,I,F,v),Ls(k),p};function Ke(p){if(u)return ye(0,1,p);if(S=p,!(0<he)){for(var v of ct)He(v);for(v of Oe)He(v);Oe=[],ct=[],Ct={},Q=!0}y(0,new Ce(p))}function Be(p){if(u)return ye(1,0,p);Se(p)}var Se=p=>{if(S=p,u)throw Be(p),"unwind";Ke(p)},Oe=[],ct=[],bt=[],Ct={},Et=p=>{var v=p.Bb;delete Ct[v],Oe.push(p),ct.splice(ct.indexOf(p),1),p.Bb=0,Zo(v)};function hn(){bt.forEach(p=>p())}var En=p=>new Promise(v=>{p.onmessage=k=>{var F=(k=k.data).Db;if(k.Hb&&k.Hb!=aa()){var ie=Ct[k.Hb];ie?ie.postMessage(k,k.Nb):me(`Internal error! Worker sent a message "${F}" to target pthread ${k.Hb}, but that thread no longer exists!`)}else F==="checkMailbox"?pe():F==="spawnThread"?Z(k):F==="cleanupThread"?Et(Ct[k.ic]):F==="loaded"?(p.loaded=!0,v(p)):k.target==="setimmediate"?p.postMessage(k):F==="callHandler"?s[k.Rb](...k.args):F&&me(`worker sent an unknown command ${F}`)},p.onerror=k=>{throw me(`worker sent an error! ${k.filename}:${k.lineno}: ${k.message}`),k};var E,I=[];for(E of[])s.propertyIsEnumerable(E)&&I.push(E);p.postMessage({Db:"load",Sb:I,kc:T,lc:x})});function Kt(){var p=new Worker((()=>{let v=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new v("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});Oe.push(p)}var yi=p=>{U();var v=Ne()[p+52>>>2>>>0];p=Ne()[p+56>>>2>>>0],fo(v,v-p),Ls(v)},Ji=(p,v)=>{he=0,p=nl(p,v),0<he?S=p:oa(p)};class tr{constructor(v){this.Ib=v-24}}function Ti(p,v,E){var I=new tr(p>>>=0);throw v>>>=0,E>>>=0,Ne()[I.Ib+16>>>2>>>0]=0,Ne()[I.Ib+4>>>2>>>0]=v,Ne()[I.Ib+8>>>2>>>0]=E,p}function Yn(p,v,E,I){return u?ye(2,1,p,v,E,I):$n(p,v,E,I)}function $n(p,v,E,I){if(p>>>=0,E>>>=0,I>>>=0,c===void 0)return 6;var k=[];return u&&k.length===0?Yn(p,v>>>=0,E,I):(p={fc:E,Bb:p,Jb:I,Nb:k},u?(p.Db="spawnThread",postMessage(p,k),0):Z(p))}var Yi=typeof TextDecoder<"u"?new TextDecoder:void 0,Gi=(p,v=0,E=NaN)=>{var I=(v>>>=0)+E;for(E=v;p[E]&&!(E>=I);)++E;if(16<E-v&&p.buffer&&Yi)return Yi.decode(p.buffer instanceof ArrayBuffer?p.subarray(v,E):p.slice(v,E));for(I="";v<E;){var k=p[v++];if(128&k){var F=63&p[v++];if((224&k)==192)I+=String.fromCharCode((31&k)<<6|F);else{var ie=63&p[v++];65536>(k=(240&k)==224?(15&k)<<12|F<<6|ie:(7&k)<<18|F<<12|ie<<6|63&p[v++])?I+=String.fromCharCode(k):(k-=65536,I+=String.fromCharCode(55296|k>>10,56320|1023&k))}}else I+=String.fromCharCode(k)}return I},xt=(p,v)=>(p>>>=0)?Gi(ee(),p,v):"";function ji(p,v,E){return u?ye(3,1,p,v,E):0}function Wi(p,v){if(u)return ye(4,1,p,v)}function Sn(p,v){if(u)return ye(5,1,p,v)}function Ii(p,v,E){if(u)return ye(6,1,p,v,E)}function Xt(p,v,E){return u?ye(7,1,p,v,E):0}function nr(p,v){if(u)return ye(8,1,p,v)}function L(p,v,E){if(u)return ye(9,1,p,v,E)}function oe(p,v,E,I){if(u)return ye(10,1,p,v,E,I)}function K(p,v,E,I){if(u)return ye(11,1,p,v,E,I)}function re(p,v,E,I){if(u)return ye(12,1,p,v,E,I)}function de(p){if(u)return ye(13,1,p)}function xe(p,v){if(u)return ye(14,1,p,v)}function Ue(p,v,E){if(u)return ye(15,1,p,v,E)}var _t,$t=()=>$e(""),mt=p=>{for(var v="";ee()[p>>>0];)v+=_t[ee()[p++>>>0]];return v},Ht={},It={},Zt=s.BindingError=class extends Error{constructor(p){super(p),this.name="BindingError"}};function St(p,v,E={}){return function(I,k,F={}){var ie=k.name;if(!I)throw new Zt(`type "${ie}" must have a positive integer typeid pointer`);if(It.hasOwnProperty(I)){if(F.Tb)return;throw new Zt(`Cannot register type '${ie}' twice`)}It[I]=k,Ht.hasOwnProperty(I)&&(k=Ht[I],delete Ht[I],k.forEach(ge=>ge()))}(p,v,E)}var tn=(p,v,E)=>{switch(v){case 1:return E?I=>B()[I>>>0]:I=>ee()[I>>>0];case 2:return E?I=>_e()[I>>>1>>>0]:I=>le()[I>>>1>>>0];case 4:return E?I=>ae()[I>>>2>>>0]:I=>Ne()[I>>>2>>>0];case 8:return E?I=>V[I>>>3]:I=>te[I>>>3];default:throw new TypeError(`invalid integer width (${v}): ${p}`)}};function vn(p,v,E){E>>>=0,St(p>>>=0,{name:v=mt(v>>>0),fromWireType:I=>I,toWireType:function(I,k){if(typeof k!="bigint"&&typeof k!="number")throw k=k===null?"null":(I=typeof k)=="object"||I==="array"||I==="function"?k.toString():""+k,new TypeError(`Cannot convert "${k}" to ${this.name}`);return typeof k=="number"&&(k=BigInt(k)),k},Cb:Wn,readValueFromPointer:tn(v,E,v.indexOf("u")==-1),Eb:null})}var Wn=8;function ei(p,v,E,I){St(p>>>=0,{name:v=mt(v>>>0),fromWireType:function(k){return!!k},toWireType:function(k,F){return F?E:I},Cb:Wn,readValueFromPointer:function(k){return this.fromWireType(ee()[k>>>0])},Eb:null})}var Bn=[],Je=[];function qt(p){9<(p>>>=0)&&--Je[p+1]==0&&(Je[p]=void 0,Bn.push(p))}var Pt=p=>{if(!p)throw new Zt(`Cannot use deleted val. handle = ${p}`);return Je[p]},kt=p=>{switch(p){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let v=Bn.pop()||Je.length;return Je[v]=p,Je[v+1]=1,v}};function An(p){return this.fromWireType(Ne()[p>>>2>>>0])}var zn={name:"emscripten::val",fromWireType:p=>{var v=Pt(p);return qt(p),v},toWireType:(p,v)=>kt(v),Cb:Wn,readValueFromPointer:An,Eb:null};function ni(p){return St(p>>>0,zn)}var Un=(p,v)=>{switch(v){case 4:return function(E){return this.fromWireType(Ye()[E>>>2>>>0])};case 8:return function(E){return this.fromWireType(ze()[E>>>3>>>0])};default:throw new TypeError(`invalid float width (${v}): ${p}`)}};function In(p,v,E){E>>>=0,St(p>>>=0,{name:v=mt(v>>>0),fromWireType:I=>I,toWireType:(I,k)=>k,Cb:Wn,readValueFromPointer:Un(v,E),Eb:null})}function ir(p,v,E,I,k){if(p>>>=0,E>>>=0,v=mt(v>>>0),k===-1&&(k=4294967295),k=ge=>ge,I===0){var F=32-8*E;k=ge=>ge<<F>>>F}var ie=v.includes("unsigned")?function(ge,Te){return Te>>>0}:function(ge,Te){return Te};St(p,{name:v,fromWireType:k,toWireType:ie,Cb:Wn,readValueFromPointer:tn(v,E,I!==0),Eb:null})}function Mi(p,v,E){function I(F){var ie=Ne()[F>>>2>>>0];return F=Ne()[F+4>>>2>>>0],new k(B().buffer,F,ie)}var k=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][v];St(p>>>=0,{name:E=mt(E>>>0),fromWireType:I,Cb:Wn,readValueFromPointer:I},{Tb:!0})}var ci=(p,v,E)=>{var I=ee();if(v>>>=0,0<E){var k=v;E=v+E-1;for(var F=0;F<p.length;++F){var ie=p.charCodeAt(F);if(55296<=ie&&57343>=ie&&(ie=65536+((1023&ie)<<10)|1023&p.charCodeAt(++F)),127>=ie){if(v>=E)break;I[v++>>>0]=ie}else{if(2047>=ie){if(v+1>=E)break;I[v++>>>0]=192|ie>>6}else{if(65535>=ie){if(v+2>=E)break;I[v++>>>0]=224|ie>>12}else{if(v+3>=E)break;I[v++>>>0]=240|ie>>18,I[v++>>>0]=128|ie>>12&63}I[v++>>>0]=128|ie>>6&63}I[v++>>>0]=128|63&ie}}I[v>>>0]=0,p=v-k}else p=0;return p},Xi=p=>{for(var v=0,E=0;E<p.length;++E){var I=p.charCodeAt(E);127>=I?v++:2047>=I?v+=2:55296<=I&&57343>=I?(v+=4,++E):v+=3}return v};function Cr(p,v){St(p>>>=0,{name:v=mt(v>>>0),fromWireType:function(E){for(var I,k=Ne()[E>>>2>>>0],F=E+4,ie=F,ge=0;ge<=k;++ge){var Te=F+ge;ge!=k&&ee()[Te>>>0]!=0||(ie=xt(ie,Te-ie),I===void 0?I=ie:(I+="\0",I+=ie),ie=Te+1)}return Ni(E),I},toWireType:function(E,I){I instanceof ArrayBuffer&&(I=new Uint8Array(I));var k=typeof I=="string";if(!(k||ArrayBuffer.isView(I)&&I.BYTES_PER_ELEMENT==1))throw new Zt("Cannot pass non-string to std::string");var F=k?Xi(I):I.length,ie=Ns(4+F+1),ge=ie+4;return Ne()[ie>>>2>>>0]=F,k?ci(I,ge,F+1):ee().set(I,ge>>>0),E!==null&&E.push(Ni,ie),ie},Cb:Wn,readValueFromPointer:An,Eb(E){Ni(E)}})}var Hi=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,ot=(p,v)=>{for(var E=p>>1,I=E+v/2;!(E>=I)&&le()[E>>>0];)++E;if(32<(E<<=1)-p&&Hi)return Hi.decode(ee().slice(p,E));for(E="",I=0;!(I>=v/2);++I){var k=_e()[p+2*I>>>1>>>0];if(k==0)break;E+=String.fromCharCode(k)}return E},lt=(p,v,E)=>{if(E??(E=2147483647),2>E)return 0;var I=v;E=(E-=2)<2*p.length?E/2:p.length;for(var k=0;k<E;++k){var F=p.charCodeAt(k);_e()[v>>>1>>>0]=F,v+=2}return _e()[v>>>1>>>0]=0,v-I},wt=p=>2*p.length,mn=(p,v)=>{for(var E=0,I="";!(E>=v/4);){var k=ae()[p+4*E>>>2>>>0];if(k==0)break;++E,65536<=k?(k-=65536,I+=String.fromCharCode(55296|k>>10,56320|1023&k)):I+=String.fromCharCode(k)}return I},os=(p,v,E)=>{if(v>>>=0,E??(E=2147483647),4>E)return 0;var I=v;E=I+E-4;for(var k=0;k<p.length;++k){var F=p.charCodeAt(k);if(55296<=F&&57343>=F&&(F=65536+((1023&F)<<10)|1023&p.charCodeAt(++k)),ae()[v>>>2>>>0]=F,(v+=4)+4>E)break}return ae()[v>>>2>>>0]=0,v-I},Yr=p=>{for(var v=0,E=0;E<p.length;++E){var I=p.charCodeAt(E);55296<=I&&57343>=I&&++E,v+=4}return v};function ls(p,v,E){if(p>>>=0,v>>>=0,E=mt(E>>>=0),v===2)var I=ot,k=lt,F=wt,ie=ge=>le()[ge>>>1>>>0];else v===4&&(I=mn,k=os,F=Yr,ie=ge=>Ne()[ge>>>2>>>0]);St(p,{name:E,fromWireType:ge=>{for(var Te,Re=Ne()[ge>>>2>>>0],nt=ge+4,ht=0;ht<=Re;++ht){var At=ge+4+ht*v;ht!=Re&&ie(At)!=0||(nt=I(nt,At-nt),Te===void 0?Te=nt:(Te+="\0",Te+=nt),nt=At+v)}return Ni(ge),Te},toWireType:(ge,Te)=>{if(typeof Te!="string")throw new Zt(`Cannot pass non-string to C++ string type ${E}`);var Re=F(Te),nt=Ns(4+Re+v);return Ne()[nt>>>2>>>0]=Re/v,k(Te,nt+4,Re+v),ge!==null&&ge.push(Ni,nt),nt},Cb:Wn,readValueFromPointer:An,Eb(ge){Ni(ge)}})}function ia(p,v){St(p>>>=0,{Ub:!0,name:v=mt(v>>>0),Cb:0,fromWireType:()=>{},toWireType:()=>{}})}function Ee(p){Va(p>>>0,!l,1,!o,131072,!1),hn()}var z=p=>{if(!Q)try{if(p(),!(0<he))try{u?oa(S):Se(S)}catch(v){v instanceof Ce||v=="unwind"||y(0,v)}}catch(v){v instanceof Ce||v=="unwind"||y(0,v)}};function ne(p){p>>>=0,typeof Atomics.jc=="function"&&(Atomics.jc(ae(),p>>>2,p).value.then(pe),p+=128,Atomics.store(ae(),p>>>2,1))}var pe=()=>{var p=aa();p&&(ne(p),z(tl))};function be(p,v){(p>>>=0)==v>>>0?setTimeout(pe):u?postMessage({Hb:p,Db:"checkMailbox"}):(p=Ct[p])&&p.postMessage({Db:"checkMailbox"})}var Me=[];function Fe(p,v,E,I,k){for(v>>>=0,I/=2,Me.length=I,E=k>>>0>>>3,k=0;k<I;k++)Me[k]=V[E+2*k]?V[E+2*k+1]:ze()[E+2*k+1>>>0];return(v?lo[v]:uu[p])(...Me)}var ut=()=>{he=0};function yt(p){p>>>=0,u?postMessage({Db:"cleanupThread",ic:p}):Et(Ct[p])}function gt(p){}var Mt=(p,v)=>{var E=It[p];if(E===void 0)throw p=Yo(p),E=mt(p),Ni(p),new Zt(`${v} has unknown type ${E}`);return E},Wt=(p,v,E)=>{var I=[];return p=p.toWireType(I,E),I.length&&(Ne()[v>>>2>>>0]=kt(I)),p};function Cn(p,v,E){return v>>>=0,E>>>=0,p=Pt(p>>>0),v=Mt(v,"emval::as"),Wt(v,E,p)}function Tn(p,v){return v>>>=0,p=Pt(p>>>0),(v=Mt(v,"emval::as")).toWireType(null,p)}var Pn=p=>{try{p()}catch(v){$e(v)}},wn=0,Hn=null,Ei=0,oi=[],Si={},Pi={},_r=0,tt=null,it=[];function Ve(p){return function(v){if(!Q){if(wn===0){var E=!1,I=!1;v((k=0)=>{if(!Q&&(Ei=k,E=!0,I)){wn=2,Pn(()=>rl(Hn)),typeof MainLoop<"u"&&MainLoop.Qb&&MainLoop.resume(),k=!1;try{var F=function(){var Te=ae()[Hn+8>>>2>>>0];return Te=Xe[Pi[Te]],--he,Te()}()}catch(Te){F=Te,k=!0}var ie=!1;if(!Hn){var ge=tt;ge&&(tt=null,(k?ge.reject:ge.resolve)(F),ie=!0)}if(k&&!ie)throw F}}),I=!0,E||(wn=1,Hn=function(){var k=Ns(65548),F=k+12;Ne()[k>>>2>>>0]=F,Ne()[k+4>>>2>>>0]=F+65536,F=oi[0];var ie=Si[F];return ie===void 0&&(ie=_r++,Si[F]=ie,Pi[ie]=F),F=ie,ae()[k+8>>>2>>>0]=F,k}(),typeof MainLoop<"u"&&MainLoop.Qb&&MainLoop.pause(),Pn(()=>il(Hn)))}else wn===2?(wn=0,Pn(sl),Ni(Hn),Hn=null,it.forEach(z)):$e(`invalid state: ${wn}`);return Ei}}(v=>{p().then(v)})}function vt(p){return p>>>=0,Ve(async()=>{var v=await Pt(p);return kt(v)})}var Gt=[];function rn(p,v,E,I){return E>>>=0,I>>>=0,(p=Gt[p>>>0])(null,v=Pt(v>>>0),E,I)}var kn={},Mn=p=>{var v=kn[p];return v===void 0?mt(p):v};function Dn(p,v,E,I,k){return E>>>=0,I>>>=0,k>>>=0,(p=Gt[p>>>0])(v=Pt(v>>>0),v[E=Mn(E)],I,k)}function li(p,v){return v>>>=0,(p=Pt(p>>>0))==Pt(v)}var Vn=()=>typeof globalThis=="object"?globalThis:Function("return this")();function Bi(p){return(p>>>=0)==0?kt(Vn()):(p=Mn(p),kt(Vn()[p]))}var $r=p=>{var v=Gt.length;return Gt.push(p),v},yr=(p,v)=>{for(var E=Array(p),I=0;I<p;++I)E[I]=Mt(Ne()[v+4*I>>>2>>>0],`parameter ${I}`);return E};function $s(p,v,E){var I=(v=yr(p,v>>>0)).shift();p--;var k=`return function (obj, func, destructorsRef, args) {
`,F=0,ie=[];E===0&&ie.push("obj");for(var ge=["retType"],Te=[I],Re=0;Re<p;++Re)ie.push(`arg${Re}`),ge.push(`argType${Re}`),Te.push(v[Re]),k+=`  var arg${Re} = argType${Re}.readValueFromPointer(args${F?"+"+F:""});
`,F+=v[Re].Cb;return k+=`  var rv = ${E===1?"new func":"func.call"}(${ie.join(", ")});
`,I.Ub||(ge.push("emval_returnValue"),Te.push(Wt),k+=`  return emval_returnValue(retType, destructorsRef, rv);
`),p=new Function(...ge,k+`};
`)(...Te),E=`methodCaller<(${v.map(nt=>nt.name).join(", ")}) => ${I.name}>`,$r(Object.defineProperty(p,"name",{value:E}))}function As(p){return p=Mn(p>>>0),kt(s[p])}function us(p,v){return v>>>=0,p=Pt(p>>>0),v=Pt(v),kt(p[v])}function Is(p){9<(p>>>=0)&&(Je[p+1]+=1)}function Ps(){return kt([])}function Rr(p){p=Pt(p>>>0);for(var v=Array(p.length),E=0;E<p.length;E++)v[E]=p[E];return kt(v)}function ks(p){return kt(Mn(p>>>0))}function Ds(){return kt({})}function Os(p){for(var v=Pt(p>>>=0);v.length;){var E=v.pop();v.pop()(E)}qt(p)}function Rs(p,v,E){v>>>=0,E>>>=0,p=Pt(p>>>0),v=Pt(v),E=Pt(E),p[v]=E}function Ra(p,v){return v>>>=0,p=(p=Mt(p>>>0,"_emval_take_value")).readValueFromPointer(v),kt(p)}function Br(p,v){p=-9007199254740992>p||9007199254740992<p?NaN:Number(p),v>>>=0,p=new Date(1e3*p),ae()[v>>>2>>>0]=p.getUTCSeconds(),ae()[v+4>>>2>>>0]=p.getUTCMinutes(),ae()[v+8>>>2>>>0]=p.getUTCHours(),ae()[v+12>>>2>>>0]=p.getUTCDate(),ae()[v+16>>>2>>>0]=p.getUTCMonth(),ae()[v+20>>>2>>>0]=p.getUTCFullYear()-1900,ae()[v+24>>>2>>>0]=p.getUTCDay(),p=(p.getTime()-Date.UTC(p.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,ae()[v+28>>>2>>>0]=p}var Xl=p=>p%4==0&&(p%100!=0||p%400==0),Ql=[0,31,60,91,121,152,182,213,244,274,305,335],Zl=[0,31,59,90,120,151,181,212,243,273,304,334];function eu(p,v){p=-9007199254740992>p||9007199254740992<p?NaN:Number(p),v>>>=0,p=new Date(1e3*p),ae()[v>>>2>>>0]=p.getSeconds(),ae()[v+4>>>2>>>0]=p.getMinutes(),ae()[v+8>>>2>>>0]=p.getHours(),ae()[v+12>>>2>>>0]=p.getDate(),ae()[v+16>>>2>>>0]=p.getMonth(),ae()[v+20>>>2>>>0]=p.getFullYear()-1900,ae()[v+24>>>2>>>0]=p.getDay();var E=(Xl(p.getFullYear())?Ql:Zl)[p.getMonth()]+p.getDate()-1|0;ae()[v+28>>>2>>>0]=E,ae()[v+36>>>2>>>0]=-60*p.getTimezoneOffset(),E=new Date(p.getFullYear(),6,1).getTimezoneOffset();var I=new Date(p.getFullYear(),0,1).getTimezoneOffset();p=0|(E!=I&&p.getTimezoneOffset()==Math.min(I,E)),ae()[v+32>>>2>>>0]=p}function tu(p){p>>>=0;var v=new Date(ae()[p+20>>>2>>>0]+1900,ae()[p+16>>>2>>>0],ae()[p+12>>>2>>>0],ae()[p+8>>>2>>>0],ae()[p+4>>>2>>>0],ae()[p>>>2>>>0],0),E=ae()[p+32>>>2>>>0],I=v.getTimezoneOffset(),k=new Date(v.getFullYear(),6,1).getTimezoneOffset(),F=new Date(v.getFullYear(),0,1).getTimezoneOffset(),ie=Math.min(F,k);return 0>E?ae()[p+32>>>2>>>0]=+(k!=F&&ie==I):0<E!=(ie==I)&&(k=Math.max(F,k),v.setTime(v.getTime()+6e4*((0<E?ie:k)-I))),ae()[p+24>>>2>>>0]=v.getDay(),E=(Xl(v.getFullYear())?Ql:Zl)[v.getMonth()]+v.getDate()-1|0,ae()[p+28>>>2>>>0]=E,ae()[p>>>2>>>0]=v.getSeconds(),ae()[p+4>>>2>>>0]=v.getMinutes(),ae()[p+8>>>2>>>0]=v.getHours(),ae()[p+12>>>2>>>0]=v.getDate(),ae()[p+16>>>2>>>0]=v.getMonth(),ae()[p+20>>>2>>>0]=v.getYear(),p=v.getTime(),BigInt(isNaN(p)?-1:p/1e3)}function no(p,v,E,I,k,F,ie){return u?ye(16,1,p,v,E,I,k,F,ie):-52}function nu(p,v,E,I,k,F){if(u)return ye(17,1,p,v,E,I,k,F)}var Na={},jo=()=>performance.timeOrigin+performance.now();function Wo(p,v){if(u)return ye(18,1,p,v);if(Na[p]&&(clearTimeout(Na[p].id),delete Na[p]),!v)return 0;var E=setTimeout(()=>{delete Na[p],z(()=>el(p,performance.timeOrigin+performance.now()))},v);return Na[p]={id:E,rc:v},0}function ra(p,v,E,I){p>>>=0,v>>>=0,E>>>=0,I>>>=0;var k=new Date().getFullYear(),F=new Date(k,0,1).getTimezoneOffset();k=new Date(k,6,1).getTimezoneOffset();var ie=Math.max(F,k);Ne()[p>>>2>>>0]=60*ie,ae()[v>>>2>>>0]=+(F!=k),p=(v=ge=>{var Te=Math.abs(ge);return`UTC${0<=ge?"-":"+"}${String(Math.floor(Te/60)).padStart(2,"0")}${String(Te%60).padStart(2,"0")}`})(F),v=v(k),k<F?(ci(p,E,17),ci(v,I,17)):(ci(p,I,17),ci(v,E,17))}var mc=()=>Date.now();function Ho(p,v,E){return 0<=p&&3>=p?(p===0?p=Date.now():p=performance.timeOrigin+performance.now(),V[E>>>0>>>3]=BigInt(Math.round(1e6*p)),0):28}var iu=[],ru=(p,v)=>{iu.length=0;for(var E;E=ee()[p++>>>0];){var I=E!=105;v+=(I&=E!=112)&&v%8?4:0,iu.push(E==112?Ne()[v>>>2>>>0]:E==106?V[v>>>3]:E==105?ae()[v>>>2>>>0]:ze()[v>>>3>>>0]),v+=I?8:4}return iu};function su(p,v,E){return p>>>=0,v=ru(v>>>0,E>>>0),lo[p](...v)}function io(p,v,E){return p>>>=0,v=ru(v>>>0,E>>>0),lo[p](...v)}var ro=()=>{};function gc(p,v){return me(xt(p>>>0,v>>>0))}var _c=()=>{throw he+=1,"unwind"};function yc(){return 4294901760}var vc=()=>navigator.hardwareConcurrency;function wc(){return $e("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function bc(p){p>>>=0;var v=ee().length;if(p<=v||4294901760<p)return!1;for(var E=1;4>=E;E*=2){var I=v*(1+.2/E);I=Math.min(I,p+100663296);e:{I=(Math.min(4294901760,65536*Math.ceil(Math.max(p,I)/65536))-T.buffer.byteLength+65535)/65536|0;try{T.grow(I),U();var k=1;break e}catch{}k=void 0}if(k)return!0}return!1}var La=()=>($e("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),za={},au=p=>{p.forEach(v=>{La()})};function Fa(){var p=Error().stack.toString().split(`
`);return p[0]=="Error"&&p.shift(),au(p),za.Mb=La(),za.dc=p,za.Mb}function Ba(p,v,E){if(p>>>=0,v>>>=0,za.Mb==p)var I=za.dc;else(I=Error().stack.toString().split(`
`))[0]=="Error"&&I.shift(),au(I);for(var k=3;I[k]&&La()!=p;)++k;for(p=0;p<E&&I[p+k];++p)ae()[v+4*p>>>2>>>0]=La();return p}var sa,so={},ou=()=>{if(!sa){var p,v={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(p in so)so[p]===void 0?delete v[p]:v[p]=so[p];var E=[];for(p in v)E.push(`${p}=${v[p]}`);sa=E}return sa};function Ua(p,v){if(u)return ye(19,1,p,v);p>>>=0,v>>>=0;var E,I=0,k=0;for(E of ou()){var F=v+I;Ne()[p+k>>>2>>>0]=F,I+=ci(E,F,1/0)+1,k+=4}return 0}function Xr(p,v){if(u)return ye(20,1,p,v);p>>>=0,v>>>=0;var E=ou();for(var I of(Ne()[p>>>2>>>0]=E.length,p=0,E))p+=Xi(I)+1;return Ne()[v>>>2>>>0]=p,0}function qo(p){return u?ye(21,1,p):52}function lu(p,v,E,I){return u?ye(22,1,p,v,E,I):52}function Ko(p,v,E,I){return u?ye(23,1,p,v,E,I):70}var xc=[null,[],[]];function Jo(p,v,E,I){if(u)return ye(24,1,p,v,E,I);v>>>=0,E>>>=0,I>>>=0;for(var k=0,F=0;F<E;F++){var ie=Ne()[v>>>2>>>0],ge=Ne()[v+4>>>2>>>0];v+=8;for(var Te=0;Te<ge;Te++){var Re=p,nt=ee()[ie+Te>>>0],ht=xc[Re];nt===0||nt===10?((Re===1?ce:me)(Gi(ht)),ht.length=0):ht.push(nt)}k+=ge}return Ne()[I>>>2>>>0]=k,0}u||function(){for(var p=s.numThreads-1;p--;)Kt();at.push(()=>{ke++,function(v){u?v():Promise.all(Oe.map(En)).then(v)}(()=>Ge())})}();for(var ao=Array(256),oo=0;256>oo;++oo)ao[oo]=String.fromCharCode(oo);_t=ao,Je.push(0,1,void 0,1,null,1,!0,1,!1,1),s.count_emval_handles=()=>Je.length/2-5-Bn.length,u||(T=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),U()),s.wasmBinary&&(_=s.wasmBinary),s.stackSave=()=>la(),s.stackRestore=p=>Ls(p),s.stackAlloc=p=>Ga(p),s.setValue=function(p,v,E="i8"){switch(E.endsWith("*")&&(E="*"),E){case"i1":case"i8":B()[p>>>0]=v;break;case"i16":_e()[p>>>1>>>0]=v;break;case"i32":ae()[p>>>2>>>0]=v;break;case"i64":V[p>>>3]=BigInt(v);break;case"float":Ye()[p>>>2>>>0]=v;break;case"double":ze()[p>>>3>>>0]=v;break;case"*":Ne()[p>>>2>>>0]=v;break;default:$e(`invalid type for setValue: ${E}`)}},s.getValue=function(p,v="i8"){switch(v.endsWith("*")&&(v="*"),v){case"i1":case"i8":return B()[p>>>0];case"i16":return _e()[p>>>1>>>0];case"i32":return ae()[p>>>2>>>0];case"i64":return V[p>>>3];case"float":return Ye()[p>>>2>>>0];case"double":return ze()[p>>>3>>>0];case"*":return Ne()[p>>>2>>>0];default:$e(`invalid type for getValue: ${v}`)}},s.UTF8ToString=xt,s.stringToUTF8=ci,s.lengthBytesUTF8=Xi;var uu=[Ke,Be,Yn,ji,Wi,Sn,Ii,Xt,nr,L,oe,K,re,de,xe,Ue,no,nu,Wo,Ua,Xr,qo,lu,Ko,Jo],lo={893836:(p,v,E,I,k)=>{if(s===void 0||!s.Fb)return 1;if((p=xt(Number(p>>>0))).startsWith("./")&&(p=p.substring(2)),!(p=s.Fb.get(p)))return 2;if(v=Number(v>>>0),E=Number(E>>>0),I=Number(I>>>0),v+E>p.byteLength)return 3;try{let F=p.subarray(v,v+E);switch(k){case 0:ee().set(F,I>>>0);break;case 1:s.mc?s.mc(I,F):s.cc(I,F);break;default:return 4}return 0}catch{return 4}},894660:(p,v,E)=>{s.Pb(p,ee().subarray(v>>>0,v+E>>>0))},894724:()=>s.oc(),894766:p=>{s.Ob(p)},894803:()=>{s.Wb()},894834:()=>{s.Xb()},894863:()=>{s.ac()},894888:p=>s.Vb(p),894921:p=>s.Zb(p),894953:(p,v,E)=>{s.Lb(Number(p),Number(v),Number(E),!0)},895016:(p,v,E)=>{s.Lb(Number(p),Number(v),Number(E))},895073:()=>typeof wasmOffsetConverter<"u",895130:p=>{s.Ab("Abs",p,void 0)},895181:p=>{s.Ab("Neg",p,void 0)},895232:p=>{s.Ab("Floor",p,void 0)},895285:p=>{s.Ab("Ceil",p,void 0)},895337:p=>{s.Ab("Reciprocal",p,void 0)},895395:p=>{s.Ab("Sqrt",p,void 0)},895447:p=>{s.Ab("Exp",p,void 0)},895498:p=>{s.Ab("Erf",p,void 0)},895549:p=>{s.Ab("Sigmoid",p,void 0)},895604:(p,v,E)=>{s.Ab("HardSigmoid",p,{alpha:v,beta:E})},895683:p=>{s.Ab("Log",p,void 0)},895734:p=>{s.Ab("Sin",p,void 0)},895785:p=>{s.Ab("Cos",p,void 0)},895836:p=>{s.Ab("Tan",p,void 0)},895887:p=>{s.Ab("Asin",p,void 0)},895939:p=>{s.Ab("Acos",p,void 0)},895991:p=>{s.Ab("Atan",p,void 0)},896043:p=>{s.Ab("Sinh",p,void 0)},896095:p=>{s.Ab("Cosh",p,void 0)},896147:p=>{s.Ab("Asinh",p,void 0)},896200:p=>{s.Ab("Acosh",p,void 0)},896253:p=>{s.Ab("Atanh",p,void 0)},896306:p=>{s.Ab("Tanh",p,void 0)},896358:p=>{s.Ab("Not",p,void 0)},896409:(p,v,E)=>{s.Ab("Clip",p,{min:v,max:E})},896478:p=>{s.Ab("Clip",p,void 0)},896530:(p,v)=>{s.Ab("Elu",p,{alpha:v})},896588:p=>{s.Ab("Gelu",p,void 0)},896640:p=>{s.Ab("Relu",p,void 0)},896692:(p,v)=>{s.Ab("LeakyRelu",p,{alpha:v})},896756:(p,v)=>{s.Ab("ThresholdedRelu",p,{alpha:v})},896826:(p,v)=>{s.Ab("Cast",p,{to:v})},896884:p=>{s.Ab("Add",p,void 0)},896935:p=>{s.Ab("Sub",p,void 0)},896986:p=>{s.Ab("Mul",p,void 0)},897037:p=>{s.Ab("Div",p,void 0)},897088:p=>{s.Ab("Pow",p,void 0)},897139:p=>{s.Ab("Equal",p,void 0)},897192:p=>{s.Ab("Greater",p,void 0)},897247:p=>{s.Ab("GreaterOrEqual",p,void 0)},897309:p=>{s.Ab("Less",p,void 0)},897361:p=>{s.Ab("LessOrEqual",p,void 0)},897420:(p,v,E,I,k)=>{s.Ab("ReduceMean",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},897595:(p,v,E,I,k)=>{s.Ab("ReduceMax",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},897769:(p,v,E,I,k)=>{s.Ab("ReduceMin",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},897943:(p,v,E,I,k)=>{s.Ab("ReduceProd",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},898118:(p,v,E,I,k)=>{s.Ab("ReduceSum",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},898292:(p,v,E,I,k)=>{s.Ab("ReduceL1",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},898465:(p,v,E,I,k)=>{s.Ab("ReduceL2",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},898638:(p,v,E,I,k)=>{s.Ab("ReduceLogSum",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},898815:(p,v,E,I,k)=>{s.Ab("ReduceSumSquare",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},898995:(p,v,E,I,k)=>{s.Ab("ReduceLogSumExp",p,{keepDims:!!v,noopWithEmptyAxes:!!E,axes:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},899175:p=>{s.Ab("Where",p,void 0)},899228:(p,v,E)=>{s.Ab("Transpose",p,{perm:v?Array.from(ae().subarray(Number(v)>>>0,Number(E)>>>0)):[]})},899352:(p,v,E,I)=>{s.Ab("DepthToSpace",p,{blocksize:v,mode:xt(E),format:I?"NHWC":"NCHW"})},899485:(p,v,E,I)=>{s.Ab("DepthToSpace",p,{blocksize:v,mode:xt(E),format:I?"NHWC":"NCHW"})},899618:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui)=>{s.Ab("ConvTranspose",p,{format:Te?"NHWC":"NCHW",autoPad:v,dilations:[E],group:I,kernelShape:[k],pads:[F,ie],strides:[ge],wIsConst:()=>!!B()[Re>>>0],outputPadding:nt?Array.from(ae().subarray(Number(nt)>>>0,Number(ht)>>>0)):[],outputShape:At?Array.from(ae().subarray(Number(At)>>>0,Number(Jt)>>>0)):[],activation:xt(ui)})},900051:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.Ab("ConvTranspose",p,{format:ge?"NHWC":"NCHW",autoPad:v,dilations:Array.from(ae().subarray(Number(E)>>>0,2+(Number(E)>>>0)>>>0)),group:I,kernelShape:Array.from(ae().subarray(Number(k)>>>0,2+(Number(k)>>>0)>>>0)),pads:Array.from(ae().subarray(Number(F)>>>0,4+(Number(F)>>>0)>>>0)),strides:Array.from(ae().subarray(Number(ie)>>>0,2+(Number(ie)>>>0)>>>0)),wIsConst:()=>!!B()[Te>>>0],outputPadding:Re?Array.from(ae().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],outputShape:ht?Array.from(ae().subarray(Number(ht)>>>0,Number(At)>>>0)):[],activation:xt(Jt)})},900712:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui)=>{s.Ab("ConvTranspose",p,{format:Te?"NHWC":"NCHW",autoPad:v,dilations:[E],group:I,kernelShape:[k],pads:[F,ie],strides:[ge],wIsConst:()=>!!B()[Re>>>0],outputPadding:nt?Array.from(ae().subarray(Number(nt)>>>0,Number(ht)>>>0)):[],outputShape:At?Array.from(ae().subarray(Number(At)>>>0,Number(Jt)>>>0)):[],activation:xt(ui)})},901145:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.Ab("ConvTranspose",p,{format:ge?"NHWC":"NCHW",autoPad:v,dilations:Array.from(ae().subarray(Number(E)>>>0,2+(Number(E)>>>0)>>>0)),group:I,kernelShape:Array.from(ae().subarray(Number(k)>>>0,2+(Number(k)>>>0)>>>0)),pads:Array.from(ae().subarray(Number(F)>>>0,4+(Number(F)>>>0)>>>0)),strides:Array.from(ae().subarray(Number(ie)>>>0,2+(Number(ie)>>>0)>>>0)),wIsConst:()=>!!B()[Te>>>0],outputPadding:Re?Array.from(ae().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],outputShape:ht?Array.from(ae().subarray(Number(ht)>>>0,Number(At)>>>0)):[],activation:xt(Jt)})},901806:(p,v)=>{s.Ab("GlobalAveragePool",p,{format:v?"NHWC":"NCHW"})},901897:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.Ab("AveragePool",p,{format:Jt?"NHWC":"NCHW",auto_pad:v,ceil_mode:E,count_include_pad:I,storage_order:k,dilations:F?Array.from(ae().subarray(Number(F)>>>0,Number(ie)>>>0)):[],kernel_shape:ge?Array.from(ae().subarray(Number(ge)>>>0,Number(Te)>>>0)):[],pads:Re?Array.from(ae().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],strides:ht?Array.from(ae().subarray(Number(ht)>>>0,Number(At)>>>0)):[]})},902376:(p,v)=>{s.Ab("GlobalAveragePool",p,{format:v?"NHWC":"NCHW"})},902467:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.Ab("AveragePool",p,{format:Jt?"NHWC":"NCHW",auto_pad:v,ceil_mode:E,count_include_pad:I,storage_order:k,dilations:F?Array.from(ae().subarray(Number(F)>>>0,Number(ie)>>>0)):[],kernel_shape:ge?Array.from(ae().subarray(Number(ge)>>>0,Number(Te)>>>0)):[],pads:Re?Array.from(ae().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],strides:ht?Array.from(ae().subarray(Number(ht)>>>0,Number(At)>>>0)):[]})},902946:(p,v)=>{s.Ab("GlobalMaxPool",p,{format:v?"NHWC":"NCHW"})},903033:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.Ab("MaxPool",p,{format:Jt?"NHWC":"NCHW",auto_pad:v,ceil_mode:E,count_include_pad:I,storage_order:k,dilations:F?Array.from(ae().subarray(Number(F)>>>0,Number(ie)>>>0)):[],kernel_shape:ge?Array.from(ae().subarray(Number(ge)>>>0,Number(Te)>>>0)):[],pads:Re?Array.from(ae().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],strides:ht?Array.from(ae().subarray(Number(ht)>>>0,Number(At)>>>0)):[]})},903508:(p,v)=>{s.Ab("GlobalMaxPool",p,{format:v?"NHWC":"NCHW"})},903595:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>{s.Ab("MaxPool",p,{format:Jt?"NHWC":"NCHW",auto_pad:v,ceil_mode:E,count_include_pad:I,storage_order:k,dilations:F?Array.from(ae().subarray(Number(F)>>>0,Number(ie)>>>0)):[],kernel_shape:ge?Array.from(ae().subarray(Number(ge)>>>0,Number(Te)>>>0)):[],pads:Re?Array.from(ae().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],strides:ht?Array.from(ae().subarray(Number(ht)>>>0,Number(At)>>>0)):[]})},904070:(p,v,E,I,k)=>{s.Ab("Gemm",p,{alpha:v,beta:E,transA:I,transB:k})},904174:p=>{s.Ab("MatMul",p,void 0)},904228:(p,v,E,I)=>{s.Ab("ArgMax",p,{keepDims:!!v,selectLastIndex:!!E,axis:I})},904336:(p,v,E,I)=>{s.Ab("ArgMin",p,{keepDims:!!v,selectLastIndex:!!E,axis:I})},904444:(p,v)=>{s.Ab("Softmax",p,{axis:v})},904507:(p,v)=>{s.Ab("Concat",p,{axis:v})},904567:(p,v,E,I,k)=>{s.Ab("Split",p,{axis:v,numOutputs:E,splitSizes:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},904723:p=>{s.Ab("Expand",p,void 0)},904777:(p,v)=>{s.Ab("Gather",p,{axis:Number(v)})},904848:(p,v)=>{s.Ab("GatherElements",p,{axis:Number(v)})},904927:(p,v)=>{s.Ab("GatherND",p,{batch_dims:Number(v)})},905006:(p,v,E,I,k,F,ie,ge,Te,Re,nt)=>{s.Ab("Resize",p,{antialias:v,axes:E?Array.from(ae().subarray(Number(E)>>>0,Number(I)>>>0)):[],coordinateTransformMode:xt(k),cubicCoeffA:F,excludeOutside:ie,extrapolationValue:ge,keepAspectRatioPolicy:xt(Te),mode:xt(Re),nearestMode:xt(nt)})},905368:(p,v,E,I,k,F,ie)=>{s.Ab("Slice",p,{starts:v?Array.from(ae().subarray(Number(v)>>>0,Number(E)>>>0)):[],ends:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[],axes:F?Array.from(ae().subarray(Number(F)>>>0,Number(ie)>>>0)):[]})},905632:p=>{s.Ab("Tile",p,void 0)},905684:(p,v,E)=>{s.Ab("InstanceNormalization",p,{epsilon:v,format:E?"NHWC":"NCHW"})},905798:(p,v,E)=>{s.Ab("InstanceNormalization",p,{epsilon:v,format:E?"NHWC":"NCHW"})},905912:p=>{s.Ab("Range",p,void 0)},905965:(p,v)=>{s.Ab("Einsum",p,{equation:xt(v)})},906046:(p,v,E,I,k)=>{s.Ab("Pad",p,{mode:v,value:E,pads:I?Array.from(ae().subarray(Number(I)>>>0,Number(k)>>>0)):[]})},906189:(p,v,E,I,k,F)=>{s.Ab("BatchNormalization",p,{epsilon:v,momentum:E,spatial:!!k,trainingMode:!!I,format:F?"NHWC":"NCHW"})},906358:(p,v,E,I,k,F)=>{s.Ab("BatchNormalization",p,{epsilon:v,momentum:E,spatial:!!k,trainingMode:!!I,format:F?"NHWC":"NCHW"})},906527:(p,v,E)=>{s.Ab("CumSum",p,{exclusive:Number(v),reverse:Number(E)})},906624:(p,v,E)=>{s.Ab("DequantizeLinear",p,{axis:v,blockSize:E})},906714:(p,v,E,I,k)=>{s.Ab("GridSample",p,{align_corners:v,mode:xt(E),padding_mode:xt(I),format:k?"NHWC":"NCHW"})},906884:(p,v,E,I,k)=>{s.Ab("GridSample",p,{align_corners:v,mode:xt(E),padding_mode:xt(I),format:k?"NHWC":"NCHW"})},907054:(p,v)=>{s.Ab("ScatterND",p,{reduction:xt(v)})},907139:(p,v,E,I,k,F,ie,ge,Te)=>{s.Ab("Attention",p,{numHeads:v,isUnidirectional:E,maskFilterValue:I,scale:k,doRotary:F,qkvHiddenSizes:ie?Array.from(ae().subarray(Number(ge)>>>0,Number(ge)+ie>>>0)):[],pastPresentShareBuffer:!!Te})},907411:p=>{s.Ab("BiasAdd",p,void 0)},907466:p=>{s.Ab("BiasSplitGelu",p,void 0)},907527:p=>{s.Ab("FastGelu",p,void 0)},907583:(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr)=>{s.Ab("Conv",p,{format:ht?"NHWC":"NCHW",auto_pad:v,dilations:E?Array.from(ae().subarray(Number(E)>>>0,Number(I)>>>0)):[],group:k,kernel_shape:F?Array.from(ae().subarray(Number(F)>>>0,Number(ie)>>>0)):[],pads:ge?Array.from(ae().subarray(Number(ge)>>>0,Number(Te)>>>0)):[],strides:Re?Array.from(ae().subarray(Number(Re)>>>0,Number(nt)>>>0)):[],w_is_const:()=>!!B()[Number(At)>>>0],activation:xt(Jt),activation_params:ui?Array.from(Ye().subarray(Number(ui)>>>0,Number(vr)>>>0)):[]})},908167:p=>{s.Ab("Gelu",p,void 0)},908219:(p,v,E,I,k,F,ie,ge,Te)=>{s.Ab("GroupQueryAttention",p,{numHeads:v,kvNumHeads:E,scale:I,softcap:k,doRotary:F,rotaryInterleaved:ie,smoothSoftmax:ge,localWindowSize:Te})},908436:(p,v,E,I)=>{s.Ab("LayerNormalization",p,{axis:v,epsilon:E,simplified:!!I})},908547:(p,v,E,I)=>{s.Ab("LayerNormalization",p,{axis:v,epsilon:E,simplified:!!I})},908658:(p,v,E,I,k,F)=>{s.Ab("MatMulNBits",p,{k:v,n:E,accuracyLevel:I,bits:k,blockSize:F})},908785:(p,v,E,I,k,F)=>{s.Ab("MultiHeadAttention",p,{numHeads:v,isUnidirectional:E,maskFilterValue:I,scale:k,doRotary:F})},908944:(p,v)=>{s.Ab("QuickGelu",p,{alpha:v})},909008:(p,v,E,I,k)=>{s.Ab("RotaryEmbedding",p,{interleaved:!!v,numHeads:E,rotaryEmbeddingDim:I,scale:k})},909147:(p,v,E)=>{s.Ab("SkipLayerNormalization",p,{epsilon:v,simplified:!!E})},909249:(p,v,E)=>{s.Ab("SkipLayerNormalization",p,{epsilon:v,simplified:!!E})},909351:(p,v,E,I)=>{s.Ab("GatherBlockQuantized",p,{gatherAxis:v,quantizeAxis:E,blockSize:I})},909472:p=>{s.$b(p)},909506:(p,v)=>s.bc(Number(p),Number(v),s.Gb.ec,s.Gb.errors)};function uo(p,v,E){return Ve(async()=>{await s.Yb(Number(p),Number(v),Number(E))})}function Ft(){return typeof wasmOffsetConverter<"u"}var Xe=await async function(){function p(I,k){return Xe=I.exports,Xe=function(){var F=Xe,ie={};for(let[ge,Te]of Object.entries(F))ie[ge]=typeof Te=="function"?(...Re)=>{oi.push(ge);try{return Te(...Re)}finally{Q||(oi.pop(),Hn&&wn===1&&oi.length===0&&(wn=0,he+=1,Pn(po),typeof Fibers<"u"&&Fibers.sc()))}}:Te;return ie}(),Xe=function(){var F=Xe,ie=Te=>Re=>Te(Re)>>>0,ge=Te=>()=>Te()>>>0;return(F=Object.assign({},F)).Ea=ie(F.Ea),F.gb=ge(F.gb),F.ib=ie(F.ib),F.tb=ie(F.tb),F.ub=ge(F.ub),F.__cxa_get_exception_ptr=ie(F.__cxa_get_exception_ptr),F}(),bt.push(Xe.jb),x=k,Ge(),Xe}ke++;var v=et();if(s.instantiateWasm)return new Promise(I=>{s.instantiateWasm(v,(k,F)=>{I(p(k,F))})});if(u)return new Promise(I=>{j=k=>{var F=new WebAssembly.Instance(k,et());I(p(F,k))}});Pe??(Pe=s.locateFile?s.locateFile?s.locateFile("ort-wasm-simd-threaded.jsep.wasm",g):g+"ort-wasm-simd-threaded.jsep.wasm":new URL("/Gemini-AI-Translator/assets/ort-wasm-simd-threaded.jsep-BGTZ4Y7F.wasm",import.meta.url).href);try{var E=await async function(I){var k=Pe;if(!_&&typeof WebAssembly.instantiateStreaming=="function"&&!H(k))try{var F=fetch(k,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(F,I)}catch(ie){me(`wasm streaming compile failed: ${ie}`),me("falling back to ArrayBuffer instantiation")}return async function(ie,ge){try{var Te=await async function(Re){if(!_)try{var nt=await h(Re);return new Uint8Array(nt)}catch{}if(Re==Pe&&_)Re=new Uint8Array(_);else{if(!m)throw"both async and sync fetching of the wasm failed";Re=m(Re)}return Re}(ie);return await WebAssembly.instantiate(Te,ge)}catch(Re){me(`failed to asynchronously prepare wasm: ${Re}`),$e(Re)}}(k,I)}(v);return p(E.instance,E.module)}catch(I){return r(I),Promise.reject(I)}}(),Yo=p=>(Yo=Xe.Ea)(p),Xo=()=>(Xo=Xe.Fa)();s._OrtInit=(p,v)=>(s._OrtInit=Xe.Ga)(p,v),s._OrtGetLastError=(p,v)=>(s._OrtGetLastError=Xe.Ha)(p,v),s._OrtCreateSessionOptions=(p,v,E,I,k,F,ie,ge,Te,Re)=>(s._OrtCreateSessionOptions=Xe.Ia)(p,v,E,I,k,F,ie,ge,Te,Re),s._OrtAppendExecutionProvider=(p,v,E,I,k)=>(s._OrtAppendExecutionProvider=Xe.Ja)(p,v,E,I,k),s._OrtAddFreeDimensionOverride=(p,v,E)=>(s._OrtAddFreeDimensionOverride=Xe.Ka)(p,v,E),s._OrtAddSessionConfigEntry=(p,v,E)=>(s._OrtAddSessionConfigEntry=Xe.La)(p,v,E),s._OrtReleaseSessionOptions=p=>(s._OrtReleaseSessionOptions=Xe.Ma)(p),s._OrtCreateSession=(p,v,E)=>(s._OrtCreateSession=Xe.Na)(p,v,E),s._OrtReleaseSession=p=>(s._OrtReleaseSession=Xe.Oa)(p),s._OrtGetInputOutputCount=(p,v,E)=>(s._OrtGetInputOutputCount=Xe.Pa)(p,v,E),s._OrtGetInputOutputMetadata=(p,v,E,I)=>(s._OrtGetInputOutputMetadata=Xe.Qa)(p,v,E,I),s._OrtFree=p=>(s._OrtFree=Xe.Ra)(p),s._OrtCreateTensor=(p,v,E,I,k,F)=>(s._OrtCreateTensor=Xe.Sa)(p,v,E,I,k,F),s._OrtGetTensorData=(p,v,E,I,k)=>(s._OrtGetTensorData=Xe.Ta)(p,v,E,I,k),s._OrtReleaseTensor=p=>(s._OrtReleaseTensor=Xe.Ua)(p),s._OrtCreateRunOptions=(p,v,E,I)=>(s._OrtCreateRunOptions=Xe.Va)(p,v,E,I),s._OrtAddRunConfigEntry=(p,v,E)=>(s._OrtAddRunConfigEntry=Xe.Wa)(p,v,E),s._OrtReleaseRunOptions=p=>(s._OrtReleaseRunOptions=Xe.Xa)(p),s._OrtCreateBinding=p=>(s._OrtCreateBinding=Xe.Ya)(p),s._OrtBindInput=(p,v,E)=>(s._OrtBindInput=Xe.Za)(p,v,E),s._OrtBindOutput=(p,v,E,I)=>(s._OrtBindOutput=Xe._a)(p,v,E,I),s._OrtClearBoundOutputs=p=>(s._OrtClearBoundOutputs=Xe.$a)(p),s._OrtReleaseBinding=p=>(s._OrtReleaseBinding=Xe.ab)(p),s._OrtRunWithBinding=(p,v,E,I,k)=>(s._OrtRunWithBinding=Xe.bb)(p,v,E,I,k),s._OrtRun=(p,v,E,I,k,F,ie,ge)=>(s._OrtRun=Xe.cb)(p,v,E,I,k,F,ie,ge),s._OrtEndProfiling=p=>(s._OrtEndProfiling=Xe.db)(p),s._JsepOutput=(p,v,E)=>(s._JsepOutput=Xe.eb)(p,v,E),s._JsepGetNodeName=p=>(s._JsepGetNodeName=Xe.fb)(p);var aa=()=>(aa=Xe.gb)(),Ni=s._free=p=>(Ni=s._free=Xe.hb)(p),Ns=s._malloc=p=>(Ns=s._malloc=Xe.ib)(p),Va=(p,v,E,I,k,F)=>(Va=Xe.kb)(p,v,E,I,k,F),co=()=>(co=Xe.lb)(),Qo=(p,v,E,I,k)=>(Qo=Xe.mb)(p,v,E,I,k),Zo=p=>(Zo=Xe.nb)(p),oa=p=>(oa=Xe.ob)(p),el=(p,v)=>(el=Xe.pb)(p,v),tl=()=>(tl=Xe.qb)(),fo=(p,v)=>(fo=Xe.rb)(p,v),Ls=p=>(Ls=Xe.sb)(p),Ga=p=>(Ga=Xe.tb)(p),la=()=>(la=Xe.ub)(),nl=s.dynCall_ii=(p,v)=>(nl=s.dynCall_ii=Xe.vb)(p,v);s.dynCall_vii=(p,v,E)=>(s.dynCall_vii=Xe.dynCall_vii)(p,v,E),s.dynCall_iiiii=(p,v,E,I,k)=>(s.dynCall_iiiii=Xe.dynCall_iiiii)(p,v,E,I,k),s.dynCall_iii=(p,v,E)=>(s.dynCall_iii=Xe.dynCall_iii)(p,v,E),s.dynCall_iiiiii=(p,v,E,I,k,F)=>(s.dynCall_iiiiii=Xe.dynCall_iiiiii)(p,v,E,I,k,F),s.dynCall_iiiiiiii=(p,v,E,I,k,F,ie,ge)=>(s.dynCall_iiiiiiii=Xe.dynCall_iiiiiiii)(p,v,E,I,k,F,ie,ge),s.dynCall_iiiiiii=(p,v,E,I,k,F,ie)=>(s.dynCall_iiiiiii=Xe.dynCall_iiiiiii)(p,v,E,I,k,F,ie),s.dynCall_vi=(p,v)=>(s.dynCall_vi=Xe.dynCall_vi)(p,v),s.dynCall_iiii=(p,v,E,I)=>(s.dynCall_iiii=Xe.dynCall_iiii)(p,v,E,I),s.dynCall_i=p=>(s.dynCall_i=Xe.dynCall_i)(p),s.dynCall_viiiiiiii=(p,v,E,I,k,F,ie,ge,Te)=>(s.dynCall_viiiiiiii=Xe.dynCall_viiiiiiii)(p,v,E,I,k,F,ie,ge,Te),s.dynCall_viii=(p,v,E,I)=>(s.dynCall_viii=Xe.dynCall_viii)(p,v,E,I),s.dynCall_viijj=(p,v,E,I,k)=>(s.dynCall_viijj=Xe.dynCall_viijj)(p,v,E,I,k),s.dynCall_viiiiii=(p,v,E,I,k,F,ie)=>(s.dynCall_viiiiii=Xe.dynCall_viiiiii)(p,v,E,I,k,F,ie),s.dynCall_viiii=(p,v,E,I,k)=>(s.dynCall_viiii=Xe.dynCall_viiii)(p,v,E,I,k),s.dynCall_viiiii=(p,v,E,I,k,F)=>(s.dynCall_viiiii=Xe.dynCall_viiiii)(p,v,E,I,k,F),s.dynCall_vfiii=(p,v,E,I,k)=>(s.dynCall_vfiii=Xe.dynCall_vfiii)(p,v,E,I,k),s.dynCall_viiiiff=(p,v,E,I,k,F,ie)=>(s.dynCall_viiiiff=Xe.dynCall_viiiiff)(p,v,E,I,k,F,ie),s.dynCall_viiiiiff=(p,v,E,I,k,F,ie,ge)=>(s.dynCall_viiiiiff=Xe.dynCall_viiiiiff)(p,v,E,I,k,F,ie,ge),s.dynCall_ffff=(p,v,E,I)=>(s.dynCall_ffff=Xe.dynCall_ffff)(p,v,E,I),s.dynCall_viiff=(p,v,E,I,k)=>(s.dynCall_viiff=Xe.dynCall_viiff)(p,v,E,I,k),s.dynCall_fffffff=(p,v,E,I,k,F,ie)=>(s.dynCall_fffffff=Xe.dynCall_fffffff)(p,v,E,I,k,F,ie),s.dynCall_jjjjjjj=(p,v,E,I,k,F,ie)=>(s.dynCall_jjjjjjj=Xe.dynCall_jjjjjjj)(p,v,E,I,k,F,ie),s.dynCall_jjjjjj=(p,v,E,I,k,F)=>(s.dynCall_jjjjjj=Xe.dynCall_jjjjjj)(p,v,E,I,k,F),s.dynCall_iijjii=(p,v,E,I,k,F)=>(s.dynCall_iijjii=Xe.dynCall_iijjii)(p,v,E,I,k,F),s.dynCall_viiiiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt)=>(s.dynCall_viiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt),s.dynCall_viiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt)=>(s.dynCall_viiiiiiiiii=Xe.dynCall_viiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt),s.dynCall_viiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht)=>(s.dynCall_viiiiiiiiiii=Xe.dynCall_viiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht),s.dynCall_viiiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At)=>(s.dynCall_viiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At),s.dynCall_viiiiiiiiiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr,cs,ja,al)=>(s.dynCall_viiiiiiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr,cs,ja,al),s.dynCall_viiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re)=>(s.dynCall_viiiiiiiii=Xe.dynCall_viiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re),s.dynCall_viiiiiiiiiiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr,cs,ja,al,cu)=>(s.dynCall_viiiiiiiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr,cs,ja,al,cu),s.dynCall_viiiiiii=(p,v,E,I,k,F,ie,ge)=>(s.dynCall_viiiiiii=Xe.dynCall_viiiiiii)(p,v,E,I,k,F,ie,ge),s.dynCall_viiiiiiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr)=>(s.dynCall_viiiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr),s.dynCall_jiji=(p,v,E,I)=>(s.dynCall_jiji=Xe.dynCall_jiji)(p,v,E,I),s.dynCall_v=p=>(s.dynCall_v=Xe.dynCall_v)(p),s.dynCall_iidiiii=(p,v,E,I,k,F,ie)=>(s.dynCall_iidiiii=Xe.dynCall_iidiiii)(p,v,E,I,k,F,ie),s.dynCall_iiiiiiiii=(p,v,E,I,k,F,ie,ge,Te)=>(s.dynCall_iiiiiiiii=Xe.dynCall_iiiiiiiii)(p,v,E,I,k,F,ie,ge,Te),s.dynCall_iiij=(p,v,E,I)=>(s.dynCall_iiij=Xe.dynCall_iiij)(p,v,E,I),s.dynCall_iiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re)=>(s.dynCall_iiiiiiiiii=Xe.dynCall_iiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re),s.dynCall_iiiiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At)=>(s.dynCall_iiiiiiiiiiiii=Xe.dynCall_iiiiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At),s.dynCall_iiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt)=>(s.dynCall_iiiiiiiiiii=Xe.dynCall_iiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt),s.dynCall_ji=(p,v)=>(s.dynCall_ji=Xe.dynCall_ji)(p,v),s.dynCall_iijii=(p,v,E,I,k)=>(s.dynCall_iijii=Xe.dynCall_iijii)(p,v,E,I,k),s.dynCall_vij=(p,v,E)=>(s.dynCall_vij=Xe.dynCall_vij)(p,v,E),s.dynCall_viiijii=(p,v,E,I,k,F,ie)=>(s.dynCall_viiijii=Xe.dynCall_viiijii)(p,v,E,I,k,F,ie),s.dynCall_viijiiiiiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr,cs,ja)=>(s.dynCall_viijiiiiiiiiiiiiii=Xe.dynCall_viijiiiiiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr,cs,ja),s.dynCall_viiiji=(p,v,E,I,k,F)=>(s.dynCall_viiiji=Xe.dynCall_viiiji)(p,v,E,I,k,F),s.dynCall_fiii=(p,v,E,I)=>(s.dynCall_fiii=Xe.dynCall_fiii)(p,v,E,I),s.dynCall_viijii=(p,v,E,I,k,F)=>(s.dynCall_viijii=Xe.dynCall_viijii)(p,v,E,I,k,F),s.dynCall_viij=(p,v,E,I)=>(s.dynCall_viij=Xe.dynCall_viij)(p,v,E,I),s.dynCall_jiij=(p,v,E,I)=>(s.dynCall_jiij=Xe.dynCall_jiij)(p,v,E,I),s.dynCall_fi=(p,v)=>(s.dynCall_fi=Xe.dynCall_fi)(p,v),s.dynCall_fii=(p,v,E)=>(s.dynCall_fii=Xe.dynCall_fii)(p,v,E),s.dynCall_jii=(p,v,E)=>(s.dynCall_jii=Xe.dynCall_jii)(p,v,E),s.dynCall_dii=(p,v,E)=>(s.dynCall_dii=Xe.dynCall_dii)(p,v,E),s.dynCall_fiiii=(p,v,E,I,k)=>(s.dynCall_fiiii=Xe.dynCall_fiiii)(p,v,E,I,k),s.dynCall_fif=(p,v,E)=>(s.dynCall_fif=Xe.dynCall_fif)(p,v,E),s.dynCall_jfi=(p,v,E)=>(s.dynCall_jfi=Xe.dynCall_jfi)(p,v,E),s.dynCall_viiiiiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui)=>(s.dynCall_viiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui),s.dynCall_viiiiiiiiiiiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr,cs,ja,al,cu,Lp)=>(s.dynCall_viiiiiiiiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr,cs,ja,al,cu,Lp),s.dynCall_viiiiiiiiiiiiiiii=(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr,cs)=>(s.dynCall_viiiiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiiiii)(p,v,E,I,k,F,ie,ge,Te,Re,nt,ht,At,Jt,ui,vr,cs),s.dynCall_iif=(p,v,E)=>(s.dynCall_iif=Xe.dynCall_iif)(p,v,E),s.dynCall_jiiii=(p,v,E,I,k)=>(s.dynCall_jiiii=Xe.dynCall_jiiii)(p,v,E,I,k),s.dynCall_jiii=(p,v,E,I)=>(s.dynCall_jiii=Xe.dynCall_jiii)(p,v,E,I),s.dynCall_viif=(p,v,E,I)=>(s.dynCall_viif=Xe.dynCall_viif)(p,v,E,I),s.dynCall_viiij=(p,v,E,I,k)=>(s.dynCall_viiij=Xe.dynCall_viiij)(p,v,E,I,k),s.dynCall_viiiijii=(p,v,E,I,k,F,ie,ge)=>(s.dynCall_viiiijii=Xe.dynCall_viiiijii)(p,v,E,I,k,F,ie,ge),s.dynCall_iiiiij=(p,v,E,I,k,F)=>(s.dynCall_iiiiij=Xe.dynCall_iiiiij)(p,v,E,I,k,F),s.dynCall_iiiiid=(p,v,E,I,k,F)=>(s.dynCall_iiiiid=Xe.dynCall_iiiiid)(p,v,E,I,k,F),s.dynCall_iiiiijj=(p,v,E,I,k,F,ie)=>(s.dynCall_iiiiijj=Xe.dynCall_iiiiijj)(p,v,E,I,k,F,ie),s.dynCall_iiiiiijj=(p,v,E,I,k,F,ie,ge)=>(s.dynCall_iiiiiijj=Xe.dynCall_iiiiiijj)(p,v,E,I,k,F,ie,ge);var il=p=>(il=Xe.wb)(p),po=()=>(po=Xe.xb)(),rl=p=>(rl=Xe.yb)(p),sl=()=>(sl=Xe.zb)();return function p(){if(0<ke)Le=p;else if(u)i(s),we();else{for(;0<at.length;)at.shift()(s);0<ke?Le=p:(s.calledRun=!0,Q||(we(),i(s)))}}(),s.PTR_SIZE=4,a},V8=Cv,OO=(t=(e=globalThis.self)==null?void 0:e.name)==null?void 0:t.startsWith("em-pthread"),OO&&Cv()}),$v,o1,RO,ps,G8,jh,NO,LO,Av,zO,Iv,j8,Pv,W8,MT=ft(()=>{TT(),$v=typeof location>"u"?void 0:location.origin,o1=import.meta.url>"file:"&&import.meta.url<"file;",RO=()=>{{if(o1){let e=URL;return new URL(new e("ort.bundle.min.mjs",import.meta.url).href,$v).href}return import.meta.url}},ps=RO(),G8=()=>{if(ps&&!ps.startsWith("blob:"))return ps.substring(0,ps.lastIndexOf("/")+1)},jh=(e,t)=>{try{let n=t??ps;return(n?new URL(e,n):new URL(e)).origin===$v}catch{return!1}},NO=(e,t)=>{let n=t??ps;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},LO=(e,t)=>`${t??"./"}${e}`,Av=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},zO=async e=>(await import(e)).default,Iv=(Fre(),vp(F8)).default,j8=async()=>{if(!ps)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(jh(ps))return[void 0,Iv()];let e=await Av(ps);return[e,Iv(e)]},Pv=(Bre(),vp(U8)).default,W8=async(e,t,n,i)=>{let r=Pv&&!(e||t);if(r)if(ps)r=jh(ps);else if(i&&!n)r=!0;else throw new Error("cannot determine the script source URL.");if(r)return[void 0,Pv];{let s="ort-wasm-simd-threaded.jsep.mjs",a=e??NO(s,t),o=n&&a&&!jh(a,t),l=o?await Av(a):a??LO(s,t);return[o?l:void 0,await zO(l)]}}}),kv,Wh,pf,Dv,FO,BO,UO,ET,gi,pc=ft(()=>{MT(),Wh=!1,pf=!1,Dv=!1,FO=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},BO=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},UO=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},ET=async e=>{if(Wh)return Promise.resolve();if(pf)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Dv)throw new Error("previous call to 'initializeWebAssembly()' failed.");pf=!0;let t=e.initTimeout,n=e.numThreads;if(e.simd!==!1){if(e.simd==="relaxed"){if(!UO())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!BO())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let i=FO();n>1&&!i&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let r=e.wasmPaths,s=typeof r=="string"?r:void 0,a=r==null?void 0:r.mjs,o=(a==null?void 0:a.href)??a,l=r==null?void 0:r.wasm,u=(l==null?void 0:l.href)??l,c=e.wasmBinary,[f,d]=await W8(o,s,n>1,!!c||!!u),h=!1,m=[];if(t>0&&m.push(new Promise(y=>{setTimeout(()=>{h=!0,y()},t)})),m.push(new Promise((y,M)=>{let g={numThreads:n};if(c)g.wasmBinary=c;else if(u||s)g.locateFile=_=>u??s+_;else if(o&&o.indexOf("blob:")!==0)g.locateFile=_=>new URL(_,o).href;else if(f){let _=G8();_&&(g.locateFile=T=>_+T)}d(g).then(_=>{pf=!1,Wh=!0,kv=_,y(),f&&URL.revokeObjectURL(f)},_=>{pf=!1,Dv=!0,M(_)})})),await Promise.race(m),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},gi=()=>{if(Wh&&kv)return kv;throw new Error("WebAssembly is not initialized yet.")}}),Ta,bg,ri,ST=ft(()=>{pc(),Ta=(e,t)=>{let n=gi(),i=n.lengthBytesUTF8(e)+1,r=n._malloc(i);return n.stringToUTF8(e,r,i),t.push(r),r},bg=(e,t,n,i)=>{if(typeof e=="object"&&e!==null){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([r,s])=>{let a=t?t+r:r;if(typeof s=="object")bg(s,a+".",n,i);else if(typeof s=="string"||typeof s=="number")i(a,s.toString());else if(typeof s=="boolean")i(a,s?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof s}`)})},ri=e=>{let t=gi(),n=t.stackSave();try{let i=t.PTR_SIZE,r=t.stackAlloc(2*i);t._OrtGetLastError(r,r+i);let s=Number(t.getValue(r,i===4?"i32":"i64")),a=t.getValue(r+i,"*"),o=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${s}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(n)}}}),H8,Ure=ft(()=>{pc(),ST(),H8=e=>{let t=gi(),n=0,i=[],r=e||{};try{if((e==null?void 0:e.logSeverityLevel)===void 0)r.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log severity level is not valid: ${e.logSeverityLevel}`);if((e==null?void 0:e.logVerbosityLevel)===void 0)r.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);(e==null?void 0:e.terminate)===void 0&&(r.terminate=!1);let s=0;return(e==null?void 0:e.tag)!==void 0&&(s=Ta(e.tag,i)),n=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,s),n===0&&ri("Can't create run options."),(e==null?void 0:e.extra)!==void 0&&bg(e.extra,"",new WeakSet,(a,o)=>{let l=Ta(a,i),u=Ta(o,i);t._OrtAddRunConfigEntry(n,l,u)!==0&&ri(`Can't set a run config entry: ${a} - ${o}.`)}),[n,i]}catch(s){throw n!==0&&t._OrtReleaseRunOptions(n),i.forEach(a=>t._free(a)),s}}}),VO,GO,jO,hf,WO,q8,Vre=ft(()=>{pc(),ST(),VO=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},GO=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},jO=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(e.enableMemPattern=!1)},hf=(e,t,n,i)=>{let r=Ta(t,i),s=Ta(n,i);gi()._OrtAddSessionConfigEntry(e,r,s)!==0&&ri(`Can't set a session config entry: ${t} - ${n}.`)},WO=async(e,t,n)=>{for(let i of t){let r=typeof i=="string"?i:i.name,s=[];switch(r){case"webnn":if(r="WEBNN",typeof i!="string"){let c=i==null?void 0:i.deviceType;c&&hf(e,"deviceType",c,n)}break;case"webgpu":if(r="JS",typeof i!="string"){let c=i;if(c!=null&&c.preferredLayout){if(c.preferredLayout!=="NCHW"&&c.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${c.preferredLayout}`);hf(e,"preferredLayout",c.preferredLayout,n)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let a=Ta(r,n),o=s.length,l=0,u=0;if(o>0){l=gi()._malloc(o*gi().PTR_SIZE),n.push(l),u=gi()._malloc(o*gi().PTR_SIZE),n.push(u);for(let c=0;c<o;c++)gi().setValue(l+c*gi().PTR_SIZE,s[c][0],"*"),gi().setValue(u+c*gi().PTR_SIZE,s[c][1],"*")}await gi()._OrtAppendExecutionProvider(e,a,l,u,o)!==0&&ri(`Can't append execution provider: ${r}.`)}},q8=async e=>{let t=gi(),n=0,i=[],r=e||{};jO(r);try{let s=VO(r.graphOptimizationLevel??"all"),a=GO(r.executionMode??"sequential"),o=typeof r.logId=="string"?Ta(r.logId,i):0,l=r.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log severity level is not valid: ${l}`);let u=r.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let c=typeof r.optimizedModelFilePath=="string"?Ta(r.optimizedModelFilePath,i):0;if(n=t._OrtCreateSessionOptions(s,!!r.enableCpuMemArena,!!r.enableMemPattern,a,!!r.enableProfiling,0,o,l,u,c),n===0&&ri("Can't create session options."),r.executionProviders&&await WO(n,r.executionProviders,i),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);hf(n,"enableGraphCapture",r.enableGraphCapture.toString(),i)}if(r.freeDimensionOverrides)for(let[f,d]of Object.entries(r.freeDimensionOverrides)){if(typeof f!="string")throw new Error(`free dimension override name must be a string: ${f}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let h=Ta(f,i);t._OrtAddFreeDimensionOverride(n,h,d)!==0&&ri(`Can't set a free dimension override: ${f} - ${d}.`)}return r.extra!==void 0&&bg(r.extra,"",new WeakSet,(f,d)=>{hf(n,f,d,i)}),[n,i]}catch(s){throw n!==0&&t._OrtReleaseSessionOptions(n)!==0&&ri("Can't release session options."),i.forEach(a=>t._free(a)),s}}}),Du,So,Ou,a_,xg,CT,$T,l1,Qt=ft(()=>{Du=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},So=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},Ou=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],i=typeof t=="number"?t:t.reduce((r,s)=>r*s,1);return n>0?Math.ceil(i*n):void 0},a_=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},xg=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},CT=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",$T=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",l1=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),AT,K8=ft(()=>{TT(),AT=async e=>{if(typeof e=="string"){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),i=n?parseInt(n,10):0;if(i<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),s;try{s=new ArrayBuffer(i)}catch(o){if(o instanceof RangeError){let l=Math.ceil(i/65536);s=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw o}let a=0;for(;;){let{done:o,value:l}=await r.read();if(o)break;let u=l.byteLength;new Uint8Array(s,a,u).set(l),a+=u}return new Uint8Array(s,0,i)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),HO,qO,KO,JO,IT,YO,Ln,Go=ft(()=>{Qt(),HO=["V","I","W","E","F"],qO=(e,t)=>{console.log(`[${HO[e]},${new Date().toISOString()}]${t}`)},IT=(e,t)=>{KO=e,JO=t},YO=(e,t)=>{let n=xg(e),i=xg(KO);n>=i&&qO(n,typeof t=="function"?t():t)},Ln=(...e)=>{JO&&YO(...e)}}),XO,Cd,qe,Tg,J8,Y8,X8,un=ft(()=>{XO=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},Cd=class{static calcShape(e,t,n=!1){let i=e.length,r=t.length;if(i===0)return t;if(r===0)return e;let s=Math.max(e.length,t.length),a=new Array(s);if(n){if(i<2||r<2)return;let o=XO.calcMatMulShape([e[i-2],e[i-1]],[t[r-2],t[r-1]]);if(o===void 0)return;[a[s-2],a[s-1]]=o}for(let o=n?3:1;o<=s;o++){let l=i-o<0?1:e[i-o],u=r-o<0?1:t[r-o];if(l!==u&&l>1&&u>1)return;let c=Math.max(l,u);if(l&&u)a[s-o]=Math.max(l,u);else{if(c>1)return;a[s-o]=0}}return a}static isValidBroadcast(e,t){let n=e.length,i=t.length;if(n>i)return!1;for(let r=1;r<=n;r++)if(e[n-r]!==1&&e[n-r]!==t[i-r])return!1;return!0}},qe=class $m{static size(t){return $m.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,n=4){let i=t.length;if(i===0)return[];let r=new Array(i),s=i-1;for(;s>=0;){if(t[s]%n===0){r[s]=t[s]/n;break}if(n%t[s]!==0)throw new Error("cannot convert shape");r[s]=1,n/=t[s],s--}for(s--;s>=0;s--)r[s]=t[s];return r}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return $m.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return $m.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(t,n,i){let r=1;for(let s=n;s<i;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=Number(t[s])}return r}static computeStrides(t){let n=t.length;if(n===0)return[];if(n===1)return[1];let i=new Array(n);i[n-1]=1,i[n-2]=t[n-1];for(let r=n-3;r>=0;--r)i[r]=i[r+1]*t[r+1];return i}static normalizeAxis(t,n){if(t<-n&&t>=n)throw new Error("unsupported axis for this operation.");return t<0?t+n:t}static normalizeAxes(t,n){return t.map(i=>this.normalizeAxis(i,n??t.length))}static sortBasedOnPerm(t,n){return n?n.map(i=>t[i]):t.slice().reverse()}static padShape(t,n){let i=t.length;return t.map((r,s)=>r+n[s]+n[s+i])}static areEqual(t,n){return t.length!==n.length?!1:t.every((i,r)=>i===n[r])}},Tg=class Rf{static adjustPoolAttributes(t,n,i,r,s,a){if(!t&&i.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let o=0;o<n.length-2;o++)o>=i.length?i.push(n[o+2]):i[o]=n[o+2];for(let o=0;o<i.length;o++)if(o<r.length){if(r[o]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let o=0;o<i.length;o++)if(o<s.length){if(s[o]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let o=0;o<i.length*2;o++)if(o<a.length){if(a[o]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let o=0;o<i.length;o++){if(i[o]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[o]>=i[o]||a[o+i.length]>=i[o])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,i,r,s,a,o){if(o){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<t.length-2;l++)Rf.adjustPadAndReturnShape(t[l+(a?1:2)],n[l],i[l],r[l],s,l,l+t.length-2,o)}}static computePoolOutputShape(t,n,i,r,s,a,o){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let l=[n[0],n[1]];return Rf.computeShapeHelper(t,n,l,i,r,s,a,o),l}static computeConvOutputShape(t,n,i,r,s,a,o){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[t[0],n[0]];return Rf.computeShapeHelper(!1,t,l,i,r,s,a,o),l}static computeShapeHelper(t,n,i,r,s,a,o,l){if(t)for(let u=0;u<n.length-2;u++)i.push(1);else for(let u=0;u<n.length-2;u++)i.push(Rf.adjustPadAndReturnShape(n[u+2],r[u],s[u],a[u],o,u,u+n.length-2,l))}static adjustPadAndReturnShape(t,n,i,r,s,a,o,l){let u=i*(r-1)+1;if(l&&l!=="NOTSET")switch(l){case"VALID":return s[a]=0,s[o]=0,Math.floor((t-u)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(i!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let c=((t+n-1)/n-1)*n+r-t;return s[a]=Math.floor(l==="SAME_LOWER"?(c+1)/2:c/2),s[o]=c-s[a],Math.floor((t+c-r)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[a]+s[o]-u)/n+1)}},J8=class{static getShapeOfGemmResult(e,t,n,i,r){if(e.length!==2||n.length!==2)throw new Error("shape need to be of size 2");let s,a,o;t?(s=e[1],a=e[0]):(s=e[0],a=e[1]);let l=-1;if(i?(o=n[0],l=1):(o=n[1],l=0),n[l]!==a)throw new Error("dimension mismatch");if(s<=0||o<=0||a<=0)throw new Error("invalid shape specified");if(r&&!Cd.isValidBroadcast(r,[s,o]))throw new Error("gemm: invalid bias shape for broadcast");return[s,o,a]}},Y8=-34028234663852886e22,X8=34028234663852886e22}),PT,Q8=ft(()=>{Qt(),PT=(e,t)=>new(a_(t))(e)}),Ov,u1,Rv,QO,Nv,ZO,Lv,zv,Fv,eR,Z8,Gre=ft(()=>{Qt(),Go(),Ov=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),u1=(e,t)=>{if(t==="int32")return e;let n=Ov.get(t);if(!n)throw new Error(`WebNN backend does not support data type: ${t}`);let i=n/8;if(e.byteLength%i!==0)throw new Error(`Invalid Uint8Array length - must be a multiple of ${i}.`);let r=e.byteLength/i,s=new(a_(t))(e.buffer,e.byteOffset,r);switch(t){case"int64":case"uint64":{let a=new Int32Array(r);for(let o=0;o<r;o++){let l=s[o];if(l>2147483647n||l<-2147483648n)throw new Error("Can not convert int64 data to int32 - value out of range.");a[o]=Number(l)}return new Uint8Array(a.buffer)}case"int8":case"uint8":case"uint32":{if(t==="uint32"&&s.some(o=>o>2147483647))throw new Error("Can not convert uint32 data to int32 - value out of range.");let a=Int32Array.from(s,Number);return new Uint8Array(a.buffer)}default:throw new Error(`Unsupported data conversion from ${t} to 'int32'`)}},Rv=(e,t)=>{if(t==="int32")return e;if(e.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");let n=e.byteLength/4,i=new Int32Array(e.buffer,e.byteOffset,n);switch(t){case"int64":{let r=BigInt64Array.from(i,BigInt);return new Uint8Array(r.buffer)}case"uint64":{if(i.some(s=>s<0))throw new Error("Can not convert int32 data to uin64 - negative value found.");let r=BigUint64Array.from(i,BigInt);return new Uint8Array(r.buffer)}case"int8":{if(i.some(s=>s<-128||s>127))throw new Error("Can not convert int32 data to int8 - value out of range.");let r=Int8Array.from(i,Number);return new Uint8Array(r.buffer)}case"uint8":{if(i.some(r=>r<0||r>255))throw new Error("Can not convert int32 data to uint8 - value out of range.");return Uint8Array.from(i,Number)}case"uint32":{if(i.some(s=>s<0))throw new Error("Can not convert int32 data to uint32 - negative value found.");let r=Uint32Array.from(i,Number);return new Uint8Array(r.buffer)}default:throw new Error(`Unsupported data conversion from 'int32' to ${t}`)}},QO=1,Nv=()=>QO++,ZO=new Map([["int8","int32"],["uint8","int32"],["uint32","int32"],["int64","int32"]]),Lv=(e,t)=>{let n=Ov.get(e);if(!n)throw new Error(`WebNN backend does not support data type: ${e}`);return t.length>0?Math.ceil(t.reduce((i,r)=>i*r)*n/8):0},zv=class{constructor(e){this.isDataConverted=!1;let{sessionId:t,context:n,tensor:i,dataType:r,shape:s,fallbackDataType:a}=e;this.sessionId=t,this.mlContext=n,this.mlTensor=i,this.dataType=r,this.tensorShape=s,this.fallbackDataType=a}get tensor(){return this.mlTensor}get type(){return this.dataType}get fallbackType(){return this.fallbackDataType}get shape(){return this.tensorShape}get byteLength(){return Lv(this.dataType,this.tensorShape)}destroy(){Ln("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){if(this.fallbackDataType){let t=await this.mlContext.readTensor(this.mlTensor),n=Rv(new Uint8Array(t),this.dataType);if(e){(e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)).set(n);return}else return n.buffer}else return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,t,n){return this.mlContext===e&&this.dataType===t&&this.tensorShape.length===n.length&&this.tensorShape.every((i,r)=>i===n[r])}setIsDataConverted(e){this.isDataConverted=e}},Fv=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,n,i){let r=this.tensorManager.getMLContext(e),s;if(!r.opSupportLimits().input.dataTypes.includes(t)){if(s=ZO.get(t),!s||!r.opSupportLimits().input.dataTypes.includes(s))throw new Error(`WebNN backend does not support data type: ${t}`);Ln("verbose",()=>`[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${t} to ${s}`)}if(this.wrapper){if(this.wrapper.canReuseTensor(r,t,n))return this.wrapper.tensor;if(i){if(this.wrapper.byteLength!==Lv(t,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let a=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,t,n,a,!0,!0,s),i&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let t=e;if(this.wrapper){if(this.wrapper.fallbackType)if(this.wrapper.fallbackType==="int32")t=u1(e,this.wrapper.type),this.wrapper.setIsDataConverted(!0);else throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);if(e.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else Ln("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(e){var t,n;if(this.activeUpload){let i=(t=this.wrapper)!=null&&t.isDataConverted?Rv(this.activeUpload,(n=this.wrapper)==null?void 0:n.type):this.activeUpload;if(e){e instanceof ArrayBuffer?new Uint8Array(e).set(i):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(i);return}else return i.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},eR=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let t=this.backend.getMLContext(e);if(!t)throw new Error("MLContext not found for session.");return t}reserveTensorId(){let e=Nv();return this.tensorTrackersById.set(e,new Fv(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,n,i,r){Ln("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${n}, shape: ${i}, copyOld: ${r}}`);let s=this.tensorTrackersById.get(t);if(!s)throw new Error("Tensor not found.");return s.ensureTensor(e,n,i,r)}upload(e,t){let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");n.upload(t)}async download(e,t){Ln("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t==null?void 0:t.byteLength}}`);let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter(t=>t.sessionId!==e)}registerTensor(e,t,n,i){let r=this.getMLContext(e),s=Nv(),a=new zv({sessionId:e,context:r,tensor:t,dataType:n,shape:i});return this.tensorTrackersById.set(s,new Fv(this,a)),this.externalTensors.add(a),s}async getCachedTensor(e,t,n,i,r,s,a){let o=this.getMLContext(e);for(let[u,c]of this.freeTensors.entries())if(c.canReuseTensor(o,t,n)){Ln("verbose",()=>`[WebNN] Reusing tensor {dataType: ${t}, ${a?`fallbackDataType: ${a},`:""} shape: ${n}`);let f=this.freeTensors.splice(u,1)[0];return f.sessionId=e,f}Ln("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, ${a?`fallbackDataType: ${a},`:""} shape: ${n}}`);let l=await o.createTensor({dataType:a??t,shape:n,dimensions:n,usage:i,writable:r,readable:s});return new zv({sessionId:e,context:o,tensor:l,dataType:t,shape:n,fallbackDataType:a})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},Z8=(...e)=>new eR(...e)}),mf,tR,ej,jre=ft(()=>{Qt(),pc(),Q8(),Gre(),Go(),mf=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),tR=(e,t)=>{if(e===t)return!0;if(e===void 0||t===void 0)return!1;let n=Object.keys(e).sort(),i=Object.keys(t).sort();return n.length===i.length&&n.every((r,s)=>r===i[s]&&e[r]===t[r])},ej=class{constructor(e){this.tensorManager=Z8(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.sessionGraphOutputs=new Map,this.temporaryGraphInputs=[],this.temporaryGraphOutputs=[],this.temporarySessionTensorIds=new Map,IT(e.logLevel,!!e.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(e){Ln("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){Ln("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let t=this.temporarySessionTensorIds.get(e);if(t){for(let n of t)Ln("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${n}}`),this.tensorManager.releaseTensorId(n);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let n=this.mlContextCache.findIndex(i=>i.gpuDevice===e);if(n!==-1)return this.mlContextCache[n].mlContext;{let i=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:i}),i}}else if(e===void 0){let n=this.mlContextCache.findIndex(i=>i.options===void 0&&i.gpuDevice===void 0);if(n!==-1)return this.mlContextCache[n].mlContext;{let i=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:i}),i}}let t=this.mlContextCache.findIndex(n=>tR(n.options,e));if(t!==-1)return this.mlContextCache[t].mlContext;{let n=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:n}),n}}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let n=this.sessionIdsByMLContext.get(t);n||(n=new Set,this.sessionIdsByMLContext.set(t,n)),n.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[]),this.temporaryGraphOutputs.length>0&&(this.sessionGraphOutputs.set(e,this.temporaryGraphOutputs),this.temporaryGraphOutputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e),this.sessionGraphOutputs.delete(e);let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(t);if(n.delete(e),n.size===0){this.sessionIdsByMLContext.delete(t);let i=this.mlContextCache.findIndex(r=>r.mlContext===t);i!==-1&&this.mlContextCache.splice(i,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){Ln("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,n,i,r){let s=mf.get(n);if(!s)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,t,s,i,r)}async createTemporaryTensor(e,t,n){Ln("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${t}, shape: ${n}}`);let i=mf.get(t);if(!i)throw new Error(`Unsupported ONNX data type: ${t}`);let r=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,r,i,n,!1);let s=this.temporarySessionTensorIds.get(e);return s?s.push(r):this.temporarySessionTensorIds.set(e,[r]),r}uploadTensor(e,t){if(!gi().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");Ln("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let n=await this.tensorManager.download(e);return PT(n,t)}}registerMLTensor(e,t,n,i){let r=mf.get(n);if(!r)throw new Error(`Unsupported ONNX data type: ${n}`);let s=this.tensorManager.registerTensor(e,t,r,i);return Ln("verbose",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${r}, dimensions: ${i}} -> {tensorId: ${s}}`),s}registerMLConstant(e,t,n,i,r,s,a=!1){if(!s)throw new Error("External mounted files are not available.");let o=e;e.startsWith("./")&&(o=e.substring(2));let l=s.get(o);if(!l)throw new Error(`File with name ${o} not found in preloaded files.`);if(t+n>l.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let u=l.slice(t,t+n).buffer,c;switch(r.dataType){case"float32":c=new Float32Array(u);break;case"float16":c=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(u):new Uint16Array(u);break;case"int32":c=new Int32Array(u);break;case"uint32":c=new Uint32Array(u);break;case"int64":if(a){let f=u1(new Uint8Array(u),"int64");c=new Int32Array(f.buffer),r.dataType="int32"}else c=new BigInt64Array(u);break;case"uint64":c=new BigUint64Array(u);break;case"int8":c=new Int8Array(u);break;case"int4":case"uint4":case"uint8":c=new Uint8Array(u);break;default:throw new Error(`Unsupported data type: ${r.dataType} in creating WebNN Constant from external data.`)}return Ln("verbose",()=>`[WebNN] registerMLConstant {dataType: ${r.dataType}, shape: ${r.shape}}} ${a?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),i.constant(r,c)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}registerGraphOutput(e){this.temporaryGraphOutputs.push(e)}isGraphInput(e,t){let n=this.sessionGraphInputs.get(e);return n?n.includes(t):!1}isGraphOutput(e,t){let n=this.sessionGraphOutputs.get(e);return n?n.includes(t):!1}isGraphInputOutputTypeSupported(e,t,n=!0){let i=this.mlContextBySessionId.get(e),r=mf.get(Du(t));return typeof r>"u"?!1:n?!!(i!=null&&i.opSupportLimits().input.dataTypes.includes(r)):!!(i!=null&&i.opSupportLimits().output.dataTypes.includes(r))}flush(){}}}),kT=ft(()=>{}),Bv,Hh,qh,nR,iR,Uv,c1,rR,tj,Wre=ft(()=>{Go(),kT(),Bv=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Hh=[],qh=e=>Math.ceil(Number(e)/16)*16,nR=e=>{for(let t=0;t<Hh.length;t++){let n=Hh[t];if(e<=n)return n}return Math.ceil(e/16)*16},iR=1,Uv=()=>iR++,c1=async(e,t,n,i)=>{let r=qh(n),s=e.device.createBuffer({size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,s,0,r),e.flush(),await s.mapAsync(GPUMapMode.READ);let o=s.getMappedRange();if(i){let l=i();return l.set(new Uint8Array(o,0,n)),l}else return new Uint8Array(o.slice(0,n))}finally{s.destroy()}},rR=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[t]of Bv)Hh.push(t),this.freeBuffers.set(t,[]),this.freeUniformBuffers.set(t,[]);this.sessionCount=0}upload(e,t){let n=t.buffer,i=t.byteOffset,r=t.byteLength,s=qh(r),a=this.storageCache.get(e);if(!a)throw new Error("gpu data for uploading does not exist");if(Number(a.originalSize)!==r)throw new Error(`inconsistent data size. gpu data size=${a.originalSize}, data size=${r}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=o.getMappedRange();new Uint8Array(l).set(new Uint8Array(n,i,r)),o.unmap();let u=this.backend.device.createCommandEncoder();u.copyBufferToBuffer(o,0,a.gpuData.buffer,0,s),this.backend.device.queue.submit([u.finish()]),o.destroy(),Ln("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`)}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(t);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let r=qh(n.originalSize),s=this.backend.getCommandEncoder();this.backend.endComputePass(),s.copyBufferToBuffer(n.gpuData.buffer,0,i.gpuData.buffer,0,r)}registerExternalBuffer(e,t,n){let i;if(n){if(i=n[0],e===n[1])return Ln("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${i}, buffer is the same, skip.`),i;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else i=Uv();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:e},originalSize:t}),Ln("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${i}, registered.`),i}unregisterExternalBuffer(e){e!==void 0&&(this.storageCache.delete(e),Ln("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=nR(e),i,r=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,s=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(r||s){let o=(r?this.freeBuffers:this.freeUniformBuffers).get(n);o?o.length>0?i=o.pop():i=this.backend.device.createBuffer({size:n,usage:t}):i=this.backend.device.createBuffer({size:n,usage:t})}else i=this.backend.device.createBuffer({size:n,usage:t});let a={id:Uv(),type:0,buffer:i};return this.storageCache.set(a.id,{gpuData:a,originalSize:Number(e)}),Ln("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${a.id}`),a}get(e){var t;return(t=this.storageCache.get(e))==null?void 0:t.gpuData}release(e){let t=typeof e=="bigint"?Number(e):e,n=this.storageCache.get(t);if(!n){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return Ln("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,t){let n=this.storageCache.get(Number(e));if(!n)throw new Error("data does not exist");await c1(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let e of this.buffersPending){let t=Bv.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(e.size)||[];t===void 0||n.length>=t?e.destroy():n.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(e.size)||[];t===void 0||n.length>=t?e.destroy():n.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,this.sessionCount===0&&(Ln("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.storageCache=new Map)}},tj=(...e)=>new rR(...e)}),sR,Zn,Vi=ft(()=>{sR=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},Zn=e=>new sR(e)}),$d,Kh,mr,Lr,Ut,Fi,d1,rd,Wl,zt,gf,Ze,Rt,nj,DT,aR,ij,dn=ft(()=>{Qt(),un(),$d=64,Kh=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},mr=(e,t=1)=>{let n=Kh(e,t);return typeof n=="string"?n:n[0]},Lr=(e,t=1)=>{let n=Kh(e,t);return typeof n=="string"?n:n[1]},Ut=(...e)=>{let t=[];return e.forEach(n=>{n.length!==0&&t.push({type:12,data:n},{type:12,data:qe.computeStrides(n)})}),t},Fi=e=>e%4===0?4:e%2===0?2:1,d1=(e="f32",t,n="0")=>!t||t===1?`${e}(${n})`:`vec${t}<${e}>(${n})`,rd=(e,t,n)=>e==="f32"?n:t===1?`f32(${n})`:`vec${t}<f32>(${n})`,Wl=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,zt=(e,t,n,i)=>e.startsWith("uniforms.")&&n>4?typeof t=="string"?i==="f16"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:i==="f16"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,gf=(e,t,n,i,r)=>{let s=typeof n=="number",a=s?n:n.length,o=[...new Array(a).keys()],l=a<2?"u32":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,u=Kh(t,r),c=typeof u=="string"?u:u[1],f=typeof u=="string"?u:u[0],d={indices:l,value:c,storage:f,tensor:t},h=Q=>typeof Q=="string"?Q:`${Q}u`,m={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},y=s?"uniforms.":"",M=`${y}${e}_shape`,g=`${y}${e}_strides`,_="";for(let Q=0;Q<a-1;Q++)_+=`
    let dim${Q} = current / ${zt(g,Q,a)};
    let rest${Q} = current % ${zt(g,Q,a)};
    indices[${Q}] = dim${Q};
    current = rest${Q};
    `;_+=`indices[${a-1}] = current;`;let T=a<2?"":`
  fn o2i_${e}(offset: u32) -> ${d.indices} {
    var indices: ${d.indices};
    var current = offset;
    ${_}
    return indices;
  }`,x=Q=>(m.offsetToIndices=!0,a<2?Q:`o2i_${e}(${Q})`),S=[];if(a>=2)for(let Q=a-1;Q>=0;Q--)S.push(`${zt(g,Q,a)} * (indices[${Q}])`);let $=a<2?"":`
  fn i2o_${e}(indices: ${d.indices}) -> u32 {
    return ${S.join("+")};
  }`,C=Q=>(m.indicesToOffset=!0,a<2?Q:`i2o_${e}(${Q})`),P=(...Q)=>a===0?"0u":`${d.indices}(${Q.map(h).join(",")})`,O=(Q,H)=>a<2?`${Q}`:`${zt(Q,H,a)}`,R=(Q,H,B)=>a<2?`${Q}=${B};`:`${zt(Q,H,a)}=${B};`,G={},W=(Q,H)=>{m.broadcastedIndicesToOffset=!0;let B=`${H.name}broadcastedIndicesTo${e}Offset`;if(B in G)return`${B}(${Q})`;let ee=[];for(let _e=a-1;_e>=0;_e--){let le=H.indicesGet("outputIndices",_e+H.rank-a);ee.push(`${O(g,_e)} * (${le} % ${O(M,_e)})`)}return G[B]=`fn ${B}(outputIndices: ${H.type.indices}) -> u32 {
             return ${ee.length>0?ee.join("+"):"0u"};
           }`,`${B}(${Q})`},V=(Q,H)=>(()=>{if(d.storage===d.value)return`${e}[${Q}]=${H};`;if(d.storage==="vec2<u32>"&&d.value==="i32")return`${e}[${Q}]=vec2<u32>(u32(${H}), select(0u, 0xFFFFFFFFu, ${H} < 0));`;if(d.storage==="vec2<u32>"&&d.value==="u32")return`${e}[${Q}]=vec2<u32>(u32(${H}), 0u);`;if(d.storage==="u32"&&d.value==="vec4<bool>")return`${e}[${Q}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${H}));`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),te=Q=>(()=>{if(d.storage===d.value)return`${e}[${Q}]`;if(d.storage==="vec2<u32>"&&d.value==="i32")return`i32(${e}[${Q}].x)`;if(d.storage==="vec2<u32>"&&d.value==="u32")return`u32(${e}[${Q}].x)`;if(d.storage==="u32"&&d.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${Q}] & 0xFFu), bool(${e}[${Q}] & 0xFF00u), bool(${e}[${Q}] & 0xFF0000u), bool(${e}[${Q}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),J=a<2?"":`
  fn get_${e}ByIndices(indices: ${d.indices}) -> ${c} {
    return ${te(`i2o_${e}(indices)`)};
  }`,j=a<2?"":(()=>{let Q=o.map(B=>`d${B}: u32`).join(", "),H=o.map(B=>`d${B}`).join(", ");return`
  fn get_${e}(${Q}) -> ${c} {
    return get_${e}ByIndices(${P(H)});
  }`})(),Y=(...Q)=>{if(Q.length!==a)throw new Error(`indices length must be ${a}`);let H=Q.map(h).join(",");return a===0?te("0u"):a===1?te(H[0]):(m.get=!0,m.getByIndices=!0,m.indicesToOffset=!0,`get_${e}(${H})`)},X=Q=>a<2?te(Q):(m.getByIndices=!0,m.indicesToOffset=!0,`get_${e}ByIndices(${Q})`),ce=a<2?"":`
  fn set_${e}ByIndices(indices: ${d.indices}, value: ${c}) {
    ${V(`i2o_${e}(indices)`,"value")}
  }`,me=a<2?"":(()=>{let Q=o.map(B=>`d${B}: u32`).join(", "),H=o.map(B=>`d${B}`).join(", ");return`
  fn set_${e}(${Q}, value: ${c}) {
    set_${e}ByIndices(${P(H)}, value);
  }`})();return{impl:()=>{let Q=[],H=!1;return m.offsetToIndices&&(Q.push(T),H=!0),m.indicesToOffset&&(Q.push($),H=!0),m.broadcastedIndicesToOffset&&(Object.values(G).forEach(B=>Q.push(B)),H=!0),m.set&&(Q.push(me),H=!0),m.setByIndices&&(Q.push(ce),H=!0),m.get&&(Q.push(j),H=!0),m.getByIndices&&(Q.push(J),H=!0),!s&&H&&Q.unshift(`const ${M} = ${d.indices}(${n.join(",")});`,`const ${g} = ${d.indices}(${qe.computeStrides(n).join(",")});`),Q.join(`
`)},type:d,offsetToIndices:x,indicesToOffset:C,broadcastedIndicesToOffset:W,indices:P,indicesGet:O,indicesSet:R,set:(...Q)=>{if(Q.length!==a+1)throw new Error(`indices length must be ${a}`);let H=Q[a];if(typeof H!="string")throw new Error("value must be string");let B=Q.slice(0,a).map(h).join(",");return a===0?V("0u",H):a===1?V(B[0],H):(m.set=!0,m.setByIndices=!0,m.indicesToOffset=!0,`set_${e}(${B}, ${H})`)},setByOffset:V,setByIndices:(Q,H)=>a<2?V(Q,H):(m.setByIndices=!0,m.indicesToOffset=!0,`set_${e}ByIndices(${Q}, ${H});`),get:Y,getByOffset:te,getByIndices:X,usage:i,name:e,strides:g,shape:M,rank:a}},Ze=(e,t,n,i=1)=>gf(e,t,n,"input",i),Rt=(e,t,n,i=1)=>gf(e,t,n,"output",i),nj=(e,t,n)=>gf(e,t,n,"atomicOutput",1),DT=(e,t,n,i=1)=>gf(e,t,n,"internal",i),aR=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${typeof e=="number"?`${e}u`:e}) { return; }`}mainStart(e=$d){let t=typeof e=="number"?e:e[0],n=typeof e=="number"?1:e[1],i=typeof e=="number"?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||i>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${n}, ${i}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*n*i>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${n}, ${i}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let r=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,s=r?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,a=r?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${t*n*i}u + local_idx;`;return`@compute @workgroup_size(${t}, ${n}, ${i})
  fn main(${s}) {
    ${a}
  `}appendVariableUniforms(e){e.rank!==0&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if(e.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n=e.usage==="input"?"read":"read_write",i=e.usage==="atomicOutput"?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${i}>;`}declareVariables(...e){return e.map(t=>this.declareVariable(t,this.variableIndex++)).join(`
`)}registerInternalVariable(e){if(e.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach(t=>this.registerInternalVariable(t)),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let e=[];for(let{name:t,type:n,length:i}of this.uniforms)if(i&&i>4)n==="f16"?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(i/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(i/4)}>`);else{let r=i==null||i===1?n:`vec${i}<${n}>`;e.push(`${t}:${r}`)}return`
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(e=>e.impl()).join(`
`)+this.internalVariables.map(e=>e.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let e=t=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(t)];return this.uniforms.map(t=>[e(t.type),t.length??1])}},ij=(e,t)=>new aR(e,t)}),oR,Vv,lR,uR,cR,dR,Es,rj,sj,Yl=ft(()=>{Qt(),un(),Vi(),dn(),oR=(e,t)=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(t.length!==0&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},Vv=(e,t)=>t.length!==0?t:[...new Array(e).keys()].reverse(),lR=(e,t)=>qe.sortBasedOnPerm(e,Vv(e.length,t)),uR=(e,t,n,i)=>{let r=`fn perm(i: ${i.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`;for(let s=0;s<t;++s)r+=`a[${e[s]}]=i[${s}];`;return r+="return a;}"},cR=(e,t)=>{let n=[],i=[];for(let r=0;r<e.length;++r)e[r]!==1&&n.push(e[r]),e[t[r]]!==1&&i.push(t[r]);return{newShape:n,newPerm:i}},dR=(e,t)=>{let n=0;for(let i=0;i<e.length;++i)if(t[e[i]]!==1){if(e[i]<n)return!1;n=e[i]}return!0},Es=(e,t)=>{let n=e.dataType,i=e.dims.length,r=Vv(i,t),s=lR(e.dims,r),a=e.dims,o=s,l=i<2||dR(r,e.dims),u;if(l)return u=m=>{let y=Ze("input",n,a,4),M=Rt("output",n,o,4);return`
  ${m.registerUniform("output_size","u32").declareVariables(y,M)}
  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let m=qe.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(m/64/4)},programUniforms:[{type:12,data:Math.ceil(m/4)}]}},getShaderSource:u};let{newShape:c,newPerm:f}=cR(e.dims,r),d=qe.areEqual(f,[2,3,1]),h=qe.areEqual(f,[3,1,2]);if(c.length===2||d||h){a=d?[c[0],c[1]*c[2]]:h?[c[0]*c[1],c[2]]:c,o=[a[1],a[0]];let m=16;return u=y=>{let M=Ze("a",n,a.length),g=Rt("output",n,o.length);return`
  ${y.registerUniform("output_size","u32").declareVariables(M,g)}
  var<workgroup> tile : array<array<${g.type.value}, ${m+1}>, ${m}>;
  ${y.mainStart([m,m,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${m} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${m}u + local_id.x;
    let input_row = workgroup_id_x * ${m}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${M.getByIndices(`${M.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${m}u + local_id.x;
    let output_row = workgroup_id_y * ${m}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${g.setByIndices(`${g.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let y=qe.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(o[1]/m),y:Math.ceil(o[0]/m)},programUniforms:[{type:12,data:y},...Ut(a,o)]}},getShaderSource:u}}return u=m=>{let y=Ze("a",n,a.length),M=Rt("output",n,o.length);return`
  ${m.registerUniform("output_size","u32").declareVariables(y,M)}

  ${uR(r,i,y,M)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${M.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${M.setByOffset("global_idx",y.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let m=qe.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},...Ut(a,o)]}},getShaderSource:u}},rj=(e,t)=>{oR(e.inputs,t.perm),e.compute(Es(e.inputs[0],t.perm))},sj=e=>Zn({perm:e.perm})}),fR,pR,hR,mR,gR,_R,yR,vR,wR,bR,ga,aj,oj,lj,uj,cj,dj,fj,pj,hj,mj,Hre=ft(()=>{Qt(),un(),dn(),OT(),Yl(),fR={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},pR={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},hR={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},mR={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},gR=(e,t)=>{let n=[];for(let i=t-e;i<t;++i)n.push(i);return n},_R=(e,t)=>{let n=[],i=e.length;for(let s=0;s<i;s++)t.indexOf(s)===-1&&n.push(e[s]);let r=t.map(s=>e[s]);return[n,r]},yR=(e,t)=>{let n=e.length+t.length,i=[],r=0;for(let s=0;s<n;s++)t.indexOf(s)===-1?i.push(e[r++]):i.push(1);return i},vR=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},wR=(e,t)=>{let n=[];if(!vR(e,t)){for(let i=0;i<t;++i)e.indexOf(i)===-1&&n.push(i);e.forEach(i=>n.push(i))}return n},bR=(e,t,n,i,r,s,a)=>{let o=n[0].dims,l=qe.size(s),u=qe.size(a),c=Ze("_A",n[0].dataType,o),f=Rt("output",r,s),d=64;l===1&&(d=256);let h=`
          var<workgroup> aBestValues : array<f32, ${d}>;
       `,m=y=>`
        ${y.registerUniform("reduceSize","u32").declareVariables(c,f)}
        ${h}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${y.mainStart(d)}

          let outputIndex = global_idx / ${d};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${hR[i]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${d}) {
           let candidate = f32(${c.getByOffset("offset + k")});
           bestValue = ${fR[i]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${d}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${pR[i]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${f.setByOffset("outputIndex",`${i==="mean"?`${f.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${f.type.storage}(${mR[i]})`}`)};
         }
        }`;return{name:e,shaderCache:{hint:`${t};${d}`,inputDependencies:["type"]},getShaderSource:m,getRunData:()=>({outputs:[{dims:s,dataType:r}],dispatchGroup:{x:l},programUniforms:[{type:12,data:u}]})}},ga=(e,t,n,i)=>{let r=e.inputs.length===1?n:f1(e.inputs,n),s=r.axes;s.length===0&&!r.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((h,m)=>m));let a=qe.normalizeAxes(s,e.inputs[0].dims.length),o=a,l=e.inputs[0],u=wR(o,e.inputs[0].dims.length);u.length>0&&(l=e.compute(Es(e.inputs[0],u),{inputs:[0],outputs:[-1]})[0],o=gR(o.length,l.dims.length));let[c,f]=_R(l.dims,o),d=c;r.keepDims&&(d=yR(c,a)),e.compute(bR(t,r.cacheKey,[l],i,e.inputs[0].dataType,d,f),{inputs:[l]})},aj=(e,t)=>{ga(e,"ReduceMeanShared",t,"mean")},oj=(e,t)=>{ga(e,"ReduceL1Shared",t,"l1")},lj=(e,t)=>{ga(e,"ReduceL2Shared",t,"l2")},uj=(e,t)=>{ga(e,"ReduceLogSumExpShared",t,"logSumExp")},cj=(e,t)=>{ga(e,"ReduceMaxShared",t,"max")},dj=(e,t)=>{ga(e,"ReduceMinShared",t,"min")},fj=(e,t)=>{ga(e,"ReduceProdShared",t,"prod")},pj=(e,t)=>{ga(e,"ReduceSumShared",t,"sum")},hj=(e,t)=>{ga(e,"ReduceSumSquareShared",t,"sumSquare")},mj=(e,t)=>{ga(e,"ReduceLogSumShared",t,"logSum")}}),_a,xR,Mg,f1,ya,TR,MR,ER,SR,CR,$R,AR,IR,PR,kR,va,gj,_j,yj,vj,wj,bj,xj,Tj,Mj,Ej,OT=ft(()=>{Qt(),un(),Vi(),dn(),Hre(),_a=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},xR=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Mg=(e,t,n,i,r,s,a=!1,o=!1)=>{let l=[],u=n[0].dims,c=u.length,f=qe.normalizeAxes(r,c),d=!o&&f.length===0;u.forEach((y,M)=>{d||f.indexOf(M)>=0?a&&l.push(1):l.push(y)});let h=l.length,m=qe.size(l);return{name:e,shaderCache:t,getShaderSource:y=>{let M=[],g=Ze("_A",n[0].dataType,c),_=Rt("output",s,h),T=i(g,_,f),x=T[2];for(let S=0,$=0;S<c;S++)d||f.indexOf(S)>=0?(a&&$++,x=`for(var j${S}: u32 = 0; j${S} < ${u[S]}; j${S}++) {
                  ${T[2].includes("last_index")?`let last_index = j${S};`:""}
                  ${g.indicesSet("input_indices",S,`j${S}`)}
                  ${x}
                }`):(M.push(`${g.indicesSet("input_indices",S,_.indicesGet("output_indices",$))};`),$++);return`

        ${y.registerUniform("output_size","u32").declareVariables(g,_)}

        ${y.mainStart()}
          ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${g.type.indices};
          let output_indices = ${_.offsetToIndices("global_idx")};

          ${M.join(`
`)}
          ${T[0]}       // init ops for reduce max/min
          ${T[1]}
          ${x}
          ${T[3]}
          ${T.length===4?_.setByOffset("global_idx","value"):T.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:l,dataType:s}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},...Ut(u,l)]})}},f1=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(i=>n.push(Number(i))),Zn({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},ya=(e,t,n,i)=>{let r=e.inputs,s=r.length===1?n:f1(r,n);e.compute(Mg(t,{hint:s.cacheKey,inputDependencies:["rank"]},[r[0]],s.noopWithEmptyAxes&&s.axes.length===0?xR:i,s.axes,r[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},TR=(e,t)=>{_a(e.inputs),ya(e,"ReduceLogSum",t,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,"value = log(value);"])},MR=(e,t)=>{_a(e.inputs),ya(e,"ReduceL1",t,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += abs(${n.getByIndices("input_indices")});`,""])},ER=(e,t)=>{_a(e.inputs),ya(e,"ReduceL2",t,(n,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},SR=(e,t)=>{_a(e.inputs),ya(e,"ReduceLogSumExp",t,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += exp(${n.getByIndices("input_indices")});`,"value = log(value);"])},CR=(e,t)=>{_a(e.inputs),ya(e,"ReduceMax",t,(n,i,r)=>{let s=[];for(let a=0;a<n.rank;a++)(r.indexOf(a)>=0||r.length===0)&&s.push(n.indicesSet("input_indices",a,0));return[`${s.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = max(value, ${n.getByIndices("input_indices")});`,""]})},$R=(e,t)=>{_a(e.inputs),ya(e,"ReduceMean",t,(n,i,r)=>{let s=1;for(let a=0;a<n.rank;a++)(r.indexOf(a)>=0||r.length===0)&&(s*=e.inputs[0].dims[a]);return["var sum = f32(0);","",`sum += f32(${n.getByIndices("input_indices")});`,`let value = ${i.type.value}(sum / ${s});`]})},AR=(e,t)=>{_a(e.inputs),ya(e,"ReduceMin",t,(n,i,r)=>{let s=[];for(let a=0;a<n.rank;a++)(r.indexOf(a)>=0||r.length===0)&&s.push(`input_indices[${a}] = 0;`);return[`${s.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = min(value, ${n.getByIndices("input_indices")});`,""]})},IR=(e,t)=>{_a(e.inputs),ya(e,"ReduceProd",t,(n,i)=>[`var value = ${i.type.storage}(1);`,"",`value *= ${n.getByIndices("input_indices")};`,""])},PR=(e,t)=>{_a(e.inputs),ya(e,"ReduceSum",t,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,""])},kR=(e,t)=>{_a(e.inputs),ya(e,"ReduceSumSquare",t,(n,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += t * t;`,""])},va=(e,t,n)=>{if(t.length===0)return n;let i=1,r=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?i*=e[s]:r*=e[s];return r<32&&i>1024},gj=(e,t)=>{va(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?$R(e,t):aj(e,t)},_j=(e,t)=>{va(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?MR(e,t):oj(e,t)},yj=(e,t)=>{va(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ER(e,t):lj(e,t)},vj=(e,t)=>{va(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?SR(e,t):uj(e,t)},wj=(e,t)=>{va(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?CR(e,t):cj(e,t)},bj=(e,t)=>{va(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?AR(e,t):dj(e,t)},xj=(e,t)=>{va(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?IR(e,t):fj(e,t)},Tj=(e,t)=>{va(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?PR(e,t):pj(e,t)},Mj=(e,t)=>{va(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?kR(e,t):hj(e,t)},Ej=(e,t)=>{va(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?TR(e,t):mj(e,t)}}),Gv,Sj,Cj,p1,qre=ft(()=>{Qt(),Vi(),OT(),Gv=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Sj=(e,t)=>{Gv(e.inputs);let n=(i,r,s)=>{let a=[];for(let o=0;o<i.rank;o++)(s.indexOf(o)>=0||s.length===0)&&a.push(`input_indices[${o}] = 0;`);return[`${a.join(`
`)}`,`var value = ${i.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${i.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${i.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",r.setByOffset("global_idx","best_index")]};e.compute(Mg("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},Cj=(e,t)=>{Gv(e.inputs);let n=(i,r,s)=>{let a=[];for(let o=0;o<i.rank;o++)(s.indexOf(o)>=0||s.length===0)&&a.push(`input_indices[${o}] = 0;`);return[`${a.join(`
`)}`,`var value = ${i.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${i.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${i.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",r.setByOffset("global_idx","best_index")]};e.compute(Mg("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},p1=e=>Zn(e)}),DR,Jh,OR,RR,NR,bp,LR,$j,RT=ft(()=>{Qt(),un(),kT(),dn(),DR=(e,t)=>{let n=e[0],i=e[1],r=e[2],s=e[3],a=e[4],o=e[5];if(a&&o)throw new Error("Attention cannot have both past and attention_bias");if(n.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let l=n.dims[0],u=n.dims[1],c=n.dims[2];if(r.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(i.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(i.dims[0]!==c)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(r.dims[0]!==i.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let f=r.dims[0]/3,d=f,h=d;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let T of t.qkvHiddenSizes)if(T%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");f=t.qkvHiddenSizes[0],d=t.qkvHiddenSizes[1],h=t.qkvHiddenSizes[2]}let m=u;if(f!==d)throw new Error("qkv_hidden_sizes first element should be same as the second");if(r.dims[0]!==f+d+h)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let y=0;if(a){if(d!==h)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(a.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(a.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(a.dims[1]!==l)throw new Error('Input "past" second dimension must be batch_size');if(a.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(a.dims[4]!==d/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(y=a.dims[3])}let M=m+y,g=-1,_=0;if(s)throw new Error("Mask not supported");if(a)throw new Error("past is not supported");if(o){if(o.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(o.dims[0]!==l||o.dims[1]!==t.numHeads||o.dims[2]!==u||o.dims[3]!==M)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:u,pastSequenceLength:y,kvSequenceLength:m,totalSequenceLength:M,maxSequenceLength:g,inputHiddenSize:c,hiddenSize:f,vHiddenSize:h,headSize:Math.floor(f/t.numHeads),vHeadSize:Math.floor(h/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:_,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Jh=(e,t,n)=>t&&e?`
      let total_sequence_length_input = u32(${t.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${e==null?void 0:e.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,OR=(e,t,n,i,r,s,a,o)=>{let l=Fi(a?1:s),u=64,c=s/l;c<u&&(u=32);let f=Math.ceil(s/l/u),d=[{type:12,data:t},{type:12,data:n},{type:12,data:i},{type:12,data:r},{type:12,data:c},{type:12,data:f}],h=mr(e.dataType,l),m=Lr(1,l),y=["type"];a&&y.push("type"),o&&y.push("type");let M=g=>{let _=Rt("x",e.dataType,e.dims,l),T=[_],x=a?Ze("seq_lens",a.dataType,a.dims):void 0;x&&T.push(x);let S=o?Ze("total_sequence_length_input",o.dataType,o.dims):void 0;S&&T.push(S);let $=Lr(e.dataType),C=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${u}>;
  var<workgroup> thread_sum: array<f32, ${u}>;
  ${g.registerUniforms(C).declareVariables(...T)}
  ${g.mainStart([u,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${Jh(x,S,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${u}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${a?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${m}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${m}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(l){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${u}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${m}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${m}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${u}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${_.type.value}(${$}(1.0) / ${$}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${m}(x[offset + i]);
        x[offset + i] = ${_.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${a?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${_.type.value}(${$}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${h};${l}`,inputDependencies:y},getShaderSource:M,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:r,z:t*n},programUniforms:d})}},RR=(e,t,n,i,r,s,a,o,l)=>{let u=a+s.kvSequenceLength,c=[s.batchSize,s.numHeads,s.sequenceLength,u],f=e>1&&i,d=s.kvNumHeads?s.kvNumHeads:s.numHeads,h=f?[s.batchSize,d,u,s.headSize]:void 0,m=s.nReps?s.nReps:1,y=s.scale===0?1/Math.sqrt(s.headSize):s.scale,M=Fi(s.headSize),g=s.headSize/M,_=12,T={x:Math.ceil(u/_),y:Math.ceil(s.sequenceLength/_),z:s.batchSize*s.numHeads},x=[{type:12,data:s.sequenceLength},{type:12,data:g},{type:12,data:u},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:1,data:y},{type:12,data:a},{type:12,data:s.kvSequenceLength},{type:12,data:m}],S=f&&i&&qe.size(i.dims)>0,$=["type","type"];S&&$.push("type"),r&&$.push("type"),o&&$.push("type"),l&&$.push("type");let C=[{dims:c,dataType:t.dataType,gpuDataType:0}];f&&C.push({dims:h,dataType:t.dataType,gpuDataType:0});let P=O=>{let R=Ze("q",t.dataType,t.dims,M),G=Ze("key",n.dataType,n.dims,M),W=[R,G];if(S){let ce=Ze("past_key",i.dataType,i.dims,M);W.push(ce)}r&&W.push(Ze("attention_bias",r.dataType,r.dims));let V=o?Ze("seq_lens",o.dataType,o.dims):void 0;V&&W.push(V);let te=l?Ze("total_sequence_length_input",l.dataType,l.dims):void 0;te&&W.push(te);let J=Rt("output",t.dataType,c),j=[J];f&&j.push(Rt("present_key",t.dataType,h,M));let Y=Lr(1,M),X=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${_}u;

  var<workgroup> tileQ: array<${R.type.storage}, ${_*_}>;
  var<workgroup> tileK: array<${R.type.storage}, ${_*_}>;
  ${O.registerUniforms(X).declareVariables(...W,...j)}
  ${O.mainStart([_,_,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${m===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${m===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${Jh(V,te,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${S&&f?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${f?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${Y}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${S&&f?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${f?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${Y}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(M){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${M}`)}})()};
        output[outputIdx] = ${J.type.value} (sum * uniforms.alpha) + ${r?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${M};${r!==void 0};${i!==void 0};${e}`,inputDependencies:$},getRunData:()=>({outputs:C,dispatchGroup:T,programUniforms:x}),getShaderSource:P}},NR=(e,t,n,i,r,s,a=void 0,o=void 0)=>{let l=s+r.kvSequenceLength,u=r.nReps?r.nReps:1,c=r.vHiddenSize*u,f=e>1&&i,d=r.kvNumHeads?r.kvNumHeads:r.numHeads,h=f?[r.batchSize,d,l,r.headSize]:void 0,m=[r.batchSize,r.sequenceLength,c],y=12,M={x:Math.ceil(r.vHeadSize/y),y:Math.ceil(r.sequenceLength/y),z:r.batchSize*r.numHeads},g=[{type:12,data:r.sequenceLength},{type:12,data:l},{type:12,data:r.vHeadSize},{type:12,data:r.numHeads},{type:12,data:r.headSize},{type:12,data:c},{type:12,data:s},{type:12,data:r.kvSequenceLength},{type:12,data:u}],_=f&&i&&qe.size(i.dims)>0,T=["type","type"];_&&T.push("type"),a&&T.push("type"),o&&T.push("type");let x=[{dims:m,dataType:t.dataType,gpuDataType:0}];f&&x.push({dims:h,dataType:t.dataType,gpuDataType:0});let S=$=>{let C=Ze("probs",t.dataType,t.dims),P=Ze("v",n.dataType,n.dims),O=[C,P];_&&O.push(Ze("past_value",i.dataType,i.dims));let R=a?Ze("seq_lens",a.dataType,a.dims):void 0;a&&O.push(R);let G=o?Ze("total_sequence_length_input",o.dataType,o.dims):void 0;o&&O.push(G);let W=[Rt("output",t.dataType,m)];f&&W.push(Rt("present_value",t.dataType,h));let V=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${y}u;
  var<workgroup> tileQ: array<${C.type.value}, ${y*y}>;
  var<workgroup> tileV: array<${C.type.value}, ${y*y}>;
  ${$.registerUniforms(V).declareVariables(...O,...W)}
  ${$.mainStart([y,y,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${u===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${u===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${Jh(R,G,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${_&&f?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${f?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${C.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${_&&f?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${f?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${i!==void 0};${e}`,inputDependencies:T},getRunData:()=>({outputs:x,dispatchGroup:M,programUniforms:g}),getShaderSource:S}},bp=(e,t,n,i,r,s,a,o,l,u,c=void 0,f=void 0)=>{let d=Math.min(e.outputCount,1+(a?1:0)+(o?1:0)),h=d>1?u.pastSequenceLength:0,m=h+u.kvSequenceLength,y=l&&qe.size(l.dims)>0?l:void 0,M=[t,n];d>1&&a&&qe.size(a.dims)>0&&M.push(a),y&&M.push(y),c&&M.push(c),f&&M.push(f);let g=e.compute(RR(d,t,n,a,y,u,h,c,f),{inputs:M,outputs:d>1?[-1,1]:[-1]})[0];e.compute(OR(g,u.batchSize,u.numHeads,h,u.sequenceLength,m,c,f),{inputs:c&&f?[g,c,f]:[g],outputs:[]});let _=[g,i];d>1&&o&&qe.size(o.dims)>0&&_.push(o),c&&_.push(c),f&&_.push(f),e.compute(NR(d,g,i,o,u,h,c,f),{inputs:_,outputs:d>1?[0,2]:[0]})},LR=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],i=t.sequenceLength,r=t.inputHiddenSize,s=t.headSize,a=12,o={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],u=[{type:12,data:i},{type:12,data:r},{type:12,data:s},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],c=f=>{let d=Rt("output_q",l[0].dataType,n),h=Rt("output_k",l[0].dataType,n),m=Rt("output_v",l[0].dataType,n),y=Ze("input",l[0].dataType,l[0].dims),M=Ze("weight",l[1].dataType,l[1].dims),g=Ze("bias",l[2].dataType,l[2].dims),_=y.type.storage,T=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${a}u;
  var<workgroup> tileInput: array<${_}, ${a*a}>;
  var<workgroup> tileWeightQ: array<${_}, ${a*a}>;
  var<workgroup> tileWeightK: array<${_}, ${a*a}>;
  var<workgroup> tileWeightV: array<${_}, ${a*a}>;
  ${f.registerUniforms(T).declareVariables(y,M,g,d,h,m)}
  ${f.mainStart([a,a,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${_}(0);
    var valueK = ${_}(0);
    var valueV = ${_}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:o,programUniforms:u}),getShaderSource:c},{inputs:l,outputs:[-1,-1,-1]})},$j=(e,t)=>{let n=DR(e.inputs,t),[i,r,s]=LR(e,n);return bp(e,i,r,s,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}}),zR,FR,BR,Aj,Kre=ft(()=>{na(),Qt(),un(),Vi(),dn(),zR=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let n=(i,r,s)=>{let a=r.length;if(a!==i.length)throw new Error(`${s}: num dimensions != ${a}`);r.forEach((o,l)=>{if(o!==i[l])throw new Error(`${s}: dim[${l}] do not match`)})};if(e[0].dims.length>1){let i=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,i,"Invalid input scale"),n(e[2].dims,i,"Invalid input B"),n(e[3].dims,i,"Invalid input mean"),n(e[4].dims,i,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},FR=(e,t)=>{let{epsilon:n,spatial:i,format:r}=t,s=e[0].dims,a=i?Fi(s[s.length-1]):1,o=r==="NHWC"&&s.length>1?a:1,l=qe.size(s)/a,u=i,c=u?s.length:s,f=Ze("x",e[0].dataType,e[0].dims,a),d=Ze("scale",e[1].dataType,e[1].dims,o),h=Ze("bias",e[2].dataType,e[2].dims,o),m=Ze("inputMean",e[3].dataType,e[3].dims,o),y=Ze("inputVar",e[4].dataType,e[4].dims,o),M=Rt("y",e[0].dataType,c,a),g=()=>{let T="";if(i)T=`let cOffset = ${s.length===1?"0u":r==="NHWC"?`outputIndices[${s.length-1}] / ${a}`:"outputIndices[1]"};`;else if(r==="NCHW")T=`
            ${M.indicesSet("outputIndices","0","0")}
            let cOffset = ${M.indicesToOffset("outputIndices")};`;else{T=`var cIndices = ${d.type.indices}(0);
                       cIndices[0] = outputIndices[${s.length-1}];`;for(let x=1;x<d.rank;x++)T+=`cIndices[${x}] = outputIndices[${x}];`;T+=`let cOffset = ${d.indicesToOffset("cIndices")};`}return T},_=T=>`
  const epsilon = ${n};
  ${T.registerUniform("outputSize","u32").declareVariables(f,d,h,m,y,M)}
  ${T.mainStart()}
  ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${M.offsetToIndices(`global_idx * ${a}`)};
    ${g()}
    let scale = ${d.getByOffset("cOffset")};
    let bias = ${h.getByOffset("cOffset")};
    let inputMean = ${m.getByOffset("cOffset")};
    let inputVar = ${y.getByOffset("cOffset")};
    let x = ${f.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${M.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${i}_${a}`,inputDependencies:u?["rank","type","type","type","type"]:void 0},getShaderSource:_,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u?[{type:12,data:l},...Ut(s)]:[{type:12,data:l}]})}},BR=e=>Zn(e),Aj=(e,t)=>{let{inputs:n,outputCount:i}=e,r=BR({...t,outputCount:i});if(bi.webgpu.validateInputContent&&zR(n,r),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(FR(n,r))}}),UR,VR,Ij,Jre=ft(()=>{un(),dn(),UR=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},VR=e=>{let t=e[0].dims,n=e[0].dims[2],i=qe.size(t)/4,r=e[0].dataType,s=Ze("input",r,t,4),a=Ze("bias",r,[n],4),o=Ze("residual",r,t,4),l=Rt("output",r,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:u=>`
  const channels = ${n}u / 4;
  ${u.declareVariables(s,a,o,l)}

  ${u.mainStart()}
    ${u.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let value = ${s.getByOffset("global_idx")}
      + ${a.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};
    ${l.setByOffset("global_idx","value")}
  }`}},Ij=e=>{UR(e.inputs),e.compute(VR(e.inputs))}}),GR,Jn,Pj,kj,Dj,Oj,Rj,Nj,Lj,zj,Fj,jR,Bj,Uj,Vj,Gj,Nf,jj,Am,Wj,Hj,qj,Kj,Jj,Yj,Xj,Qj,Zj,eW,tW,nW,iW,rW,sW,aW,jv,oW,h1,m1,lW,uW,cW,WR,HR,dW,NT=ft(()=>{Qt(),un(),Vi(),dn(),GR=(e,t,n,i,r,s,a)=>{let o=Math.ceil(t/4),l="";typeof r=="string"?l=`${r}(a)`:l=r("a");let u=Ze("inputData",n,[o],4),c=Rt("outputData",i,[o],4),f=[{name:"vec_size",type:"u32"}];return a&&f.push(...a),`
      ${e.registerUniforms(f).declareVariables(u,c)}

  ${s??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${u.getByOffset("global_idx")};
    ${c.setByOffset("global_idx",l)}
  }`},Jn=(e,t,n,i,r,s=e.dataType,a,o)=>{let l=[{type:12,data:Math.ceil(qe.size(e.dims)/4)}];return a&&l.push(...a),{name:t,shaderCache:{hint:r,inputDependencies:["type"]},getShaderSource:u=>GR(u,qe.size(e.dims),e.dataType,s,n,i,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(qe.size(u[0].dims)/64/4)},programUniforms:l})}},Pj=e=>{e.compute(Jn(e.inputs[0],"Abs","abs"))},kj=e=>{e.compute(Jn(e.inputs[0],"Acos","acos"))},Dj=e=>{e.compute(Jn(e.inputs[0],"Acosh","acosh"))},Oj=e=>{e.compute(Jn(e.inputs[0],"Asin","asin"))},Rj=e=>{e.compute(Jn(e.inputs[0],"Asinh","asinh"))},Nj=e=>{e.compute(Jn(e.inputs[0],"Atan","atan"))},Lj=e=>{e.compute(Jn(e.inputs[0],"Atanh","atanh"))},zj=e=>Zn(e),Fj=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Jn(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},jR=e=>{let t,n,i=e.length>=2&&e[1].data!==0,r=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:t=i?e[1].getFloat32Array()[0]:-34028234663852886e22,n=r?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=i?e[1].getUint16Array()[0]:64511,n=r?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return Zn({min:t,max:n})},Bj=(e,t)=>{let n=t||jR(e.inputs),i=Lr(e.inputs[0].dataType);e.compute(Jn(e.inputs[0],"Clip",r=>`clamp(${r}, vec4<${i}>(uniforms.min), vec4<${i}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:"min",type:i},{name:"max",type:i}]),{inputs:[0]})},Uj=e=>{e.compute(Jn(e.inputs[0],"Ceil","ceil"))},Vj=e=>{e.compute(Jn(e.inputs[0],"Cos","cos"))},Gj=e=>{e.compute(Jn(e.inputs[0],"Cosh","cosh"))},Nf=e=>Zn(e),jj=(e,t)=>{let n=Lr(e.inputs[0].dataType);e.compute(Jn(e.inputs[0],"Elu",i=>`elu_vf32(${i})`,`
  const elu_alpha_ = ${n}(${t.alpha});

  fn elu_f32(a: ${n}) -> ${n} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},Am=(e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Wj=e=>{let t=Lr(e.inputs[0].dataType);e.compute(Jn(e.inputs[0],"Erf",n=>`erf_vf32(${n})`,Am(t)))},Hj=e=>{e.compute(Jn(e.inputs[0],"Exp","exp"))},qj=e=>{e.compute(Jn(e.inputs[0],"Floor","floor"))},Kj=e=>{let t=Lr(e.inputs[0].dataType);e.compute(Jn(e.inputs[0],"Gelu",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,Am(t)))},Jj=(e,t)=>{let n=Lr(e.inputs[0].dataType);e.compute(Jn(e.inputs[0],"LeakyRelu",i=>`select(leaky_relu_alpha_ * ${i}, ${i}, ${i} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},Yj=e=>{e.compute(Jn(e.inputs[0],"Not",t=>`!${t}`))},Xj=e=>{e.compute(Jn(e.inputs[0],"Neg",t=>`-${t}`))},Qj=e=>{e.compute(Jn(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},Zj=e=>{let t=Lr(e.inputs[0].dataType);e.compute(Jn(e.inputs[0],"Relu",n=>`select(vec4<${t}>(0.0), ${n}, ${n} > vec4<${t}>(0.0))`))},eW=e=>{e.compute(Jn(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},tW=e=>Zn(e),nW=(e,t)=>{let n=Lr(e.inputs[0].dataType);e.compute(Jn(e.inputs[0],"HardSigmoid",i=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${i} + vec4<${n}>(${t.beta})))`,void 0,t.cacheKey))},iW=e=>{e.compute(Jn(e.inputs[0],"Sin","sin"))},rW=e=>{e.compute(Jn(e.inputs[0],"Sinh","sinh"))},sW=e=>{e.compute(Jn(e.inputs[0],"Sqrt","sqrt"))},aW=e=>{e.compute(Jn(e.inputs[0],"Tan","tan"))},jv=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,oW=e=>{e.compute(Jn(e.inputs[0],"Tanh",jv))},h1=(e="f32")=>`
const fast_gelu_a: ${e} = 0.5;
const fast_gelu_b: ${e} = 0.7978845608028654;
const fast_gelu_c: ${e} = 0.035677408136300125;

fn tanh_v(v: vec4<${e}>) -> vec4<${e}> {
  return ${jv("v")};
}
`,m1=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,lW=e=>{let t=Lr(e.inputs[0].dataType);e.compute(Jn(e.inputs[0],"FastGelu",m1,h1(t),void 0,e.inputs[0].dataType))},uW=(e,t)=>{let n=Lr(e.inputs[0].dataType);return e.compute(Jn(e.inputs[0],"ThresholdedRelu",i=>`select(vec4<${n}>(0.0), ${i}, ${i} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},cW=e=>{e.compute(Jn(e.inputs[0],"Log","log"))},WR=(e,t)=>`
const alpha = vec4<${e}>(${t});
const one = ${e}(1.0);
const zero = ${e}(0.0);

fn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {
  let v = x *alpha;
  var x1 : vec4<${e}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,HR=e=>`quick_gelu_impl(${e})`,dW=(e,t)=>{let n=Lr(e.inputs[0].dataType);e.compute(Jn(e.inputs[0],"QuickGelu",HR,WR(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}}),qR,KR,fW,Yre=ft(()=>{un(),dn(),NT(),qR=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},KR=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=Ze("input",e[0].dataType,e[0].dims,4),i=Ze("bias",e[0].dataType,[e[0].dims[2]],4),r=Rt("output",e[0].dataType,t,4),s=qe.size(t)/4,a=mr(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:o=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${o.declareVariables(n,i,r)}

  ${Am(a)}

  ${o.mainStart()}
    ${o.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${r.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},fW=e=>{qR(e.inputs),e.compute(KR(e.inputs))}}),JR,YR,wa,pW,hW,mW,gW,_W,yW,vW,wW,bW,xW,Xre=ft(()=>{Qt(),un(),dn(),JR=(e,t,n,i,r,s,a,o,l,u,c,f)=>{let d,h;typeof o=="string"?d=h=(_,T)=>`${o}((${_}),(${T}))`:typeof o=="function"?d=h=o:(d=o.scalar,h=o.vector);let m=Rt("outputData",c,i.length,4),y=Ze("aData",l,t.length,4),M=Ze("bData",u,n.length,4),g;if(r)if(s){let _=qe.size(t)===1,T=qe.size(n)===1,x=t.length>0&&t[t.length-1]%4===0,S=n.length>0&&n[n.length-1]%4===0;_||T?g=m.setByOffset("global_idx",h(_?`${y.type.value}(${y.getByOffset("0")}.x)`:y.getByOffset("global_idx"),T?`${M.type.value}(${M.getByOffset("0")}.x)`:M.getByOffset("global_idx"))):g=`
            let outputIndices = ${m.offsetToIndices("global_idx * 4u")};
            let offsetA = ${y.broadcastedIndicesToOffset("outputIndices",m)};
            let offsetB = ${M.broadcastedIndicesToOffset("outputIndices",m)};
            ${m.setByOffset("global_idx",h(a||x?y.getByOffset("offsetA / 4u"):`${y.type.value}(${y.getByOffset("offsetA / 4u")}[offsetA % 4u])`,a||S?M.getByOffset("offsetB / 4u"):`${M.type.value}(${M.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else g=m.setByOffset("global_idx",h(y.getByOffset("global_idx"),M.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let _=(T,x,S="")=>{let $=`aData[indexA${x}][componentA${x}]`,C=`bData[indexB${x}][componentB${x}]`;return`
            let outputIndices${x} = ${m.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offsetA${x} = ${y.broadcastedIndicesToOffset(`outputIndices${x}`,m)};
            let offsetB${x} = ${M.broadcastedIndicesToOffset(`outputIndices${x}`,m)};
            let indexA${x} = offsetA${x} / 4u;
            let indexB${x} = offsetB${x} / 4u;
            let componentA${x} = offsetA${x} % 4u;
            let componentB${x} = offsetB${x} % 4u;
            ${T}[${x}] = ${S}(${d($,C)});
          `};c===9?g=`
            var data = vec4<u32>(0);
            ${_("data",0,"u32")}
            ${_("data",1,"u32")}
            ${_("data",2,"u32")}
            ${_("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:g=`
            ${_("outputData[global_idx]",0)}
            ${_("outputData[global_idx]",1)}
            ${_("outputData[global_idx]",2)}
            ${_("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(y,M,m)}

        ${f??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${g}
      }`},YR=(e,t,n,i,r,s,a=n.dataType)=>{let o=n.dims.map(y=>Number(y)??1),l=i.dims.map(y=>Number(y)??1),u=!qe.areEqual(o,l),c=o,f=qe.size(o),d=!1,h=!1,m=[u];if(u){let y=Cd.calcShape(o,l,!1);if(!y)throw new Error("Can't perform binary op on the given tensors");c=y.slice(),f=qe.size(c);let M=qe.size(o)===1,g=qe.size(l)===1,_=o.length>0&&o[o.length-1]%4===0,T=l.length>0&&l[l.length-1]%4===0;m.push(M),m.push(g),m.push(_),m.push(T);let x=1;for(let S=1;S<c.length;S++){let $=o[o.length-S],C=l[l.length-S];if($===C)x*=$;else break}x%4===0?(h=!0,d=!0):(M||g||_||T)&&(d=!0)}else d=!0;return m.push(d),{name:e,shaderCache:{hint:t+m.map(y=>y.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:y=>JR(y,o,l,c,d,u,h,r,n.dataType,i.dataType,a,s),getRunData:()=>({outputs:[{dims:c,dataType:a}],dispatchGroup:{x:Math.ceil(f/64/4)},programUniforms:[{type:12,data:Math.ceil(qe.size(c)/4)},...Ut(o,l,c)]})}},wa=(e,t,n,i,r,s)=>{e.compute(YR(t,r??"",e.inputs[0],e.inputs[1],n,i,s))},pW=e=>{wa(e,"Add",(t,n)=>`${t}+${n}`)},hW=e=>{wa(e,"Div",(t,n)=>`${t}/${n}`)},mW=e=>{wa(e,"Equal",{scalar:(t,n)=>`u32(${t}==${n})`,vector:(t,n)=>`vec4<u32>(${t}==${n})`},void 0,void 0,9)},gW=e=>{wa(e,"Mul",(t,n)=>`${t}*${n}`)},_W=e=>{let t=Ze("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;wa(e,"Pow",{scalar:(n,i)=>`pow_custom(${n},${i})`,vector:(n,i)=>`pow_vector_custom(${n},${i})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},yW=e=>{wa(e,"Sub",(t,n)=>`${t}-${n}`)},vW=e=>{wa(e,"Greater",{scalar:(t,n)=>`u32(${t}>${n})`,vector:(t,n)=>`vec4<u32>(${t}>${n})`},void 0,void 0,9)},wW=e=>{wa(e,"Less",{scalar:(t,n)=>`u32(${t}<${n})`,vector:(t,n)=>`vec4<u32>(${t}<${n})`},void 0,void 0,9)},bW=e=>{wa(e,"GreaterOrEqual",{scalar:(t,n)=>`u32(${t}>=${n})`,vector:(t,n)=>`vec4<u32>(${t}>=${n})`},void 0,void 0,9)},xW=e=>{wa(e,"LessOrEqual",{scalar:(t,n)=>`u32(${t}<=${n})`,vector:(t,n)=>`vec4<u32>(${t}<=${n})`},void 0,void 0,9)}}),XR,QR,ZR,eN,TW,MW,Qre=ft(()=>{Qt(),un(),Vi(),dn(),XR=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let n=0,i=e[n],r=i.dataType,s=i.dims.length;e.forEach((a,o)=>{if(o!==n){if(a.dataType!==r)throw new Error("input tensors should be one type");if(a.dims.length!==s)throw new Error("input tensors should have the same shape");a.dims.forEach((l,u)=>{if(u!==t&&l!==i.dims[u])throw new Error("non concat dimensions must match")})}})},QR=(e,t)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${e}u>(${t});
    for (var i: u32 = 0u; i < ${e}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,ZR=(e,t)=>{let n=e.length,i=[];for(let r=0;r<n;++r){let s=t.setByOffset("global_idx",e[r].getByIndices("indices"));n===1?i.push(s):r===0?i.push(`if (inputIndex == ${r}u) { ${s} }`):r===n-1?i.push(`else { ${s} }`):i.push(`else if (inputIndex == ${r}) { ${s} }`)}return i.join(`
`)},eN=(e,t,n,i)=>{let r=qe.size(n),s=new Array(e.length),a=new Array(e.length),o=0,l=[],u=[],c=[{type:12,data:r}];for(let y=0;y<e.length;++y)o+=e[y].dims[t],s[y]=o,u.push(e[y].dims.length),a[y]=Ze(`input${y}`,i,u[y]),l.push("rank"),c.push({type:12,data:s[y]});for(let y=0;y<e.length;++y)c.push(...Ut(e[y].dims));c.push(...Ut(n));let f=Rt("output",i,n.length),d=f.indicesGet("indices",t),h=Array.from(Array(s.length).keys()).map(y=>`uniforms.sizeInConcatAxis${y}`).join(","),m=y=>`

  ${(()=>{y.registerUniform("outputSize","u32");for(let M=0;M<e.length;M++)y.registerUniform(`sizeInConcatAxis${M}`,"u32");return y.declareVariables(...a,f)})()}

  ${QR(s.length,h)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${f.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${d});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${s.length}u>(${h});
      ${d} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${ZR(a,f)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:i}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:c}),getShaderSource:m}},TW=(e,t)=>{let n=e.inputs,i=n[0].dims,r=qe.normalizeAxis(t.axis,i.length);XR(n,r);let s=i.slice();s[r]=n.reduce((o,l)=>o+(l.dims.length>r?l.dims[r]:0),0);let a=n.filter(o=>qe.size(o.dims)>0);e.compute(eN(a,r,s,n[0].dataType),{inputs:a})},MW=e=>Zn({axis:e.axis})}),tc,nc,ic,LT,hc=ft(()=>{Qt(),un(),tc=(e,t,n="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},nc=(e,t)=>{e.activation==="Clip"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation==="HardSigmoid"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation==="LeakyRelu"&&t.push({type:1,data:e.alpha})},ic=(e,t)=>{e.activation==="Clip"?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):e.activation==="HardSigmoid"?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):e.activation==="LeakyRelu"&&t.push({name:"alpha",type:"f32"})},LT=e=>{let t=(e==null?void 0:e.activation)||"";if(t==="HardSigmoid"){let[n,i]=(e==null?void 0:e.activation_params)||[.2,.5];return{activation:t,alpha:n,beta:i}}else if(t==="Clip"){let[n,i]=(e==null?void 0:e.activation_params)||[Y8,X8];return{activation:t,clipMax:i,clipMin:n}}else if(t==="LeakyRelu"){let[n]=(e==null?void 0:e.activation_params)||[.01];return{activation:t,alpha:n}}return{activation:t}}}),xr,EW,zT=ft(()=>{xr=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},EW=e=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      `}),SW,Zre=ft(()=>{SW=e=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));
}
`}),Zf,FT,BT=ft(()=>{Qt(),un(),dn(),hc(),Zf=(e,t,n,i,r)=>{let s=i-n;return`
      ${Array.from({length:n}).map((a,o)=>`
      if (${zt(t.shape,o,t.rank)} != 1) {
        ${t.indicesSet(e,o,zt(r,o+s,i))}
      } else {
        ${t.indicesSet(e,o,0)}
      }`).join("")}
`},FT=(e,t,n,i,r=!1,s)=>{let a=e[0].dims,o=e[1].dims,l=a[a.length-2],u=o[o.length-1],c=a[a.length-1],f=Fi(u),d=Fi(c),h=Fi(l),m=qe.size(n)/f/h,y=e.length>2,M=i?i.slice(0,-2):n.slice(0,-2),g=[qe.size(M),l,u],_=[{type:12,data:m},{type:12,data:l},{type:12,data:u},{type:12,data:c}];nc(t,_),_.push(...Ut(M,a,o)),y&&_.push(...Ut(e[2].dims)),_.push(...Ut(g));let T=x=>{let S=DT("batch_dims",e[0].dataType,M.length),$=Ze("a",e[0].dataType,a.length,d),C=Ze("b",e[1].dataType,o.length,f),P=Rt("output",e[0].dataType,g.length,f),O=mr(P.type.tensor),R=tc(t,P.type.value,O),G=[$,C],W="";if(y){let J=r?f:1;G.push(Ze("bias",e[2].dataType,e[2].dims.length,J)),W=`${r?`value += bias[col / ${J}];`:`value += ${P.type.value}(bias[row + i]);`}`}let V=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];ic(t,V);let te=()=>{let J=`var a_data: ${$.type.value};`;for(let j=0;j<d;j++)J+=`
              let b_data${j} = b[(b_offset + (k + ${j}) * uniforms.N + col) / ${f}];`;for(let j=0;j<h;j++){J+=`a_data = a[(a_offset + (row + ${j}) * uniforms.K + k) / ${d}];`;for(let Y=0;Y<d;Y++)J+=`
            values[${j}] = fma(${C.type.value}(a_data${d===1?"":`[${Y}]`}), b_data${Y}, values[${j}]);
`}return J};return`
  ${x.registerUniforms(V).registerInternalVariables(S).declareVariables(...G,P)}
  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${f})) * ${f};
    var index1 = global_idx / (uniforms.N / ${f});
    let stride1 = uniforms.M / ${h};
    let row = (index1 % stride1) * ${h};
    let batch = index1 / stride1;

    ${n.length===2?"":`let batch_indices = ${S.offsetToIndices("batch")};`}

    var a_indices: ${$.type.indices};
    ${Zf("a_indices",$,$.rank-2,S.rank,"batch_indices")}
    ${$.indicesSet("a_indices",$.rank-2,0)}
    ${$.indicesSet("a_indices",$.rank-1,0)}
    let a_offset = ${$.indicesToOffset("a_indices")};

    var b_indices: ${C.type.indices};
    ${Zf("b_indices",C,C.rank-2,S.rank,"batch_indices")}
    ${C.indicesSet("b_indices",C.rank-2,0)}
    ${C.indicesSet("b_indices",C.rank-1,0)}
    let b_offset = ${C.indicesToOffset("b_indices")};
    var values: array<${P.type.value}, ${h}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${d}) {
      ${te()}
    }
    for (var i = 0u; i < ${h}u; i++) {
      var value = values[i];
      ${W}
      ${R}
      let cur_indices = ${P.type.indices}(batch, row + i, col);
      let offset = ${P.indicesToOffset("cur_indices")};
      ${P.setByOffset(`offset / ${f}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${f};${d};${h};${r}`,inputDependencies:y?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:s?s(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:_}),getShaderSource:T}}}),tN,nN,g1,Wv,iN,_1,rN,Eg,UT=ft(()=>{Qt(),un(),dn(),hc(),BT(),zT(),tN=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,nN=(e,t)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,g1=(e,t,n="f32",i,r=!1,s=32,a=!1,o=32)=>{let l=t[1]*e[1],u=t[0]*e[0],c=r?l:s,f=r?s:l,d=c/t[0],h=s/t[1];if(!((r&&d===4&&e[1]===4||!r&&(d===3||d===4))&&c%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${r} is true, innerElementSize ${d} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${d} must be 3 or 4.
  tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${d}<${n}>, ${c/d}>, ${f}>;
var<workgroup> mm_Bsub: array<array<vec4<${n}>, ${u/e[0]}>, ${s}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${d};
const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${a?"0":"i32(globalId.z)"};
  ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${l};

  let num_tiles = ${a?`${Math.ceil(o/s)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${a?`i32(globalId.z) * ${o}`:"0"};

  var acc: array<vec4<${n}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${h};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${tN(r,i)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${i?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${d===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${nN(r,d)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Wv=(e,t)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,iN=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",_1=(e,t,n="f32",i,r=!1,s=32,a=!1,o=32,l=!1)=>{let u=e[1]*t[1],c=e[0]*t[0],f=r?u:s,d=r?s:u;if(!(d%t[1]===0&&f%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${d} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${f} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let h=d/t[1],m=f/t[0],y=s/t[1],M=l?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${u};
    let globalColStart = i32(workgroupId.x) * ${c};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${f}; inputCol = inputCol + ${t[0]}) {
          ${Wv(r,i)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${i?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${n}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${u};

let tileRowA = i32(localId.y) * ${h};
let tileColA = i32(localId.x) * ${m};
let tileRowB = i32(localId.y) * ${y};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${m}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Wv(r,i)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${i?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${n}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${iN(r)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${n}, ${f}>, ${d}>;
  var<workgroup> mm_Bsub : array<array<${n}, ${c}>, ${s}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${a?"0":"i32(globalId.z)"};
    ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${a?`${Math.ceil(o/s)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${a?`i32(globalId.z) * ${o}`:"0"};

    var acc : array<array<${n}, colPerThread>, rowPerThread>;
    ${M}
  }
`},rN=(e,t,n,i,r=!1)=>{let[s,a,o,l]=i,u=mr(i[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${s.type.indices}) -> ${xr(e,u)} {
      var value = ${xr(e,u)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${a.type.indices};
        ${Zf("aIndices",a,a.rank-2,s.rank,"batchIndices")}
        ${a.indicesSet("aIndices",a.rank-2,"u32(row)")}
        ${a.indicesSet("aIndices",a.rank-1,"u32(colIn)")}
        value = ${a.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${s.type.indices}) -> ${xr(e,u)} {
      var value = ${xr(e,u)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${o.type.indices};
        ${Zf("bIndices",o,o.rank-2,s.rank,"batchIndices")}
        ${o.indicesSet("bIndices",o.rank-2,"u32(row)")}
        ${o.indicesSet("bIndices",o.rank-1,"u32(colIn)")}
        value = ${o.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${xr(e,u)}) {
      let col = colIn * ${e};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${r?"bias[colIn]":`${xr(e,u)}(bias[row])`};`:""}
        ${n}
        ${l.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Eg=(e,t,n,i,r=!1,s)=>{let a=e[0].dims,o=e[1].dims,l=a.slice(0,-2),u=o.slice(0,-2),c=i?i.slice(0,-2):n.slice(0,-2),f=qe.size(c),d=a[a.length-2],h=a[a.length-1],m=o[o.length-1],y=h%4===0&&m%4===0,M=d<=8?[4,1,1]:[4,4,1],g=[8,8,1],_=[Math.ceil(m/g[0]/M[0]),Math.ceil(d/g[1]/M[1]),Math.ceil(f/g[2]/M[2])],T=y?4:1,x=[...l,d,h/T],S=x.length,$=[...u,h,m/T],C=$.length,P=[f,d,m/T],O=[{type:6,data:d},{type:6,data:m},{type:6,data:h}];nc(t,O),O.push(...Ut(c,x,$));let R=["rank","rank"],G=e.length>2;G&&(O.push(...Ut(e[2].dims)),R.push("rank")),O.push(...Ut(P));let W=V=>{let te=c.length,J=DT("batchDims",e[0].dataType,te,1),j=mr(e[0].dataType),Y=Ze("a",e[0].dataType,S,T),X=Ze("b",e[1].dataType,C,T),ce=Rt("result",e[0].dataType,P.length,T),me=[Y,X];if(G){let _e=r?T:1;me.push(Ze("bias",e[2].dataType,e[2].dims.length,_e))}let Q=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];ic(t,Q);let H=mr(ce.type.tensor),B=tc(t,ce.type.value,H),ee=rN(T,G,B,[J,Y,X,ce],r);return`
  ${V.registerUniforms(Q).registerInternalVariables(J).declareVariables(...me,ce)}
  ${ee}
  ${y?g1(M,g,j,J):_1(M,g,j,J)}
                   `};return{name:"MatMul",shaderCache:{hint:`${M};${t.activation};${y};${r}`,inputDependencies:R},getRunData:()=>({outputs:[{dims:s?s(n):n,dataType:e[0].dataType}],dispatchGroup:{x:_[0],y:_[1],z:_[2]},programUniforms:O}),getShaderSource:W}}}),sN,CW,ese=ft(()=>{Qt(),Go(),dn(),hc(),zT(),Zre(),UT(),sN=(e,t,n,i,r=!1,s,a=4,o=4,l=4,u="f32")=>{let c=O=>{switch(O){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${u}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${O} is not supported.`)}},f=O=>{switch(O){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${O} is not supported.`)}},d=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,h=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,m=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",y=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",M=e?"row":"col",g=e?"col":"row",_=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${M} / outWidth;
    let outCol = ${M} % outWidth;

    let WRow = ${g} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${g} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${g} % inChannels;
    var resData = ${xr(a,u)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${m} && xCol >= 0 && xCol < ${y}) {
      ${d}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${c(a)}
    }
    return resData;`,T=e?t&&i?`
    let col = colIn * ${a};
    ${_}`:`
    let col = colIn * ${a};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${_}
    }
    return ${xr(a,u)}(0.0);`:i&&n?`
    let col = colIn * ${a};
    ${_}`:`
    let col = colIn * ${a};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${_}
    }
    return ${xr(a,u)}(0.0);`,x=e?i&&n?f(o):`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${f(o)}
    }
    return ${xr(o,u)}(0.0);`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${f(o)}
    }
    return ${xr(o,u)}(0.0);`,S=xr(l,u),$=xr(e?a:o,u),C=xr(e?o:a,u),P=tc(s,S,u);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${$} {
      ${e?T:x}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${C} {
      ${e?x:T}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${S}) {
      let col = colIn * ${l};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${h}
      ${EW(r)}
      ${P}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},CW=(e,t,n,i,r,s,a,o,l)=>{let u=t.format==="NHWC",c=u?e[0].dims[3]:e[0].dims[1],f=n[0],d=u?n[2]:n[3],h=u?n[1]:n[2],m=u?n[3]:n[1],y=u&&(c%4===0||c%3===0)&&m%4===0,M=u?m:d*h,g=u?d*h:m,_=[8,8,1],T=i<=8?[4,1,1]:[4,4,1],x=[Math.ceil(M/_[0]/T[0]),Math.ceil(g/_[1]/T[1]),Math.ceil(f/_[2]/T[2])];Ln("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${x}`);let S=y?u&&c%4!==0?3:4:1,$=_[1]*T[1],C=_[0]*T[0],P=Math.max(_[0]*S,_[1]),O=i%$===0,R=r%C===0,G=s%P===0,W=y?[S,4,4]:[1,1,1],V=[{type:6,data:i},{type:6,data:r},{type:6,data:s},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];nc(t,V),V.push(...Ut(e[0].dims,e[1].dims));let te=["rank","rank"];a&&(V.push(...Ut(e[2].dims)),te.push("rank")),V.push(...Ut(n));let J=j=>{let Y=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];ic(t,Y);let X=y?4:1,ce=mr(e[0].dataType),me=`
      fn setOutputAtIndex(flatIndex : i32, value : ${y?`vec4<${ce}>`:ce}) {
        result[flatIndex] = ${y?`vec4<${ce}>`:ce}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${y?`vec4<${ce}>`:ce}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${y?"/ 4":""}, value);
      }`,Q=Ze("x",e[0].dataType,e[0].dims.length,S===3?1:S),H=Ze("w",e[1].dataType,e[1].dims.length,X),B=[Q,H],ee=Rt("result",e[0].dataType,n.length,X);if(a){let _e=Ze("bias",e[2].dataType,e[2].dims.length,X);B.push(_e),me+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?`vec4<${ce}>`:ce} {
          return bias[coords.${u?"w":"y"}${y?"/ 4":""}];
        }`}return`
        ${SW("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${j.registerUniforms(Y).declareVariables(...B,ee)}
        ${me}
        ${sN(u,O,R,G,a,t,W[0],W[1],W[2],ce)}
        ${y?g1(T,_,ce,void 0,!u,P):_1(T,_,ce,void 0,!u,P,!1,void 0,o)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${S};${y};${O};${R};${G};${$};${C};${P}`,inputDependencies:te},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:e[0].dataType}],dispatchGroup:{x:x[0],y:x[1],z:x[2]},programUniforms:V}),getShaderSource:J}}}),aN,Hv,_f,oN,qv,lN,$W,AW,tse=ft(()=>{Qt(),Go(),un(),dn(),hc(),zT(),aN=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},Hv=e=>typeof e=="number"?[e,e,e]:e,_f=(e,t)=>t<=1?e:e+(e-1)*(t-1),oN=(e,t,n,i=1)=>{let r=_f(t,i);return Math.floor((e[0]*(n-1)-n+r)/2)},qv=(e,t,n,i,r)=>{r==null&&(r=oN(e,t[0],i[0]));let s=[0,0,0,n];for(let a=0;a<3;a++)e[a]+2*r>=t[a]&&(s[a]=Math.trunc((e[a]-t[a]+2*r)/i[a]+1));return s},lN=(e,t,n,i,r,s,a,o,l,u)=>{let c,f,d,h;if(e==="VALID"&&(e=0),typeof e=="number"){c={top:e,bottom:e,left:e,right:e,front:e,back:e};let m=qv([t,n,i,1],[o,l,u],1,[r,s,a],e);f=m[0],d=m[1],h=m[2]}else if(Array.isArray(e)){if(!e.every((y,M,g)=>y===g[0]))throw Error(`Unsupported padding parameter: ${e}`);c={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let m=qv([t,n,i,1],[o,l,u],1,[r,s,a],e[0]);f=m[0],d=m[1],h=m[2]}else if(e==="SAME_UPPER"){f=Math.ceil(t/r),d=Math.ceil(n/s),h=Math.ceil(i/a);let m=(f-1)*r+o-t,y=(d-1)*s+l-n,M=(h-1)*a+u-i,g=Math.floor(m/2),_=m-g,T=Math.floor(y/2),x=y-T,S=Math.floor(M/2),$=M-S;c={top:T,bottom:x,left:S,right:$,front:g,back:_}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outDepth:f,outHeight:d,outWidth:h}},$W=(e,t,n,i,r,s=!1,a="channelsLast")=>{let o,l,u,c,f;if(a==="channelsLast")[o,l,u,c,f]=e;else if(a==="channelsFirst")[o,f,l,u,c]=e;else throw new Error(`Unknown dataFormat ${a}`);let[d,,h,m,y]=t,[M,g,_]=Hv(n),[T,x,S]=Hv(i),$=_f(h,T),C=_f(m,x),P=_f(y,S),{padInfo:O,outDepth:R,outHeight:G,outWidth:W}=lN(r,l,u,c,M,g,_,$,C,P),V=s?d*f:d,te=[0,0,0,0,0];return a==="channelsFirst"?te=[o,V,R,G,W]:a==="channelsLast"&&(te=[o,R,G,W,V]),{batchSize:o,dataFormat:a,inDepth:l,inHeight:u,inWidth:c,inChannels:f,outDepth:R,outHeight:G,outWidth:W,outChannels:V,padInfo:O,strideDepth:M,strideHeight:g,strideWidth:_,filterDepth:h,filterHeight:m,filterWidth:y,effectiveFilterDepth:$,effectiveFilterHeight:C,effectiveFilterWidth:P,dilationDepth:T,dilationHeight:x,dilationWidth:S,inShape:e,outShape:te,filterShape:t}},AW=(e,t,n,i,r,s)=>{let a=s==="channelsLast";a?e[0].dims[3]:e[0].dims[1];let o=[64,1,1],l={x:n.map((M,g)=>g)},u=[Math.ceil(aN(l.x.map(M=>n[M]))/o[0]),1,1];Ln("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${u}`);let c=1,f=qe.size(n),d=[{type:12,data:f},{type:12,data:i},{type:12,data:r},{type:12,data:t.strides},{type:12,data:t.dilations}];nc(t,d),d.push(...Ut(e[0].dims,e[1].dims));let h=["rank","rank"],m=e.length===3;m&&(d.push(...Ut(e[2].dims)),h.push("rank")),d.push(...Ut(n));let y=M=>{let g=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:i.length},{name:"pads",type:"u32",length:r.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];ic(t,g);let _=1,T=mr(e[0].dataType),x=Ze("x",e[0].dataType,e[0].dims.length,c),S=Ze("W",e[1].dataType,e[1].dims.length,_),$=[x,S],C=Rt("result",e[0].dataType,n.length,_),P="";if(m){let G=Ze("bias",e[2].dataType,e[2].dims.length,_);$.push(G),P+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${T} {
          return bias[${a?zt("coords",4,5):zt("coords",1,5)}];
        }`}let O=xr(c,T),R=tc(t,O,T);return`
            ${P}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${S.getByIndices("aIndices")};
            }
          ${M.registerUniforms(g).declareVariables(...$,C)}
          ${M.mainStart()}
          ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${C.offsetToIndices("global_idx")};
              let batch = ${zt("coords",0,x.rank)};
              let d2 = ${a?zt("coords",x.rank-1,x.rank):zt("coords",1,x.rank)};
              let xFRCCorner = vec3<u32>(${a?zt("coords",1,x.rank):zt("coords",2,x.rank)},
              ${a?zt("coords",2,x.rank):zt("coords",3,x.rank)},
              ${a?zt("coords",3,x.rank):zt("coords",4,x.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${a?zt("uniforms.x_shape",1,x.rank):zt("uniforms.x_shape",2,x.rank)};
              let xShapeZ = ${a?zt("uniforms.x_shape",2,x.rank):zt("uniforms.x_shape",3,x.rank)};
              let xShapeW = ${a?zt("uniforms.x_shape",3,x.rank):zt("uniforms.x_shape",4,x.rank)};
              let xShapeU = ${a?zt("uniforms.x_shape",4,x.rank):zt("uniforms.x_shape",1,x.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${a?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${a?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${a?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${a?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${m?"value = value + getBiasByOutputCoords(coords)":""};
              ${R}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${a};${c};${m}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:u[0],y:u[1],z:u[2]},programUniforms:d}),getShaderSource:y}}}),IW,PW,nse=ft(()=>{Qt(),un(),dn(),hc(),IW=(e,t,n,i)=>{let r=e.length>2,s=r?"value += b[output_channel];":"",a=e[0].dims,o=e[1].dims,l=t.format==="NHWC",u=l?n[3]:n[1],c=u/t.group,f=l&&c>=4?Fi(u):1,d=qe.size(n)/f,h=[{type:12,data:d},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:c}];nc(t,h),h.push(...Ut(a,[o[0],o[1],o[2],o[3]/f]));let m=r?["rank","rank","rank"]:["rank","rank"];h.push(...Ut([n[0],n[1],n[2],n[3]/f]));let y=M=>{let g=Rt("output",e[0].dataType,n.length,f),_=mr(g.type.tensor),T=tc(t,g.type.value,_),x=Ze("x",e[0].dataType,a.length),S=Ze("w",e[1].dataType,o.length,f),$=[x,S];r&&$.push(Ze("b",e[2].dataType,e[2].dims,f));let C=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];ic(t,C);let P=l?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${x.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${S.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${x.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${S.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${M.registerUniforms(C).declareVariables(...$,g)}

  ${M.mainStart()}
    ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${g.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${l?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${f} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];

    var value: ${g.type.value} = ${g.type.value}(0);
    ${P}
    ${s}
    ${T}
    ${g.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${f}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:y}},PW=(e,t,n,i)=>{let r=e.length>2,s=Fi(n[3]),a=Fi(n[2]),o=qe.size(n)/s/a,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/s],u=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/s],c=[n[0],n[1],n[2],n[3]/s],f=[{type:12,data:o},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];nc(t,f),f.push(...Ut(l,u,c));let d=(a-1)*t.strides[1]+u[1],h=m=>{let y=Rt("output",e[0].dataType,c.length,s),M=mr(y.type.tensor),g=tc(t,y.type.value,M),_=Ze("x",e[0].dataType,l.length,s),T=Ze("w",e[1].dataType,u.length,s),x=[_,T];r&&x.push(Ze("b",e[2].dataType,e[2].dims,s));let S=r?"value += b[output_channel];":"",$=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return ic(t,$),`
  ${m.registerUniforms($).declareVariables(...x,y)}
  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${a}u;
    let col = (index1 % width1) * ${a}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${_.type.value}, ${d}>;
    var values: array<${y.type.value}, ${a}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${u[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${d}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${_.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${_.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${u[1]}; w_width++) {
          let w_val = ${T.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${a}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${a}u; i++) {
      var value = values[i];
      ${S}
      ${g}
      ${y.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${s};${a};${d};${u[0]};${u[1]}`,inputDependencies:r?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:f}),getShaderSource:h}}}),uN,Yh,cN,Xh,y1,Kv,dN,fN,v1,ise=ft(()=>{un(),ese(),tse(),UT(),nse(),hc(),BT(),Yl(),uN=(e,t,n,i,r,s)=>{let a=e[0],o=e.slice(s?1:2,s?3:4),l=o.length,u=t[0],c=t.slice(2).map((d,h)=>d+(d-1)*(n[h]-1)),f=o.map((d,h)=>d+i[h]+i[h+l]).map((d,h)=>Math.floor((d-c[h]+r[h])/r[h]));return f.splice(0,0,a),f.splice(s?3:1,0,u),f},Yh=[2,3,1,0],cN=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let n=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[1]*t.group;if(n!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.length!==r*2)throw new Error(`pads should be ${r*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Xh=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let s=2;s<t[1].dims.length;++s)n[s-2]===0&&(n[s-2]=t[1].dims[s]);let i=e.pads.slice();Tg.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,i,e.format==="NHWC",e.autoPad);let r=Object.assign({},e);return Object.assign(r,{kernelShape:n,pads:i}),r},y1=e=>{let t=LT(e),n=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],r=e.dilations,s=e.group,a=e.kernel_shape,o=e.pads,l=e.strides,u=e.w_is_const();return{autoPad:i,format:n,dilations:r,group:s,kernelShape:a,pads:o,strides:l,wIsConst:u,...t,cacheKey:`${e.format};${t.activation};`}},Kv=(e,t,n,i)=>{let r=n.format==="NHWC",s=uN(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,r);if(n.group!==1){let $=[t[0]];if(r){let C=e.kernelCustomData.wT??e.compute(Es(t[1],Yh),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=C),$.push(C)}else $.push(t[1]);t.length===3&&$.push(t[2]),!e.adapterInfo.isArchitecture("ampere")&&r&&t[1].dims[0]===n.group&&t[1].dims[1]===1&&n.dilations[0]===1&&n.dilations[1]===1?e.compute(PW($,n,s,i),{inputs:$}):e.compute(IW($,n,s,i),{inputs:$});return}let a=t.length===3,o=t[0].dims[r?1:2],l=t[0].dims[r?2:3],u=t[0].dims[r?3:1],c=t[1].dims[2],f=t[1].dims[3],d=s[r?1:2],h=s[r?2:3],m=s[r?3:1],y=r&&c===o&&f===l&&n.pads[0]===0&&n.pads[1]===0;if(y||c===1&&f===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let $=s[0],C,P,O,R=[];if(r){let V=e.kernelCustomData.wT??e.compute(Es(t[1],Yh),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=V),y){let te=o*l*u;C=t[0].reshape([1,$,te]),P=V.reshape([1,te,m]),O=[1,$,m]}else C=t[0].reshape([$,o*l,u]),P=V.reshape([1,u,m]),O=[$,d*h,m];R.push(C),R.push(P)}else C=t[0].reshape([$,u,o*l]),P=t[1].reshape([1,m,u]),O=[$,m,d*h],R.push(P),R.push(C);a&&R.push(t[2]);let G=O[2],W=R[0].dims[R[0].dims.length-1];G<8&&W<8?e.compute(FT(R,n,s,O,r,i),{inputs:R}):e.compute(Eg(R,n,s,O,r,i),{inputs:R});return}let M=!0,g=e.kernelCustomData.wT??e.compute(Es(t[1],Yh),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=g);let _=[t[0],g];a&&_.push(t[2]);let T=r?d*h:m,x=r?m:d*h,S=c*f*u;e.compute(CW(_,n,s,T,x,S,a,M,i),{inputs:_})},dN=(e,t)=>{let n=t.format==="NHWC",i=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&i.push(e.inputs[2]);let r=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),a=[1].concat(t.dilations),o=[1].concat(t.kernelShape),l=Xh({...t,pads:r,strides:s,dilations:a,kernelShape:o},i);Kv(e,i,l,u=>n?[u[0],u[2],u[3]]:[u[0],u[1],u[3]])},fN=(e,t,n)=>{let i=n.format==="NHWC"?"channelsLast":"channelsFirst",r=Xh(n,t),s=n.autoPad==="NOTSET"?n.pads:n.autoPad,a=$W(t[0].dims,t[1].dims,n.strides,n.dilations,s,!1,i);e.compute(AW(t,r,a.outShape,[a.filterDepth,a.filterHeight,a.filterWidth],[a.padInfo.front,a.padInfo.top,a.padInfo.left],i))},v1=(e,t)=>{if(cN(e.inputs,t),e.inputs[0].dims.length===3)dN(e,t);else if(e.inputs[0].dims.length===5)fN(e,e.inputs,t);else{let n=Xh(t,e.inputs);Kv(e,e.inputs,n)}}}),kW,rse=ft(()=>{Qt(),Go(),un(),dn(),kW=(e,t,n)=>{let i=e.length>2,r=t.outputShape,s=t.format==="NHWC",a=t.group,o=e[1].dims,l=o[2]/a,u=o[3],c=s?Fi(l):1,f=s&&u===1&&l>=4,d=f?Math.floor(l/4)*4:Math.floor(l/c)*c,h=l-d,m=s?Fi(u):1,y=s?u===1?c:m:1,M=qe.size(r)/m,g=[Math.ceil(M/64),1,1];Ln("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${g}`);let _=["rank","rank"],T=[t.strides[0],t.strides[1]],x=[t.kernelShape[s?1:2],t.kernelShape[s?2:3]],S=[t.dilations[0],t.dilations[1]],$=[x[0]+(t.dilations[0]<=1?0:(t.kernelShape[s?1:2]-1)*(t.dilations[0]-1)),x[1]+(t.dilations[1]<=1?0:(t.kernelShape[s?2:3]-1)*(t.dilations[1]-1))],C=[$[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),$[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],P=[{type:12,data:M},{type:12,data:T},{type:12,data:x},{type:12,data:S},{type:12,data:$},{type:6,data:C},{type:12,data:d},{type:12,data:l},{type:12,data:u},...Ut(e[0].dims,e[1].dims)];i&&(P.push(...Ut(e[2].dims)),_.push("rank")),P.push(...Ut(r));let O=R=>{let G=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:T.length},{name:"filter_dims",type:"u32",length:x.length},{name:"dilations",type:"u32",length:x.length},{name:"effective_filter_dims",type:"u32",length:$.length},{name:"pads",type:"i32",length:C.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],W=mr(e[0].dataType),V=s?1:2,te=s?2:3,J=s?3:1,j=Ze("W",e[1].dataType,e[1].dims.length,y),Y=Ze("Dy",e[0].dataType,e[0].dims.length,c),X=[Y,j];i&&X.push(Ze("bias",e[2].dataType,[r[J]].length,m));let ce=Rt("result",e[0].dataType,r.length,m),me=()=>{let B="";if(f)c===4?B+=`
        let xValue = ${Y.getByOffset("x_offset")};
        let wValue = ${j.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:c===2?B+=`
          dotProd = dotProd + dot(vec4<${W}>(${Y.getByOffset("x_offset")}, ${Y.getByOffset("x_offset + 1u")}), vec4<${W}>(${j.getByOffset("w_offset")}, ${j.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:c===1&&(B+=`
          dotProd = dotProd + dot(vec4<${W}>(${Y.getByOffset("x_offset")}, ${Y.getByOffset("x_offset + 1u")}, ${Y.getByOffset("x_offset + 2u")}, ${Y.getByOffset("x_offset + 3u")}), vec4<${W}>(${j.getByOffset("w_offset")}, ${j.getByOffset("w_offset + 1u")}, ${j.getByOffset("w_offset + 2u")}, ${j.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(B+=`
                  let xValue = ${s?Y.getByOffset(`${Y.indicesToOffset(`${Y.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c}`):Y.get("batch","inputChannel","idyR","idyC")};
        `,c===1)B+=`
          let w_offset = ${j.indicesToOffset(`${j.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${j.getByOffset(`w_offset / ${y}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let ee=0;ee<c;ee++)B+=`
            let wValue${ee} = ${j.getByOffset(`${j.indicesToOffset(`${j.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${ee}, wOutChannel)`)} / ${y}`)};
            dotProd = dotProd + xValue[${ee}] * wValue${ee};`;return B},Q=()=>{if(h===0)return"";if(!f)throw new Error(`packInputAs4 ${f} is not true.`);let B="";if(c===1){B+="dotProd = dotProd";for(let ee=0;ee<h;ee++)B+=`
            + ${Y.getByOffset(`x_offset + ${ee}`)} * ${j.getByOffset(`w_offset + ${ee}`)}`;B+=";"}else if(c===2){if(h!==2)throw new Error(`Invalid inputChannelsRemainder ${h}.`);B+=`
          let xValue = ${Y.getByOffset("x_offset")};
          let wValue = ${j.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return B},H=`
            let outputIndices = ${ce.offsetToIndices(`global_idx * ${m}`)};
            let batch = ${ce.indicesGet("outputIndices",0)};
            let d1 = ${ce.indicesGet("outputIndices",J)};
            let r = ${ce.indicesGet("outputIndices",V)};
            let c = ${ce.indicesGet("outputIndices",te)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${ce.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${W}(dyRCorner) + ${W}(wR)) / ${W}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${W}(uniforms.Dy_shape[${V}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${W}(dyCCorner) + ${W}(wC)) / ${W}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${W}(uniforms.Dy_shape[${te}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${f?`
                var x_offset = ${Y.indicesToOffset(`${Y.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c};
                var w_offset = ${j.indicesToOffset(`${j.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${y};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${f?4:c}) {
                  ${me()}
                  inputChannel = inputChannel + ${f?4:c};
                }
                ${Q()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${i?` + bias[d1 / ${m}]`:""};
            ${ce.setByOffset("global_idx","value")};
          `;return`
    ${R.registerUniforms(G).declareVariables(...X,ce)}
      ${R.mainStart()}
      ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${H}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${c}${y}${m}${f}${h}`,inputDependencies:_},getRunData:()=>({dispatchGroup:{x:g[0],y:g[1],z:g[2]},outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],programUniforms:P}),getShaderSource:O}}}),pN,hN,mN,Jv,DW,gN,Yv,_N,OW,sse=ft(()=>{rse(),hc(),Yl(),pN=(e,t,n,i,r,s)=>(e-1)*t+n+(i-1)*r+1-s,hN=(e,t,n,i,r)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(n[i]=s,n[r]=e-s):t==="SAME_LOWER"&&(n[i]=e-s,n[r]=s)},mN=(e,t,n,i,r,s,a,o,l,u)=>{let c=e.length-2,f=u.length===0;l.length<c&&l.push(...Array(c-l.length).fill(0));let d=e[0],h=t[o?3:1]*r;for(let m=0,y=e.length-c-(o?1:0);m<c;++m,++y){let M=e[y],g=f?M*a[m]:u[m],_=pN(M,a[m],s[m],t[y],n[m],g);hN(_,i,s,m,m+c),f&&u.push(a[m]*(M-1)+l[m]+(t[y]-1)*n[m]+1-s[m]-s[m+c])}u.splice(0,0,d),u.splice(o?3:1,0,h)},Jv=(e,t)=>{let n=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((f,d)=>f*d,1)===0){n.length=0;for(let f=2;f<t[1].dims.length;++f)n.push(t[1].dims[f])}let i=e.format==="NHWC";n.splice(0,0,t[1].dims[0]),n.splice(i?3:1,0,t[1].dims[1]);let r=e.pads.slice(),s=e.outputShape.slice(),a=e.outputPadding.slice(),o=t[0].dims,l=e.dilations.slice();if(l.reduce((f,d)=>f+d,0)===0){let f=t[0].dims.length-2;l=new Array(f).fill(1)}let u=e.strides.slice();if(u.reduce((f,d)=>f+d,0)===0){let f=t[0].dims.length-2;u=new Array(f).fill(1)}mN(o,n,l,e.autoPad,e.group,r,u,i,a,s);let c=Object.assign({},e);return Object.assign(c,{kernelShape:n,pads:r,outputPadding:a,outputShape:s,dilations:l,strides:u}),c},DW=e=>{let t=LT(e),n=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],r=e.dilations,s=e.group,a=e.kernelShape,o=e.pads,l=e.strides,u=e.wIsConst(),c=e.outputPadding,f=e.outputShape;return{autoPad:i,format:n,dilations:r,group:s,kernelShape:a,outputPadding:c,outputShape:f,pads:o,strides:l,wIsConst:u,...t,cacheKey:`${e.format};${t.activation};`}},gN=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let n=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[0];if(n!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let r=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==r))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((a,o)=>a+o,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((a,o)=>a+o,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((a,o)=>a+o,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((a,o)=>a+o,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Yv=(e,t,n,i)=>{let r=e.kernelCustomData.wT??e.compute(Es(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r);let s=[t[0],r];t.length===3&&s.push(t[2]),e.compute(kW(s,n,i),{inputs:s})},_N=(e,t)=>{let n=t.format==="NHWC",i=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&i.push(e.inputs[2]);let r=t.kernelShape;(r.length===0||r[0]===0)&&(r=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let a=t.strides;(a.length===0||a[0]===0)&&(a=[1]);let o=t.pads;o.length===0&&(o=[0,0]),o=[0,o[0],0,o[1]],a=[1].concat(a),s=[1].concat(s),r=[1].concat(r);let l=t.outputPadding;l=[0].concat(l);let u=Jv({...t,pads:o,strides:a,dilations:s,kernelShape:r,outputPadding:l},i);Yv(e,i,u,c=>n?[c[0],c[2],c[3]]:[c[0],c[1],c[3]])},OW=(e,t)=>{if(gN(e.inputs,t),e.inputs[0].dims.length===3)_N(e,t);else{let n=Jv(t,e.inputs);Yv(e,e.inputs,n)}}}),yN,RW,NW,ase=ft(()=>{Qt(),un(),Vi(),dn(),yN=(e,t,n,i)=>{let r=qe.size(t),s=t.length,a=Ze("input",e,s),o=Rt("output",e,s),l=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),u=qe.normalizeAxis(l,s),c=f=>{let d=` i32(${a.indicesGet("inputIndices","uniforms.axis")}) `,h=zt("uniforms.input_shape","uniforms.axis",s),m=i.reverse?d+(i.exclusive?" + 1":""):"0",y=i.reverse?h:d+(i.exclusive?"":" + 1");return`
                ${f.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(a,o)}
                ${f.mainStart()}
                  ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${o.offsetToIndices("global_idx")};
                  var sum = ${o.type.value}(0);
                  let first : i32 = ${m};
                  let last : i32 = ${y};
                  for (var i : i32 = first; i < last; i++) {
                    ${a.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${a.getByIndices("inputIndices")};
                  }
                  ${o.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:i.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:[{type:12,data:r},{type:12,data:u},...Ut(t,t)]}),getShaderSource:c}},RW=(e,t)=>{let n=e.inputs[0].dims,i=e.inputs[0].dataType,r=e.inputs[1];e.compute(yN(i,n,r,t),{inputs:[0]})},NW=e=>{let t=e.exclusive===1,n=e.reverse===1;return Zn({exclusive:t,reverse:n})}}),vN,wN,bN,LW,zW,ose=ft(()=>{Qt(),un(),Vi(),dn(),vN=e=>{if(!e||e.length!==1)throw new Error("DepthToSpace requires 1 input.");if(e[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},wN=(e,t,n,i)=>{let r=[];r.push(`fn perm(i: ${i.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`);for(let s=0;s<t;++s)r.push(n.indicesSet("a",e[s],`i[${s}]`));return r.push("return a;}"),r.join(`
`)},bN=(e,t)=>{let n,i,r,s,a,o,l=t.format==="NHWC",u=t.blocksize,c=t.mode==="DCR";l?([n,i,r,s]=e.dims,a=c?[n,i,r,u,u,s/u**2]:[n,i,r,s/u**2,u,u],o=c?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,i,r,s]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],a=c?[n,u,u,s/u**2,i,r]:[n,s/u**2,u,u,i,r],o=c?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let f=e.reshape(a),d=f.dims.length,h=e.dataType,m=Ze("a",h,d),y=Rt("output",h,d),M=g=>`
  ${g.registerUniform("output_size","u32").declareVariables(m,y)}

  ${wN(o,d,m,y)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${y.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${y.setByOffset("global_idx",m.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:g=>{let _=l?[n,i*u,r*u,s/u**2]:[n,s/u**2,i*u,r*u],T=qe.size(_),x=f.dims,S=qe.sortBasedOnPerm(x,o);return{outputs:[{dims:_,dataType:g[0].dataType}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:[{type:12,data:T},...Ut(x,S)]}},getShaderSource:M}},LW=(e,t)=>{vN(e.inputs),e.compute(bN(e.inputs[0],t))},zW=e=>Zn({blocksize:e.blocksize,mode:e.mode,format:e.format})}),Qh,yf,Xv,xN,TN,MN,EN,Qv,SN,FW,BW,lse=ft(()=>{Qt(),un(),Vi(),dn(),Qh="[a-zA-Z]|\\.\\.\\.",yf="("+Qh+")+",Xv="^"+yf+"$",xN="("+yf+",)*"+yf,TN="^"+xN+"$",MN=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);n===void 0?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},EN=class{constructor(e,t){var r;this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,i]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(TN)))throw new Error("Invalid LHS term");if(n.split(",").forEach((s,a)=>{let o=e[a].dims.slice();if(!s.match(RegExp(Xv)))throw new Error("Invalid LHS term");let l=this.processTerm(s,!0,o,a);this.lhs.push(l)}),i==="")i+=[...this.symbolToInfo.entries()].filter(([s,a])=>a.count===1||s==="...").map(([s])=>s).join("");else if(!i.match(RegExp(yf)))throw new Error("Invalid RHS");(r=i.match(RegExp(Qh,"g")))==null||r.forEach(s=>{if(s==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let a=this.symbolToInfo.get(s);if(a===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(a.dimValue)}}),this.rhs=this.processTerm(i,!1,this.outputDims)}addSymbol(e,t,n){let i=this.symbolToInfo.get(e);if(i!==void 0){if(i.dimValue!==t&&i.count!==1)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(n)}else i={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,i)}processTerm(e,t,n,i=-1){let r=n.length,s=!1,a=[],o=0;if(!e.match(RegExp(Xv))&&!t&&e!=="")throw new Error("Invalid LHS term");let l=e.match(RegExp(Qh,"g")),u=new MN(i);return l==null||l.forEach((c,f)=>{if(c==="..."){if(s)throw new Error("Only one ellipsis is allowed per input term");s=!0;let d=r-l.length+1;if(d<0)throw new Error("Ellipsis out of bounds");if(a=n.slice(o,o+d),this.hasEllipsis){if(this.ellipsisDims.length!==a.length||this.ellipsisDims.toString()!==a.toString())throw new Error("Ellipsis dimensions mismatch")}else if(t)this.hasEllipsis=!0,this.ellipsisDims=a;else throw new Error("Ellipsis must be specified in the LHS");for(let h=0;h<a.length;h++){let m=String.fromCharCode(48+h);u.addSymbol(m,f+h),this.addSymbol(m,n[o++],i)}}else u.addSymbol(c,f+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(c,n[o++],i)}),u}},Qv=e=>e+"_max",SN=(e,t,n,i)=>{let r=e.map(u=>u.length).map((u,c)=>Ze(`input${c}`,t,u)),s=qe.size(i),a=Rt("output",t,i.length),o=[...n.symbolToInfo.keys()].filter(u=>!n.rhs.symbolToIndices.has(u)),l=u=>{let c=[],f="var prod = 1.0;",d="var sum = 0.0;",h="sum += prod;",m=[],y=[],M=[],g=[],_=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((x,S)=>{var $;if(n.rhs.symbolToIndices.has(S)){let C=($=n.rhs.symbolToIndices.get(S))==null?void 0:$[0];C!==void 0&&n.lhs.forEach((P,O)=>{if(x.inputIndices.includes(O)){let R=P.symbolToIndices.get(S);if(R===void 0)throw new Error("Invalid symbol error");R.forEach(G=>{c.push(`${r[O].indicesSet(`input${O}Indices`,G,a.indicesGet("outputIndices",C))}`)})}})}else n.lhs.forEach((C,P)=>{if(x.inputIndices.includes(P)){let O=C.symbolToIndices.get(S);if(O===void 0)throw new Error("Invalid symbol error");O.forEach(R=>{m.push(`${r[P].indicesSet(`input${P}Indices`,R,`${S}`)}`)}),g.push(`prod *= ${r[P].getByIndices(`input${P}Indices`)};`)}}),y.push(`for(var ${S}: u32 = 0; ${S} < uniforms.${Qv(S)}; ${S}++) {`),M.push("}")});let T=_?[...c,`let sum = ${r.map((x,S)=>x.getByIndices(`input${S}Indices`)).join(" * ")};`]:[...c,d,...y,...m,f,...g,h,...M];return`
            ${u.registerUniforms(o.map(x=>({name:`${Qv(x)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...r,a)}

            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${a.offsetToIndices("global_idx")};
            ${r.map((x,S)=>`var input${S}Indices: ${r[S].type.indices};`).join(`
`)}
            ${T.join(`
`)};
            ${a.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let u=o.filter(f=>n.symbolToInfo.has(f)).map(f=>{var d;return{type:12,data:((d=n.symbolToInfo.get(f))==null?void 0:d.dimValue)||0}});u.push({type:12,data:s});let c=e.map((f,d)=>[...Ut(f)]).reduce((f,d)=>f.concat(d),u);return c.push(...Ut(i)),{outputs:[{dims:i,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:c}},getShaderSource:l}},FW=(e,t)=>{let n=new EN(e.inputs,t.equation),i=n.outputDims,r=e.inputs.map((s,a)=>s.dims);e.compute(SN(r,e.inputs[0].dataType,n,i))},BW=e=>{let t=e.equation.replace(/\s+/g,"");return Zn({equation:t})}}),CN,Zv,$N,AN,UW,use=ft(()=>{Qt(),un(),dn(),CN=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),i=n.length<t.length?0:n.length-t.length,r=t.length<n.length?0:t.length-n.length;for(;i<n.length&&r<t.length;++i,++r)if(n[i]!==t[r]&&n[i]!==1&&t[r]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Zv=(e,t)=>{let n=e.length-t.length,i=[];for(let r=0;r<n;++r)i.push(e[r]);for(let r=0;r<t.length;++r)i.push(t[r]===1?e[r+n]:t[r]);return i},$N=(e,t)=>e.length>t.length?Zv(e,t):Zv(t,e),AN=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),i=$N(t,n),r=e[0].dataType,s=r===9||qe.size(t)===1,a=r===9||t.length>0&&t[t.length-1]%4===0?4:1,o=s||i.length>0&&i[i.length-1]%4===0?4:1,l=Math.ceil(qe.size(i)/o),u=f=>{let d=Ze("input",r,t.length,a),h=Rt("output",r,i.length,o),m;if(r===9){let y=(M,g,_="")=>`
          let outputIndices${g} = ${h.offsetToIndices(`outputOffset + ${g}u`)};
          let offset${g} = ${d.broadcastedIndicesToOffset(`outputIndices${g}`,h)};
          let index${g} = offset${g} / 4u;
          let component${g} = offset${g} % 4u;
          ${M}[${g}] = ${_}(${d.getByOffset(`index${g}`)}[component${g}]);
        `;m=`
        let outputOffset = global_idx * ${o};
        var data = vec4<u32>(0);
        ${y("data",0,"u32")}
        ${y("data",1,"u32")}
        ${y("data",2,"u32")}
        ${y("data",3,"u32")}
        ${h.setByOffset("global_idx","data")}
      }`}else m=`
        let outputIndices = ${h.offsetToIndices(`global_idx * ${o}`)};
        let inputOffset = ${d.broadcastedIndicesToOffset("outputIndices",h)};
        let data = ${h.type.value}(${d.getByOffset(`inputOffset / ${a}`)});
        ${h.setByOffset("global_idx","data")}
      }`;return`
    ${f.registerUniform("vec_size","u32").declareVariables(d,h)}
    ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${m}`},c=[{type:12,data:l},...Ut(t,i)];return{name:"Expand",shaderCache:{hint:`${i.length};${a}${o}`,inputDependencies:["rank"]},getShaderSource:u,getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c})}},UW=e=>{CN(e.inputs),e.compute(AN(e.inputs),{inputs:[0]})}}),IN,VW,cse=ft(()=>{Qt(),un(),dn(),NT(),IN=e=>{let t=e[0].dataType,n=qe.size(e[0].dims),i=qe.size(e[1].dims),r=i%4===0,s=a=>{let o=Ze("x",t,[1],4),l=Ze("bias",t,[1],4),u=Rt("y",t,[1],4),c=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],f=h=>`
      let bias${h}_offset: u32 = (global_idx * 4 + ${h}) % uniforms.bias_size;
      let bias${h} = ${l.getByOffset(`bias${h}_offset / 4`)}[bias${h}_offset % 4];`,d=r?`
      let bias = ${l.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${f(0)}${f(1)}${f(2)}${f(3)}
      let bias = ${o.type.value}(bias0, bias1, bias2, bias3);`;return`${a.registerUniforms(c).declareVariables(o,l,u)}

    ${h1(Lr(t))}

    ${a.mainStart($d)}
      ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${o.getByOffset("global_idx")};
      ${d}
      let x_in = x + bias;
      ${u.setByOffset("global_idx",m1("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${r}`,inputDependencies:["type","type"]},getShaderSource:s,getRunData:a=>({outputs:[{dims:a[0].dims,dataType:a[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:i}],dispatchGroup:{x:Math.ceil(n/$d/4)}})}},VW=e=>{e.inputs.length<2||qe.size(e.inputs[1].dims)===0?lW(e):e.compute(IN(e.inputs))}}),PN,kN,GW,jW,dse=ft(()=>{Qt(),un(),Vi(),dn(),PN=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},kN=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n.length,s=qe.normalizeAxis(t.axis,r),a=n.slice(0);a.splice(s,1,...i);let o=n[s],l=e[0].dataType===9?4:1,u=Math.ceil(qe.size(a)/l),c=[{type:12,data:u},{type:6,data:o},{type:12,data:s},...Ut(e[0].dims,e[1].dims,a)],f=d=>{let h=Ze("data",e[0].dataType,e[0].dims.length,l),m=Ze("inputIndices",e[1].dataType,e[1].dims.length),y=Rt("output",e[0].dataType,a.length,l),M=_=>{let T=i.length,x=`var indicesIndices${_}  = ${m.type.indices}(0);`;for(let S=0;S<T;S++)x+=`${T>1?`indicesIndices${_}[${S}]`:`indicesIndices${_}`} = ${a.length>1?`outputIndices${_}[uniforms.axis + ${S}]`:`outputIndices${_}`};`;x+=`
          var idx${_} = ${m.getByIndices(`indicesIndices${_}`)};
          if (idx${_} < 0) {
            idx${_} = idx${_} + uniforms.axisDimLimit;
          }
          var dataIndices${_} : ${h.type.indices};
        `;for(let S=0,$=0;S<r;S++)S===s?(x+=`${r>1?`dataIndices${_}[${S}]`:`dataIndices${_}`} = u32(idx${_});`,$+=T):(x+=`${r>1?`dataIndices${_}[${S}]`:`dataIndices${_}`} = ${a.length>1?`outputIndices${_}[${$}]`:`outputIndices${_}`};`,$++);return x},g;if(e[0].dataType===9){let _=(T,x,S="")=>`
          let outputIndices${x} = ${y.offsetToIndices(`outputOffset + ${x}u`)};
          ${M(x)};
          let offset${x} = ${h.indicesToOffset(`dataIndices${x}`)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${T}[${x}] = ${S}(${h.getByOffset(`index${x}`)}[component${x}]);
        `;g=`
        let outputOffset = global_idx * ${l};
        var value = vec4<u32>(0);
        ${_("value",0,"u32")}
        ${_("value",1,"u32")}
        ${_("value",2,"u32")}
        ${_("value",3,"u32")}
        ${y.setByOffset("global_idx","value")}
      `}else g=`
      let outputIndices = ${y.offsetToIndices("global_idx")};
      ${M("")};
      let value = ${h.getByIndices("dataIndices")};
      ${y.setByOffset("global_idx","value")};
      `;return`
      ${d.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(h,m,y)}
      ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${g}
      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c}),getShaderSource:f}},GW=e=>Zn({axis:e.axis}),jW=(e,t)=>{let n=e.inputs;PN(n),e.compute(kN(e.inputs,t))}}),DN,WW,HW,fse=ft(()=>{Qt(),un(),dn(),DN=(e,t,n,i,r,s,a,o,l)=>{let u=[{type:12,data:s},{type:12,data:i},{type:12,data:r},{type:12,data:n},{type:12,data:a},{type:12,data:o},{type:12,data:l}],c=[s];u.push(...Ut(t.dims,c));let f=d=>{let h=Ze("indices_data",t.dataType,t.dims.length),m=Rt("input_slice_offsets_data",12,1,1),y=[h,m],M=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:r.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${d.registerUniforms(M).declareVariables(...y)}
  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${r.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${n.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${r.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:c,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:u}),getShaderSource:f},{inputs:[t],outputs:[-1]})[0]},WW=(e,t)=>{let n=e.inputs,i=n[0].dims,r=n[0].dataType,s=n[1].dims,a=s[s.length-1],o=qe.sizeToDimension(s,s.length-1),l=qe.sizeFromDimension(i,t.batchDims+a),u=qe.sizeToDimension(i,t.batchDims),c=qe.sizeFromDimension(i,t.batchDims),f=o/u,d=new Array(a),h=l;for(let x=0;x<a;++x)d[a-1-x]=h,h*=i[t.batchDims+a-1-x];let m=DN(e,n[1],d,t.batchDims,i,o,f,c,a),y=t.batchDims+a;if(y>i.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let M=s.slice(0,-1).concat(i.slice(y)),g=qe.size(M),_=[{type:12,data:g},{type:12,data:l},...Ut(n[0].dims,m.dims,M)],T=x=>{let S=Ze("data",n[0].dataType,n[0].dims.length),$=Ze("slice_offsets",12,m.dims.length),C=Rt("output",n[0].dataType,M.length);return`
          ${x.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(S,$,C)}
            ${x.mainStart()}
            ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:M,dataType:r}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:_}),getShaderSource:T},{inputs:[n[0],m]})},HW=e=>({batchDims:e.batch_dims,cacheKey:""})}),ON,RN,qW,KW,pse=ft(()=>{Qt(),un(),Vi(),dn(),ON=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=qe.normalizeAxis(t.quantizeAxis,e[0].dims.length),i=t.blockSize,r=e[0],s=e[2],a=e.length===4?e[3]:void 0;if(s.dims.length!==r.dims.length||!r.dims.map((o,l)=>l===n?Math.ceil(o/i)===s.dims[l]:o===s.dims[l]).reduce((o,l)=>o&&l,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(a){if(a.dataType!==r.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(a.dims.length!==s.dims.length||!a.dims.map((o,l)=>o===s.dims[l]).reduce((o,l)=>o&&l,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},RN=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n.length,s=qe.normalizeAxis(t.gatherAxis,r),a=qe.normalizeAxis(t.quantizeAxis,r),o=n.slice(0);o.splice(s,1,...i);let l=qe.size(o),u=e[2].dataType,c=e[0].dataType===22,f=[{type:12,data:l},{type:12,data:a},{type:12,data:s},{type:12,data:t.blockSize},...Ut(...e.map((h,m)=>h.dims),o)],d=h=>{let m=Ze("data",e[0].dataType,e[0].dims.length),y=Ze("inputIndices",e[1].dataType,e[1].dims.length),M=Ze("scales",e[2].dataType,e[2].dims.length),g=e.length>3?Ze("zeroPoint",e[3].dataType,e[3].dims.length):void 0,_=Rt("output",u,o.length),T=[m,y,M];g&&T.push(g);let x=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${h.registerUniforms(x).declareVariables(...T,_)}
        ${h.mainStart()}
        let output_indices = ${_.offsetToIndices("global_idx")};
        var indices_indices = ${y.type.indices}(0);
        ${i.length>1?`
          for (var i: u32 = 0; i < ${i.length}; i++) {
            let index = ${_.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${y.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${_.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${m.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${_.indicesGet("output_indices","i")};
          ${m.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${y.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${n[s]};
        }
        ${m.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${o.length}; i++) {
          let index = ${_.indicesGet("output_indices",`i + ${i.length} - 1`)};
          ${m.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${m.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${m.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${M.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${M.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${M.getByIndices("scale_indices")};
        ${g?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${g.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${g.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${Lr(u)}(quantized_data - zero_point) * scale;
        ${_.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter((h,m)=>m!==1).map(h=>h.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:e.length},(h,m)=>"rank")},getRunData:()=>({outputs:[{dims:o,dataType:u}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:f}),getShaderSource:d}},qW=(e,t)=>{let n=e.inputs;ON(n,t),e.compute(RN(e.inputs,t))},KW=e=>Zn({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})}),NN,LN,JW,YW,hse=ft(()=>{Qt(),un(),Vi(),dn(),NN=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},LN=(e,t)=>{let n=e[0].dims,i=e[0].dataType,r=n.length,s=e[1].dims,a=e[1].dataType,o=qe.normalizeAxis(t.axis,r),l=n[o],u=s.slice(0),c=qe.size(u),f=Ze("input",i,r),d=Ze("indicesInput",a,s.length),h=Rt("output",i,u.length),m=[{type:12,data:c},{type:6,data:l},{type:12,data:o}];return m.push(...Ut(n,s,u)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:m}),getShaderSource:y=>`
      ${y.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(f,d,h)}
      ${y.mainStart()}
      ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${h.offsetToIndices("global_idx")};

      var idx = ${d.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${f.type.indices}(outputIndices);
      ${f.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${f.getByIndices("inputIndices")};

      ${h.setByOffset("global_idx","value")};
  }`}},JW=e=>Zn({axis:e.axis}),YW=(e,t)=>{let n=e.inputs;NN(n),e.compute(LN(e.inputs,t))}}),zN,FN,XW,QW,mse=ft(()=>{Qt(),un(),dn(),zN=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},FN=(e,t)=>{let n=e[0].dims.slice(),i=e[1].dims.slice(),[r,s,a]=J8.getShapeOfGemmResult(n,t.transA,i,t.transB,e.length===3?e[2].dims:void 0),o=[r,s];if(!o)throw new Error("Can't use gemm on the given tensors");let l=16,u=Math.ceil(s/l),c=Math.ceil(r/l),f=!0,d=qe.size(o),h=[{type:12,data:f?u:d},{type:12,data:r},{type:12,data:s},{type:12,data:a},{type:1,data:t.alpha},{type:1,data:t.beta}],m=["type","type"];e.length===3&&(h.push(...Ut(e[2].dims)),m.push("rank")),h.push(...Ut(o));let y=g=>{let _="";t.transA&&t.transB?_="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?_="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?_="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(_="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let T=t.alpha===1?"":"value *= uniforms.alpha;",x=Ze("a",e[0].dataType,e[0].dims),S=Ze("b",e[1].dataType,e[1].dims),$=x.type.value,C=null,P=[x,S];e.length===3&&(C=Ze("c",e[2].dataType,e[2].dims.length),P.push(C));let O=Rt("output",e[0].dataType,o.length);P.push(O);let R=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${g.registerUniforms(R).declareVariables(...P)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${$}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${_}
    }

    ${T}
    ${C!=null?`let cOffset = ${C.broadcastedIndicesToOffset("vec2(m, n)",O)}; value += ${$}(uniforms.beta) * ${C.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},M=g=>{let _=Ze("a",e[0].dataType,e[0].dims),T=Ze("b",e[1].dataType,e[1].dims),x=null,S=[_,T];e.length===3&&(x=Ze("c",e[2].dataType,e[2].dims.length),S.push(x));let $=Rt("output",e[0].dataType,o.length);S.push($);let C=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],P="",O="";t.transA&&t.transB?(O=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,P="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(O=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,P="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(O=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,P="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(O=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,P="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let R=t.alpha===1?"":"value *= uniforms.alpha;";return`
  ${g.registerUniforms(C).declareVariables(...S)}
  var<workgroup> tile_a: array<array<${_.type.storage}, ${l}>, ${l}>;
  var<workgroup> tile_b: array<array<${T.type.storage}, ${l}>, ${l}>;
  ${g.mainStart([l,l,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};
    let num_tiles = (uniforms.K - 1) / ${l} + 1;
    var k_start = 0u;
    var value = ${$.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${O}
      k_start = k_start + ${l};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${l}; k++) {
        ${P}
      }
      workgroupBarrier();
    }

    ${R}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${x!=null?`let cOffset = ${x.broadcastedIndicesToOffset("vec2(m, n)",$)}; value += ${$.type.value}(uniforms.beta) * ${x.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return f?{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u*c},programUniforms:h}),getShaderSource:M}:{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:y}},XW=e=>{let t=e.transA,n=e.transB,i=e.alpha,r=e.beta;return{transA:t,transB:n,alpha:i,beta:r,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},QW=(e,t)=>{zN(e.inputs),e.compute(FN(e.inputs,t))}}),qa,bo,wu,bu,BN,UN,VN,GN,jN,WN,HN,qN,ZW,e5,gse=ft(()=>{Qt(),un(),Vi(),dn(),[qa,bo,wu,bu]=[0,1,2,3],BN=e=>{if(e[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${e[0].dims.length-2}`);if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},UN=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,VN=e=>`
  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,GN=e=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${e.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,jN=e=>`
  ${e.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,WN=(e,t,n)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {
     var pixel = ${t}(0);
     var indices = vec4<u32>(0);
     indices[${qa}] = batch;
     indices[${bo}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${wu}] = u32(r);
            indices[${bu}] = u32(c);
          } else {
            return ${t}(0);
          }
        `;case"border":return`
          indices[${wu}] = u32(clamp(r, 0, H - 1));
          indices[${bu}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${wu}] = gs_reflect(r, border[1], border[3]);
          indices[${bu}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`
    return ${e.getByIndices("indices")};
  }
`,HN=(e,t,n)=>(()=>{switch(n.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${qa}], indices[${bo}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${qa}], indices[${bo}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${qa}], indices[${bo}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${qa}], indices[${bo}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${qa}], indices[${bo}], border);

          let dx2 = ${t}(f32(x2) - x);
          let dx1 = ${t}(x - f32(x1));
          let dy2 = ${t}(f32(y2) - y);
          let dy1 = ${t}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${t}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${qa}], indices[${bo}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,qN=(e,t)=>{let n=Ze("x",e[0].dataType,e[0].dims.length),i=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],r=Ze("grid",e[1].dataType,i.length,2),s=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];t.format==="NHWC"&&(s=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[qa,bo,wu,bu]=[0,3,1,2]);let a=Rt("output",e[0].dataType,s.length),o=n.type.value,l=qe.size(s),u=[{type:12,data:l},...Ut(e[0].dims,i,s)],c=f=>`
  ${f.registerUniform("output_size","u32").declareVariables(n,r,a)}
  ${UN}
  ${VN(o)}
  ${GN(t)}
  ${jN(t)}
  ${WN(n,o,t)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${wu}]);
      let W_in = i32(uniforms.x_shape[${bu}]);

      ${t.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${a.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${qa}], indices[${wu}], indices[${bu}]);
      let nxy = ${r.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${HN(a,o,t)}
  }`;return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:f=>{let d=qe.size(s);return{outputs:[{dims:s,dataType:f[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:u}},getShaderSource:c}},ZW=(e,t)=>{BN(e.inputs),e.compute(qN(e.inputs,t))},e5=e=>Zn({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})}),jr,KN,t5,ew,JN,Lf,n5,i5=ft(()=>{Qt(),un(),Vi(),kT(),RT(),dn(),Yl(),jr=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,KN=(e,t)=>{let n=e[0],i=jr(e,1),r=jr(e,2),s=jr(e,3),a=jr(e,4),o=jr(e,5),l=jr(e,6),u=jr(e,7);if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let c=n.dims[0],f=n.dims[1],d=n.dims.length===3?n.dims[2]:t.numHeads*n.dims[4],h=f,m=0,y=0,M=Math.floor(d/t.numHeads);if(l&&u&&qe.size(l.dims)&&qe.size(u.dims)){if(l.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(l.dims[0]!==c||l.dims[1]!==t.numHeads||l.dims[3]!==M)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(u.dims[0]!==c||u.dims[1]!==t.numHeads||u.dims[3]!==M)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==u.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(u.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');m=l.dims[2],y=l.dims[2]}else if(l&&qe.size(l.dims)||u&&qe.size(u.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let g;if(i&&qe.size(i.dims)>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(i.dims.length===3){if(i.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');g=2,h=i.dims[1]}else if(i.dims.length===5){if(i.dims[2]!==t.numHeads||i.dims[3]!==2||i.dims[4]!==M)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');g=5,h=i.dims[1]}else{if(i.dims[1]!==t.numHeads||i.dims[3]!==M)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');g=0,h=i.dims[2]}}else{if(n.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==t.numHeads||n.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');g=3}if(s&&qe.size(s.dims)>0){if(s.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(i&&i.dims.length===5&&i.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let _=m+h,T=0;if(a&&qe.size(a.dims)>0){T=8;let C=a.dims;throw C.length===1?C[0]===c?T=1:C[0]===3*c+2&&(T=3):C.length===2&&C[0]===c&&C[1]===_&&(T=5),T===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let x=!1,S=d;if(r&&qe.size(r.dims)>0){if(r.dims.length!==3&&r.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(r.dims.length===3){if(h!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');S=r.dims[2]}else{if(h!==r.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');S=r.dims[1]*r.dims[3],x=!0}}let $=!1;if(a&&qe.size(a.dims)>0)throw new Error("Key padding mask is not supported");if(o&&qe.size(o.dims)>0){if(o.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(o.dims[0]!==c||o.dims[1]!==t.numHeads||o.dims[2]!==f||o.dims[3]!==_)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:c,sequenceLength:f,pastSequenceLength:m,kvSequenceLength:h,totalSequenceLength:_,maxSequenceLength:y,inputHiddenSize:0,hiddenSize:d,vHiddenSize:S,headSize:M,vHeadSize:Math.floor(S/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:T,scale:t.scale,broadcastResPosBias:$,passPastInKv:x,qkvFormat:g}},t5=e=>Zn({...e}),ew=Zn({perm:[0,2,1,3]}),JN=(e,t,n,i,r,s,a)=>{let o=[i,r,s],l=qe.size(o),u=[{type:12,data:l},{type:12,data:a},{type:12,data:s}],c=f=>{let d=Rt("qkv_with_bias",t.dataType,o),h=Ze("qkv",t.dataType,o),m=Ze("bias",n.dataType,o),y=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${f.registerUniforms(y).declareVariables(h,m,d)}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u}),getShaderSource:c},{inputs:[t,n],outputs:[-1]})[0]},Lf=(e,t,n,i,r,s,a,o)=>{let l=s;if(a&&qe.size(a.dims)>0){if(i===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=JN(e,s,a,t,i,n*r,o),l=l.reshape([t,i,n,r]),n===1||i===1?l:e.compute(Es(l,ew.perm),{inputs:[l],outputs:[-1]})[0]}else return s.dims.length===3&&(l=s.reshape([t,i,n,r])),n===1||i===1?l:e.compute(Es(l,ew.perm),{inputs:[l],outputs:[-1]})[0]},n5=(e,t)=>{let n=KN(e.inputs,t),i=e.inputs[0],r=jr(e.inputs,1),s=jr(e.inputs,2),a=jr(e.inputs,3),o=jr(e.inputs,4),l=jr(e.inputs,5),u=jr(e.inputs,6),c=jr(e.inputs,7);if(i.dims.length===5)throw new Error("Packed QKV is not implemented");if((r==null?void 0:r.dims.length)===5)throw new Error("Packed KV is not implemented");let f=r&&s&&r.dims.length===4&&s.dims.length===4,d=Lf(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,i,a,0);if(f)return bp(e,d,r,s,o,void 0,u,c,l,n);if(!r||!s)throw new Error("key and value must be provided");let h=Lf(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,r,a,n.hiddenSize),m=Lf(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,s,a,2*n.hiddenSize);bp(e,d,h,m,o,void 0,u,c,l,n)}}),YN,XN,QN,ZN,w1,r5,s5,a5=ft(()=>{Qt(),un(),Vi(),dn(),YN=e=>{if(!e||e.length<1)throw new Error("too few inputs")},XN=(e,t)=>{let n=[],i=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(r=>n.push(Number(r))),i=n.length),Zn({numOutputs:i,axis:t.axis,splitSizes:n})},QN=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < ${zt("uniforms.size_in_split_axis","i",e)}) {
        return i;
    }
    }
    return ${e}u;
}`,ZN=e=>{let t=e.length,n=[];for(let i=0;i<t;++i){let r=e[i].setByIndices("indices","input[global_idx]");t===1?n.push(r):i===0?n.push(`if (output_number == ${i}u) { ${r} }`):i===t-1?n.push(`else { ${r} }`):n.push(`else if (output_number == ${i}) { ${r} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${n.join(`
`)}
      }`},w1=(e,t)=>{let n=e[0].dims,i=qe.size(n),r=e[0].dataType,s=qe.normalizeAxis(t.axis,n.length),a=new Array(t.numOutputs),o=Ze("input",r,n.length),l=new Array(t.numOutputs),u=[],c=[],f=0,d=[{type:12,data:i}];for(let m=0;m<t.numOutputs;m++){f+=t.splitSizes[m],l[m]=f;let y=n.slice();y[s]=t.splitSizes[m],c.push(y),a[m]=Rt(`output${m}`,r,y.length),u.push({dims:c[m],dataType:e[0].dataType})}d.push({type:12,data:l},...Ut(n,...c));let h=m=>`
  ${m.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(o,...a)}
  ${QN(l.length)}
  ${ZN(a)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${o.offsetToIndices("global_idx")};
    var index = ${o.indicesGet("indices",s)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${zt("uniforms.size_in_split_axis","output_number - 1u",l.length)};
      ${o.indicesSet("indices",s,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:h,getRunData:()=>({outputs:u,dispatchGroup:{x:Math.ceil(i/64)},programUniforms:d})}},r5=(e,t)=>{YN(e.inputs);let n=e.inputs.length===1?t:XN(e.inputs,t);e.compute(w1(e.inputs,n),{inputs:[0]})},s5=e=>{let t=e.axis,n=e.splitSizes,i=e.numOutputs<0?n.length:e.numOutputs;if(i!==n.length)throw new Error("numOutputs and splitSizes length must be equal");return Zn({axis:t,numOutputs:i,splitSizes:n})}}),eL,Sg,o5,l5=ft(()=>{Qt(),un(),Vi(),dn(),eL=(e,t)=>{let[n,i,r,s]=e,{numHeads:a,rotaryEmbeddingDim:o}=t;if(n.dims.length!==3&&n.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!qe.areEqual(i.dims,[])&&!qe.areEqual(i.dims,[1])&&i.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${i.dims.length}`);if(r.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${r.dims.length}`);if(s.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${s.dims.length}`);if(!qe.areEqual(r.dims,s.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(o>0&&a===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let l=n.dims[0],u=n.dims[n.dims.length-2],c=r.dims[0],f=qe.sizeFromDimension(n.dims,1)/u,d=o===0?r.dims[1]*2:f/a;if(o>d)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(i.dims.length===2){if(l!==i.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${i.dims[0]}`);if(u!==i.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${i.dims[1]}`)}if(d/2!==r.dims[1]&&o/2!==r.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${r.dims[1]}`);if(u>c)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},Sg=(e,t)=>{let{interleaved:n,numHeads:i,rotaryEmbeddingDim:r,scale:s}=t,a=e[0].dims[0],o=qe.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],u=o/l,c=e[2].dims[1],f=r===0?c*2:u/i,d=new Array(a,l,u/f,f-c),h=qe.computeStrides(d),m=[{type:1,data:s},{type:12,data:d},{type:12,data:h},...e[0].dims.length===3?new Array({type:12,data:[o,u,f,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[o,f,l*f,1]}):[],...Ut(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],y=M=>{let g=Ze("input",e[0].dataType,e[0].dims.length),_=Ze("position_ids",e[1].dataType,e[1].dims.length),T=Ze("cos_cache",e[2].dataType,e[2].dims.length),x=Ze("sin_cache",e[3].dataType,e[3].dims.length),S=Rt("output",e[0].dataType,e[0].dims.length);return M.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:d.length},{name:"global_strides",type:"u32",length:h.length},{name:"input_output_strides",type:"u32",length:h.length}]),`
        ${M.declareVariables(g,_,T,x,S)}

        ${M.mainStart($d)}
          let half_rotary_emb_dim = uniforms.${T.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${M.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${_.broadcastedIndicesToOffset("bsnh.xy",Rt("",_.type.tensor,2))};
            let position_id =
                u32(${_.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});
            let j = i + select(half_rotary_emb_dim, 1, ${n});
            let re = ${g.getByOffset("i")} * ${T.get("position_id","bsnh[3]")} -
                ${g.getByOffset("j")} * ${x.get("position_id","bsnh[3]")};
            ${S.setByOffset("i","re")}
            let im = ${g.getByOffset("i")} * ${x.get("position_id","bsnh[3]")} +
                ${g.getByOffset("j")} * ${T.get("position_id","bsnh[3]")};
            ${S.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${S.setByOffset("k",g.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:Zn({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(qe.size(d)/$d)},programUniforms:m})}},o5=(e,t)=>{eL(e.inputs,t),e.compute(Sg(e.inputs,t))}}),tL,nL,tw,iL,u5,_se=ft(()=>{Vi(),Qt(),RT(),i5(),a5(),Yl(),l5(),dn(),tL=(e,t)=>{if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=e[0],i=e[1],r=e[2],s=e[3],a=e[4];if(t.doRotary!==0&&e.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(t.localWindowSize!==-1)throw new Error("Local attention is not supported");if(t.softcap!==0)throw new Error("Softcap is not supported");if(t.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let o=!1,l=n.dims[0],u=n.dims[1],c=n.dims.length===3?o?n.dims[2]/3:n.dims[2]:t.numHeads*n.dims[4],f=u,d=0,h=!i||i.dims.length===0,m=Math.floor(h?c/(t.numHeads+2*t.kvNumHeads):c/t.numHeads);h&&(c=m*t.numHeads);let y=s&&s.dims.length!==0,M=a&&a.dims.length!==0;if(y&&s.dims.length===4&&s.dims[0]===l&&s.dims[1]!==t.kvNumHeads&&s.dims[2]===t.kvNumHeads&&s.dims[3]===m)throw new Error("BSNH pastKey/pastValue is not supported");if(y&&M){if(s.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(a.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');d=s.dims[2]}else if(y||M)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let g=1;if(i&&i.dims.length>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(i.dims.length===3){if(n.dims[2]%i.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');f=i.dims[1]}else if(i.dims.length===5){if(i.dims[2]!==t.numHeads||i.dims[3]!==2||i.dims[4]!==m)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');f=i.dims[1]}else{if(i.dims[1]!==t.numHeads||i.dims[3]!==m)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');f=i.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==t.numHeads||n.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');g=3}let _=0,T=!1,x=t.kvNumHeads?m*t.kvNumHeads:c;if(r&&r.dims.length>0){if(r.dims.length!==3&&r.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(r.dims.length===3){if(f!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');x=r.dims[2]}else{if(f!==r.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');x=r.dims[1]*r.dims[3],T=!0}}let S=e.length>4?e[5]:void 0;if(S&&S.dims.length!==1&&S.dims[0]!==l)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:l,sequenceLength:u,pastSequenceLength:d,kvSequenceLength:f,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:c,vHiddenSize:x,headSize:m,vHeadSize:Math.floor(x/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:_,scale:t.scale,broadcastResPosBias:!1,passPastInKv:T,qkvFormat:g}},nL=Zn({perm:[0,2,1,3]}),tw=(e,t,n)=>{let i=t,r=n.kvNumHeads;return t.dims.length===3&&n.kvSequenceLength!==0&&(i=t.reshape([n.batchSize,n.kvSequenceLength,r,n.headSize]),i=e.compute(Es(i,nL.perm),{inputs:[i],outputs:[-1]})[0]),i},iL=(e,t,n,i)=>{let r=7,s=["type","type"],a=[e*t],o=e*t,l=[{type:12,data:o},{type:12,data:t},{type:12,data:e}],u=c=>{let f=Ze("seq_lens",n.dataType,n.dims),d=Ze("total_seq_lens",i.dataType,i.dims),h=Rt("pos_ids",r,a),m=[{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}];return`
  ${c.registerUniforms(m).declareVariables(f,d,h)}
  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${d.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${f.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${h.setByOffset("global_idx","pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${h.setByOffset("global_idx","pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${h.setByOffset("global_idx","seqlen")}
    };
  }
  `};return{name:"GeneratePositionIds",shaderCache:{hint:`${e};${t}`,inputDependencies:s},getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:l}),getShaderSource:u}},u5=(e,t)=>{var x;let n=tL(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((x=e.inputs[1])==null?void 0:x.dims.length)===5)throw new Error("Packed KV is not implemented");let i=e.inputs[0],r=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,s=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,a=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,o=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,u=e.inputs.length>5?e.inputs[6]:void 0,c=n.kvNumHeads?n.kvNumHeads:n.numHeads,f=Zn({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,c*n.headSize,c*n.headSize]}),[d,h,m]=!r&&!s?e.compute(w1([i],f),{inputs:[i],outputs:[-1,-1,-1]}):[i,r,s],y,M;if(t.doRotary){let S=e.compute(iL(n.batchSize,n.sequenceLength,l,u),{inputs:[l,u],outputs:[-1]})[0],$=e.inputs[7],C=e.inputs[8],P=Zn({interleaved:t.rotaryInterleaved!==0,numHeads:n.numHeads,rotaryEmbeddingDim:0,scale:t.scale}),O=[d,S,$,C],R=[-1];y=e.compute(Sg(O,P),{inputs:O,outputs:R})[0],O.splice(0,1,h);let G=Zn({interleaved:t.rotaryInterleaved!==0,numHeads:n.kvNumHeads,rotaryEmbeddingDim:0,scale:t.scale});M=e.compute(Sg(O,G),{inputs:O,outputs:R})[0]}let g=Lf(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,t.doRotary?y:d,void 0,0),_=tw(e,t.doRotary?M:h,n),T=tw(e,m,n);bp(e,g,_,T,void 0,void 0,a,o,void 0,n,l,u)}}),nw,rL,sL,c5,yse=ft(()=>{Qt(),un(),Yl(),dn(),nw=(e,t,n,i,r,s,a,o)=>{let l=Fi(s),u=l===1?"f32":`vec${l}f`,c=l===1?"vec2f":`mat2x${l}f`,f=r*a,d=64;f===1&&(d=256);let h=[r,a,s/l],m=[r,a,2],y=["rank","type","type"],M=[];M.push(...Ut(h,m));let g=_=>{let T=Ze("x",t.dataType,3,l),x=Ze("scale",n.dataType,n.dims),S=Ze("bias",i.dataType,i.dims),$=Rt("output",1,3,2),C=[T,x,S,$];return`
  var<workgroup> workgroup_shared : array<${c}, ${d}>;
  const workgroup_size = ${d}u;
  ${_.declareVariables(...C)}
  ${_.mainStart(d)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${u}(0);
    var squared_sum = ${u}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${u}(${T.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${c}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Wl("workgroup_shared[0][0]",l)} / f32(hight * ${l});
      let squared_sum_final = ${Wl("workgroup_shared[0][1]",l)} / f32(hight * ${l});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${o}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${o};${d}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:m,dataType:1}],dispatchGroup:{x:f},programUniforms:M}),getShaderSource:g},{inputs:[t,n,i],outputs:[-1]})[0]},rL=(e,t,n)=>{let i=t[0].dims,r=i,s=2,a=i[0],o=i[1],l=qe.sizeFromDimension(i,s),u=Fi(l),c=qe.size(r)/u,f=nw(e,t[0],t[1],t[2],a,l,o,n.epsilon),d=[a,o,l/u],h=[a,o],m=["type","none"],y=M=>{let g=Ze("x",t[0].dataType,d.length,u),_=Ze("scale_shift",1,h.length,2),T=Rt("output",t[0].dataType,d.length,u),x=[g,_,T];return`
  ${M.registerUniform("output_size","u32").declareVariables(...x)}
  ${M.mainStart()}
  ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${T.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${_.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${g.getByOffset("global_idx")} * ${T.type.value}(scale_shift.x) + ${T.type.value}(scale_shift.y);
      ${T.setByOffset("global_idx","value")};
  }`};e.compute({name:"InstanceNormalization",shaderCache:{hint:`${u}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:[{type:12,data:c},...Ut(d,h,d)]}),getShaderSource:y},{inputs:[t[0],f]})},sL=(e,t,n)=>{let i=t[0].dims,r=i,s=i[0],a=i[i.length-1],o=qe.sizeFromDimension(i,1)/a,l=Fi(a),u=qe.size(r)/l,c=[{type:12,data:o},{type:12,data:Math.floor(a/l)}],f=["type","type"],d=!1,h=[0,i.length-1];for(let g=0;g<i.length-2;g++)d=d||i[g+1]!==1,h.push(g+1);d=d&&i[i.length-1]!==1;let m=d?e.compute(Es(e.inputs[0],h),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:i.length},(g,_)=>i[h[_]])),y=nw(e,m,t[1],t[2],s,o,a,n.epsilon),M=g=>{let _=mr(t[0].dataType),T=l===1?"vec2f":`mat${l}x2f`,x=C=>{let P=C===0?"x":"y",O=l===1?"f32":`vec${l}f`;switch(l){case 1:return`${_}(${O}(scale.${P}))`;case 2:return`vec2<${_}>(${O}(scale[0].${P}, scale[1].${P}))`;case 4:return`vec4<${_}>(${O}(scale[0].${P}, scale[1].${P}, scale[2].${P}, scale[3].${P}))`;default:throw new Error(`Not supported compoents ${l}`)}},S=Ze("input",t[0].dataType,t[0].dims,l),$=Rt("output",t[0].dataType,r,l);return`
  @group(0) @binding(0) var<storage, read> input : array<${S.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${T}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${$.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${g.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${x(0)}, ${x(1)});
  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c}),getShaderSource:M},{inputs:[t[0],y]})},c5=(e,t)=>{t.format==="NHWC"?sL(e,e.inputs,t):rL(e,e.inputs,t)}}),aL,oL,d5,vse=ft(()=>{Qt(),un(),dn(),aL=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},oL=(e,t,n)=>{let i=t.simplified,r=e[0].dims,s=e[1],a=!i&&e[2],o=r,l=qe.normalizeAxis(t.axis,r.length),u=qe.sizeToDimension(r,l),c=qe.sizeFromDimension(r,l),f=qe.size(s.dims),d=a?qe.size(a.dims):0;if(f!==c||a&&d!==c)throw new Error(`Size of X.shape()[axis:] == ${c}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${f} and bias size of ${d}`);let h=[];for(let S=0;S<r.length;++S)S<l?h.push(r[S]):h.push(1);let m=Fi(c),y=["type","type"],M=[{type:12,data:u},{type:1,data:c},{type:12,data:Math.floor(c/m)},{type:1,data:t.epsilon}];a&&y.push("type");let g=n>1,_=n>2,T=S=>{let $=mr(e[0].dataType),C=[Ze("x",e[0].dataType,e[0].dims,m),Ze("scale",s.dataType,s.dims,m)];a&&C.push(Ze("bias",a.dataType,a.dims,m)),C.push(Rt("output",e[0].dataType,o,m)),g&&C.push(Rt("mean_data_output",1,h)),_&&C.push(Rt("inv_std_output",1,h));let P=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${S.registerUniforms(P).declareVariables(...C)}
  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${d1("f32",m)};
    var mean_square_vector = ${d1("f32",m)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${rd($,m,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Wl("mean_vector",m)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Wl("mean_square_vector",m)} / uniforms.norm_size ${i?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${rd($,m,"x[j + offset]")};
      let f32scale = ${rd($,m,"scale[j]")};
      output[j + offset] = ${C[0].type.value}((f32input ${i?"":"- mean"}) * inv_std_dev * f32scale
        ${a?`+ ${rd($,m,"bias[j]")}`:""}
      );
    }

    ${g?"mean_data_output[global_idx] = mean":""};
    ${_?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},x=[{dims:o,dataType:e[0].dataType}];return g&&x.push({dims:h,dataType:1}),_&&x.push({dims:h,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${m};${n};${i}`,inputDependencies:y},getRunData:()=>({outputs:x,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:M}),getShaderSource:T}},d5=(e,t)=>{aL(e.inputs),e.compute(oL(e.inputs,t,e.outputCount))}}),lL,f5,wse=ft(()=>{un(),BT(),UT(),lL=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},f5=e=>{lL(e.inputs);let t=Cd.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let n=t[t.length-1],i=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&i<8)e.compute(FT(e.inputs,{activation:""},t));else{let r=t[t.length-2],s=qe.size(e.inputs[0].dims.slice(0,-2)),a=qe.size(e.inputs[1].dims.slice(0,-2));if(s!==1&&r===1&&a===1){let o=e.inputs[0].reshape([1,s,i]),l=e.inputs[1].reshape([1,i,n]),u=[1,s,n],c=[o,l];e.compute(Eg(c,{activation:""},t,u),{inputs:c})}else e.compute(Eg(e.inputs,{activation:""},t))}}}),uL,cL,dL,p5,h5,bse=ft(()=>{Qt(),un(),Vi(),dn(),uL=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=e[0],i=n.dims.length;if(n.dims[i-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let r=Math.floor((t.k+t.blockSize-1)/t.blockSize),s=t.blockSize/8*t.bits,a=e[1];if(!qe.areEqual(a.dims,[t.n,r,s]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let o=e[2].dims;if(qe.size(o)!==t.n*r)throw new Error("scales input size error.");if(e.length===4){let l=e[3].dims,u=t.n*(t.bits===8?r:Math.floor((r*t.bits+7)/8));if(qe.size(l)!==u)throw new Error("zeroPoints input size error.")}},cL=(e,t)=>{let n=e[0].dims,i=n.length,r=n[i-2],s=t.k,a=t.n,o=n.slice(0,i-2),l=qe.size(o),u=e[1].dims[2]/4,c=e[0].dataType,f=Fi(t.k),d=Fi(u),h=Fi(a),m=o.concat([r,a]),y=r>1&&a/h%2===0?2:1,M=qe.size(m)/h/y,g=64,_=[],T=[l,r,s/f],x=qe.convertShape(e[1].dims).slice();x.splice(-1,1,u/d),_.push(...Ut(T)),_.push(...Ut(x)),_.push(...Ut(e[2].dims)),e.length===4&&_.push(...Ut(qe.convertShape(e[3].dims)));let S=[l,r,a/h];_.push(...Ut(S));let $=C=>{let P=T.length,O=Ze("a",e[0].dataType,P,f),R=Ze("b",12,x.length,d),G=Ze("scales",e[2].dataType,e[2].dims.length),W=[O,R,G],V=e.length===4?Ze("zero_points",12,e[3].dims.length):void 0;V&&W.push(V);let te=S.length,J=Rt("output",e[0].dataType,te,h),j=mr(e[0].dataType),Y=(()=>{switch(f){case 1:return`array<${j}, 8>`;case 2:return`mat4x2<${j}>`;case 4:return`mat2x4<${j}>`;default:throw new Error(`${f}-component is not supported.`)}})(),X=()=>{let Q=`
          // reuse a data
            var input_offset = ${O.indicesToOffset(`${O.type.indices}(batch, row, word_offset)`)};
            var a_data: ${Y};
            for (var j: u32 = 0; j < ${8/f}; j++) {
              a_data[j] = ${O.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let H=0;H<h*y;H++)Q+=`
            b_value = ${d===1?`b${H}_data`:`b${H}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${Y}(${Array.from({length:4},(B,ee)=>`${j}(b_value_lower[${ee}]), ${j}(b_value_upper[${ee}])`).join(", ")});
            b_dequantized_values = ${f===1?`${Y}(${Array.from({length:8},(B,ee)=>`(b_quantized_values[${ee}] - ${V?`zero_point${H}`:"zero_point"}) * scale${H}`).join(", ")});`:`(b_quantized_values - ${Y}(${Array(8).fill(`${V?`zero_point${H}`:"zero_point"}`).join(",")})) * scale${H};`};
            workgroup_shared[local_id.x * ${y} + ${Math.floor(H/h)}]${h>1?`[${H%h}]`:""} += ${Array.from({length:8/f},(B,ee)=>`${f===1?`a_data[${ee}] * b_dequantized_values[${ee}]`:`dot(a_data[${ee}], b_dequantized_values[${ee}])`}`).join(" + ")};
          `;return Q},ce=()=>{let Q=`
            var col_index = col * ${h};
            ${V?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${j}(8);`}
            `;for(let H=0;H<h*y;H++)Q+=`
            let scale${H} = ${G.getByOffset("col_index * nBlocksPerCol + block")};
            ${V?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${V.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${H} = ${j}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return Q},me=()=>{let Q=`col_index = col * ${h};`;for(let H=0;H<h*y;H++)Q+=`
            let b${H}_data = ${R.getByIndices(`${R.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return Q+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${Y};
            var b_dequantized_values: ${Y};`,Q};return`
        var<workgroup> workgroup_shared: array<${J.type.value}, ${y*g}>;
        ${C.declareVariables(...W,J)}
        ${C.mainStart([g,1,1])}
          let output_indices = ${J.offsetToIndices(`(global_idx / ${g}) * ${y}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${g}) {
            //process one block
            var word_offset: u32 = block * ${t.blockSize/f};
            ${ce()}
            for (var word: u32 = 0; word < ${u}; word += ${d}) {
              ${me()}
              for (var i: u32 = 0; i < ${d}; i++) {
                ${X()}
                word_offset += ${8/f};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${y}) {
            var output_value: ${J.type.value} = ${J.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${g}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${y};
            }
            ${J.setByIndices(`${J.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${f};${d};${h};${y};${g}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:m,dataType:c}],dispatchGroup:{x:M},programUniforms:_}),getShaderSource:$}},dL=(e,t)=>{let n=e[0].dims,i=n.length,r=n[i-2],s=t.k,a=t.n,o=n.slice(0,i-2),l=qe.size(o),u=e[1].dims[2]/4,c=e[0].dataType,f=Fi(t.k),d=Fi(u),h=o.concat([r,a]),m=128,y=a%8===0?8:a%4===0?4:1,M=m/y,g=M*d*8,_=g/f,T=g/t.blockSize,x=qe.size(h)/y,S=[],$=[l,r,s/f],C=qe.convertShape(e[1].dims).slice();C.splice(-1,1,u/d),S.push(...Ut($)),S.push(...Ut(C)),S.push(...Ut(e[2].dims)),e.length===4&&S.push(...Ut(qe.convertShape(e[3].dims)));let P=[l,r,a];S.push(...Ut(P));let O=R=>{let G=$.length,W=Ze("a",e[0].dataType,G,f),V=Ze("b",12,C.length,d),te=Ze("scales",e[2].dataType,e[2].dims.length),J=[W,V,te],j=e.length===4?Ze("zero_points",12,e[3].dims.length):void 0;j&&J.push(j);let Y=P.length,X=Rt("output",e[0].dataType,Y),ce=mr(e[0].dataType),me=()=>{switch(f){case 1:return`
          let a_data0 = vec4<${ce}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${ce}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${ce}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${ce}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${f}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${W.type.value}, ${_}>;
        var<workgroup> inter_results: array<array<${X.type.value}, ${M}>, ${y}>;
        ${R.declareVariables(...J,X)}
        ${R.mainStart([M,y,1])}
          let output_indices = ${X.offsetToIndices(`workgroup_index * ${y}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${T} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${_};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${_}; a_offset += ${m})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${W.getByIndices(`${W.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${W.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${T} + local_id.x;
            ${j?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${j.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${ce}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${ce}(8);`}
            let scale = ${te.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${V.getByIndices(`${V.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${t.blockSize/f};
            for (var i: u32 = 0; i < ${d}; i++) {
              ${me()}
              let b_value = ${d===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${ce}>(${Array.from({length:4},(Q,H)=>`${ce}(b_value_lower[${H}]), ${ce}(b_value_upper[${H}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${ce}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(Q,H)=>`${`dot(a_data${H}, b_dequantized_values[${H}])`}`).join(" + ")};
              word_offset += ${8/f};
            }
            workgroupBarrier();
          }

          if (local_idx < ${y}) {
            var output_value: ${X.type.value} = ${X.type.value}(0);
            for (var b = 0u; b < ${M}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${X.setByIndices(`${X.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${f};${d};${M};${y}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:h,dataType:c}],dispatchGroup:{x},programUniforms:S}),getShaderSource:O}},p5=(e,t)=>{uL(e.inputs,t),t.blockSize===32&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(dL(e.inputs,t)):e.compute(cL(e.inputs,t))},h5=e=>Zn(e)}),fL,pL,hL,mL,gL,_L,yL,vL,m5,xse=ft(()=>{Qt(),un(),dn(),fL=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},pL=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`
            k = i32(${e.indicesGet("indices",r)}) - ${zt("uniforms.pads",r,n)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${zt("uniforms.x_shape",r,t)})) {
              break;
            }
            offset += k * i32(${zt("uniforms.x_strides",r,t)});
        `;return`
          value = ${e.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${i}
            value = x[offset];
          }
      `},hL=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`
                k = i32(${e.indicesGet("indices",r)}) - ${zt("uniforms.pads",r,n)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${zt("uniforms.x_shape",r,t)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${zt("uniforms.x_shape",r,t)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${zt("uniforms.x_strides",r,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},mL=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`
                k = i32(${e.indicesGet("indices",r)}) - ${zt("uniforms.pads",r,n)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${zt("uniforms.x_shape",r,t)})) {
                  k = i32(${zt("uniforms.x_shape",r,t)}) - 1;
                }
                offset += k * i32(${zt("uniforms.x_strides",r,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},gL=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`
                k = i32(${e.indicesGet("indices",r)}) - ${zt("uniforms.pads",r,n)};
                if (k < 0)  {
                  k += i32(${zt("uniforms.x_shape",r,t)}]);
                }
                if (k >= i32(${zt("uniforms.x_shape",r,t)})) {
                  k -= i32(${zt("uniforms.x_shape",r,t)});
                }
                offset += k * i32(${zt("uniforms.x_strides",r,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},_L=(e,t,n)=>{switch(n.mode){case 0:return pL(e,t,n.pads.length);case 1:return hL(e,t,n.pads.length);case 2:return mL(e,t,n.pads.length);case 3:return gL(e,t,n.pads.length);default:throw new Error("Invalid mode")}},yL=(e,t)=>{let n=qe.padShape(e[0].dims.slice(),t.pads),i=e[0].dims,r=qe.size(n),s=[{type:12,data:r},{type:6,data:t.pads}],a=e.length>=3&&e[2].data;t.mode===0&&s.push({type:a?e[2].dataType:1,data:t.value}),s.push(...Ut(e[0].dims,n));let o=["rank"],l=u=>{let c=Rt("output",e[0].dataType,n.length),f=Ze("x",e[0].dataType,i.length),d=f.type.value,h=_L(c,i.length,t),m=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&m.push({name:"constant_value",type:a?d:"f32"}),`
            ${u.registerUniforms(m).declareVariables(f,c)}
            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${c.offsetToIndices("global_idx")};

            var value = ${d}(0);
            ${h}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}${a}`,inputDependencies:o},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(qe.size(n)/64)},programUniforms:s}),getShaderSource:l}},vL=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),i=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,r=e[0].dims.length,s=new Int32Array(2*r).fill(0);if(e.length>=4){let o=e[3].getBigInt64Array();for(let l=0;l<o.length;l++)s[Number(o[l])]=Number(n[l]),s[Number(o[l])+r]=Number(n[l+o.length])}else n.forEach((o,l)=>s[Number(l)]=Number(o));let a=[];return s.forEach(o=>a.push(o)),{mode:t.mode,value:i,pads:a}}else return t},m5=(e,t)=>{fL(e.inputs);let n=vL(e.inputs,t);e.compute(yL(e.inputs,n),{inputs:[0]})}}),vf,iw,rw,sw,aw,wL,bL,ow,lw,g5,_5,uw,y5,v5,cw,w5,b5,x5,T5,Tse=ft(()=>{na(),Qt(),un(),dn(),vf=e=>{if(bi.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},iw=(e,t,n)=>{let i=t.format==="NHWC",r=e.dims.slice();i&&r.splice(1,0,r.pop());let s=Object.hasOwnProperty.call(t,"dilations"),a=t.kernelShape.slice(),o=t.strides.slice(),l=s?t.dilations.slice():[],u=t.pads.slice();Tg.adjustPoolAttributes(n,r,a,o,l,u);let c=Tg.computePoolOutputShape(n,r,o,l,a,u,t.autoPad),f=Object.assign({},t);s?Object.assign(f,{kernelShape:a,strides:o,pads:u,dilations:l,cacheKey:t.cacheKey}):Object.assign(f,{kernelShape:a,strides:o,pads:u,cacheKey:t.cacheKey});let d=c.slice();return d.push(d.splice(1,1)[0]),[f,i?d:c]},rw=(e,t)=>{let n=t.format==="NHWC",i=qe.size(e),r=qe.size(t.kernelShape),s=[{type:12,data:i},{type:12,data:r}],a=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let o=t.kernelShape[t.kernelShape.length-1],l=t.strides[t.strides.length-1],u=t.pads[t.pads.length/2-1],c=t.pads[t.pads.length-1],f=!!(u+c);s.push({type:12,data:o},{type:12,data:l},{type:12,data:u},{type:12,data:c}),a.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let d=!1;if(t.kernelShape.length===2){let h=t.kernelShape[t.kernelShape.length-2],m=t.strides[t.strides.length-2],y=t.pads[t.pads.length/2-2],M=t.pads[t.pads.length-2];d=!!(y+M),s.push({type:12,data:h},{type:12,data:m},{type:12,data:y},{type:12,data:M}),a.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[s,a,!0,f,d]}else{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let o=qe.computeStrides(t.kernelShape);s.push({type:12,data:o},{type:12,data:t.pads},{type:12,data:t.strides}),a.push({name:"kernelStrides",type:"u32",length:o.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let l=t.pads.reduce((u,c)=>u+c);return[s,a,!!l,!1,!1]}},sw=(e,t,n,i,r,s,a,o,l,u,c,f)=>{let d=r.format==="NHWC",h=t.type.value,m=Rt("output",t.type.tensor,i);if(r.kernelShape.length<=2){let y="",M="",g="",_=n-(d?2:1);if(c?y=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${_}] < 0 || xIndices[${_}]
                      >= uniforms.x_shape[${_}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`:y=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`,r.kernelShape.length===2){let T=n-(d?3:2);f?M=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${T}] < 0 || xIndices[${T}] >= uniforms.x_shape[${T}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:M=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;
                `,g=`
              }
            `}return`
            ${e.registerUniforms(l).declareVariables(t,m)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${m.offsetToIndices("global_idx")};
              var xIndices = ${m.offsetToIndices("global_idx")};

              var value = ${h}(${o});
              var pad = 0;
              ${M}
              ${y}
              ${g}
              ${a}

              output[global_idx] = value;
            }`}else{if(d)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let y=r.kernelShape.length,M=r.pads.length,g="";return u?g=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${s}
              }`:g=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${s}
            `,`
            ${e.registerUniforms(l).declareVariables(t,m)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${m.offsetToIndices("global_idx")};
              var xIndices = ${m.offsetToIndices("global_idx")};

              var offsets: array<u32, ${y}>;

              var value = ${h}(${o});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${y-1}u; j++) {
                  offsets[j] = offset / ${zt("uniforms.kernelStrides","j",y)};
                  offset -= offsets[j] * ${zt("uniforms.kernelStrides","j",y)};
                }
                offsets[${y-1}] = offset;

                isPad = false;
                for (var j = ${n-y}u; j < ${n}u; j++) {
                  xIndices[j] = indices[j] * ${zt("uniforms.strides",`j - ${n-y}u`,y)}
                    + offsets[j - ${n-y}u] - ${zt("uniforms.pads","j - 2u",M)};
                  ${g}
              }
              ${a}

              output[global_idx] = value;
            }`}},aw=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,wL=e=>`${aw(e)};${e.countIncludePad}`,bL=e=>`${aw(e)};${e.storageOrder};${e.dilations}`,ow=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),lw=(e,t,n,i)=>{let[r,s]=iw(t,i,n),a=Ze("x",t.dataType,t.dims.length),o=a.type.value,l="value += x_val;",u="";r.countIncludePad?u+=`value /= ${o}(uniforms.kernelSize);`:u+=`value /= ${o}(i32(uniforms.kernelSize) - pad);`;let[c,f,d,h,m]=rw(s,r);c.push(...Ut(t.dims,s));let y=["rank"];return{name:e,shaderCache:{hint:`${i.cacheKey};${d};${h};${m}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(qe.size(s)/64)},programUniforms:c}),getShaderSource:M=>sw(M,a,t.dims.length,s.length,r,l,u,0,f,d,h,m)}},g5=e=>{let t=e.count_include_pad!==0,n=ow(e);if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let i={countIncludePad:t,...n,cacheKey:""};return{...i,cacheKey:wL(i)}},_5=(e,t)=>{vf(e.inputs),e.compute(lw("AveragePool",e.inputs[0],!1,t))},uw={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},y5=e=>{let t=e.format;return{format:t,...uw,cacheKey:t}},v5=(e,t)=>{vf(e.inputs),e.compute(lw("GlobalAveragePool",e.inputs[0],!0,t))},cw=(e,t,n,i)=>{let[r,s]=iw(t,i,n),a=`
      value = max(x_val, value);
    `,o="",l=Ze("x",t.dataType,t.dims.length),u=["rank"],[c,f,d,h,m]=rw(s,r);return c.push(...Ut(t.dims,s)),{name:e,shaderCache:{hint:`${i.cacheKey};${d};${h};${m}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(qe.size(s)/64)},programUniforms:c}),getShaderSource:y=>sw(y,l,t.dims.length,s.length,r,a,o,t.dataType===10?-65504:-1e5,f,d,h,m)}},w5=(e,t)=>{vf(e.inputs),e.compute(cw("MaxPool",e.inputs[0],!1,t))},b5=e=>{let t=e.storage_order,n=e.dilations,i=ow(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let r={storageOrder:t,dilations:n,...i,cacheKey:""};return{...r,cacheKey:bL(r)}},x5=e=>{let t=e.format;return{format:t,...uw,cacheKey:t}},T5=(e,t)=>{vf(e.inputs),e.compute(cw("GlobalMaxPool",e.inputs[0],!0,t))}}),xL,TL,M5,E5,Mse=ft(()=>{Qt(),un(),Vi(),dn(),xL=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(e.length===3&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[0].dataType===6&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map((n,i)=>n===e[2].dims[i]).reduce((n,i)=>n&&i,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map((r,s)=>s===t.axis||r===e[0].dims[s]).reduce((r,s)=>r&&s,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=e[0].dims[t.axis],i=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/i)||t.blockSize>Math.ceil(n/(i-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},TL=(e,t)=>{let n=qe.normalizeAxis(t.axis,e[0].dims.length),i=e[0].dataType,r=i===3,s=e[0].dims,a=e[1].dataType,o=qe.size(s),l=i===3||i===2,u=l?[Math.ceil(qe.size(e[0].dims)/4)]:e[0].dims,c=e[1].dims,f=e.length>2?e[2]:void 0,d=f?l?[Math.ceil(qe.size(f.dims)/4)]:f.dims:void 0,h=c.length===0||c.length===1&&c[0]===1,m=h===!1&&c.length===1,y=Fi(o),M=h&&(!l||y===4),g=M?y:1,_=M&&!l?y:1,T=Ze("input",l?12:i,u.length,_),x=Ze("scale",a,c.length),S=f?Ze("zero_point",l?12:i,d.length):void 0,$=Rt("output",a,s.length,g),C=[T,x];S&&C.push(S);let P=[u,c];f&&P.push(d);let O=[{type:12,data:o/g},{type:12,data:n},{type:12,data:t.blockSize},...Ut(...P,s)],R=G=>{let W=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${G.registerUniforms(W).declareVariables(...C,$)}
      ${G.mainStart()}
          ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${$.offsetToIndices("global_idx")};

          // Set input x
          ${l?`
            let input = ${T.getByOffset("global_idx / 4")};
            let x_vec = ${r?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${g===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${T.getByOffset("global_idx")};`};

          // Set scale input
          ${h?`let scale_value= ${x.getByOffset("0")}`:m?`
            let scale_index = ${$.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${x.getByOffset("scale_index")};`:`
            var scale_indices: ${x.type.indices} = output_indices;
            let index = ${x.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${x.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${x.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${S?h?l?`
                let zero_point_input = ${S.getByOffset("0")};
                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${S.getByOffset("0")}`:m?l?`
                let zero_point_index = ${$.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${S.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${$.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${S.getByOffset("zero_point_index")};`:l?`
                let zero_point_offset = ${x.indicesToOffset("scale_indices")};
                let zero_point_input = ${S.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${S.getByIndices("scale_indices")};`:`let zero_point_value = ${l?r?"i32":"u32":T.type.value}(0);`};
      // Compute and write output
      ${$.setByOffset("global_idx",`${$.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:S?["rank","rank","rank"]:["rank","rank"]},getShaderSource:R,getRunData:()=>({outputs:[{dims:s,dataType:a}],dispatchGroup:{x:Math.ceil(o/g/64),y:1,z:1},programUniforms:O})}},M5=(e,t)=>{xL(e.inputs,t),e.compute(TL(e.inputs,t))},E5=e=>Zn({axis:e.axis,blockSize:e.blockSize})}),ML,EL,S5,Ese=ft(()=>{na(),Qt(),dn(),ML=(e,t,n)=>{let i=e===t,r=e<t&&n<0,s=e>t&&n>0;if(i||r||s)throw new Error("Range these inputs' contents are invalid.")},EL=(e,t,n,i)=>{let r=Math.abs(Math.ceil((t-e)/n)),s=[r],a=r,o=[{type:12,data:a},{type:i,data:e},{type:i,data:n},...Ut(s)],l=u=>{let c=Rt("output",i,s.length),f=c.type.value,d=[{name:"outputSize",type:"u32"},{name:"start",type:f},{name:"delta",type:f}];return`
        ${u.registerUniforms(d).declareVariables(c)}
        ${u.mainStart()}
        ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${f}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${i}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:s,dataType:i}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:o})}},S5=e=>{let t=0,n=0,i=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],i=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],i=e.inputs[2].getFloat32Array()[0]),bi.webgpu.validateInputContent&&ML(t,n,i),e.compute(EL(t,n,i,e.inputs[0].dataType),{inputs:[]})}}),SL,CL,C5,$5,Sse=ft(()=>{Qt(),un(),Vi(),dn(),SL=(e,t,n,i)=>{if(e!=="none"&&i!=="i32"&&i!=="u32"&&i!=="f32")throw new Error(`Input ${i} is not supported with reduction ${e}.`);let r=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,s=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(e){case"none":return`${t}=${n};`;case"add":return i==="i32"||i==="u32"?`atomicAdd(&${t}, bitcast<${i}>(${n}));`:`
              ${r}bitcast<${i}>(oldValue) + (${n})${s}`;case"max":return i==="i32"||i==="u32"?`atomicMax(&${t}, bitcast<${i}>(${n}));`:`
                ${r}max(bitcast<f32>(oldValue), (${n}))${s}`;case"min":return i==="i32"||i==="u32"?`atomicMin(&${t}, bitcast<${i}>(${n}));`:`${r}min(bitcast<${i}>(oldValue), (${n}))${s}`;case"mul":return`${r}(bitcast<${i}>(oldValue) * (${n}))${s}`;default:throw new Error(`Reduction ${e} is not supported.`)}},CL=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n,s=1,a=Math.ceil(qe.sizeToDimension(i,i.length-1)/s),o=i[i.length-1],l=qe.sizeFromDimension(n,o),u=[{type:12,data:a},{type:12,data:o},{type:12,data:l},...Ut(e[1].dims,e[2].dims,r)],c=f=>{let d=Ze("indices",e[1].dataType,e[1].dims.length),h=Ze("updates",e[2].dataType,e[2].dims.length,s),m=t.reduction!=="none"&&t.reduction!==""?nj("output",e[0].dataType,r.length):Rt("output",e[0].dataType,r.length,s);return`
      ${f.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(d,h,m)}
      ${f.mainStart()}
        ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var data_offset = 0u;
  let indices_start = uniforms.last_index_dimension * global_idx;
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${e[0].dims.length===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${SL(t.reduction,"output[data_offset + i]","value",m.type.value)}
  }

      }`};return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:u}),getShaderSource:c}},C5=e=>Zn({reduction:e.reduction}),$5=(e,t)=>{e.compute(CL(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}}),$L,AL,IL,dw,PL,kL,DL,OL,RL,NL,LL,zL,fw,FL,BL,UL,VL,GL,A5,I5,Cse=ft(()=>{Qt(),un(),Vi(),dn(),$L=(e,t)=>{if(e.every(n=>n>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},AL=(e,t,n)=>{t.every(r=>r>=0&&r<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let i=new Array(n).fill(1);return t.forEach((r,s)=>i[r]=e[s]),i},IL=(e,t,n,i,r,s)=>{let[a,o,l]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],u=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach(c=>s.push(c));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&e.length>o&&e[o].dims.length===1&&e[o].dims[0]>0){if(e[o].getFloat32Array().forEach(c=>i.push(c)),i.length!==0&&i.length!==u&&n>=18&&i.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");$L(i,t),t.axes.length>0&&AL(i,t.axes,u).forEach((c,f)=>i[f]=c)}if(l>0&&e.length>l&&e[l].dims.length===1&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach(c=>r.push(Number(c))),r.length!==0&&r.length!==u&&n>=18&&r.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(i.length!==0&&i.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(r.length!==0&&r.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof i<"u"&&typeof r<"u"&&i.length>0&&r.length>u)throw new Error("Resize requires only of scales or sizes to be specified")},dw=(e,t,n,i)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${e}) * (${t});
  let whole = ${i}(big / (${n}));
  let fract = ${i}(big % (${n})) / ${i}(${n});
  return whole + fract;
`,PL=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${t}(xResized) / ${t}(xScale);
          } else {
            ${dw("xResized","lengthOriginal","lengthResized",t)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${dw("xResized","lengthOriginal - 1","lengthResized - 1",t)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +
                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /
                        ${t}(lengthResized - 1);
                  } else {
                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);
                  const adjustment = ${t}(lengthResized) / outputWidth;
                  const center = ${t}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",kL=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",DL=(e,t,n)=>{let i=new Array(n).fill(0).concat(new Array(n).fill(1)),r=e.length===0?i:e.slice();return t.length>0?(t.forEach((s,a)=>{i[s]=r[a],i[a+n]=r[t.length+a]}),i):r},OL=(e,t,n,i)=>{let r=[];if(n.length>0)if(i.length>0){if(e.forEach(s=>r.push(s)),Math.max(...i)>e.length)throw new Error("axes is out of bound");i.forEach((s,a)=>r[s]=n[a])}else n.forEach(s=>r.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");r=e.map((s,a)=>Math.round(s*t[a]))}return r},RL=(e,t,n)=>{let i=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(s=>t[s]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(s=>t[s]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let r=e.slice();return n.axes.length>0?(n.axes.forEach(s=>t[s]=i),n.axes.forEach(s=>r[s]=Math.round(e[s]*t[s]))):(t.fill(i,0,t.length),r.forEach((s,a)=>r[a]=Math.round(s*t[a]))),r},NL=(e,t,n,i,r)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {
      var original_indices: array<${e.type.value}, ${n.length}>;
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var scale = ${zt("uniforms.scales","i",i)};
        var roi_low = ${zt("uniforms.roi","i",r)};
        var roi_hi = ${zt("uniforms.roi",`i + ${t.length}`,r)};
        if (scale == 1.0) {
          original_indices[i] = ${e.type.value}(output_index);
        } else {
          var input_shape_i = ${zt("uniforms.input_shape","i",t.length)};
          var output_shape_i = ${zt("uniforms.output_shape","i",n.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,LL=(e,t,n,i,r,s,a)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
      var input_indices: ${e.type.indices};
      for (var i:u32 = 0; i < ${i.length}; i++) {
        var output_index = ${t.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${zt("uniforms.scales","i",r)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${zt("uniforms.roi","i",s)};
          var roi_hi = ${zt("uniforms.roi",`i + ${n.length}`,s)};
          var input_shape_i = ${zt("uniforms.input_shape","i",n.length)};
          var output_shape_i = ${zt("uniforms.output_shape","i",i.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${e.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,zL=(e,t)=>`
    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var input_index = ${e.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${zt("uniforms.input_shape","i",t.length)}) {
          return false;
        }
      }
      return true;
    }`,fw=(e,t,n,i)=>e.rank>i?`
    ${e.indicesSet("input_indices",t,"channel")};
    ${e.indicesSet("input_indices",n,"batch")};
`:"",FL=(e,t,n,i,r)=>{let[s,a,o,l]=n.length===2?[-1,0,1,-1]:[0,2,3,1],u=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${u} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",a,`max(0, min(row, ${n[a]} - 1))`)};
      ${e.indicesSet("input_indices",o,`max(0, min(col, ${n[o]} - 1))`)};
      ${fw(e,l,s,2)}
      return ${e.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${u} = originalIndices[${a}];
      var col:${u} = originalIndices[${o}];
      ${i?`if (row < 0 || row > (${n[a]} - 1) || col < 0 || col > (${n[o]} - 1)) {
        return ${r};
      }`:""};
      row = max(0, min(row, ${n[a]} - 1));
      col = max(0, min(col, ${n[o]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${n.length>2?`u32(originalIndices[${l}])`:"0"};
      var batch: u32 =  ${n.length>2?`u32(originalIndices[${s}])`:"0"};
      var x11: ${u} = getInputValue(batch, channel, row1, col1);
      var x12: ${u} = getInputValue(batch, channel, row1, col2);
      var x21: ${u} = getInputValue(batch, channel, row2, col1);
      var x22: ${u} = getInputValue(batch, channel, row2, col2);
      var dx1: ${u} = abs(row - ${u}(row1));
      var dx2: ${u} = abs(${u}(row2) - row);
      var dy1: ${u} = abs(col - ${u}(col1));
      var dy2: ${u} = abs(${u}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},BL=(e,t,n,i,r,s,a,o,l,u)=>{let c=n.length===2,[f,d]=c?[0,1]:[2,3],h=e.type.value,m=y=>{let M=y===f?"row":"col";return`
      fn ${M}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${h} {
        var output_index = ${t.indicesGet("output_indices",y)};
        var originalIdx: ${h} = getOriginalCoordinateFromResizedCoordinate(output_index, ${r[y]},
        ${i[y]}, ${n[y]}, ${s[y]}, ${s[y]} + ${n.length});
        var fractOriginalIdx: ${h} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${o} && (originalIdx < 0 || originalIdx > (${n[y]} - 1))) {
          return ${l};
        }
        var data: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${M}: ${h} = originalIdx + ${h}(i);
          if (${M} < 0 || ${M} >= ${n[y]}) {
            ${u?`coefs[i + 1] = 0.0;
                        continue;`:o?`return ${l};`:`${M} = max(0, min(${M}, ${n[y]} - 1));`};
          }
        var input_indices_copy: ${e.type.indices} = input_indices;
          ${e.indicesSet("input_indices_copy",y,`u32(${M})`)};
          data[i + 1] = ${y===f?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${m(f)};
    ${m(d)};
  fn getCubicInterpolationCoefs(s: ${h}) -> array<${h}, 4> {
    var absS = abs(s);
    var coeffs: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${h} = 1.0 - absS;
    var twoMinusAbsS: ${h} = 2.0 - absS;
    var onePlusAbsS: ${h} = 1.0 + absS;
    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};
    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;
    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${h}, 4>, coefs: array<${h}, 4>) -> ${h} {
    var coefsSum: ${h} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${h} {
    var input_indices: ${e.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},UL=(e,t,n,i,r)=>{let[s,a,o,l,u]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],c=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${c} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",a,`max(0, min(depth, ${n[a]} - 1))`)};
      ${e.indicesSet("input_indices",o,`max(0, min(height, ${n[o]} - 1))`)};
      ${e.indicesSet("input_indices",l,`max(0, min(width, ${n[l]} - 1))`)};
      ${fw(e,u,s,3)}
      return ${e.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${c} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${c} = originalIndices[${a}];
      var height:${c} = originalIndices[${o}];
      var width:${c} = originalIndices[${l}];
      ${i?`if (depth < 0 || depth > (${n[a]} - 1) || height < 0 || height > (${n[o]} - 1) || width < 0 || (width > ${n[l]} - 1)) {
      return ${r};
        }`:""};

    depth = max(0, min(depth, ${n[a]} - 1));
      height = max(0, min(height, ${n[o]} - 1));
      width = max(0, min(width, ${n[l]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${n.length>3?`u32(originalIndices[${u}])`:"0"};
      var batch: u32 =  ${n.length>3?`u32(originalIndices[${s}])`:"0"};

      var x111: ${c} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${c} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${c} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${c} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${c} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${c} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${c} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${c} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${c} = abs(depth - ${c}(depth1));
      var dx2: ${c} = abs(${c}(depth2) - depth);
      var dy1: ${c} = abs(height - ${c}(height1));
      var dy2: ${c} = abs(${c}(height2) - height);
      var dz1: ${c} = abs(width - ${c}(width1));
      var dz2: ${c} = abs(${c}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},VL=(e,t,n,i,r,s)=>{let a=e.dims,o=DL(s,t.axes,a.length),l=OL(a,i,r,t.axes),u=i.slice();i.length===0&&(u=a.map((_,T)=>_===0?1:l[T]/_),t.keepAspectRatioPolicy!=="stretch"&&(l=RL(a,u,t)));let c=Rt("output",e.dataType,l.length),f=Ze("input",e.dataType,a.length),d=qe.size(l),h=a.length===l.length&&a.every((_,T)=>_===l[T]),m=t.coordinateTransformMode==="tf_crop_and_resize",y=t.extrapolationValue,M=f.type.value,g=_=>`
      ${h?"":`
      ${PL(t.coordinateTransformMode,M)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${zL(f,a)};
              ${kL(t.nearestMode,n,M)};
              ${LL(f,c,a,l,u.length,o.length,m)};
              `;case"linear":return`
              ${NL(c,a,l,u.length,o.length)};
              ${(()=>{if(a.length===2||a.length===4)return`${FL(f,c,a,m,y)}`;if(a.length===3||a.length===5)return`${UL(f,c,a,m,y)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(a.length===2||a.length===4)return`${BL(f,c,a,l,u,o,t.cubicCoeffA,m,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${_.registerUniform("output_size","u32").registerUniform("scales","f32",u.length).registerUniform("roi","f32",o.length).declareVariables(f,c)}
      ${_.mainStart()}
        ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${h?"output[global_idx] = input[global_idx];":`
        let output_indices = ${c.offsetToIndices("global_idx")};
        var input_indices: ${f.type.indices};
        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${f.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${t.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${a.length===2||a.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${u.length>0?t.mode==="cubic"?u:u.length:""}|${r.length>0?r:""}|${o.length>0?o:""}|${h}|${t.mode==="nearest"?a.length:a}`,inputDependencies:["rank"]},getShaderSource:g,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},{type:1,data:u},{type:1,data:o},...Ut(a,l)]})}},GL=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},A5=(e,t)=>{let n=[],i=[],r=[],s=GL(e);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");IL(e.inputs,t,s,n,i,r),e.compute(VL(e.inputs[0],t,s,n,i,r),{inputs:[0]})},I5=e=>{let t=e.antialias,n=e.axes,i=e.coordinateTransformMode,r=e.cubicCoeffA,s=e.excludeOutside!==0,a=e.extrapolationValue,o=e.keepAspectRatioPolicy,l=e.mode,u=e.nearestMode===""?"simple":e.nearestMode;return Zn({antialias:t,axes:n,coordinateTransformMode:i,cubicCoeffA:r,excludeOutside:s,extrapolationValue:a,keepAspectRatioPolicy:o,mode:l,nearestMode:u})}}),jL,WL,P5,$se=ft(()=>{Qt(),un(),dn(),jL=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],i=e[2];if(t.dataType!==n.dataType||t.dataType!==i.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Skip must be 2D or 3D");let r=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==r)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(i.dims.length!==1)throw new Error("Gamma must be 1D");if(i.dims[i.dims.length-1]!==r)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let a=e[3];if(a.dims.length!==1)throw new Error("Beta must be 1D");if(a.dims[a.dims.length-1]!==r)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let a=e[4];if(a.dims.length!==1)throw new Error("Bias must be 1D");if(a.dims[a.dims.length-1]!==r)throw new Error("Bias must have the same hidden size as input")}},WL=(e,t,n,i)=>{let r=t.simplified,s=e[0].dims,a=qe.size(s),o=s,l=a,u=s.slice(-1)[0],c=i?s.slice(0,-1).concat(1):[],f=!r&&e.length>3,d=e.length>4,h=i&&n>1,m=i&&n>2,y=n>3,M=64,g=Fi(u),_=[{type:12,data:l},{type:12,data:g},{type:12,data:u},{type:1,data:t.epsilon}],T=S=>{let $=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],C=[Ze("x",e[0].dataType,e[0].dims,g),Ze("skip",e[1].dataType,e[1].dims,g),Ze("gamma",e[2].dataType,e[2].dims,g)];f&&C.push(Ze("beta",e[3].dataType,e[3].dims,g)),d&&C.push(Ze("bias",e[4].dataType,e[4].dims,g)),C.push(Rt("output",e[0].dataType,o,g)),h&&C.push(Rt("mean_output",1,c)),m&&C.push(Rt("inv_std_output",1,c)),y&&C.push(Rt("input_skip_bias_sum",e[0].dataType,o,g));let P=mr(e[0].dataType),O=mr(1,g);return`

      ${S.registerUniforms($).declareVariables(...C)}
      var<workgroup> sum_shared : array<${O}, ${M}>;
      var<workgroup> sum_squared_shared : array<${O}, ${M}>;

      ${S.mainStart([M,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${M};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${M};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${M-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${d?"bias[offset1d + i]":P+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${y?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${rd(P,g,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${M};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Wl("sum",g)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Wl("square_sum",g)} / f32(uniforms.hidden_size) ${r?"":"- mean * mean"} + uniforms.epsilon);
        ${h?"mean_output[global_idx] = mean;":""}
        ${m?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${r?"":`- ${P}(mean)`}) *
            ${P}(inv_std_dev) * gamma[offset1d + i]
            ${f?"+ beta[offset1d + i]":""};
        }
      }`},x=[{dims:o,dataType:e[0].dataType}];return n>1&&x.push({dims:c,dataType:1}),n>2&&x.push({dims:c,dataType:1}),n>3&&x.push({dims:s,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${g};${h};${m};${y}`,inputDependencies:e.map((S,$)=>"type")},getShaderSource:T,getRunData:()=>({outputs:x,dispatchGroup:{x:Math.ceil(l/u)},programUniforms:_})}},P5=(e,t)=>{jL(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(WL(e.inputs,t,e.outputCount,!1),{outputs:n})}}),HL,wf,qL,pw,KL,JL,k5,D5,Ase=ft(()=>{Qt(),un(),Vi(),dn(),HL=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((n,i)=>{if(e[i+1].dataType!==6&&e[i+1].dataType!==7)throw new Error(`Input ${i} must be an array of int32 or int64`)})},wf=(e,t)=>{let n=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(i=>n.push(Number(i)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(i=>n.push(Number(i)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return n},qL=(e,t)=>{if(e.length>1){let n=wf(e,1),i=wf(e,2),r=wf(e,3);return r.length===0&&(r=[...Array(e[0].dims.length).keys()]),Zn({starts:n,ends:i,axes:r})}else return t},pw=(e,t,n,i,r)=>{let s=e;return e<0&&(s+=n[i[t]]),r[t]<0?Math.max(0,Math.min(s,n[i[t]]-1)):Math.max(0,Math.min(s,n[i[t]]))},KL=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
          var input_indices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${n.length-1}; i >= 0; i--) {
            let input_shape_i = ${zt("uniforms.input_shape","i",n.length)};
            let steps_i = ${zt("uniforms.steps","i",n.length)};
            let signs_i = ${zt("uniforms.signs","i",n.length)};
            let starts_i = ${zt("uniforms.starts","i",n.length)};
            var output_index = ${t.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${e.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,JL=(e,t)=>{let n=e[0].dims,i=qe.size(n),r=t.axes.length>0?qe.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],s=wf(e,4);s.forEach(g=>g!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(r.length).fill(1));let a=t.starts.map((g,_)=>pw(g,_,n,r,s)),o=t.ends.map((g,_)=>pw(g,_,n,r,s));if(r.length!==a.length||r.length!==o.length)throw new Error("start, ends and axes should have the same number of elements");if(r.length!==n.length)for(let g=0;g<n.length;++g)r.includes(g)||(a.splice(g,0,0),o.splice(g,0,n[g]),s.splice(g,0,1));let l=s.map(g=>Math.sign(g));s.forEach((g,_,T)=>{if(g<0){let x=(o[_]-a[_])/g,S=a[_],$=S+x*s[_];a[_]=$,o[_]=S,T[_]=-g}});let u=n.slice(0);r.forEach((g,_)=>{u[g]=Math.ceil((o[g]-a[g])/s[g])});let c={dims:u,dataType:e[0].dataType},f=Rt("output",e[0].dataType,u.length),d=Ze("input",e[0].dataType,e[0].dims.length),h=qe.size(u),m=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:a.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:s.length}],y=[{type:12,data:h},{type:12,data:a},{type:6,data:l},{type:12,data:s},...Ut(e[0].dims,u)],M=g=>`
      ${g.registerUniforms(m).declareVariables(d,f)}
        ${KL(d,f,n)}
        ${g.mainStart()}
          ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${f.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${f.setByOffset("global_idx",d.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${l.length}_${a.length}_${s.length}`,inputDependencies:["rank"]},getShaderSource:M,getRunData:()=>({outputs:[c],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:y})}},k5=(e,t)=>{HL(e.inputs,t);let n=qL(e.inputs,t);e.compute(JL(e.inputs,n),{inputs:[0]})},D5=e=>{let t=e.starts,n=e.ends,i=e.axes;return Zn({starts:t,ends:n,axes:i})}}),YL,XL,O5,R5,Ise=ft(()=>{Qt(),un(),Vi(),Yl(),dn(),YL=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},XL=(e,t)=>{let n=e.inputs[0],i=n.dims,r=qe.size(i),s=i.length,a=qe.normalizeAxis(t.axis,s),o=a<i.length-1,l,u=[];o?(u=Array.from({length:s},(C,P)=>P),u[a]=s-1,u[s-1]=a,l=e.compute(Es(n,u),{inputs:[n],outputs:[-1]})[0]):l=n;let c=l.dims,f=c[s-1],d=r/f,h=Fi(f),m=f/h,y=64;d===1&&(y=256);let M=(C,P)=>P===4?`max(max(${C}.x, ${C}.y), max(${C}.z, ${C}.w))`:P===2?`max(${C}.x, ${C}.y)`:P===3?`max(max(${C}.x, ${C}.y), ${C}.z)`:C,g=Ze("x",l.dataType,l.dims,h),_=Rt("result",l.dataType,l.dims,h),T=g.type.value,x=mr(l.dataType)==="f32"?`var threadMax = ${T}(-3.402823e+38f);`:`var threadMax = ${T}(-65504.0h);`,S=C=>`
      var<workgroup> rowMaxShared : ${T};
      var<workgroup> rowSumShared : ${T};
      var<workgroup> threadShared : array<${T}, ${y}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${T} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${T}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${C.registerUniform("packedCols","i32").declareVariables(g,_)}
      ${C.mainStart(y)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${y};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${x}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${T}(${M("threadShared[0]",h)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${T}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${T}(${Wl("threadShared[0]",h)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          var value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          // max operation protects against NaN since all values should be >=0
          value = max(value, ${T}(0.0));
          setValue(row, col, row_stride, value);
        }
      }`,$=e.compute({name:"Softmax",shaderCache:{hint:`${h};${y}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:c,dataType:l.dataType}],dispatchGroup:{x:d},programUniforms:[{type:6,data:m}]}),getShaderSource:S},{inputs:[l],outputs:[o?-1:0]})[0];o&&e.compute(Es($,u),{inputs:[$]})},O5=(e,t)=>{YL(e.inputs),XL(e,t)},R5=e=>Zn({axis:e.axis})}),hw,QL,ZL,ez,N5,Pse=ft(()=>{Qt(),un(),dn(),hw=e=>Array.from(e.getBigInt64Array(),Number),QL=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(hw(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ZL=(e,t)=>{let n=[];for(let i=0;i<e.length;++i)n.push(e[i]*t[i]);return n},ez=(e,t)=>{let n=e[0].dims,i=t??hw(e[1]),r=ZL(n,i),s=qe.size(r),a=e[0].dataType,o=Ze("input",a,n.length),l=Rt("output",a,r.length),u=c=>`
      const inputShape = ${o.indices(...n)};
      ${c.registerUniform("output_size","u32").declareVariables(o,l)}
      ${c.mainStart()}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${l.offsetToIndices("global_idx")};
      var input_indices: ${o.type.indices};
      for (var i = 0; i < ${n.length}; i++) {
        let input_dim_i = ${o.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;

        ${o.indicesSet("input_indices","i","input_dim_value")}
      }
      ${l.setByOffset("global_idx",o.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${i}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},...Ut(e[0].dims,r)]}),getShaderSource:u}},N5=e=>{QL(e.inputs),e.compute(ez(e.inputs),{inputs:[0]})}}),tz,nz,L5,kse=ft(()=>{Qt(),un(),dn(),tz=(e,t,n,i,r)=>{let s=Rt("output_data",r,n.length,4),a=Ze("a_data",t[1].dataType,t[1].dims.length,4),o=Ze("b_data",t[2].dataType,t[2].dims.length,4),l=Ze("c_data",t[0].dataType,t[0].dims.length,4),u,c=(f,d,h)=>`select(${d}, ${f}, ${h})`;if(!i)u=s.setByOffset("global_idx",c(a.getByOffset("global_idx"),o.getByOffset("global_idx"),l.getByOffset("global_idx")));else{let f=(d,h,m="")=>{let y=`a_data[index_a${h}][component_a${h}]`,M=`b_data[index_b${h}][component_b${h}]`,g=`bool(c_data[index_c${h}] & (0xffu << (component_c${h} * 8)))`;return`
            let output_indices${h} = ${s.offsetToIndices(`global_idx * 4u + ${h}u`)};
            let offset_a${h} = ${a.broadcastedIndicesToOffset(`output_indices${h}`,s)};
            let offset_b${h} = ${o.broadcastedIndicesToOffset(`output_indices${h}`,s)};
            let offset_c${h} = ${l.broadcastedIndicesToOffset(`output_indices${h}`,s)};
            let index_a${h} = offset_a${h} / 4u;
            let index_b${h} = offset_b${h} / 4u;
            let index_c${h} = offset_c${h} / 4u;
            let component_a${h} = offset_a${h} % 4u;
            let component_b${h} = offset_b${h} % 4u;
            let component_c${h} = offset_c${h} % 4u;
            ${d}[${h}] = ${m}(${c(y,M,g)});
          `};r===9?u=`
            var data = vec4<u32>(0);
            ${f("data",0,"u32")}
            ${f("data",1,"u32")}
            ${f("data",2,"u32")}
            ${f("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:u=`
            ${f("output_data[global_idx]",0)}
            ${f("output_data[global_idx]",1)}
            ${f("output_data[global_idx]",2)}
            ${f("output_data[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(l,a,o,s)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${u}
      }`},nz=e=>{let t=e[1].dims,n=e[2].dims,i=e[0].dims,r=e[1].dataType,s=!(qe.areEqual(t,n)&&qe.areEqual(n,i)),a=t,o=qe.size(t);if(s){let u=Cd.calcShape(Cd.calcShape(t,n,!1),i,!1);if(!u)throw new Error("Can't perform where op on the given tensors");a=u,o=qe.size(a)}let l=Math.ceil(o/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:u=>tz(u,e,a,s,r),getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:Math.ceil(o/64/4)},programUniforms:[{type:12,data:l},...Ut(i,t,n,a)]})}},L5=e=>{e.compute(nz(e.inputs))}}),z5,Dse=ft(()=>{qre(),RT(),Kre(),Jre(),Yre(),Xre(),Qre(),ise(),sse(),ase(),ose(),lse(),use(),cse(),dse(),fse(),pse(),hse(),mse(),gse(),_se(),yse(),vse(),wse(),bse(),i5(),xse(),Tse(),Mse(),Ese(),Sse(),OT(),Cse(),l5(),$se(),Ase(),Ise(),a5(),Pse(),Yl(),NT(),kse(),z5=new Map([["Abs",[Pj]],["Acos",[kj]],["Acosh",[Dj]],["Add",[pW]],["ArgMax",[Cj,p1]],["ArgMin",[Sj,p1]],["Asin",[Oj]],["Asinh",[Rj]],["Atan",[Nj]],["Atanh",[Lj]],["Attention",[$j]],["AveragePool",[_5,g5]],["BatchNormalization",[Aj]],["BiasAdd",[Ij]],["BiasSplitGelu",[fW]],["Cast",[Fj,zj]],["Ceil",[Uj]],["Clip",[Bj]],["Concat",[TW,MW]],["Conv",[v1,y1]],["ConvTranspose",[OW,DW]],["Cos",[Vj]],["Cosh",[Gj]],["CumSum",[RW,NW]],["DepthToSpace",[LW,zW]],["DequantizeLinear",[M5,E5]],["Div",[hW]],["Einsum",[FW,BW]],["Elu",[jj,Nf]],["Equal",[mW]],["Erf",[Wj]],["Exp",[Hj]],["Expand",[UW]],["FastGelu",[VW]],["Floor",[qj]],["FusedConv",[v1,y1]],["Gather",[jW,GW]],["GatherElements",[YW,JW]],["GatherBlockQuantized",[qW,KW]],["GatherND",[WW,HW]],["Gelu",[Kj]],["Gemm",[QW,XW]],["GlobalAveragePool",[v5,y5]],["GlobalMaxPool",[T5,x5]],["Greater",[vW]],["GreaterOrEqual",[bW]],["GridSample",[ZW,e5]],["GroupQueryAttention",[u5]],["HardSigmoid",[nW,tW]],["InstanceNormalization",[c5]],["LayerNormalization",[d5]],["LeakyRelu",[Jj,Nf]],["Less",[wW]],["LessOrEqual",[xW]],["Log",[cW]],["MatMul",[f5]],["MatMulNBits",[p5,h5]],["MaxPool",[w5,b5]],["Mul",[gW]],["MultiHeadAttention",[n5,t5]],["Neg",[Xj]],["Not",[Yj]],["Pad",[m5]],["Pow",[_W]],["QuickGelu",[dW,Nf]],["Range",[S5]],["Reciprocal",[Qj]],["ReduceMin",[bj]],["ReduceMean",[gj]],["ReduceMax",[wj]],["ReduceSum",[Tj]],["ReduceProd",[xj]],["ReduceL1",[_j]],["ReduceL2",[yj]],["ReduceLogSum",[Ej]],["ReduceLogSumExp",[vj]],["ReduceSumSquare",[Mj]],["Relu",[Zj]],["Resize",[A5,I5]],["RotaryEmbedding",[o5]],["ScatterND",[$5,C5]],["Sigmoid",[eW]],["Sin",[iW]],["Sinh",[rW]],["Slice",[k5,D5]],["SkipLayerNormalization",[P5]],["Split",[r5,s5]],["Sqrt",[sW]],["Softmax",[O5,R5]],["Sub",[yW]],["Tan",[aW]],["Tanh",[oW]],["ThresholdedRelu",[uW,Nf]],["Tile",[N5]],["Transpose",[rj,sj]],["Where",[L5]]])}),F5,Ose=ft(()=>{na(),Go(),dn(),F5=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,i,r){Pa(e.programInfo.name);let s=this.backend.device,a=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let o=[];for(let u of t)o.push({binding:o.length,resource:{buffer:u.buffer}});for(let u of n)o.push({binding:o.length,resource:{buffer:u.buffer}});r&&o.push({binding:o.length,resource:r});let l=s.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:o,label:e.programInfo.name});if(this.backend.sessionStatus==="capturing"){let u={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:l,dispatchGroup:i};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(u)}a.setPipeline(e.computePipeline),a.setBindGroup(0,l),a.dispatchWorkgroups(...i),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Zs(e.programInfo.name)}dispose(){}build(e,t){Pa(e.name);let n=this.backend.device,i=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(u=>{n.features.has(u.feature)&&i.push(`enable ${u.extension};`)});let r=ij(t,this.backend.device.limits),s=e.getShaderSource(r),a=`${i.join(`
`)}
${r.additionalImplementations}
${s}`,o=n.createShaderModule({code:a,label:e.name});Ln("verbose",()=>`[WebGPU] ${e.name} shader code: ${a}`);let l=n.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:e.name});return Zs(e.name),{programInfo:e,computePipeline:l,uniformVariablesInfo:r.variablesInfo}}normalizeDispatchGroupSize(e){let t=typeof e=="number"?e:e.x,n=typeof e=="number"?1:e.y||1,i=typeof e=="number"?1:e.z||1,r=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=r&&n<=r&&i<=r)return[t,n,i];let s=t*n*i,a=Math.ceil(Math.sqrt(s));if(a>r){if(a=Math.ceil(Math.cbrt(s)),a>r)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[a,a,a]}else return[a,a,1]}}}),B5={};Vd(B5,{WebGpuBackend:()=>U5});var iz,rz,sz,U5,Rse=ft(()=>{na(),Qt(),Go(),Q8(),Wre(),Dse(),Ose(),iz=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let i=0;i<e.length;++i){let r=e[i].dataType;switch(t[i]){case"none":{n.push("");break}case"type":{n.push(`${r}`);break}case"rank":{let s=e[i].dims.length;n.push(`${r};${s}`);break}case"dims":{let s=e[i].dims.join(",");n.push(`${r};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[i]}`)}}return n.join("|")},rz=(e,t,n)=>{var r,s;let i=e.name;return(r=e.shaderCache)!=null&&r.hint&&(i+="["+e.shaderCache.hint+"]"),i+=":"+n+`:${iz(t,((s=e.shaderCache)==null?void 0:s.inputDependencies)??new Array(t.length).fill("dims"))}`,i},sz=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},U5=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},r=s=>t.features.has(s)&&n.push(s)&&!0;r("chromium-experimental-timestamp-query-inside-passes")||r("timestamp-query"),r("shader-f16"),r("subgroups"),this.device=await t.requestDevice(i),this.adapterInfo=new sz(t.info||await t.requestAdapterInfo()),this.gpuDataManager=tj(this),this.programManager=new F5(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,IT(e.logLevel,!!e.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};this.queryType==="at-passes"&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Pa(),this.endComputePass();let e;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),e=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&e.mapAsync(GPUMapMode.READ).then(()=>{var i;let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let r=0;r<t.length/2;r++){let s=n[r],a=s.kernelId,o=this.kernels.get(a),l=o.kernelType,u=o.kernelName,c=s.programName,f=s.inputTensorViews,d=s.outputTensorViews,h=t[r*2],m=t[r*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=h);let y=Number(h-this.queryTimeBase),M=Number(m-this.queryTimeBase);if(!Number.isSafeInteger(y)||!Number.isSafeInteger(M))throw new RangeError("incorrect timestamp range");if((i=this.env.webgpu.profiling)!=null&&i.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:f.map(g=>({dims:g.dims,dataType:So(g.dataType)})),outputsMetadata:d.map(g=>({dims:g.dims,dataType:So(g.dataType)})),kernelId:a,kernelType:l,kernelName:u,programName:c,startTime:y,endTime:M});else{let g="";f.forEach((T,x)=>{g+=`input[${x}]: [${T.dims}] | ${So(T.dataType)}, `});let _="";d.forEach((T,x)=>{_+=`output[${x}]: [${T.dims}] | ${So(T.dataType)}, `}),console.log(`[profiling] kernel "${a}|${l}|${u}|${c}" ${g}${_}start time: ${y} ns, execution time: ${M-y} ns`)}wp("GPU",`${c}::${h}::${m}`)}e.unmap(),this.pendingQueries.delete(e)}),Zs()}run(e,t,n,i,r,s){Pa(e.name);let a=[];for(let _=0;_<t.length;++_){let T=t[_].data;if(T===0)continue;let x=this.gpuDataManager.get(T);if(!x)throw new Error(`no GPU data for input: ${T}`);a.push(x)}let{outputs:o,dispatchGroup:l,programUniforms:u}=e.getRunData(t),c=n.length===0?o.map((_,T)=>T):n;if(c.length!==o.length)throw new Error(`Output size ${c.length} must be equal to ${o.length}.`);let f=[],d=[];for(let _=0;_<o.length;++_){if(!Number.isInteger(c[_])||c[_]<-3||c[_]>=s)throw new Error(`Invalid output index: ${c[_]}`);if(c[_]===-3)continue;let T=c[_]===-1,x=c[_]===-2,S=T||x?r(o[_].dataType,o[_].dims):i(c[_],o[_].dataType,o[_].dims);if(f.push(S),S.data===0)continue;let $=this.gpuDataManager.get(S.data);if(!$)throw new Error(`no GPU data for output: ${S.data}`);if(T&&this.temporaryData.push($),x){let C=this.kernelPersistentData.get(this.currentKernelId);C||(C=[],this.kernelPersistentData.set(this.currentKernelId,C)),C.push($)}d.push($)}if(a.length!==t.length||d.length!==f.length){if(d.length===0)return Zs(e.name),f;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let h;if(u){let _=0,T=[];u.forEach(C=>{let P=typeof C.data=="number"?[C.data]:C.data;if(P.length===0)return;let O=C.type===10?2:4,R,G;C.type===10?(G=P.length>4?16:P.length>2?8:P.length*O,R=P.length>4?16:O*P.length):(G=P.length<=2?P.length*O:16,R=16),_=Math.ceil(_/G)*G,T.push(_);let W=C.type===10?8:4;_+=P.length>4?Math.ceil(P.length/W)*R:P.length*O});let x=16;_=Math.ceil(_/x)*x;let S=new ArrayBuffer(_);u.forEach((C,P)=>{let O=T[P],R=typeof C.data=="number"?[C.data]:C.data;if(C.type===6)new Int32Array(S,O,R.length).set(R);else if(C.type===12)new Uint32Array(S,O,R.length).set(R);else if(C.type===10)new Uint16Array(S,O,R.length).set(R);else if(C.type===1)new Float32Array(S,O,R.length).set(R);else throw new Error(`Unsupported uniform type: ${So(C.type)}`)});let $=this.gpuDataManager.create(_,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer($.buffer,0,S,0,_),this.gpuDataManager.release($.id),h={offset:0,size:_,buffer:$.buffer}}let m=this.programManager.normalizeDispatchGroupSize(l),y=m[1]===1&&m[2]===1,M=rz(e,t,y),g=this.programManager.getArtifact(M);if(g||(g=this.programManager.build(e,m),this.programManager.setArtifact(M,g),Ln("info",()=>`[artifact] key: ${M}, programName: ${e.name}`)),u&&g.uniformVariablesInfo){if(u.length!==g.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${g.uniformVariablesInfo.length}, got ${u.length} in program "${g.programInfo.name}".`);for(let _=0;_<u.length;_++){let T=u[_],x=T.type,S=typeof T.data=="number"?1:T.data.length,[$,C]=g.uniformVariablesInfo[_];if(x!==$||S!==C)throw new Error(`Uniform variable ${_} mismatch: expect type ${$} with size ${C}, got type ${x} with size ${S} in program "${g.programInfo.name}".`)}}if(Ln("info",()=>`[ProgramManager] run "${e.name}" (key=${M}) with ${m[0]}x${m[1]}x${m[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let _={kernelId:this.currentKernelId,programName:g.programInfo.name,inputTensorViews:t,outputTensorViews:f};this.pendingKernels.push(_),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(_)}return this.programManager.run(g,a,d,m,h),Zs(e.name),f}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,i){let r=z5.get(e);if(!r)throw new Error(`kernel not implemented: ${e}`);let s={kernelType:e,kernelName:i,kernelEntry:r[0],attributes:[r[1],n]};this.kernels.set(t,s)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let n of t)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let i=this.kernels.get(e);if(!i)throw new Error(`kernel not created: ${e}`);let r=i.kernelType,s=i.kernelName,a=i.kernelEntry,o=i.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${r}] ${s}" is not allowed to be called recursively`);this.currentKernelId=e,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),Ln("info",()=>`[WebGPU] Start to run kernel "[${r}] ${s}"...`);let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),a(t,o[1]),0}catch(u){return n.push(Promise.resolve(`[WebGPU] Kernel "[${r}] ${s}" failed. ${u}`)),1}finally{l&&n.push(this.device.popErrorScope().then(u=>u?`GPU validation error for kernel "[${r}] ${s}": ${u.message}`:null));for(let u of this.temporaryData)this.gpuDataManager.release(u.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,i){let r=this.sessionExternalDataMapping.get(e);r||(r=new Map,this.sessionExternalDataMapping.set(e,r));let s=r.get(t),a=this.gpuDataManager.registerExternalBuffer(n,i,s);return r.set(t,[a,n]),a}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[0])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let i=await c1(this,e,t);return PT(i.buffer,n)}}writeTimestamp(e){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){var e;this.queryType="none",(((e=this.env.webgpu.profiling)==null?void 0:e.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Ln("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Ln("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Ln("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),n=e.length;this.pendingKernels=[];for(let i=0;i<n;i++){let r=this.getComputePassEncoder(),s=e[i];this.writeTimestamp(this.pendingDispatchNumber*2),r.setPipeline(s.computePipeline),r.setBindGroup(0,s.bindGroup),r.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(t[i]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}}),V5={};Vd(V5,{init:()=>G5});var Zh,az,G5,Nse=ft(()=>{Qt(),Go(),un(),jre(),Zh=class j5{constructor(t,n,i,r){this.module=t,this.dataType=n,this.data=i,this.dims=r}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=qe.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=qe.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=qe.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let t=qe.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(qe.size(t)!==qe.size(this.dims))throw new Error("Invalid new shape");return new j5(this.module,this.dataType,this.data,t)}},az=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo;let i=e.PTR_SIZE,r=n/e.PTR_SIZE,s=i===4?"i32":"i64";this.opKernelContext=Number(e.getValue(i*r++,s));let a=Number(e.getValue(i*r++,s));this.outputCount=Number(e.getValue(i*r++,s)),this.customDataOffset=Number(e.getValue(i*r++,"*")),this.customDataSize=Number(e.getValue(i*r++,s));let o=[];for(let l=0;l<a;l++){let u=Number(e.getValue(i*r++,s)),c=Number(e.getValue(i*r++,"*")),f=Number(e.getValue(i*r++,s)),d=[];for(let h=0;h<f;h++)d.push(Number(e.getValue(i*r++,s)));o.push(new Zh(e,u,c,d))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){var a;let n=((a=t==null?void 0:t.inputs)==null?void 0:a.map(o=>typeof o=="number"?this.inputs[o]:o))??this.inputs,i=(t==null?void 0:t.outputs)??[],r=(o,l,u)=>new Zh(this.module,l,this.output(o,u),u),s=(o,l)=>{let u=Ou(o,l);if(!u)throw new Error(`Unsupported data type: ${o}`);let c=u>0?this.backend.gpuDataManager.create(u).id:0;return new Zh(this.module,o,c,l)};return this.backend.run(e,n,i,r,s,this.outputCount)}output(e,t){let n=this.module.stackSave();try{let i=this.module.PTR_SIZE,r=i===4?"i32":"i64",s=this.module.stackAlloc((1+t.length)*i);this.module.setValue(s,t.length,r);for(let a=0;a<t.length;a++)this.module.setValue(s+i*(a+1),t[a],r);return this.module._JsepOutput(this.opKernelContext,e,s)}catch(i){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${i}`)}finally{this.module.stackRestore(n)}}},G5=async(e,t,n,i)=>{let r=t.jsepInit;if(!r)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(e==="webgpu"){let s=(Rse(),vp(B5)).WebGpuBackend,a=new s;await a.initialize(n,i),r("webgpu",[a,o=>a.alloc(Number(o)),o=>a.free(o),(o,l,u,c=!1)=>{if(c)Ln("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(o)}, dst=${Number(l)}, size=${Number(u)}`),a.memcpy(Number(o),Number(l));else{Ln("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(o)}, gpuDataId=${Number(l)}, size=${Number(u)}`);let f=t.HEAPU8.subarray(Number(o>>>0),Number(o>>>0)+Number(u));a.upload(Number(l),f)}},async(o,l,u)=>{Ln("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${o}, dataOffset=${l}, size=${u}`),await a.download(Number(o),()=>t.HEAPU8.subarray(Number(l)>>>0,Number(l+u)>>>0))},(o,l,u)=>a.createKernel(o,Number(l),u,t.UTF8ToString(t._JsepGetNodeName(Number(l)))),o=>a.releaseKernel(o),(o,l,u,c)=>{Ln("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${o}, contextDataOffset=${l}`);let f=new az(t,a,Number(l));return a.computeKernel(Number(o),f,c)},()=>a.captureBegin(),()=>a.captureEnd(),()=>a.replay()])}else{let s=new ej(n);r("webnn",[s,()=>s.reserveTensorId(),a=>s.releaseTensorId(a),async(a,o,l,u,c)=>s.ensureTensor(a,o,l,u,c),(a,o)=>{s.uploadTensor(a,o)},async(a,o)=>s.downloadTensor(a,o),(a,o)=>s.registerMLContext(a,o),!!n.trace])}}}),oz,VT,GT,ml,lz,mw,Cg,jT,WT,gw,HT,qT,KT,W5=ft(()=>{na(),Ure(),Vre(),Qt(),pc(),ST(),K8(),oz=(e,t)=>{gi()._OrtInit(e,t)!==0&&ri("Can't initialize onnxruntime.")},VT=async e=>{oz(e.wasm.numThreads,xg(e.logLevel))},GT=async(e,t)=>{var i,r;(r=(i=gi()).asyncInit)==null||r.call(i);let n=e.webgpu.adapter;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");if(n){if(typeof n.limits!="object"||typeof n.features!="object"||typeof n.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let s=e.webgpu.powerPreference;if(s!==void 0&&s!=="low-power"&&s!=="high-performance")throw new Error(`Invalid powerPreference setting: "${s}"`);let a=e.webgpu.forceFallbackAdapter;if(a!==void 0&&typeof a!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${a}"`);if(n=await navigator.gpu.requestAdapter({powerPreference:s,forceFallbackAdapter:a}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if(t==="webnn"&&(typeof navigator>"u"||!navigator.ml))throw new Error("WebNN is not supported in current environment");{let s=(Nse(),vp(V5)).init;t==="webgpu"&&await s("webgpu",gi(),e,n),t==="webnn"&&await s("webnn",gi(),e)}},ml=new Map,lz=e=>{let t=gi(),n=t.stackSave();try{let i=t.PTR_SIZE,r=t.stackAlloc(2*i);t._OrtGetInputOutputCount(e,r,r+i)!==0&&ri("Can't get session input/output count.");let s=i===4?"i32":"i64";return[Number(t.getValue(r,s)),Number(t.getValue(r+i,s))]}finally{t.stackRestore(n)}},mw=(e,t)=>{let n=gi(),i=n.stackSave(),r=0;try{let s=n.PTR_SIZE,a=n.stackAlloc(2*s);n._OrtGetInputOutputMetadata(e,t,a,a+s)!==0&&ri("Can't get session input/output metadata.");let o=Number(n.getValue(a,"*"));r=Number(n.getValue(a+s,"*"));let l=n.HEAP32[r/4];if(l===0)return[o,0];let u=n.HEAPU32[r/4+1],c=[];for(let f=0;f<u;f++){let d=Number(n.getValue(r+8+f*s,"*"));c.push(d!==0?n.UTF8ToString(d):Number(n.getValue(r+8+(f+u)*s,"*")))}return[o,l,c]}finally{n.stackRestore(i),r!==0&&n._OrtFree(r)}},Cg=e=>{let t=gi(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},jT=async(e,t)=>{var f,d,h,m;let n,i,r=gi();Array.isArray(e)?[n,i]=e:e.buffer===r.HEAPU8.buffer?[n,i]=[e.byteOffset,e.byteLength]:[n,i]=Cg(e);let s=0,a=0,o=0,l=[],u=[],c=[];try{if([a,l]=await q8(t),(t==null?void 0:t.externalData)&&r.mountExternalData){let P=[];for(let O of t.externalData){let R=typeof O=="string"?O:O.path;P.push(AT(typeof O=="string"?O:O.data).then(G=>{r.mountExternalData(R,G)}))}await Promise.all(P)}for(let P of(t==null?void 0:t.executionProviders)??[])if((typeof P=="string"?P:P.name)==="webnn"){if(r.shouldTransferToMLTensor=!1,typeof P!="string"){let O=P,R=O==null?void 0:O.context,G=O==null?void 0:O.gpuDevice,W=O==null?void 0:O.deviceType,V=O==null?void 0:O.powerPreference;R?r.currentContext=R:G?r.currentContext=await r.webnnCreateMLContext(G):r.currentContext=await r.webnnCreateMLContext({deviceType:W,powerPreference:V})}else r.currentContext=await r.webnnCreateMLContext();break}s=await r._OrtCreateSession(n,i,a),(f=r.webgpuOnCreateSession)==null||f.call(r,s),s===0&&ri("Can't create a session."),(d=r.jsepOnCreateSession)==null||d.call(r),r.currentContext&&(r.webnnRegisterMLContext(s,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[y,M]=lz(s),g=!!(t!=null&&t.enableGraphCapture),_=[],T=[],x=[],S=[],$=[];for(let P=0;P<y;P++){let[O,R,G]=mw(s,P);O===0&&ri("Can't get an input name."),u.push(O);let W=r.UTF8ToString(O);_.push(W),x.push(R===0?{name:W,isTensor:!1}:{name:W,isTensor:!0,type:So(R),shape:G})}for(let P=0;P<M;P++){let[O,R,G]=mw(s,P+y);O===0&&ri("Can't get an output name."),c.push(O);let W=r.UTF8ToString(O);T.push(W),S.push(R===0?{name:W,isTensor:!1}:{name:W,isTensor:!0,type:So(R),shape:G});{if(g&&(t==null?void 0:t.preferredOutputLocation)===void 0){$.push("gpu-buffer");continue}let V=typeof(t==null?void 0:t.preferredOutputLocation)=="string"?t.preferredOutputLocation:((h=t==null?void 0:t.preferredOutputLocation)==null?void 0:h[W])??"cpu",te=r.webnnIsGraphOutput;if(V==="cpu"&&te&&te(s,W)){$.push("ml-tensor-cpu-output");continue}if(V!=="cpu"&&V!=="cpu-pinned"&&V!=="gpu-buffer"&&V!=="ml-tensor")throw new Error(`Not supported preferred output location: ${V}.`);if(g&&V!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${V}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);$.push(V)}}let C=null;return $.some(P=>P==="gpu-buffer"||P==="ml-tensor"||P==="ml-tensor-cpu-output")&&(o=r._OrtCreateBinding(s),o===0&&ri("Can't create IO binding."),C={handle:o,outputPreferredLocations:$,outputPreferredLocationsEncoded:$.map(P=>P==="ml-tensor-cpu-output"?"ml-tensor":P).map(P=>l1(P))}),ml.set(s,[s,u,c,C,g,!1]),[s,_,T,x,S]}catch(y){throw u.forEach(M=>r._OrtFree(M)),c.forEach(M=>r._OrtFree(M)),o!==0&&r._OrtReleaseBinding(o)!==0&&ri("Can't release IO binding."),s!==0&&r._OrtReleaseSession(s)!==0&&ri("Can't release session."),y}finally{r._free(n),a!==0&&r._OrtReleaseSessionOptions(a)!==0&&ri("Can't release session options."),l.forEach(y=>r._free(y)),(m=r.unmountExternalData)==null||m.call(r)}},WT=e=>{var l,u,c;let t=gi(),n=ml.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[i,r,s,a,o]=n;a&&(o&&t._OrtClearBoundOutputs(a.handle)!==0&&ri("Can't clear bound outputs."),t._OrtReleaseBinding(a.handle)!==0&&ri("Can't release IO binding.")),(l=t.jsepOnReleaseSession)==null||l.call(t,e),(u=t.webnnOnReleaseSession)==null||u.call(t,e),(c=t.webgpuOnReleaseSession)==null||c.call(t,e),r.forEach(f=>t._OrtFree(f)),s.forEach(f=>t._OrtFree(f)),t._OrtReleaseSession(i)!==0&&ri("Can't release session."),ml.delete(e)},gw=async(e,t,n,i,r,s,a=!1)=>{if(!e){t.push(0);return}let o=gi(),l=o.PTR_SIZE,u=e[0],c=e[1],f=e[3],d=f,h,m;if(u==="string"&&(f==="gpu-buffer"||f==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(a&&f!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${s} when enableGraphCapture is true.`);if(f==="gpu-buffer"){let g=e[2].gpuBuffer;m=Ou(Du(u),c);{let _=o.jsepRegisterBuffer;if(!_)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');h=_(i,s,g,m)}}else if(f==="ml-tensor"){let g=e[2].mlTensor;m=Ou(Du(u),c);let _=o.webnnRegisterMLTensor;if(!_)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');h=_(i,g,Du(u),c)}else{let g=e[2];if(Array.isArray(g)){m=l*g.length,h=o._malloc(m),n.push(h);for(let _=0;_<g.length;_++){if(typeof g[_]!="string")throw new TypeError(`tensor data at index ${_} is not a string`);o.setValue(h+_*l,Ta(g[_],n),"*")}}else{let _=o.webnnIsGraphInput,T=o.webnnIsGraphOutput;if(u!=="string"&&_&&T){let x=o.UTF8ToString(r);if(_(i,x)||T(i,x)){let S=Du(u);m=Ou(S,c),d="ml-tensor";let $=o.webnnCreateTemporaryTensor,C=o.webnnUploadTensor;if(!$||!C)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let P=await $(i,S,c);C(P,new Uint8Array(g.buffer,g.byteOffset,g.byteLength)),h=P}else m=g.byteLength,h=o._malloc(m),n.push(h),o.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,m),h)}else m=g.byteLength,h=o._malloc(m),n.push(h),o.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,m),h)}}let y=o.stackSave(),M=o.stackAlloc(4*c.length);try{c.forEach((_,T)=>o.setValue(M+T*l,_,l===4?"i32":"i64"));let g=o._OrtCreateTensor(Du(u),h,m,M,c.length,l1(d));g===0&&ri(`Can't create tensor for input/output. session=${i}, index=${s}.`),t.push(g)}finally{o.stackRestore(y)}},HT=async(e,t,n,i,r,s)=>{var G,W,V,te;let a=gi(),o=a.PTR_SIZE,l=ml.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let u=l[0],c=l[1],f=l[2],d=l[3],h=l[4],m=l[5],y=t.length,M=i.length,g=0,_=[],T=[],x=[],S=[],$=a.stackSave(),C=a.stackAlloc(y*o),P=a.stackAlloc(y*o),O=a.stackAlloc(M*o),R=a.stackAlloc(M*o);try{[g,_]=H8(s),zl("wasm prepareInputOutputTensor");for(let X=0;X<y;X++)await gw(n[X],T,S,e,c[t[X]],t[X],h);for(let X=0;X<M;X++)await gw(r[X],x,S,e,f[i[X]],y+i[X],h);Fl("wasm prepareInputOutputTensor");for(let X=0;X<y;X++)a.setValue(C+X*o,T[X],"*"),a.setValue(P+X*o,c[t[X]],"*");for(let X=0;X<M;X++)a.setValue(O+X*o,x[X],"*"),a.setValue(R+X*o,f[i[X]],"*");if(d&&!m){let{handle:X,outputPreferredLocations:ce,outputPreferredLocationsEncoded:me}=d;if(c.length!==y)throw new Error(`input count from feeds (${y}) is expected to be always equal to model's input count (${c.length}).`);zl("wasm bindInputsOutputs");for(let Q=0;Q<y;Q++){let H=t[Q];await a._OrtBindInput(X,c[H],T[Q])!==0&&ri(`Can't bind input[${Q}] for session=${e}.`)}for(let Q=0;Q<M;Q++){let H=i[Q];(G=r[Q])!=null&&G[3]?a._OrtBindOutput(X,f[H],x[Q],0)!==0&&ri(`Can't bind pre-allocated output[${Q}] for session=${e}.`):a._OrtBindOutput(X,f[H],0,me[H])!==0&&ri(`Can't bind output[${Q}] to ${ce[Q]} for session=${e}.`)}Fl("wasm bindInputsOutputs"),ml.set(e,[u,c,f,d,h,!0])}(W=a.jsepOnRunStart)==null||W.call(a,u),(V=a.webnnOnRunStart)==null||V.call(a,u);let J;d?J=await a._OrtRunWithBinding(u,d.handle,M,O,g):J=await a._OrtRun(u,P,C,y,R,M,O,g),J!==0&&ri("failed to call OrtRun().");let j=[],Y=[];zl("wasm ProcessOutputTensor");for(let X=0;X<M;X++){let ce=Number(a.getValue(O+X*o,"*"));if(ce===x[X]){j.push(r[X]);continue}let me=a.stackSave(),Q=a.stackAlloc(4*o),H=!1,B,ee=0;try{a._OrtGetTensorData(ce,Q,Q+o,Q+2*o,Q+3*o)!==0&&ri(`Can't access output tensor data on index ${X}.`);let _e=o===4?"i32":"i64",le=Number(a.getValue(Q,_e));ee=a.getValue(Q+o,"*");let ae=a.getValue(Q+o*2,"*"),Ne=Number(a.getValue(Q+o*3,_e)),Ye=[];for(let U=0;U<Ne;U++)Ye.push(Number(a.getValue(ae+U*o,_e)));a._OrtFree(ae)!==0&&ri("Can't free memory for tensor dims.");let ze=Ye.reduce((U,we)=>U*we,1);B=So(le);let ue=d==null?void 0:d.outputPreferredLocations[i[X]];if(B==="string"){if(ue==="gpu-buffer"||ue==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let U=[];for(let we=0;we<ze;we++){let Pe=a.getValue(ee+we*o,"*"),ke=a.getValue(ee+(we+1)*o,"*"),Le=we===ze-1?void 0:ke-Pe;U.push(a.UTF8ToString(Pe,Le))}j.push([B,Ye,U,"cpu"])}else if(ue==="gpu-buffer"&&ze>0){let U=a.jsepGetBuffer;if(!U)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let we=U(ee),Pe=Ou(le,ze);if(Pe===void 0||!CT(B))throw new Error(`Unsupported data type: ${B}`);H=!0,j.push([B,Ye,{gpuBuffer:we,download:a.jsepCreateDownloader(we,Pe,B),dispose:()=>{a._OrtReleaseTensor(ce)!==0&&ri("Can't release tensor.")}},"gpu-buffer"])}else if(ue==="ml-tensor"&&ze>0){let U=a.webnnEnsureTensor,we=a.webnnIsGraphInputOutputTypeSupported;if(!U||!we)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Ou(le,ze)===void 0||!$T(B))throw new Error(`Unsupported data type: ${B}`);if(!we(e,B,!1))throw new Error(`preferredLocation "ml-tensor" for ${B} output is not supported by current WebNN Context.`);let Pe=await U(e,ee,le,Ye,!1);H=!0,j.push([B,Ye,{mlTensor:Pe,download:a.webnnCreateMLTensorDownloader(ee,B),dispose:()=>{a.webnnReleaseTensorId(ee),a._OrtReleaseTensor(ce)}},"ml-tensor"])}else if(ue==="ml-tensor-cpu-output"&&ze>0){let U=a.webnnCreateMLTensorDownloader(ee,B)(),we=j.length;H=!0,Y.push((async()=>{let Pe=[we,await U];return a.webnnReleaseTensorId(ee),a._OrtReleaseTensor(ce),Pe})()),j.push([B,Ye,[],"cpu"])}else{let U=a_(B),we=new U(ze);new Uint8Array(we.buffer,we.byteOffset,we.byteLength).set(a.HEAPU8.subarray(ee,ee+we.byteLength)),j.push([B,Ye,we,"cpu"])}}finally{a.stackRestore(me),B==="string"&&ee&&a._free(ee),H||a._OrtReleaseTensor(ce)}}d&&!h&&(a._OrtClearBoundOutputs(d.handle)!==0&&ri("Can't clear bound outputs."),ml.set(e,[u,c,f,d,h,!1]));for(let[X,ce]of await Promise.all(Y))j[X][2]=ce;return Fl("wasm ProcessOutputTensor"),j}finally{(te=a.webnnOnRunEnd)==null||te.call(a,u),a.stackRestore($),T.forEach(J=>a._OrtReleaseTensor(J)),x.forEach(J=>a._OrtReleaseTensor(J)),S.forEach(J=>a._free(J)),g!==0&&a._OrtReleaseRunOptions(g),_.forEach(J=>a._free(J))}},qT=e=>{let t=gi(),n=ml.get(e);if(!n)throw new Error("invalid session id");let i=n[0],r=t._OrtEndProfiling(i);r===0&&ri("Can't get an profile file name."),t._OrtFree(r)},KT=e=>{let t=[];for(let n of e){let i=n[2];!Array.isArray(i)&&"buffer"in i&&t.push(i.buffer)}return t}}),gl,ts,Ic,bf,xf,em,_w,tm,xu,Tu,uz,H5,q5,K5,J5,Y5,X5,Q5,Z5=ft(()=>{na(),W5(),pc(),MT(),gl=()=>!!bi.wasm.proxy&&typeof document<"u",Ic=!1,bf=!1,xf=!1,tm=new Map,xu=(e,t)=>{let n=tm.get(e);n?n.push(t):tm.set(e,[t])},Tu=()=>{if(Ic||!bf||xf||!ts)throw new Error("worker not ready")},uz=e=>{switch(e.data.type){case"init-wasm":Ic=!1,e.data.err?(xf=!0,_w[1](e.data.err)):(bf=!0,_w[0]()),em&&(URL.revokeObjectURL(em),em=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=tm.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},H5=async()=>{if(!bf){if(Ic)throw new Error("multiple calls to 'initWasm()' detected.");if(xf)throw new Error("previous call to 'initWasm()' failed.");if(Ic=!0,gl())return new Promise((e,t)=>{ts==null||ts.terminate(),j8().then(([n,i])=>{try{ts=i,ts.onerror=s=>t(s),ts.onmessage=uz,_w=[e,t];let r={type:"init-wasm",in:bi};!r.in.wasm.wasmPaths&&(n||o1)&&(r.in.wasm.wasmPaths={wasm:new URL("/Gemini-AI-Translator/assets/ort-wasm-simd-threaded.jsep-BGTZ4Y7F.wasm",import.meta.url).href}),ts.postMessage(r),em=n}catch(r){t(r)}},t)});try{await ET(bi.wasm),await VT(bi),bf=!0}catch(e){throw xf=!0,e}finally{Ic=!1}}},q5=async e=>{if(gl())return Tu(),new Promise((t,n)=>{xu("init-ep",[t,n]);let i={type:"init-ep",in:{epName:e,env:bi}};ts.postMessage(i)});await GT(bi,e)},K5=async e=>gl()?(Tu(),new Promise((t,n)=>{xu("copy-from",[t,n]);let i={type:"copy-from",in:{buffer:e}};ts.postMessage(i,[e.buffer])})):Cg(e),J5=async(e,t)=>{if(gl()){if(t!=null&&t.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Tu(),new Promise((n,i)=>{xu("create",[n,i]);let r={type:"create",in:{model:e,options:{...t}}},s=[];e instanceof Uint8Array&&s.push(e.buffer),ts.postMessage(r,s)})}else return jT(e,t)},Y5=async e=>{if(gl())return Tu(),new Promise((t,n)=>{xu("release",[t,n]);let i={type:"release",in:e};ts.postMessage(i)});WT(e)},X5=async(e,t,n,i,r,s)=>{if(gl()){if(n.some(a=>a[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(r.some(a=>a))throw new Error("pre-allocated output tensor is not supported for proxy.");return Tu(),new Promise((a,o)=>{xu("run",[a,o]);let l=n,u={type:"run",in:{sessionId:e,inputIndices:t,inputs:l,outputIndices:i,options:s}};ts.postMessage(u,KT(l))})}else return HT(e,t,n,i,r,s)},Q5=async e=>{if(gl())return Tu(),new Promise((t,n)=>{xu("end-profiling",[t,n]);let i={type:"end-profiling",in:e};ts.postMessage(i)});qT(e)}}),yw,cz,eH,Lse=ft(()=>{na(),Z5(),Qt(),TT(),K8(),yw=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},cz=e=>{switch(e[3]){case"cpu":return new Ea(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!CT(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:i,dispose:r}=e[2];return Ea.fromGpuBuffer(n,{dataType:t,dims:e[1],download:i,dispose:r})}case"ml-tensor":{let t=e[0];if(!$T(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:i,dispose:r}=e[2];return Ea.fromMLTensor(n,{dataType:t,dims:e[1],download:i,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},eH=class{async fetchModelAndCopyToWasmMemory(e){return K5(await AT(e))}async loadModel(e,t){Pa();let n;typeof e=="string"?n=await this.fetchModelAndCopyToWasmMemory(e):n=e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await J5(n,t),Zs()}async dispose(){return Y5(this.sessionId)}async run(e,t,n){Pa();let i=[],r=[];Object.entries(e).forEach(f=>{let d=f[0],h=f[1],m=this.inputNames.indexOf(d);if(m===-1)throw new Error(`invalid input '${d}'`);i.push(h),r.push(m)});let s=[],a=[];Object.entries(t).forEach(f=>{let d=f[0],h=f[1],m=this.outputNames.indexOf(d);if(m===-1)throw new Error(`invalid output '${d}'`);s.push(h),a.push(m)});let o=i.map((f,d)=>yw(f,()=>`input "${this.inputNames[r[d]]}"`)),l=s.map((f,d)=>f?yw(f,()=>`output "${this.outputNames[a[d]]}"`):null),u=await X5(this.sessionId,r,o,a,l,n),c={};for(let f=0;f<u.length;f++)c[this.outputNames[a[f]]]=s[f]??cz(u[f]);return Zs(),c}startProfiling(){}endProfiling(){Q5(this.sessionId)}}}),tH={};Vd(tH,{OnnxruntimeWebAssemblyBackend:()=>x1,initializeFlags:()=>b1,wasmBackend:()=>nH});var b1,x1,nH,zse=ft(()=>{na(),Z5(),Lse(),b1=()=>{(typeof bi.wasm.initTimeout!="number"||bi.wasm.initTimeout<0)&&(bi.wasm.initTimeout=0);let e=bi.wasm.simd;if(typeof e!="boolean"&&e!==void 0&&e!=="fixed"&&e!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),bi.wasm.simd=!1),typeof bi.wasm.proxy!="boolean"&&(bi.wasm.proxy=!1),typeof bi.wasm.trace!="boolean"&&(bi.wasm.trace=!1),typeof bi.wasm.numThreads!="number"||!Number.isInteger(bi.wasm.numThreads)||bi.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)bi.wasm.numThreads=1;else{let t=typeof navigator>"u"?Mre("node:os").cpus().length:navigator.hardwareConcurrency;bi.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},x1=class{async init(e){b1(),await H5(),await q5(e)}async createInferenceSessionHandler(e,t){let n=new eH;return await n.loadModel(e,t),n}},nH=new x1});na();na();na();var Fse="1.23.2",iH=z8;{let e=(zse(),vp(tH)).wasmBackend;Lu("webgpu",e,5),Lu("webnn",e,5),Lu("cpu",e,10),Lu("wasm",e,10)}Object.defineProperty(bi.versions,"web",{value:Fse,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bse=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return xT},get TRACE(){return wp},get TRACE_EVENT_BEGIN(){return zl},get TRACE_EVENT_END(){return Fl},get TRACE_FUNC_BEGIN(){return Pa},get TRACE_FUNC_END(){return Zs},get Tensor(){return Ea},default:iH,get env(){return bi},get registerBackend(){return Lu}},Symbol.toStringTag,{value:"Module"})),Use="PaddleOCR-ModelCache",Ad="models",Vse=1;let nm;const rH=()=>new Promise((e,t)=>{if(nm)return e(nm);const n=indexedDB.open(Use,Vse);n.onerror=()=>{t("Error opening IndexedDB.")},n.onsuccess=()=>{nm=n.result,e(nm)},n.onupgradeneeded=()=>{const i=n.result;i.objectStoreNames.contains(Ad)||i.createObjectStore(Ad)}}),vw=e=>new Promise(async(t,n)=>{try{const a=(await rH()).transaction(Ad,"readonly").objectStore(Ad).get(e);a.onsuccess=()=>{t(a.result)},a.onerror=()=>{n("Error getting data from IndexedDB.")}}catch(i){n(i)}}),ww=(e,t)=>new Promise(async(n,i)=>{try{const o=(await rH()).transaction(Ad,"readwrite").objectStore(Ad).put(t,e);o.onsuccess=()=>{n()},o.onerror=()=>{i("Error setting data in IndexedDB.")}}catch(r){i(r)}}),Gse=()=>{const[e,t]=Ie.useState(null),[n,i]=Ie.useState("uninitialized"),[r,s]=Ie.useState(null),a=Ie.useCallback(async l=>{i("initializing"),s(null);try{const u=iH||Bse,c="det-model",f=`rec-model-${l.key}`,d=`dict-${l.key}`;let h=await vw(c),m=await vw(f),y=await vw(d);const M=[];if(h||M.push(fetch(l.detPath).then(_=>_.arrayBuffer()).then(async _=>{h=_,await ww(c,_)})),m||M.push(fetch(l.recPath).then(_=>_.arrayBuffer()).then(async _=>{m=_,await ww(f,_)})),y||M.push(fetch(l.dictPath).then(_=>_.arrayBuffer()).then(async _=>{y=new TextDecoder("utf-8").decode(_),await ww(d,y)})),M.length>0&&await Promise.all(M),!h||!m||!y)throw new Error("Failed to load required assets.");const g=await Yie({det:{input:new Uint8Array(h)},rec:{input:new Uint8Array(m),decodeDic:y,optimize:{space:!1}},ort:u});t(g),i("ready")}catch(u){s(`Initialization failed: ${u.message||"Check models"}`),i("error"),console.error("OCR Engine initialization error:",u)}},[]),o=Ie.useCallback(async l=>{if(n!=="ready"||!e)return null;try{const u=performance.now(),c=await e.ocr(l),f=performance.now();return{result:c,time:f-u}}catch(u){throw console.error("Recognition error:",u),new Error(u.message||"OCR processing failed.")}},[e,n]);return{status:n,error:r,recognize:o,initializeOcr:a}},dz=e=>{let t;if(e.numberOfChannels>1){t=new Float32Array(e.length);for(let c=0;c<e.length;c++){let f=0;for(let d=0;d<e.numberOfChannels;d++)f+=e.getChannelData(d)[c];t[c]=f/e.numberOfChannels}}else t=e.getChannelData(0);const n=1,i=t.length*n*2+44,r=new ArrayBuffer(i),s=new DataView(r);let a=0;const o=c=>{s.setUint16(a,c,!0),a+=2},l=c=>{s.setUint32(a,c,!0),a+=4},u=c=>{for(let f=0;f<c.length;f++)s.setUint8(a+f,c.charCodeAt(f));a+=c.length};u("RIFF"),l(i-8),u("WAVE"),u("fmt "),l(16),o(1),o(n),l(e.sampleRate),l(e.sampleRate*2*n),o(n*2),o(16),u("data"),l(t.length*2);for(let c=0;c<t.length;c++){let f=Math.max(-1,Math.min(1,t[c]));s.setInt16(a,f<0?f*32768:f*32767,!0),a+=2}return new Blob([s],{type:"audio/wav"})},jse=e=>{const t=e.box.map(o=>o[0]),n=e.box.map(o=>o[1]),i=Math.min(...t),r=Math.max(...t),s=Math.min(...n),a=Math.max(...n);return{...e,minX:i,maxX:r,minY:s,maxY:a,centerX:(i+r)/2,centerY:(s+a)/2,height:a-s}},im=e=>{const t=[];return e.sort((n,i)=>n.centerY-i.centerY),e.forEach(n=>{const i=t.find(r=>{const s=r.reduce((o,l)=>o+l.centerY,0)/r.length,a=r.reduce((o,l)=>o+l.height,0)/r.length;return Math.abs(n.centerY-s)<a*.6});i?i.push(n):t.push([n])}),t.sort((n,i)=>{const r=s=>Math.min(...s.map(a=>a.minY));return r(n)-r(i)}),t.map(n=>(n.sort((i,r)=>i.minX-r.minX),n.map(i=>i.text).join(" "))).join(`
`)},Wse=e=>{if(!e||e.length===0)return"";const t=e.map(jse);if(t.length<2)return im(t);const n=Math.min(...t.map(d=>d.minX)),r=Math.max(...t.map(d=>d.maxX))-n,s=new Int32Array(Math.ceil(r)+1);t.forEach(d=>{const h=Math.floor(d.minX-n),m=Math.ceil(d.maxX-n);for(let y=h;y<m;y++)y>=0&&y<s.length&&s[y]++});const a=Math.floor(r*.25),o=Math.floor(r*.75);let l=0,u=-1,c=-1;for(let d=a;d<=o;d++)if(s[d]===0)c===-1&&(c=d);else if(c!==-1){const h=d-c;h>l&&(l=h,u=c+h/2),c=-1}if(u!==-1&&l>10){const d=n+u,h=t.filter(g=>g.centerX<d),m=t.filter(g=>g.centerX>=d),y=im(h),M=im(m);return`${y}

${M}`}return im(t)},Hse=e=>{var n;const t=e.src;return!t||t.length===0?((n=e.parragraphs)==null?void 0:n.map(i=>i.text).join(`
`))||"":Wse(t)},qse=()=>{var _r;const{t:e,i18n:t}=uc(),[n,i]=Ie.useState(""),[r,s]=Ie.useState(""),[a,o]=Ie.useState(sg[0]),[l,u]=Ie.useState(sg[6]),[c,f]=Ie.useState(!1),[d,h]=Ie.useState(!1),[m,y]=Ie.useState(!1),[M,g]=Ie.useState(!1),[_,T]=Ie.useState(!1),[x,S]=Ie.useState(!1),[$,C]=Ie.useState([]),[P,O]=Ie.useState(""),[R,G]=Ie.useState("gemini-2.5-flash"),[W,V]=Ie.useState("gemini"),[te,J]=Ie.useState(""),[j,Y]=Ie.useState(""),[X,ce]=Ie.useState(""),[me,Q]=Ie.useState(!1),[H,B]=Ie.useState([]),[ee,_e]=Ie.useState([]),[le,ae]=Ie.useState(navigator.onLine),[Ne,Ye]=Ie.useState(!1),[ze,ue]=Ie.useState(null),[U,we]=Ie.useState(!1),[Pe,ke]=Ie.useState(""),[Le,Ge]=Ie.useState(1),[$e,et]=Ie.useState(1),[Ce,He]=Ie.useState(!1),[at,Z]=Ie.useState({}),[he,ye]=Ie.useState(!1),[Ke,Be]=Ie.useState(!1),[Se,Oe]=Ie.useState(4096),[ct,bt]=Ie.useState(40),[Ct,Et]=Ie.useState(.3),[hn,En]=Ie.useState(101),[Kt,yi]=Ie.useState(!1),[Ji,tr]=Ie.useState(0),[Ti,Yn]=Ie.useState(!0),[$n,Yi]=Ie.useState(!1),[Gi,xt]=Ie.useState(Ru[0].id),[ji,Wi]=Ie.useState(!1),[Sn,Ii]=Ie.useState(!1),[Xt,nr]=Ie.useState({}),[L,oe]=Ie.useState({file:"",progress:0}),[K,re]=Ie.useState(!1),[de,xe]=Ie.useState(1),[Ue,_t]=Ie.useState(null),[$t,mt]=Ie.useState(!1),{status:Ht,error:It,recognize:Zt,initializeOcr:St}=Gse(),[tn,vn]=Ie.useState("ch_v5"),[Wn,ei]=Ie.useState(null),Bn=Ie.useRef(null),Je=Ie.useRef(null),qt=Ie.useRef(tt=>{}),Pt=Ie.useRef(null),kt=Ie.useCallback((tt,it="error")=>{Bn.current&&clearTimeout(Bn.current),ei({message:tt,type:it}),Bn.current=window.setTimeout(()=>{ei(null)},5e3)},[]);Ie.useRef(null),Ie.useRef(null),Ie.useRef(""),Ie.useRef(null);const An=Ie.useRef(null),zn=Ie.useRef([]),ni=Ie.useRef(null),Un=Ie.useRef(null),In=Ie.useRef(null),ir=Ie.useRef(null),Mi=Ie.useRef(!1),ci=Ie.useCallback(()=>{if(Je.current)return Je.current;console.log("Creating offline worker...");const tt=new Worker(new URL("/Gemini-AI-Translator/assets/offline.worker-Dn22XZOm.js",import.meta.url),{type:"module"});Je.current=tt;const it=Ve=>qt.current(Ve);return tt.addEventListener("message",it),tt.onerror=Ve=>{console.error("Worker error:",Ve),kt(`A critical worker error occurred: ${Ve.message}`,"error"),ye(!1),f(!1)},tt},[kt]);Ie.useEffect(()=>()=>{Je.current&&(Je.current.terminate(),Je.current=null,console.log("Offline worker terminated on component unmount."))},[]),Ie.useEffect(()=>{qt.current=tt=>{const{type:it,payload:Ve}=tt.data;switch(it){case"init_done":Be(!0),kt(e("notifications.offlineModelInitSuccess",{modelIdentifier:Ve.modelIdentifier}),"success"),ye(!1);break;case"init_error":Be(!1),kt(Ve.error||e("notifications.offlineModelInitFailed"),"error"),console.error("Offline model init failed via worker:",Ve.error),ye(!1);break;case"unload_done":Be(!1),ye(!1);break;case"translation_chunk":s(Gt=>Gt.length===0?Ve.chunk.trimStart():Gt+Ve.chunk);break;case"translation_done":{const Gt={id:Date.now(),inputText:n,translatedText:Ve.result,sourceLang:a,targetLang:l};C(rn=>{const kn=[Gt,...rn].slice(0,50);return localStorage.setItem("translation-history",JSON.stringify(kn)),kn}),f(!1);break}case"translation_error":kt(e("notifications.translationFailed",{errorMessage:Ve.error}),"error"),f(!1);break;case"translation_cancelled":f(!1);break;case"extract_text_done":i(Ve.text),s(""),Ve.text.trim()||kt(e("notifications.noTextInImage"),"error"),f(!1);break;case"extract_text_error":kt(e("notifications.imageProcessingFailed",{errorMessage:Ve.error}),"error"),i(""),f(!1);break;case"transcribe_done":const vt=Ve.text;i(vt),f(!1),$t&&(mt(!1),vt.trim()&&mn(vt));break;case"transcribe_error":kt(e("notifications.transcriptionFailed",{errorMessage:Ve.error}),"error"),i(""),f(!1),mt(!1);break}}},[e,kt,n,a,l,$t]);const Xi=Ie.useCallback(async()=>{const tt={};for(const it of Ru)tt[it.id]=await CO(it.id);return tt},[]),Cr=Ie.useCallback(async tt=>{tt.trim()},[l,a]),Hi=Ie.useCallback(tt=>{const{type:it,payload:Ve}=tt.data;switch(it){case"progress":(Ve.status==="progress"||Ve.status==="download")&&oe({file:Ve.file,progress:Ve.progress});break;case"error":kt(Ve,"error"),i(Ve),Wi(!1);break;case"loaded":Ii(!0),Wi(!1),Xi().then(nr);break;case"unloaded":Ii(!1),kt(e("notifications.asrModelUnloaded"),"info");break;case"transcription-partial":i(Ve);break;case"transcription":i(Ve),Mi.current&&(Ve.trim(),Mi.current=!1);break;case"log":console.log("[ASR Worker]:",Ve);break}},[kt,Xi,e]),ot=Ie.useCallback(()=>{Pt.current&&Pt.current.terminate();const tt=new Worker(new URL("/Gemini-AI-Translator/assets/asr.worker-CWoSFOAw.js",import.meta.url),{type:"module"});tt.addEventListener("message",Hi),Pt.current=tt,console.log("ASR Worker initialized.")},[Hi]);Ie.useEffect(()=>{$n?(Pt.current||ot(),(async()=>{if(Pt.current&&Gi&&!Sn&&!ji&&await CO(Gi)){const Ve=Ru.find(vt=>vt.id===Gi);Ve&&(console.log(`Auto-loading cached ASR model: ${Ve.id}`),Wi(!0),oe({file:"",progress:0}),Pt.current.postMessage({type:"load",payload:{modelId:Ve.id,quantization:Ve.quantization}}))}})()):Pt.current&&(console.log("Disabling offline ASR. Terminating worker."),Pt.current.terminate(),Pt.current=null,Ii(!1),Wi(!1))},[$n,Gi,Sn,ji,ot]),Ie.useEffect(()=>{(async()=>{const it={};for(const Ve of ag)Ve.value&&(it[Ve.value]=await $c.getStatus(Ve.value));Z(it)})(),Xi().then(it=>{nr(it)})},[Xi]),Ie.useEffect(()=>{const tt=()=>ae(!0),it=()=>ae(!1);return window.addEventListener("online",tt),window.addEventListener("offline",it),()=>{window.removeEventListener("online",tt),window.removeEventListener("offline",it)}},[]),Ie.useEffect(()=>{const tt=localStorage.getItem("api-key");tt&&O(tt);const it=localStorage.getItem("model-name");it&&G(it);const Ve=localStorage.getItem("online-provider");Ve&&V(Ve);const vt=localStorage.getItem("openai-api-url");vt&&J(vt);const Gt=localStorage.getItem("hf-api-key");Gt&&Y(Gt);const rn=localStorage.getItem("offline-model-name");rn&&ce(rn);const kn=localStorage.getItem("offline-mode-enabled");kn&&He(JSON.parse(kn));const Mn=localStorage.getItem("is-two-step-jp-cn-enabled");Mn&&Q(JSON.parse(Mn));const Dn=localStorage.getItem("tts-enabled");Dn&&we(JSON.parse(Dn));const li=localStorage.getItem("tts-voice-uri");li&&ke(li);const Vn=localStorage.getItem("tts-rate");Vn&&Ge(JSON.parse(Vn));const Bi=localStorage.getItem("tts-pitch");Bi&&et(JSON.parse(Bi));const $r=localStorage.getItem("offline-max-tokens");$r&&Oe(JSON.parse($r));const yr=localStorage.getItem("offline-top-k");yr&&bt(JSON.parse(yr));const $s=localStorage.getItem("offline-temperature");$s&&Et(JSON.parse($s));const As=localStorage.getItem("offline-random-seed");As&&En(JSON.parse(As));const us=localStorage.getItem("offline-support-audio");us&&yi(JSON.parse(us));const Is=localStorage.getItem("offline-max-num-images");Is&&tr(JSON.parse(Is));const Ps=localStorage.getItem("is-offline-asr-enabled");Ps&&Yi(JSON.parse(Ps));const Rr=localStorage.getItem("is-web-speech-api-enabled");Rr&&Yn(JSON.parse(Rr));const ks=localStorage.getItem("asr-model-id");ks&&xt(ks);const Ds=localStorage.getItem("is-noise-cancellation-enabled");Ds&&re(JSON.parse(Ds));const Os=localStorage.getItem("audio-gain-value");Os&&xe(JSON.parse(Os));const Rs=localStorage.getItem("custom-offline-models");Rs&&B(JSON.parse(Rs));const Ra=localStorage.getItem("selected-ocr-model");Ra&&Object.prototype.hasOwnProperty.call(xb,Ra)&&vn(Ra);try{const Br=localStorage.getItem("translation-history");Br&&C(JSON.parse(Br))}catch(Br){console.error("Failed to load translation history:",Br)}},[]),Ie.useEffect(()=>{const tt=()=>_e(window.speechSynthesis.getVoices());window.speechSynthesis.onvoiceschanged=tt,tt()},[]);const lt=Ce&&!!X&&((_r=at[X])==null?void 0:_r.status)==="completed",wt=lt&&Ke;Ie.useEffect(()=>{const tt=lt?X:null;if(!Ce||!tt){(Ke||he)&&Je.current&&(console.log("Requesting offline model unload."),Je.current.postMessage({type:"unload"}));return}(async()=>{ye(!0),Be(!1);try{const Ve=await $c.getModelAsBlob(tt);if(!Ve)throw new Error(`Model blob for ${tt} not found.`);const vt={maxTokens:Se,topK:ct,temperature:Ct,randomSeed:hn,supportAudio:Kt,maxNumImages:Ji};ci().postMessage({type:"init",payload:{modelBlob:Ve,modelSource:tt,options:vt}})}catch(Ve){const vt=Ve instanceof Error?Ve.message:e("notifications.offlineModelInitFailed");kt(vt,"error"),console.error("Offline model init failed (main thread):",Ve),Be(!1),ye(!1)}})()},[lt,X,Ce,kt,e,ci,Se,ct,Ct,hn,Kt,Ji]);const mn=Ie.useCallback(async tt=>{if(!tt.trim()){s("");return}Un.current&&Un.current.abort();const it=new AbortController;Un.current=it,f(!0),s("");try{const Ve=t.t(a.name,{lng:"en"}),vt=t.t(l.name,{lng:"en"});if(Ce){if(!X)throw new Error("Please select an offline model in settings.");if(he)throw new Error("Offline model is still initializing.");if(!wt)throw new Error("Selected offline model is not ready.");ci().postMessage({type:"translate",payload:{text:tt,sourceLang:Ve,targetLang:vt,sourceLangCode:a.code,targetLangCode:l.code,isTwoStepEnabled:me}})}else{if(!le)throw new Error("You are offline. Enable offline mode or connect to the internet.");let Gt="";const rn=Mn=>{Gt+=Mn,s(Dn=>Dn.length===0?Mn.trimStart():Dn+Mn)};if(W==="openai"){if(!P)throw new Error("OpenAI API Key is not set. Please add it in the settings.");if(!te)throw new Error("OpenAI API URL is not set. Please add it in the settings.");Gt=await Ite(tt,Ve,vt,P,R,te,rn,it.signal)}else{if(!P)throw new Error("Gemini API Key is not set. Please add it in the settings.");Gt=await $te(tt,Ve,vt,P,R,rn,it.signal)}const kn={id:Date.now(),inputText:tt,translatedText:Gt,sourceLang:a,targetLang:l};C(Mn=>{const Dn=[kn,...Mn].slice(0,50);return localStorage.setItem("translation-history",JSON.stringify(Dn)),Dn}),f(!1)}}catch(Ve){if(Ve instanceof DOMException&&Ve.name==="AbortError"){console.log("Translation cancelled by user."),f(!1);return}const vt=Ve instanceof Error?Ve.message:"An unknown error occurred.";kt(e("notifications.translationFailed",{errorMessage:vt}),"error"),Ve instanceof Error&&(Ve.message.includes("select an offline model")||Ve.message.includes("API Key is not set")||Ve.message.includes("API URL is not set"))&&T(!0),console.error(Ve),f(!1)}finally{!Ce&&Un.current===it&&(Un.current=null)}},[a,l,P,R,le,Ce,X,wt,he,kt,W,te,me,e,t,ci]),os=Ie.useCallback(()=>{mn(n)},[n,mn]),Yr=Ie.useCallback(()=>{var tt;Ce?Je.current&&Je.current.postMessage({type:"cancel_translation"}):(tt=Un.current)==null||tt.abort(),In.current&&(In.current.abort(),In.current=null)},[Ce]),ls=Ie.useCallback(()=>{a.code!=="auto"&&(o(l),u(a),i(r),s(n))},[a,l,n,r]),ia=Ie.useCallback(async tt=>{if(!r)return;if(window.speechSynthesis.speaking&&(window.speechSynthesis.cancel(),Ne&&(U||ze===tt))){Ye(!1),ue(null);return}if(Ye(!0),ue(tt),!("speechSynthesis"in window)){Ye(!1),ue(null);return}const it=new SpeechSynthesisUtterance(r);if(it.lang=l.code,U){const Ve=ee.find(vt=>vt.voiceURI===Pe);Ve&&(it.voice=Ve),it.rate=Le,it.pitch=$e}else{const Ve=ee.filter(vt=>vt.lang.startsWith(l.code));if(Ve.length>0){const vt=Ve.find(kn=>/female|women|girl|mei-jia|zira|ayumi|kyoko/i.test(kn.name)),Gt=Ve.find(kn=>/male|men|boy|liang|ichiro/i.test(kn.name));let rn;tt==="female"?rn=vt||Ve.find(kn=>kn!==Gt)||Ve[0]:rn=Gt||Ve.find(kn=>kn!==vt)||Ve[0],it.voice=rn}}it.onstart=()=>{Ye(!0),ue(U?null:tt)},it.onend=()=>{Ye(!1),ue(null)},it.onerror=Ve=>{console.error("SpeechSynthesisUtterance.onerror",Ve),kt(e("notifications.speechError",{error:Ve.error}),"error"),Ye(!1),ue(null)},window.speechSynthesis.speak(it)},[r,l,ee,Ne,ze,kt,U,Pe,Le,$e,e,le,W,P]),Ee=()=>{An.current&&An.current.state==="recording"&&An.current.stop(),In.current&&(In.current.abort(),In.current=null)},z=tt=>{d||m||navigator.mediaDevices.getUserMedia({audio:!0}).then(it=>{zn.current=[],ir.current=tt;const Ve=new MediaRecorder(it);An.current=Ve,Ve.ondataavailable=vt=>{vt.data.size>0&&zn.current.push(vt.data)},Ve.onstop=()=>{var rn;const vt=((rn=An.current)==null?void 0:rn.mimeType)||"audio/webm",Gt=new Blob(zn.current,{type:vt});ir.current&&ir.current(Gt),it.getTracks().forEach(kn=>kn.stop()),An.current=null,ir.current=null,h(!1),y(!1)},Ve.onerror=vt=>{kt(`Recording error: ${vt.error.message}`,"error"),h(!1),y(!1)},Ve.start()}).catch(it=>{kt(`Could not start recording: ${it.message}`,"error"),h(!1),y(!1)})},ne=Ie.useCallback((tt,it)=>{i(tt),it&&Mi.current&&(mn(tt),Mi.current=!1)},[mn]),pe=Ie.useCallback(tt=>{kt(e("notifications.speechRecognitionError",{error:tt}),"error")},[kt,e]),be=Ie.useCallback(()=>{h(!1),y(!1),Mi.current=!1},[]),Me=Ie.useCallback(()=>{},[]),Fe=Oie({onResult:ne,onError:pe,onStart:Me,onEnd:be}),ut=Ie.useCallback(()=>{An.current&&An.current.state==="recording"?An.current.stop():Fe.isListening&&Fe.stopRecognition()},[Fe]);Ie.useEffect(()=>(d||m?(_t(30),ni.current=window.setInterval(()=>{_t(tt=>tt!==null&&tt<=1?(ni.current&&(clearInterval(ni.current),ni.current=null),ut(),null):tt!==null?tt-1:null)},1e3)):(ni.current&&(clearInterval(ni.current),ni.current=null),_t(null)),()=>{ni.current&&clearInterval(ni.current)}),[d,m,ut]);const yt=Ie.useCallback(()=>{if(d||!$n&&Ti&&Fe.isListening&&!Mi.current)$n||!Ti?Ee():Fe.stopRecognition();else{if(m&&Ee(),a.code==="auto"&&($n||!Ti)){kt(e("notifications.selectLanguageError"),"info");return}s(""),h(!0),i(e("translationInput.placeholderListening")),$n?z(async it=>{i(e("notifications.transcribing"));try{const Ve=await Uh(it,{noiseSuppression:K,gain:de});if(Pt.current)Pt.current.postMessage({type:"transcribe",payload:{audio:Ve,asrLanguage:a.asrCode,promptLanguage:a.code}});else throw new Error("ASR Worker is not initialized.")}catch(Ve){console.error(Ve),i("");const vt=Ve instanceof Error?Ve.message:"Transcription failed.";kt(vt,"error")}}):Ti?Fe.startRecognition(a.code):Ce&&Kt?wt?(i(e("notifications.transcribing")),z(async it=>{const Ve=await Uh(it),vt=dz(new AudioBuffer({length:Ve.length,numberOfChannels:1,sampleRate:16e3}));ci().postMessage({type:"transcribe",payload:{audioData:vt,sourceLang:a.name}})})):kt(e("notifications.offlineModelNotReadyRecording"),"error"):z(async it=>{i(e("notifications.transcribingApi"));const Ve=new AbortController;In.current=Ve;try{let vt="";if(W==="openai"){const Gt=a.code.split("-")[0];vt=await BP(it,Gt,P,te,Ve.signal)}else{const Gt=e(a.name,{lng:"en"});vt=await FP(it,Gt,P,R,Ve.signal)}i(vt)}catch(vt){if(vt instanceof DOMException&&vt.name==="AbortError")return;const Gt=vt instanceof Error?vt.message:"Transcription failed.";kt(Gt,"error"),i("")}finally{In.current=null}})}},[d,m,kt,e,a,$n,Fe,K,de,Ti,W,P,te,R,Ce,wt,Kt,ci]),gt=Ie.useCallback(()=>{if(m||!$n&&Ti&&Fe.isListening&&Mi.current)$n||!Ti?Ee():Fe.stopRecognition();else{if(d&&Ee(),l.code==="auto"){kt(e("notifications.astSelectLanguage"),"info");return}i(""),s(""),y(!0),Mi.current=!0,$n?z(async it=>{i(e("notifications.transcribing"));try{const Ve=await Uh(it,{noiseSuppression:K,gain:de});if(Pt.current)Pt.current.postMessage({type:"transcribe",payload:{audio:Ve,asrLanguage:l.asrCode,promptLanguage:l.code}});else throw new Error("ASR Worker is not initialized.")}catch(Ve){console.error(Ve),i(""),Mi.current=!1;const vt=Ve instanceof Error?Ve.message:"Transcription failed.";kt(vt,"error")}}):Ti?Fe.startRecognition(l.code):Ce&&Kt?wt?(mt(!0),i(e("notifications.transcribing")),z(async it=>{const Ve=await Uh(it),vt=dz(new AudioBuffer({length:Ve.length,numberOfChannels:1,sampleRate:16e3}));ci().postMessage({type:"transcribe",payload:{audioData:vt,sourceLang:l.name}})})):(kt(e("notifications.offlineModelNotReadyRecording"),"error"),y(!1),Mi.current=!1):z(async it=>{i(e("notifications.transcribingApi"));const Ve=new AbortController;In.current=Ve;try{let vt="";if(W==="openai"){const Gt=l.code.split("-")[0];vt=await BP(it,Gt,P,te,Ve.signal)}else{const Gt=e(l.name,{lng:"en"});vt=await FP(it,Gt,P,R,Ve.signal)}i(vt),vt.trim()&&Cr(vt)}catch(vt){if(vt instanceof DOMException&&vt.name==="AbortError")return;const Gt=vt instanceof Error?vt.message:"Transcription failed.";kt(Gt,"error"),i("")}finally{In.current=null,Mi.current=!1}})}},[m,d,l,kt,e,$n,Fe,K,de,Ti,W,P,te,R,Ce,Kt,wt,ci,Cr]),Mt=Ie.useCallback(async tt=>{g(!1),f(!0),i(e("notifications.processingImage")),s("");try{if(Ht==="ready"){const it=new Image;it.src=tt,await new Promise((Gt,rn)=>{it.onload=()=>Gt(),it.onerror=kn=>rn(kn)});const Ve=await Zt(it);if(!Ve)throw new Error("OCR recognition returned no data.");const vt=Hse(Ve.result);i(vt),vt.trim()?await mn(vt):(kt(e("notifications.noTextInImage"),"info"),s(""),f(!1));return}if(Ce){if(!wt||Ji<1)throw new Error(e("notifications.offlineImageError"));const it=await new Promise((vt,Gt)=>{const rn=new Image;rn.onload=()=>createImageBitmap(rn).then(vt).catch(Gt),rn.onerror=()=>Gt(new Error("Failed to load image for bitmap.")),rn.src=tt});ci().postMessage({type:"extractText",payload:{imageBitmap:it}},[it])}else{if(!le)throw new Error(e("notifications.offlineImageTranslateError"));let it;const Ve=t.t(l.name,{lng:"en"});if(W==="openai"){if(!P)throw new Error("OpenAI API Key is not set.");if(!te)throw new Error("OpenAI API URL is not set.");it=await Pte(tt,Ve,P,R,te)}else{if(!P)throw new Error("Gemini API Key is not set.");it=await Ate(tt,Ve,P,R)}i(it.sourceText),s(it.translatedText);const vt={id:Date.now(),inputText:it.sourceText,translatedText:it.translatedText,sourceLang:a,targetLang:l};C(Gt=>{const rn=[vt,...Gt].slice(0,50);return localStorage.setItem("translation-history",JSON.stringify(rn)),rn}),f(!1)}}catch(it){const Ve=it instanceof Error?it.message:"An unknown error occurred.";kt(e("notifications.imageProcessingFailed",{errorMessage:Ve}),"error"),i(""),f(!1)}},[Ce,wt,Ji,le,P,R,l,a,kt,W,te,e,t,ci,Ht,Zt,mn]),Wt=(tt,it,Ve,vt,Gt,rn,kn,Mn,Dn,li,Vn,Bi,$r,yr,$s,As,us,Is,Ps,Rr,ks,Ds,Os,Rs)=>{O(tt),G(it),V(Dn),J(li),Y(Ve),ce(vt),xt(Gt),He(rn),Yi(kn),Yn(Mn),Q($s),we(Vn),ke(Bi),Ge($r),et(yr),Oe(As),bt(us),Et(Is),En(Ps),yi(Rr),tr(ks),re(Ds),xe(Os),vn(Rs),localStorage.setItem("api-key",tt),localStorage.setItem("model-name",it),localStorage.setItem("online-provider",Dn),localStorage.setItem("openai-api-url",li),localStorage.setItem("hf-api-key",Ve),localStorage.setItem("offline-model-name",vt),localStorage.setItem("asr-model-id",Gt),localStorage.setItem("offline-mode-enabled",JSON.stringify(rn)),localStorage.setItem("is-offline-asr-enabled",JSON.stringify(kn)),localStorage.setItem("is-web-speech-api-enabled",JSON.stringify(Mn)),localStorage.setItem("is-two-step-jp-cn-enabled",JSON.stringify($s)),localStorage.setItem("tts-enabled",JSON.stringify(Vn)),localStorage.setItem("tts-voice-uri",Bi),localStorage.setItem("tts-rate",JSON.stringify($r)),localStorage.setItem("tts-pitch",JSON.stringify(yr)),localStorage.setItem("offline-max-tokens",JSON.stringify(As)),localStorage.setItem("offline-top-k",JSON.stringify(us)),localStorage.setItem("offline-temperature",JSON.stringify(Is)),localStorage.setItem("offline-random-seed",JSON.stringify(Ps)),localStorage.setItem("offline-support-audio",JSON.stringify(Rr)),localStorage.setItem("offline-max-num-images",JSON.stringify(ks)),localStorage.setItem("is-noise-cancellation-enabled",JSON.stringify(Ds)),localStorage.setItem("audio-gain-value",JSON.stringify(Os)),localStorage.setItem("selected-ocr-model",Rs)},Cn=tt=>{i(tt.inputText),s(tt.translatedText),o(tt.sourceLang),u(tt.targetLang),S(!1)},Tn=()=>{C([]),localStorage.removeItem("translation-history")},Pn=Ie.useCallback((tt,it)=>{Z(Ve=>({...Ve,[tt]:it}))},[]),wn=Ie.useCallback((tt,it)=>{$c.startDownload(tt,it,j,Ve=>Pn(tt,Ve))},[j,Pn]),Hn=Ie.useCallback((tt,it)=>{$c.resumeDownload(tt,it,j,Ve=>Pn(tt,Ve))},[j,Pn]),Ei=Ie.useCallback(tt=>{$c.pauseDownload(tt)},[]),oi=Ie.useCallback(async tt=>{await $c.deleteModel(tt),Pn(tt,{downloaded:0,total:0,percent:0,status:"not_started"})},[Pn]),Si=Ie.useCallback(async tt=>{if(ji||!Pt.current)return;const it=Ru.find(Ve=>Ve.id===tt);if(!it){kt(`ASR model ${tt} not found.`,"error");return}Wi(!0),oe({file:"",progress:0}),Pt.current.postMessage({type:"load",payload:{modelId:it.id,quantization:it.quantization}})},[ji,kt]),Pi=Ie.useCallback(async()=>{try{Pt.current&&(Pt.current.terminate(),Pt.current=null),Ii(!1),await Die(),Xi().then(nr),kt(e("notifications.asrModelDeleted"),"success")}catch(tt){const it=tt instanceof Error?tt.message:"Unknown error";kt(it,"error")}},[Xi,kt,e]);return se.jsxs("div",{className:"bg-slate-100 h-full flex flex-col",children:[se.jsxs("div",{className:"w-full h-full max-w-6xl mx-auto flex-grow flex flex-col landscape:flex-row p-2 landscape:p-4 gap-4",children:[se.jsx("main",{className:"flex-1 landscape:h-full flex flex-col min-h-0 min-w-0",children:se.jsx(d7,{translatedText:r,targetLang:l,setTargetLang:u,isLoading:c,onSpeak:ia,onSwapLanguages:ls,onOpenHistory:()=>S(!0),onClearText:()=>s(""),isOfflineModeEnabled:Ce,isOfflineModelInitializing:he,isOfflineModelReady:wt,offlineModelName:X,isSpeaking:Ne,speakingGender:ze,onlineProvider:W,isOfflineTtsEnabled:U,isAstRecording:m,onToggleAstRecording:gt})}),se.jsx("div",{className:"flex-1 landscape:h-full flex flex-col min-h-0 min-w-0",children:se.jsx(c7,{inputText:n,setInputText:i,sourceLang:a,setSourceLang:o,isLoading:c||he||ji||Ht==="initializing",onTranslate:os,onCancel:Yr,isRecording:d,onToggleRecording:yt,onOpenCamera:()=>g(!0),onOpenSettings:()=>T(!0),isOnline:le,isOfflineModeEnabled:Ce,isOfflineModelReady:wt,recordingCountdown:Ue})})]}),Wn&&se.jsx("div",{className:`fixed top-5 left-1/2 -translate-x-1/2 px-4 py-3 rounded z-20 shadow-lg text-white ${Wn.type==="error"?"bg-red-500":Wn.type==="success"?"bg-green-500":"bg-blue-500"}`,role:"alert",children:Wn.message}),M&&se.jsx(h7,{onClose:()=>g(!1),onImageCaptured:Mt}),se.jsx(m7,{isOpen:_,onClose:()=>T(!1),onSave:Wt,currentApiKey:P,currentModelName:R,currentOnlineProvider:W,currentOpenaiApiUrl:te,currentHuggingFaceApiKey:j,currentOfflineModelName:X,currentIsOfflineModeEnabled:Ce,currentIsTwoStepJpCnEnabled:me,downloadProgress:at,onStartDownload:wn,onResumeDownload:Hn,onPauseDownload:Ei,onDeleteModel:oi,isOfflineModelInitializing:he,voices:ee,targetLang:l,currentIsOfflineTtsEnabled:U,currentOfflineTtsVoiceURI:Pe,currentOfflineTtsRate:Le,currentOfflineTtsPitch:$e,currentOfflineMaxTokens:Se,currentOfflineTopK:ct,currentOfflineTemperature:Ct,currentOfflineRandomSeed:hn,currentOfflineSupportAudio:Kt,currentOfflineMaxNumImages:Ji,currentIsOfflineAsrEnabled:$n,currentIsWebSpeechApiEnabled:Ti,currentAsrModelId:Gi,currentIsNoiseCancellationEnabled:K,currentAudioGainValue:de,asrModelsCacheStatus:Xt,isAsrInitializing:ji,asrLoadingProgress:L,onDownloadAsrModel:Si,onClearAsrCache:Pi,ocrEngineStatus:Ht,ocrEngineError:It,onInitializeOcr:St,currentSelectedOcrModel:tn}),se.jsx(g7,{isOpen:x,onClose:()=>S(!1),history:$,onSelectHistory:Cn,onClearHistory:Tn})]})},pn=e=>typeof e=="string",Tf=()=>{let e,t;const n=new Promise((i,r)=>{e=i,t=r});return n.resolve=e,n.reject=t,n},fz=e=>e==null?"":""+e,Kse=(e,t,n)=>{e.forEach(i=>{t[i]&&(n[i]=t[i])})},Jse=/###/g,pz=e=>e&&e.indexOf("###")>-1?e.replace(Jse,"."):e,hz=e=>!e||pn(e),ep=(e,t,n)=>{const i=pn(t)?t.split("."):t;let r=0;for(;r<i.length-1;){if(hz(e))return{};const s=pz(i[r]);!e[s]&&n&&(e[s]=new n),Object.prototype.hasOwnProperty.call(e,s)?e=e[s]:e={},++r}return hz(e)?{}:{obj:e,k:pz(i[r])}},mz=(e,t,n)=>{const{obj:i,k:r}=ep(e,t,Object);if(i!==void 0||t.length===1){i[r]=n;return}let s=t[t.length-1],a=t.slice(0,t.length-1),o=ep(e,a,Object);for(;o.obj===void 0&&a.length;)s=`${a[a.length-1]}.${s}`,a=a.slice(0,a.length-1),o=ep(e,a,Object),o&&o.obj&&typeof o.obj[`${o.k}.${s}`]<"u"&&(o.obj=void 0);o.obj[`${o.k}.${s}`]=n},Yse=(e,t,n,i)=>{const{obj:r,k:s}=ep(e,t,Object);r[s]=r[s]||[],r[s].push(n)},$g=(e,t)=>{const{obj:n,k:i}=ep(e,t);if(n)return n[i]},Xse=(e,t,n)=>{const i=$g(e,n);return i!==void 0?i:$g(t,n)},sH=(e,t,n)=>{for(const i in t)i!=="__proto__"&&i!=="constructor"&&(i in e?pn(e[i])||e[i]instanceof String||pn(t[i])||t[i]instanceof String?n&&(e[i]=t[i]):sH(e[i],t[i],n):e[i]=t[i]);return e},Pc=e=>e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&");var Qse={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"};const Zse=e=>pn(e)?e.replace(/[&<>"'\/]/g,t=>Qse[t]):e;class eae{constructor(t){this.capacity=t,this.regExpMap=new Map,this.regExpQueue=[]}getRegExp(t){const n=this.regExpMap.get(t);if(n!==void 0)return n;const i=new RegExp(t);return this.regExpQueue.length===this.capacity&&this.regExpMap.delete(this.regExpQueue.shift()),this.regExpMap.set(t,i),this.regExpQueue.push(t),i}}const tae=[" ",",","?","!",";"],nae=new eae(20),iae=(e,t,n)=>{t=t||"",n=n||"";const i=tae.filter(a=>t.indexOf(a)<0&&n.indexOf(a)<0);if(i.length===0)return!0;const r=nae.getRegExp(`(${i.map(a=>a==="?"?"\\?":a).join("|")})`);let s=!r.test(e);if(!s){const a=e.indexOf(n);a>0&&!r.test(e.substring(0,a))&&(s=!0)}return s},T1=function(e,t){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:".";if(!e)return;if(e[t])return e[t];const i=t.split(n);let r=e;for(let s=0;s<i.length;){if(!r||typeof r!="object")return;let a,o="";for(let l=s;l<i.length;++l)if(l!==s&&(o+=n),o+=i[l],a=r[o],a!==void 0){if(["string","number","boolean"].indexOf(typeof a)>-1&&l<i.length-1)continue;s+=l-s+1;break}r=a}return r},Ag=e=>e&&e.replace("_","-"),rae={type:"logger",log(e){this.output("log",e)},warn(e){this.output("warn",e)},error(e){this.output("error",e)},output(e,t){console&&console[e]&&console[e].apply(console,t)}};class Ig{constructor(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this.init(t,n)}init(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this.prefix=n.prefix||"i18next:",this.logger=t||rae,this.options=n,this.debug=n.debug}log(){for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];return this.forward(n,"log","",!0)}warn(){for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];return this.forward(n,"warn","",!0)}error(){for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];return this.forward(n,"error","")}deprecate(){for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];return this.forward(n,"warn","WARNING DEPRECATED: ",!0)}forward(t,n,i,r){return r&&!this.debug?null:(pn(t[0])&&(t[0]=`${i}${this.prefix} ${t[0]}`),this.logger[n](t))}create(t){return new Ig(this.logger,{prefix:`${this.prefix}:${t}:`,...this.options})}clone(t){return t=t||this.options,t.prefix=t.prefix||this.prefix,new Ig(this.logger,t)}}var Xa=new Ig;class o_{constructor(){this.observers={}}on(t,n){return t.split(" ").forEach(i=>{this.observers[i]||(this.observers[i]=new Map);const r=this.observers[i].get(n)||0;this.observers[i].set(n,r+1)}),this}off(t,n){if(this.observers[t]){if(!n){delete this.observers[t];return}this.observers[t].delete(n)}}emit(t){for(var n=arguments.length,i=new Array(n>1?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];this.observers[t]&&Array.from(this.observers[t].entries()).forEach(a=>{let[o,l]=a;for(let u=0;u<l;u++)o(...i)}),this.observers["*"]&&Array.from(this.observers["*"].entries()).forEach(a=>{let[o,l]=a;for(let u=0;u<l;u++)o.apply(o,[t,...i])})}}class gz extends o_{constructor(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{ns:["translation"],defaultNS:"translation"};super(),this.data=t||{},this.options=n,this.options.keySeparator===void 0&&(this.options.keySeparator="."),this.options.ignoreJSONStructure===void 0&&(this.options.ignoreJSONStructure=!0)}addNamespaces(t){this.options.ns.indexOf(t)<0&&this.options.ns.push(t)}removeNamespaces(t){const n=this.options.ns.indexOf(t);n>-1&&this.options.ns.splice(n,1)}getResource(t,n,i){let r=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};const s=r.keySeparator!==void 0?r.keySeparator:this.options.keySeparator,a=r.ignoreJSONStructure!==void 0?r.ignoreJSONStructure:this.options.ignoreJSONStructure;let o;t.indexOf(".")>-1?o=t.split("."):(o=[t,n],i&&(Array.isArray(i)?o.push(...i):pn(i)&&s?o.push(...i.split(s)):o.push(i)));const l=$g(this.data,o);return!l&&!n&&!i&&t.indexOf(".")>-1&&(t=o[0],n=o[1],i=o.slice(2).join(".")),l||!a||!pn(i)?l:T1(this.data&&this.data[t]&&this.data[t][n],i,s)}addResource(t,n,i,r){let s=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{silent:!1};const a=s.keySeparator!==void 0?s.keySeparator:this.options.keySeparator;let o=[t,n];i&&(o=o.concat(a?i.split(a):i)),t.indexOf(".")>-1&&(o=t.split("."),r=n,n=o[1]),this.addNamespaces(n),mz(this.data,o,r),s.silent||this.emit("added",t,n,i,r)}addResources(t,n,i){let r=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{silent:!1};for(const s in i)(pn(i[s])||Array.isArray(i[s]))&&this.addResource(t,n,s,i[s],{silent:!0});r.silent||this.emit("added",t,n,i)}addResourceBundle(t,n,i,r,s){let a=arguments.length>5&&arguments[5]!==void 0?arguments[5]:{silent:!1,skipCopy:!1},o=[t,n];t.indexOf(".")>-1&&(o=t.split("."),r=i,i=n,n=o[1]),this.addNamespaces(n);let l=$g(this.data,o)||{};a.skipCopy||(i=JSON.parse(JSON.stringify(i))),r?sH(l,i,s):l={...l,...i},mz(this.data,o,l),a.silent||this.emit("added",t,n,i)}removeResourceBundle(t,n){this.hasResourceBundle(t,n)&&delete this.data[t][n],this.removeNamespaces(n),this.emit("removed",t,n)}hasResourceBundle(t,n){return this.getResource(t,n)!==void 0}getResourceBundle(t,n){return n||(n=this.options.defaultNS),this.options.compatibilityAPI==="v1"?{...this.getResource(t,n)}:this.getResource(t,n)}getDataByLanguage(t){return this.data[t]}hasLanguageSomeTranslations(t){const n=this.getDataByLanguage(t);return!!(n&&Object.keys(n)||[]).find(r=>n[r]&&Object.keys(n[r]).length>0)}toJSON(){return this.data}}var aH={processors:{},addPostProcessor(e){this.processors[e.name]=e},handle(e,t,n,i,r){return e.forEach(s=>{this.processors[s]&&(t=this.processors[s].process(t,n,i,r))}),t}};const _z={};class Pg extends o_{constructor(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};super(),Kse(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],t,this),this.options=n,this.options.keySeparator===void 0&&(this.options.keySeparator="."),this.logger=Xa.create("translator")}changeLanguage(t){t&&(this.language=t)}exists(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{interpolation:{}};if(t==null)return!1;const i=this.resolve(t,n);return i&&i.res!==void 0}extractFromKey(t,n){let i=n.nsSeparator!==void 0?n.nsSeparator:this.options.nsSeparator;i===void 0&&(i=":");const r=n.keySeparator!==void 0?n.keySeparator:this.options.keySeparator;let s=n.ns||this.options.defaultNS||[];const a=i&&t.indexOf(i)>-1,o=!this.options.userDefinedKeySeparator&&!n.keySeparator&&!this.options.userDefinedNsSeparator&&!n.nsSeparator&&!iae(t,i,r);if(a&&!o){const l=t.match(this.interpolator.nestingRegexp);if(l&&l.length>0)return{key:t,namespaces:pn(s)?[s]:s};const u=t.split(i);(i!==r||i===r&&this.options.ns.indexOf(u[0])>-1)&&(s=u.shift()),t=u.join(r)}return{key:t,namespaces:pn(s)?[s]:s}}translate(t,n,i){if(typeof n!="object"&&this.options.overloadTranslationOptionHandler&&(n=this.options.overloadTranslationOptionHandler(arguments)),typeof n=="object"&&(n={...n}),n||(n={}),t==null)return"";Array.isArray(t)||(t=[String(t)]);const r=n.returnDetails!==void 0?n.returnDetails:this.options.returnDetails,s=n.keySeparator!==void 0?n.keySeparator:this.options.keySeparator,{key:a,namespaces:o}=this.extractFromKey(t[t.length-1],n),l=o[o.length-1],u=n.lng||this.language,c=n.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(u&&u.toLowerCase()==="cimode"){if(c){const x=n.nsSeparator||this.options.nsSeparator;return r?{res:`${l}${x}${a}`,usedKey:a,exactUsedKey:a,usedLng:u,usedNS:l,usedParams:this.getUsedParamsDetails(n)}:`${l}${x}${a}`}return r?{res:a,usedKey:a,exactUsedKey:a,usedLng:u,usedNS:l,usedParams:this.getUsedParamsDetails(n)}:a}const f=this.resolve(t,n);let d=f&&f.res;const h=f&&f.usedKey||a,m=f&&f.exactUsedKey||a,y=Object.prototype.toString.apply(d),M=["[object Number]","[object Function]","[object RegExp]"],g=n.joinArrays!==void 0?n.joinArrays:this.options.joinArrays,_=!this.i18nFormat||this.i18nFormat.handleAsObject,T=!pn(d)&&typeof d!="boolean"&&typeof d!="number";if(_&&d&&T&&M.indexOf(y)<0&&!(pn(g)&&Array.isArray(d))){if(!n.returnObjects&&!this.options.returnObjects){this.options.returnedObjectHandler||this.logger.warn("accessing an object - but returnObjects options is not enabled!");const x=this.options.returnedObjectHandler?this.options.returnedObjectHandler(h,d,{...n,ns:o}):`key '${a} (${this.language})' returned an object instead of string.`;return r?(f.res=x,f.usedParams=this.getUsedParamsDetails(n),f):x}if(s){const x=Array.isArray(d),S=x?[]:{},$=x?m:h;for(const C in d)if(Object.prototype.hasOwnProperty.call(d,C)){const P=`${$}${s}${C}`;S[C]=this.translate(P,{...n,joinArrays:!1,ns:o}),S[C]===P&&(S[C]=d[C])}d=S}}else if(_&&pn(g)&&Array.isArray(d))d=d.join(g),d&&(d=this.extendTranslation(d,t,n,i));else{let x=!1,S=!1;const $=n.count!==void 0&&!pn(n.count),C=Pg.hasDefaultValue(n),P=$?this.pluralResolver.getSuffix(u,n.count,n):"",O=n.ordinal&&$?this.pluralResolver.getSuffix(u,n.count,{ordinal:!1}):"",R=$&&!n.ordinal&&n.count===0&&this.pluralResolver.shouldUseIntlApi(),G=R&&n[`defaultValue${this.options.pluralSeparator}zero`]||n[`defaultValue${P}`]||n[`defaultValue${O}`]||n.defaultValue;!this.isValidLookup(d)&&C&&(x=!0,d=G),this.isValidLookup(d)||(S=!0,d=a);const V=(n.missingKeyNoValueFallbackToKey||this.options.missingKeyNoValueFallbackToKey)&&S?void 0:d,te=C&&G!==d&&this.options.updateMissing;if(S||x||te){if(this.logger.log(te?"updateKey":"missingKey",u,l,a,te?G:d),s){const X=this.resolve(a,{...n,keySeparator:!1});X&&X.res&&this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}let J=[];const j=this.languageUtils.getFallbackCodes(this.options.fallbackLng,n.lng||this.language);if(this.options.saveMissingTo==="fallback"&&j&&j[0])for(let X=0;X<j.length;X++)J.push(j[X]);else this.options.saveMissingTo==="all"?J=this.languageUtils.toResolveHierarchy(n.lng||this.language):J.push(n.lng||this.language);const Y=(X,ce,me)=>{const Q=C&&me!==d?me:V;this.options.missingKeyHandler?this.options.missingKeyHandler(X,l,ce,Q,te,n):this.backendConnector&&this.backendConnector.saveMissing&&this.backendConnector.saveMissing(X,l,ce,Q,te,n),this.emit("missingKey",X,l,ce,d)};this.options.saveMissing&&(this.options.saveMissingPlurals&&$?J.forEach(X=>{const ce=this.pluralResolver.getSuffixes(X,n);R&&n[`defaultValue${this.options.pluralSeparator}zero`]&&ce.indexOf(`${this.options.pluralSeparator}zero`)<0&&ce.push(`${this.options.pluralSeparator}zero`),ce.forEach(me=>{Y([X],a+me,n[`defaultValue${me}`]||G)})}):Y(J,a,G))}d=this.extendTranslation(d,t,n,f,i),S&&d===a&&this.options.appendNamespaceToMissingKey&&(d=`${l}:${a}`),(S||x)&&this.options.parseMissingKeyHandler&&(this.options.compatibilityAPI!=="v1"?d=this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey?`${l}:${a}`:a,x?d:void 0):d=this.options.parseMissingKeyHandler(d))}return r?(f.res=d,f.usedParams=this.getUsedParamsDetails(n),f):d}extendTranslation(t,n,i,r,s){var a=this;if(this.i18nFormat&&this.i18nFormat.parse)t=this.i18nFormat.parse(t,{...this.options.interpolation.defaultVariables,...i},i.lng||this.language||r.usedLng,r.usedNS,r.usedKey,{resolved:r});else if(!i.skipInterpolation){i.interpolation&&this.interpolator.init({...i,interpolation:{...this.options.interpolation,...i.interpolation}});const u=pn(t)&&(i&&i.interpolation&&i.interpolation.skipOnVariables!==void 0?i.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables);let c;if(u){const d=t.match(this.interpolator.nestingRegexp);c=d&&d.length}let f=i.replace&&!pn(i.replace)?i.replace:i;if(this.options.interpolation.defaultVariables&&(f={...this.options.interpolation.defaultVariables,...f}),t=this.interpolator.interpolate(t,f,i.lng||this.language||r.usedLng,i),u){const d=t.match(this.interpolator.nestingRegexp),h=d&&d.length;c<h&&(i.nest=!1)}!i.lng&&this.options.compatibilityAPI!=="v1"&&r&&r.res&&(i.lng=this.language||r.usedLng),i.nest!==!1&&(t=this.interpolator.nest(t,function(){for(var d=arguments.length,h=new Array(d),m=0;m<d;m++)h[m]=arguments[m];return s&&s[0]===h[0]&&!i.context?(a.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${n[0]}`),null):a.translate(...h,n)},i)),i.interpolation&&this.interpolator.reset()}const o=i.postProcess||this.options.postProcess,l=pn(o)?[o]:o;return t!=null&&l&&l.length&&i.applyPostProcessor!==!1&&(t=aH.handle(l,t,n,this.options&&this.options.postProcessPassResolved?{i18nResolved:{...r,usedParams:this.getUsedParamsDetails(i)},...i}:i,this)),t}resolve(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},i,r,s,a,o;return pn(t)&&(t=[t]),t.forEach(l=>{if(this.isValidLookup(i))return;const u=this.extractFromKey(l,n),c=u.key;r=c;let f=u.namespaces;this.options.fallbackNS&&(f=f.concat(this.options.fallbackNS));const d=n.count!==void 0&&!pn(n.count),h=d&&!n.ordinal&&n.count===0&&this.pluralResolver.shouldUseIntlApi(),m=n.context!==void 0&&(pn(n.context)||typeof n.context=="number")&&n.context!=="",y=n.lngs?n.lngs:this.languageUtils.toResolveHierarchy(n.lng||this.language,n.fallbackLng);f.forEach(M=>{this.isValidLookup(i)||(o=M,!_z[`${y[0]}-${M}`]&&this.utils&&this.utils.hasLoadedNamespace&&!this.utils.hasLoadedNamespace(o)&&(_z[`${y[0]}-${M}`]=!0,this.logger.warn(`key "${r}" for languages "${y.join(", ")}" won't get resolved as namespace "${o}" was not yet loaded`,"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),y.forEach(g=>{if(this.isValidLookup(i))return;a=g;const _=[c];if(this.i18nFormat&&this.i18nFormat.addLookupKeys)this.i18nFormat.addLookupKeys(_,c,g,M,n);else{let x;d&&(x=this.pluralResolver.getSuffix(g,n.count,n));const S=`${this.options.pluralSeparator}zero`,$=`${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;if(d&&(_.push(c+x),n.ordinal&&x.indexOf($)===0&&_.push(c+x.replace($,this.options.pluralSeparator)),h&&_.push(c+S)),m){const C=`${c}${this.options.contextSeparator}${n.context}`;_.push(C),d&&(_.push(C+x),n.ordinal&&x.indexOf($)===0&&_.push(C+x.replace($,this.options.pluralSeparator)),h&&_.push(C+S))}}let T;for(;T=_.pop();)this.isValidLookup(i)||(s=T,i=this.getResource(g,M,T,n))}))})}),{res:i,usedKey:r,exactUsedKey:s,usedLng:a,usedNS:o}}isValidLookup(t){return t!==void 0&&!(!this.options.returnNull&&t===null)&&!(!this.options.returnEmptyString&&t==="")}getResource(t,n,i){let r=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};return this.i18nFormat&&this.i18nFormat.getResource?this.i18nFormat.getResource(t,n,i,r):this.resourceStore.getResource(t,n,i,r)}getUsedParamsDetails(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const n=["defaultValue","ordinal","context","replace","lng","lngs","fallbackLng","ns","keySeparator","nsSeparator","returnObjects","returnDetails","joinArrays","postProcess","interpolation"],i=t.replace&&!pn(t.replace);let r=i?t.replace:t;if(i&&typeof t.count<"u"&&(r.count=t.count),this.options.interpolation.defaultVariables&&(r={...this.options.interpolation.defaultVariables,...r}),!i){r={...r};for(const s of n)delete r[s]}return r}static hasDefaultValue(t){const n="defaultValue";for(const i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&n===i.substring(0,n.length)&&t[i]!==void 0)return!0;return!1}}const bw=e=>e.charAt(0).toUpperCase()+e.slice(1);class yz{constructor(t){this.options=t,this.supportedLngs=this.options.supportedLngs||!1,this.logger=Xa.create("languageUtils")}getScriptPartFromCode(t){if(t=Ag(t),!t||t.indexOf("-")<0)return null;const n=t.split("-");return n.length===2||(n.pop(),n[n.length-1].toLowerCase()==="x")?null:this.formatLanguageCode(n.join("-"))}getLanguagePartFromCode(t){if(t=Ag(t),!t||t.indexOf("-")<0)return t;const n=t.split("-");return this.formatLanguageCode(n[0])}formatLanguageCode(t){if(pn(t)&&t.indexOf("-")>-1){if(typeof Intl<"u"&&typeof Intl.getCanonicalLocales<"u")try{let r=Intl.getCanonicalLocales(t)[0];if(r&&this.options.lowerCaseLng&&(r=r.toLowerCase()),r)return r}catch{}const n=["hans","hant","latn","cyrl","cans","mong","arab"];let i=t.split("-");return this.options.lowerCaseLng?i=i.map(r=>r.toLowerCase()):i.length===2?(i[0]=i[0].toLowerCase(),i[1]=i[1].toUpperCase(),n.indexOf(i[1].toLowerCase())>-1&&(i[1]=bw(i[1].toLowerCase()))):i.length===3&&(i[0]=i[0].toLowerCase(),i[1].length===2&&(i[1]=i[1].toUpperCase()),i[0]!=="sgn"&&i[2].length===2&&(i[2]=i[2].toUpperCase()),n.indexOf(i[1].toLowerCase())>-1&&(i[1]=bw(i[1].toLowerCase())),n.indexOf(i[2].toLowerCase())>-1&&(i[2]=bw(i[2].toLowerCase()))),i.join("-")}return this.options.cleanCode||this.options.lowerCaseLng?t.toLowerCase():t}isSupportedCode(t){return(this.options.load==="languageOnly"||this.options.nonExplicitSupportedLngs)&&(t=this.getLanguagePartFromCode(t)),!this.supportedLngs||!this.supportedLngs.length||this.supportedLngs.indexOf(t)>-1}getBestMatchFromCodes(t){if(!t)return null;let n;return t.forEach(i=>{if(n)return;const r=this.formatLanguageCode(i);(!this.options.supportedLngs||this.isSupportedCode(r))&&(n=r)}),!n&&this.options.supportedLngs&&t.forEach(i=>{if(n)return;const r=this.getLanguagePartFromCode(i);if(this.isSupportedCode(r))return n=r;n=this.options.supportedLngs.find(s=>{if(s===r)return s;if(!(s.indexOf("-")<0&&r.indexOf("-")<0)&&(s.indexOf("-")>0&&r.indexOf("-")<0&&s.substring(0,s.indexOf("-"))===r||s.indexOf(r)===0&&r.length>1))return s})}),n||(n=this.getFallbackCodes(this.options.fallbackLng)[0]),n}getFallbackCodes(t,n){if(!t)return[];if(typeof t=="function"&&(t=t(n)),pn(t)&&(t=[t]),Array.isArray(t))return t;if(!n)return t.default||[];let i=t[n];return i||(i=t[this.getScriptPartFromCode(n)]),i||(i=t[this.formatLanguageCode(n)]),i||(i=t[this.getLanguagePartFromCode(n)]),i||(i=t.default),i||[]}toResolveHierarchy(t,n){const i=this.getFallbackCodes(n||this.options.fallbackLng||[],t),r=[],s=a=>{a&&(this.isSupportedCode(a)?r.push(a):this.logger.warn(`rejecting language code not found in supportedLngs: ${a}`))};return pn(t)&&(t.indexOf("-")>-1||t.indexOf("_")>-1)?(this.options.load!=="languageOnly"&&s(this.formatLanguageCode(t)),this.options.load!=="languageOnly"&&this.options.load!=="currentOnly"&&s(this.getScriptPartFromCode(t)),this.options.load!=="currentOnly"&&s(this.getLanguagePartFromCode(t))):pn(t)&&s(this.formatLanguageCode(t)),i.forEach(a=>{r.indexOf(a)<0&&s(this.formatLanguageCode(a))}),r}}let sae=[{lngs:["ach","ak","am","arn","br","fil","gun","ln","mfe","mg","mi","oc","pt","pt-BR","tg","tl","ti","tr","uz","wa"],nr:[1,2],fc:1},{lngs:["af","an","ast","az","bg","bn","ca","da","de","dev","el","en","eo","es","et","eu","fi","fo","fur","fy","gl","gu","ha","hi","hu","hy","ia","it","kk","kn","ku","lb","mai","ml","mn","mr","nah","nap","nb","ne","nl","nn","no","nso","pa","pap","pms","ps","pt-PT","rm","sco","se","si","so","son","sq","sv","sw","ta","te","tk","ur","yo"],nr:[1,2],fc:2},{lngs:["ay","bo","cgg","fa","ht","id","ja","jbo","ka","km","ko","ky","lo","ms","sah","su","th","tt","ug","vi","wo","zh"],nr:[1],fc:3},{lngs:["be","bs","cnr","dz","hr","ru","sr","uk"],nr:[1,2,5],fc:4},{lngs:["ar"],nr:[0,1,2,3,11,100],fc:5},{lngs:["cs","sk"],nr:[1,2,5],fc:6},{lngs:["csb","pl"],nr:[1,2,5],fc:7},{lngs:["cy"],nr:[1,2,3,8],fc:8},{lngs:["fr"],nr:[1,2],fc:9},{lngs:["ga"],nr:[1,2,3,7,11],fc:10},{lngs:["gd"],nr:[1,2,3,20],fc:11},{lngs:["is"],nr:[1,2],fc:12},{lngs:["jv"],nr:[0,1],fc:13},{lngs:["kw"],nr:[1,2,3,4],fc:14},{lngs:["lt"],nr:[1,2,10],fc:15},{lngs:["lv"],nr:[1,2,0],fc:16},{lngs:["mk"],nr:[1,2],fc:17},{lngs:["mnk"],nr:[0,1,2],fc:18},{lngs:["mt"],nr:[1,2,11,20],fc:19},{lngs:["or"],nr:[2,1],fc:2},{lngs:["ro"],nr:[1,2,20],fc:20},{lngs:["sl"],nr:[5,1,2,3],fc:21},{lngs:["he","iw"],nr:[1,2,20,21],fc:22}],aae={1:e=>+(e>1),2:e=>+(e!=1),3:e=>0,4:e=>e%10==1&&e%100!=11?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2,5:e=>e==0?0:e==1?1:e==2?2:e%100>=3&&e%100<=10?3:e%100>=11?4:5,6:e=>e==1?0:e>=2&&e<=4?1:2,7:e=>e==1?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2,8:e=>e==1?0:e==2?1:e!=8&&e!=11?2:3,9:e=>+(e>=2),10:e=>e==1?0:e==2?1:e<7?2:e<11?3:4,11:e=>e==1||e==11?0:e==2||e==12?1:e>2&&e<20?2:3,12:e=>+(e%10!=1||e%100==11),13:e=>+(e!==0),14:e=>e==1?0:e==2?1:e==3?2:3,15:e=>e%10==1&&e%100!=11?0:e%10>=2&&(e%100<10||e%100>=20)?1:2,16:e=>e%10==1&&e%100!=11?0:e!==0?1:2,17:e=>e==1||e%10==1&&e%100!=11?0:1,18:e=>e==0?0:e==1?1:2,19:e=>e==1?0:e==0||e%100>1&&e%100<11?1:e%100>10&&e%100<20?2:3,20:e=>e==1?0:e==0||e%100>0&&e%100<20?1:2,21:e=>e%100==1?1:e%100==2?2:e%100==3||e%100==4?3:0,22:e=>e==1?0:e==2?1:(e<0||e>10)&&e%10==0?2:3};const oae=["v1","v2","v3"],lae=["v4"],vz={zero:0,one:1,two:2,few:3,many:4,other:5},uae=()=>{const e={};return sae.forEach(t=>{t.lngs.forEach(n=>{e[n]={numbers:t.nr,plurals:aae[t.fc]}})}),e};class cae{constructor(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this.languageUtils=t,this.options=n,this.logger=Xa.create("pluralResolver"),(!this.options.compatibilityJSON||lae.includes(this.options.compatibilityJSON))&&(typeof Intl>"u"||!Intl.PluralRules)&&(this.options.compatibilityJSON="v3",this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")),this.rules=uae(),this.pluralRulesCache={}}addRule(t,n){this.rules[t]=n}clearCache(){this.pluralRulesCache={}}getRule(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(this.shouldUseIntlApi()){const i=Ag(t==="dev"?"en":t),r=n.ordinal?"ordinal":"cardinal",s=JSON.stringify({cleanedCode:i,type:r});if(s in this.pluralRulesCache)return this.pluralRulesCache[s];let a;try{a=new Intl.PluralRules(i,{type:r})}catch{if(!t.match(/-|_/))return;const l=this.languageUtils.getLanguagePartFromCode(t);a=this.getRule(l,n)}return this.pluralRulesCache[s]=a,a}return this.rules[t]||this.rules[this.languageUtils.getLanguagePartFromCode(t)]}needsPlural(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const i=this.getRule(t,n);return this.shouldUseIntlApi()?i&&i.resolvedOptions().pluralCategories.length>1:i&&i.numbers.length>1}getPluralFormsOfKey(t,n){let i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return this.getSuffixes(t,i).map(r=>`${n}${r}`)}getSuffixes(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const i=this.getRule(t,n);return i?this.shouldUseIntlApi()?i.resolvedOptions().pluralCategories.sort((r,s)=>vz[r]-vz[s]).map(r=>`${this.options.prepend}${n.ordinal?`ordinal${this.options.prepend}`:""}${r}`):i.numbers.map(r=>this.getSuffix(t,r,n)):[]}getSuffix(t,n){let i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};const r=this.getRule(t,i);return r?this.shouldUseIntlApi()?`${this.options.prepend}${i.ordinal?`ordinal${this.options.prepend}`:""}${r.select(n)}`:this.getSuffixRetroCompatible(r,n):(this.logger.warn(`no plural rule found for: ${t}`),"")}getSuffixRetroCompatible(t,n){const i=t.noAbs?t.plurals(n):t.plurals(Math.abs(n));let r=t.numbers[i];this.options.simplifyPluralSuffix&&t.numbers.length===2&&t.numbers[0]===1&&(r===2?r="plural":r===1&&(r=""));const s=()=>this.options.prepend&&r.toString()?this.options.prepend+r.toString():r.toString();return this.options.compatibilityJSON==="v1"?r===1?"":typeof r=="number"?`_plural_${r.toString()}`:s():this.options.compatibilityJSON==="v2"||this.options.simplifyPluralSuffix&&t.numbers.length===2&&t.numbers[0]===1?s():this.options.prepend&&i.toString()?this.options.prepend+i.toString():i.toString()}shouldUseIntlApi(){return!oae.includes(this.options.compatibilityJSON)}}const wz=function(e,t,n){let i=arguments.length>3&&arguments[3]!==void 0?arguments[3]:".",r=arguments.length>4&&arguments[4]!==void 0?arguments[4]:!0,s=Xse(e,t,n);return!s&&r&&pn(n)&&(s=T1(e,n,i),s===void 0&&(s=T1(t,n,i))),s},xw=e=>e.replace(/\$/g,"$$$$");class dae{constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.logger=Xa.create("interpolator"),this.options=t,this.format=t.interpolation&&t.interpolation.format||(n=>n),this.init(t)}init(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};t.interpolation||(t.interpolation={escapeValue:!0});const{escape:n,escapeValue:i,useRawValueToEscape:r,prefix:s,prefixEscaped:a,suffix:o,suffixEscaped:l,formatSeparator:u,unescapeSuffix:c,unescapePrefix:f,nestingPrefix:d,nestingPrefixEscaped:h,nestingSuffix:m,nestingSuffixEscaped:y,nestingOptionsSeparator:M,maxReplaces:g,alwaysFormat:_}=t.interpolation;this.escape=n!==void 0?n:Zse,this.escapeValue=i!==void 0?i:!0,this.useRawValueToEscape=r!==void 0?r:!1,this.prefix=s?Pc(s):a||"{{",this.suffix=o?Pc(o):l||"}}",this.formatSeparator=u||",",this.unescapePrefix=c?"":f||"-",this.unescapeSuffix=this.unescapePrefix?"":c||"",this.nestingPrefix=d?Pc(d):h||Pc("$t("),this.nestingSuffix=m?Pc(m):y||Pc(")"),this.nestingOptionsSeparator=M||",",this.maxReplaces=g||1e3,this.alwaysFormat=_!==void 0?_:!1,this.resetRegExp()}reset(){this.options&&this.init(this.options)}resetRegExp(){const t=(n,i)=>n&&n.source===i?(n.lastIndex=0,n):new RegExp(i,"g");this.regexp=t(this.regexp,`${this.prefix}(.+?)${this.suffix}`),this.regexpUnescape=t(this.regexpUnescape,`${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`),this.nestingRegexp=t(this.nestingRegexp,`${this.nestingPrefix}(.+?)${this.nestingSuffix}`)}interpolate(t,n,i,r){let s,a,o;const l=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{},u=h=>{if(h.indexOf(this.formatSeparator)<0){const g=wz(n,l,h,this.options.keySeparator,this.options.ignoreJSONStructure);return this.alwaysFormat?this.format(g,void 0,i,{...r,...n,interpolationkey:h}):g}const m=h.split(this.formatSeparator),y=m.shift().trim(),M=m.join(this.formatSeparator).trim();return this.format(wz(n,l,y,this.options.keySeparator,this.options.ignoreJSONStructure),M,i,{...r,...n,interpolationkey:y})};this.resetRegExp();const c=r&&r.missingInterpolationHandler||this.options.missingInterpolationHandler,f=r&&r.interpolation&&r.interpolation.skipOnVariables!==void 0?r.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables;return[{regex:this.regexpUnescape,safeValue:h=>xw(h)},{regex:this.regexp,safeValue:h=>this.escapeValue?xw(this.escape(h)):xw(h)}].forEach(h=>{for(o=0;s=h.regex.exec(t);){const m=s[1].trim();if(a=u(m),a===void 0)if(typeof c=="function"){const M=c(t,s,r);a=pn(M)?M:""}else if(r&&Object.prototype.hasOwnProperty.call(r,m))a="";else if(f){a=s[0];continue}else this.logger.warn(`missed to pass in variable ${m} for interpolating ${t}`),a="";else!pn(a)&&!this.useRawValueToEscape&&(a=fz(a));const y=h.safeValue(a);if(t=t.replace(s[0],y),f?(h.regex.lastIndex+=a.length,h.regex.lastIndex-=s[0].length):h.regex.lastIndex=0,o++,o>=this.maxReplaces)break}}),t}nest(t,n){let i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},r,s,a;const o=(l,u)=>{const c=this.nestingOptionsSeparator;if(l.indexOf(c)<0)return l;const f=l.split(new RegExp(`${c}[ ]*{`));let d=`{${f[1]}`;l=f[0],d=this.interpolate(d,a);const h=d.match(/'/g),m=d.match(/"/g);(h&&h.length%2===0&&!m||m.length%2!==0)&&(d=d.replace(/'/g,'"'));try{a=JSON.parse(d),u&&(a={...u,...a})}catch(y){return this.logger.warn(`failed parsing options string in nesting for key ${l}`,y),`${l}${c}${d}`}return a.defaultValue&&a.defaultValue.indexOf(this.prefix)>-1&&delete a.defaultValue,l};for(;r=this.nestingRegexp.exec(t);){let l=[];a={...i},a=a.replace&&!pn(a.replace)?a.replace:a,a.applyPostProcessor=!1,delete a.defaultValue;let u=!1;if(r[0].indexOf(this.formatSeparator)!==-1&&!/{.*}/.test(r[1])){const c=r[1].split(this.formatSeparator).map(f=>f.trim());r[1]=c.shift(),l=c,u=!0}if(s=n(o.call(this,r[1].trim(),a),a),s&&r[0]===t&&!pn(s))return s;pn(s)||(s=fz(s)),s||(this.logger.warn(`missed to resolve ${r[1]} for nesting ${t}`),s=""),u&&(s=l.reduce((c,f)=>this.format(c,f,i.lng,{...i,interpolationkey:r[1].trim()}),s.trim())),t=t.replace(r[0],s),this.regexp.lastIndex=0}return t}}const fae=e=>{let t=e.toLowerCase().trim();const n={};if(e.indexOf("(")>-1){const i=e.split("(");t=i[0].toLowerCase().trim();const r=i[1].substring(0,i[1].length-1);t==="currency"&&r.indexOf(":")<0?n.currency||(n.currency=r.trim()):t==="relativetime"&&r.indexOf(":")<0?n.range||(n.range=r.trim()):r.split(";").forEach(a=>{if(a){const[o,...l]=a.split(":"),u=l.join(":").trim().replace(/^'+|'+$/g,""),c=o.trim();n[c]||(n[c]=u),u==="false"&&(n[c]=!1),u==="true"&&(n[c]=!0),isNaN(u)||(n[c]=parseInt(u,10))}})}return{formatName:t,formatOptions:n}},kc=e=>{const t={};return(n,i,r)=>{let s=r;r&&r.interpolationkey&&r.formatParams&&r.formatParams[r.interpolationkey]&&r[r.interpolationkey]&&(s={...s,[r.interpolationkey]:void 0});const a=i+JSON.stringify(s);let o=t[a];return o||(o=e(Ag(i),r),t[a]=o),o(n)}};class pae{constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.logger=Xa.create("formatter"),this.options=t,this.formats={number:kc((n,i)=>{const r=new Intl.NumberFormat(n,{...i});return s=>r.format(s)}),currency:kc((n,i)=>{const r=new Intl.NumberFormat(n,{...i,style:"currency"});return s=>r.format(s)}),datetime:kc((n,i)=>{const r=new Intl.DateTimeFormat(n,{...i});return s=>r.format(s)}),relativetime:kc((n,i)=>{const r=new Intl.RelativeTimeFormat(n,{...i});return s=>r.format(s,i.range||"day")}),list:kc((n,i)=>{const r=new Intl.ListFormat(n,{...i});return s=>r.format(s)})},this.init(t)}init(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{interpolation:{}};this.formatSeparator=n.interpolation.formatSeparator||","}add(t,n){this.formats[t.toLowerCase().trim()]=n}addCached(t,n){this.formats[t.toLowerCase().trim()]=kc(n)}format(t,n,i){let r=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};const s=n.split(this.formatSeparator);if(s.length>1&&s[0].indexOf("(")>1&&s[0].indexOf(")")<0&&s.find(o=>o.indexOf(")")>-1)){const o=s.findIndex(l=>l.indexOf(")")>-1);s[0]=[s[0],...s.splice(1,o)].join(this.formatSeparator)}return s.reduce((o,l)=>{const{formatName:u,formatOptions:c}=fae(l);if(this.formats[u]){let f=o;try{const d=r&&r.formatParams&&r.formatParams[r.interpolationkey]||{},h=d.locale||d.lng||r.locale||r.lng||i;f=this.formats[u](o,h,{...c,...r,...d})}catch(d){this.logger.warn(d)}return f}else this.logger.warn(`there was no format function for ${u}`);return o},t)}}const hae=(e,t)=>{e.pending[t]!==void 0&&(delete e.pending[t],e.pendingCount--)};class mae extends o_{constructor(t,n,i){let r=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};super(),this.backend=t,this.store=n,this.services=i,this.languageUtils=i.languageUtils,this.options=r,this.logger=Xa.create("backendConnector"),this.waitingReads=[],this.maxParallelReads=r.maxParallelReads||10,this.readingCalls=0,this.maxRetries=r.maxRetries>=0?r.maxRetries:5,this.retryTimeout=r.retryTimeout>=1?r.retryTimeout:350,this.state={},this.queue=[],this.backend&&this.backend.init&&this.backend.init(i,r.backend,r)}queueLoad(t,n,i,r){const s={},a={},o={},l={};return t.forEach(u=>{let c=!0;n.forEach(f=>{const d=`${u}|${f}`;!i.reload&&this.store.hasResourceBundle(u,f)?this.state[d]=2:this.state[d]<0||(this.state[d]===1?a[d]===void 0&&(a[d]=!0):(this.state[d]=1,c=!1,a[d]===void 0&&(a[d]=!0),s[d]===void 0&&(s[d]=!0),l[f]===void 0&&(l[f]=!0)))}),c||(o[u]=!0)}),(Object.keys(s).length||Object.keys(a).length)&&this.queue.push({pending:a,pendingCount:Object.keys(a).length,loaded:{},errors:[],callback:r}),{toLoad:Object.keys(s),pending:Object.keys(a),toLoadLanguages:Object.keys(o),toLoadNamespaces:Object.keys(l)}}loaded(t,n,i){const r=t.split("|"),s=r[0],a=r[1];n&&this.emit("failedLoading",s,a,n),!n&&i&&this.store.addResourceBundle(s,a,i,void 0,void 0,{skipCopy:!0}),this.state[t]=n?-1:2,n&&i&&(this.state[t]=0);const o={};this.queue.forEach(l=>{Yse(l.loaded,[s],a),hae(l,t),n&&l.errors.push(n),l.pendingCount===0&&!l.done&&(Object.keys(l.loaded).forEach(u=>{o[u]||(o[u]={});const c=l.loaded[u];c.length&&c.forEach(f=>{o[u][f]===void 0&&(o[u][f]=!0)})}),l.done=!0,l.errors.length?l.callback(l.errors):l.callback())}),this.emit("loaded",o),this.queue=this.queue.filter(l=>!l.done)}read(t,n,i){let r=arguments.length>3&&arguments[3]!==void 0?arguments[3]:0,s=arguments.length>4&&arguments[4]!==void 0?arguments[4]:this.retryTimeout,a=arguments.length>5?arguments[5]:void 0;if(!t.length)return a(null,{});if(this.readingCalls>=this.maxParallelReads){this.waitingReads.push({lng:t,ns:n,fcName:i,tried:r,wait:s,callback:a});return}this.readingCalls++;const o=(u,c)=>{if(this.readingCalls--,this.waitingReads.length>0){const f=this.waitingReads.shift();this.read(f.lng,f.ns,f.fcName,f.tried,f.wait,f.callback)}if(u&&c&&r<this.maxRetries){setTimeout(()=>{this.read.call(this,t,n,i,r+1,s*2,a)},s);return}a(u,c)},l=this.backend[i].bind(this.backend);if(l.length===2){try{const u=l(t,n);u&&typeof u.then=="function"?u.then(c=>o(null,c)).catch(o):o(null,u)}catch(u){o(u)}return}return l(t,n,o)}prepareLoading(t,n){let i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},r=arguments.length>3?arguments[3]:void 0;if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),r&&r();pn(t)&&(t=this.languageUtils.toResolveHierarchy(t)),pn(n)&&(n=[n]);const s=this.queueLoad(t,n,i,r);if(!s.toLoad.length)return s.pending.length||r(),null;s.toLoad.forEach(a=>{this.loadOne(a)})}load(t,n,i){this.prepareLoading(t,n,{},i)}reload(t,n,i){this.prepareLoading(t,n,{reload:!0},i)}loadOne(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"";const i=t.split("|"),r=i[0],s=i[1];this.read(r,s,"read",void 0,void 0,(a,o)=>{a&&this.logger.warn(`${n}loading namespace ${s} for language ${r} failed`,a),!a&&o&&this.logger.log(`${n}loaded namespace ${s} for language ${r}`,o),this.loaded(t,a,o)})}saveMissing(t,n,i,r,s){let a=arguments.length>5&&arguments[5]!==void 0?arguments[5]:{},o=arguments.length>6&&arguments[6]!==void 0?arguments[6]:()=>{};if(this.services.utils&&this.services.utils.hasLoadedNamespace&&!this.services.utils.hasLoadedNamespace(n)){this.logger.warn(`did not save key "${i}" as the namespace "${n}" was not yet loaded`,"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");return}if(!(i==null||i==="")){if(this.backend&&this.backend.create){const l={...a,isUpdate:s},u=this.backend.create.bind(this.backend);if(u.length<6)try{let c;u.length===5?c=u(t,n,i,r,l):c=u(t,n,i,r),c&&typeof c.then=="function"?c.then(f=>o(null,f)).catch(o):o(null,c)}catch(c){o(c)}else u(t,n,i,r,o,l)}!t||!t[0]||this.store.addResource(t[0],n,i,r)}}}const bz=()=>({debug:!1,initImmediate:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,supportedLngs:!1,nonExplicitSupportedLngs:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",partialBundledLanguages:!1,saveMissing:!1,updateMissing:!1,saveMissingTo:"fallback",saveMissingPlurals:!0,missingKeyHandler:!1,missingInterpolationHandler:!1,postProcess:!1,postProcessPassResolved:!1,returnNull:!1,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:!1,parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:e=>{let t={};if(typeof e[1]=="object"&&(t=e[1]),pn(e[1])&&(t.defaultValue=e[1]),pn(e[2])&&(t.tDescription=e[2]),typeof e[2]=="object"||typeof e[3]=="object"){const n=e[3]||e[2];Object.keys(n).forEach(i=>{t[i]=n[i]})}return t},interpolation:{escapeValue:!0,format:e=>e,prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",nestingOptionsSeparator:",",maxReplaces:1e3,skipOnVariables:!0}}),xz=e=>(pn(e.ns)&&(e.ns=[e.ns]),pn(e.fallbackLng)&&(e.fallbackLng=[e.fallbackLng]),pn(e.fallbackNS)&&(e.fallbackNS=[e.fallbackNS]),e.supportedLngs&&e.supportedLngs.indexOf("cimode")<0&&(e.supportedLngs=e.supportedLngs.concat(["cimode"])),e),rm=()=>{},gae=e=>{Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach(n=>{typeof e[n]=="function"&&(e[n]=e[n].bind(e))})};class xp extends o_{constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;if(super(),this.options=xz(t),this.services={},this.logger=Xa,this.modules={external:[]},gae(this),n&&!this.isInitialized&&!t.isClone){if(!this.options.initImmediate)return this.init(t,n),this;setTimeout(()=>{this.init(t,n)},0)}}init(){var t=this;let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},i=arguments.length>1?arguments[1]:void 0;this.isInitializing=!0,typeof n=="function"&&(i=n,n={}),!n.defaultNS&&n.defaultNS!==!1&&n.ns&&(pn(n.ns)?n.defaultNS=n.ns:n.ns.indexOf("translation")<0&&(n.defaultNS=n.ns[0]));const r=bz();this.options={...r,...this.options,...xz(n)},this.options.compatibilityAPI!=="v1"&&(this.options.interpolation={...r.interpolation,...this.options.interpolation}),n.keySeparator!==void 0&&(this.options.userDefinedKeySeparator=n.keySeparator),n.nsSeparator!==void 0&&(this.options.userDefinedNsSeparator=n.nsSeparator);const s=c=>c?typeof c=="function"?new c:c:null;if(!this.options.isClone){this.modules.logger?Xa.init(s(this.modules.logger),this.options):Xa.init(null,this.options);let c;this.modules.formatter?c=this.modules.formatter:typeof Intl<"u"&&(c=pae);const f=new yz(this.options);this.store=new gz(this.options.resources,this.options);const d=this.services;d.logger=Xa,d.resourceStore=this.store,d.languageUtils=f,d.pluralResolver=new cae(f,{prepend:this.options.pluralSeparator,compatibilityJSON:this.options.compatibilityJSON,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),c&&(!this.options.interpolation.format||this.options.interpolation.format===r.interpolation.format)&&(d.formatter=s(c),d.formatter.init(d,this.options),this.options.interpolation.format=d.formatter.format.bind(d.formatter)),d.interpolator=new dae(this.options),d.utils={hasLoadedNamespace:this.hasLoadedNamespace.bind(this)},d.backendConnector=new mae(s(this.modules.backend),d.resourceStore,d,this.options),d.backendConnector.on("*",function(h){for(var m=arguments.length,y=new Array(m>1?m-1:0),M=1;M<m;M++)y[M-1]=arguments[M];t.emit(h,...y)}),this.modules.languageDetector&&(d.languageDetector=s(this.modules.languageDetector),d.languageDetector.init&&d.languageDetector.init(d,this.options.detection,this.options)),this.modules.i18nFormat&&(d.i18nFormat=s(this.modules.i18nFormat),d.i18nFormat.init&&d.i18nFormat.init(this)),this.translator=new Pg(this.services,this.options),this.translator.on("*",function(h){for(var m=arguments.length,y=new Array(m>1?m-1:0),M=1;M<m;M++)y[M-1]=arguments[M];t.emit(h,...y)}),this.modules.external.forEach(h=>{h.init&&h.init(this)})}if(this.format=this.options.interpolation.format,i||(i=rm),this.options.fallbackLng&&!this.services.languageDetector&&!this.options.lng){const c=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);c.length>0&&c[0]!=="dev"&&(this.options.lng=c[0])}!this.services.languageDetector&&!this.options.lng&&this.logger.warn("init: no languageDetector is used and no lng is defined"),["getResource","hasResourceBundle","getResourceBundle","getDataByLanguage"].forEach(c=>{this[c]=function(){return t.store[c](...arguments)}}),["addResource","addResources","addResourceBundle","removeResourceBundle"].forEach(c=>{this[c]=function(){return t.store[c](...arguments),t}});const l=Tf(),u=()=>{const c=(f,d)=>{this.isInitializing=!1,this.isInitialized&&!this.initializedStoreOnce&&this.logger.warn("init: i18next is already initialized. You should call init just once!"),this.isInitialized=!0,this.options.isClone||this.logger.log("initialized",this.options),this.emit("initialized",this.options),l.resolve(d),i(f,d)};if(this.languages&&this.options.compatibilityAPI!=="v1"&&!this.isInitialized)return c(null,this.t.bind(this));this.changeLanguage(this.options.lng,c)};return this.options.resources||!this.options.initImmediate?u():setTimeout(u,0),l}loadResources(t){let i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:rm;const r=pn(t)?t:this.language;if(typeof t=="function"&&(i=t),!this.options.resources||this.options.partialBundledLanguages){if(r&&r.toLowerCase()==="cimode"&&(!this.options.preload||this.options.preload.length===0))return i();const s=[],a=o=>{if(!o||o==="cimode")return;this.services.languageUtils.toResolveHierarchy(o).forEach(u=>{u!=="cimode"&&s.indexOf(u)<0&&s.push(u)})};r?a(r):this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(l=>a(l)),this.options.preload&&this.options.preload.forEach(o=>a(o)),this.services.backendConnector.load(s,this.options.ns,o=>{!o&&!this.resolvedLanguage&&this.language&&this.setResolvedLanguage(this.language),i(o)})}else i(null)}reloadResources(t,n,i){const r=Tf();return typeof t=="function"&&(i=t,t=void 0),typeof n=="function"&&(i=n,n=void 0),t||(t=this.languages),n||(n=this.options.ns),i||(i=rm),this.services.backendConnector.reload(t,n,s=>{r.resolve(),i(s)}),r}use(t){if(!t)throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");if(!t.type)throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");return t.type==="backend"&&(this.modules.backend=t),(t.type==="logger"||t.log&&t.warn&&t.error)&&(this.modules.logger=t),t.type==="languageDetector"&&(this.modules.languageDetector=t),t.type==="i18nFormat"&&(this.modules.i18nFormat=t),t.type==="postProcessor"&&aH.addPostProcessor(t),t.type==="formatter"&&(this.modules.formatter=t),t.type==="3rdParty"&&this.modules.external.push(t),this}setResolvedLanguage(t){if(!(!t||!this.languages)&&!(["cimode","dev"].indexOf(t)>-1))for(let n=0;n<this.languages.length;n++){const i=this.languages[n];if(!(["cimode","dev"].indexOf(i)>-1)&&this.store.hasLanguageSomeTranslations(i)){this.resolvedLanguage=i;break}}}changeLanguage(t,n){var i=this;this.isLanguageChangingTo=t;const r=Tf();this.emit("languageChanging",t);const s=l=>{this.language=l,this.languages=this.services.languageUtils.toResolveHierarchy(l),this.resolvedLanguage=void 0,this.setResolvedLanguage(l)},a=(l,u)=>{u?(s(u),this.translator.changeLanguage(u),this.isLanguageChangingTo=void 0,this.emit("languageChanged",u),this.logger.log("languageChanged",u)):this.isLanguageChangingTo=void 0,r.resolve(function(){return i.t(...arguments)}),n&&n(l,function(){return i.t(...arguments)})},o=l=>{!t&&!l&&this.services.languageDetector&&(l=[]);const u=pn(l)?l:this.services.languageUtils.getBestMatchFromCodes(l);u&&(this.language||s(u),this.translator.language||this.translator.changeLanguage(u),this.services.languageDetector&&this.services.languageDetector.cacheUserLanguage&&this.services.languageDetector.cacheUserLanguage(u)),this.loadResources(u,c=>{a(c,u)})};return!t&&this.services.languageDetector&&!this.services.languageDetector.async?o(this.services.languageDetector.detect()):!t&&this.services.languageDetector&&this.services.languageDetector.async?this.services.languageDetector.detect.length===0?this.services.languageDetector.detect().then(o):this.services.languageDetector.detect(o):o(t),r}getFixedT(t,n,i){var r=this;const s=function(a,o){let l;if(typeof o!="object"){for(var u=arguments.length,c=new Array(u>2?u-2:0),f=2;f<u;f++)c[f-2]=arguments[f];l=r.options.overloadTranslationOptionHandler([a,o].concat(c))}else l={...o};l.lng=l.lng||s.lng,l.lngs=l.lngs||s.lngs,l.ns=l.ns||s.ns,l.keyPrefix!==""&&(l.keyPrefix=l.keyPrefix||i||s.keyPrefix);const d=r.options.keySeparator||".";let h;return l.keyPrefix&&Array.isArray(a)?h=a.map(m=>`${l.keyPrefix}${d}${m}`):h=l.keyPrefix?`${l.keyPrefix}${d}${a}`:a,r.t(h,l)};return pn(t)?s.lng=t:s.lngs=t,s.ns=n,s.keyPrefix=i,s}t(){return this.translator&&this.translator.translate(...arguments)}exists(){return this.translator&&this.translator.exists(...arguments)}setDefaultNamespace(t){this.options.defaultNS=t}hasLoadedNamespace(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!this.isInitialized)return this.logger.warn("hasLoadedNamespace: i18next was not initialized",this.languages),!1;if(!this.languages||!this.languages.length)return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty",this.languages),!1;const i=n.lng||this.resolvedLanguage||this.languages[0],r=this.options?this.options.fallbackLng:!1,s=this.languages[this.languages.length-1];if(i.toLowerCase()==="cimode")return!0;const a=(o,l)=>{const u=this.services.backendConnector.state[`${o}|${l}`];return u===-1||u===0||u===2};if(n.precheck){const o=n.precheck(this,a);if(o!==void 0)return o}return!!(this.hasResourceBundle(i,t)||!this.services.backendConnector.backend||this.options.resources&&!this.options.partialBundledLanguages||a(i,t)&&(!r||a(s,t)))}loadNamespaces(t,n){const i=Tf();return this.options.ns?(pn(t)&&(t=[t]),t.forEach(r=>{this.options.ns.indexOf(r)<0&&this.options.ns.push(r)}),this.loadResources(r=>{i.resolve(),n&&n(r)}),i):(n&&n(),Promise.resolve())}loadLanguages(t,n){const i=Tf();pn(t)&&(t=[t]);const r=this.options.preload||[],s=t.filter(a=>r.indexOf(a)<0&&this.services.languageUtils.isSupportedCode(a));return s.length?(this.options.preload=r.concat(s),this.loadResources(a=>{i.resolve(),n&&n(a)}),i):(n&&n(),Promise.resolve())}dir(t){if(t||(t=this.resolvedLanguage||(this.languages&&this.languages.length>0?this.languages[0]:this.language)),!t)return"rtl";const n=["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ug","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam","ckb"],i=this.services&&this.services.languageUtils||new yz(bz());return n.indexOf(i.getLanguagePartFromCode(t))>-1||t.toLowerCase().indexOf("-arab")>1?"rtl":"ltr"}static createInstance(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;return new xp(t,n)}cloneInstance(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:rm;const i=t.forkResourceStore;i&&delete t.forkResourceStore;const r={...this.options,...t,isClone:!0},s=new xp(r);return(t.debug!==void 0||t.prefix!==void 0)&&(s.logger=s.logger.clone(t)),["store","services","language"].forEach(o=>{s[o]=this[o]}),s.services={...this.services},s.services.utils={hasLoadedNamespace:s.hasLoadedNamespace.bind(s)},i&&(s.store=new gz(this.store.data,r),s.services.resourceStore=s.store),s.translator=new Pg(s.services,r),s.translator.on("*",function(o){for(var l=arguments.length,u=new Array(l>1?l-1:0),c=1;c<l;c++)u[c-1]=arguments[c];s.emit(o,...u)}),s.init(r,n),s.translator.options=r,s.translator.backendConnector.services.utils={hasLoadedNamespace:s.hasLoadedNamespace.bind(s)},s}toJSON(){return{options:this.options,store:this.store,language:this.language,languages:this.languages,resolvedLanguage:this.resolvedLanguage}}}const Fr=xp.createInstance();Fr.createInstance=xp.createInstance;Fr.createInstance;Fr.dir;Fr.init;Fr.loadResources;Fr.reloadResources;Fr.use;Fr.changeLanguage;Fr.getFixedT;Fr.t;Fr.exists;Fr.setDefaultNamespace;Fr.hasLoadedNamespace;Fr.loadNamespaces;Fr.loadLanguages;const{slice:_ae,forEach:yae}=[];function vae(e){return yae.call(_ae.call(arguments,1),t=>{if(t)for(const n in t)e[n]===void 0&&(e[n]=t[n])}),e}function wae(e){return typeof e!="string"?!1:[/<\s*script.*?>/i,/<\s*\/\s*script\s*>/i,/<\s*img.*?on\w+\s*=/i,/<\s*\w+\s*on\w+\s*=.*?>/i,/javascript\s*:/i,/vbscript\s*:/i,/expression\s*\(/i,/eval\s*\(/i,/alert\s*\(/i,/document\.cookie/i,/document\.write\s*\(/i,/window\.location/i,/innerHTML/i].some(n=>n.test(e))}const Tz=/^[\u0009\u0020-\u007e\u0080-\u00ff]+$/,bae=function(e,t){const i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{path:"/"},r=encodeURIComponent(t);let s=`${e}=${r}`;if(i.maxAge>0){const a=i.maxAge-0;if(Number.isNaN(a))throw new Error("maxAge should be a Number");s+=`; Max-Age=${Math.floor(a)}`}if(i.domain){if(!Tz.test(i.domain))throw new TypeError("option domain is invalid");s+=`; Domain=${i.domain}`}if(i.path){if(!Tz.test(i.path))throw new TypeError("option path is invalid");s+=`; Path=${i.path}`}if(i.expires){if(typeof i.expires.toUTCString!="function")throw new TypeError("option expires is invalid");s+=`; Expires=${i.expires.toUTCString()}`}if(i.httpOnly&&(s+="; HttpOnly"),i.secure&&(s+="; Secure"),i.sameSite)switch(typeof i.sameSite=="string"?i.sameSite.toLowerCase():i.sameSite){case!0:s+="; SameSite=Strict";break;case"lax":s+="; SameSite=Lax";break;case"strict":s+="; SameSite=Strict";break;case"none":s+="; SameSite=None";break;default:throw new TypeError("option sameSite is invalid")}return i.partitioned&&(s+="; Partitioned"),s},Mz={create(e,t,n,i){let r=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{path:"/",sameSite:"strict"};n&&(r.expires=new Date,r.expires.setTime(r.expires.getTime()+n*60*1e3)),i&&(r.domain=i),document.cookie=bae(e,t,r)},read(e){const t=`${e}=`,n=document.cookie.split(";");for(let i=0;i<n.length;i++){let r=n[i];for(;r.charAt(0)===" ";)r=r.substring(1,r.length);if(r.indexOf(t)===0)return r.substring(t.length,r.length)}return null},remove(e,t){this.create(e,"",-1,t)}};var xae={name:"cookie",lookup(e){let{lookupCookie:t}=e;if(t&&typeof document<"u")return Mz.read(t)||void 0},cacheUserLanguage(e,t){let{lookupCookie:n,cookieMinutes:i,cookieDomain:r,cookieOptions:s}=t;n&&typeof document<"u"&&Mz.create(n,e,i,r,s)}},Tae={name:"querystring",lookup(e){var i;let{lookupQuerystring:t}=e,n;if(typeof window<"u"){let{search:r}=window.location;!window.location.search&&((i=window.location.hash)==null?void 0:i.indexOf("?"))>-1&&(r=window.location.hash.substring(window.location.hash.indexOf("?")));const a=r.substring(1).split("&");for(let o=0;o<a.length;o++){const l=a[o].indexOf("=");l>0&&a[o].substring(0,l)===t&&(n=a[o].substring(l+1))}}return n}},Mae={name:"hash",lookup(e){var r;let{lookupHash:t,lookupFromHashIndex:n}=e,i;if(typeof window<"u"){const{hash:s}=window.location;if(s&&s.length>2){const a=s.substring(1);if(t){const o=a.split("&");for(let l=0;l<o.length;l++){const u=o[l].indexOf("=");u>0&&o[l].substring(0,u)===t&&(i=o[l].substring(u+1))}}if(i)return i;if(!i&&n>-1){const o=s.match(/\/([a-zA-Z-]*)/g);return Array.isArray(o)?(r=o[typeof n=="number"?n:0])==null?void 0:r.replace("/",""):void 0}}}return i}};let Dc=null;const Ez=()=>{if(Dc!==null)return Dc;try{if(Dc=typeof window<"u"&&window.localStorage!==null,!Dc)return!1;const e="i18next.translate.boo";window.localStorage.setItem(e,"foo"),window.localStorage.removeItem(e)}catch{Dc=!1}return Dc};var Eae={name:"localStorage",lookup(e){let{lookupLocalStorage:t}=e;if(t&&Ez())return window.localStorage.getItem(t)||void 0},cacheUserLanguage(e,t){let{lookupLocalStorage:n}=t;n&&Ez()&&window.localStorage.setItem(n,e)}};let Oc=null;const Sz=()=>{if(Oc!==null)return Oc;try{if(Oc=typeof window<"u"&&window.sessionStorage!==null,!Oc)return!1;const e="i18next.translate.boo";window.sessionStorage.setItem(e,"foo"),window.sessionStorage.removeItem(e)}catch{Oc=!1}return Oc};var Sae={name:"sessionStorage",lookup(e){let{lookupSessionStorage:t}=e;if(t&&Sz())return window.sessionStorage.getItem(t)||void 0},cacheUserLanguage(e,t){let{lookupSessionStorage:n}=t;n&&Sz()&&window.sessionStorage.setItem(n,e)}},Cae={name:"navigator",lookup(e){const t=[];if(typeof navigator<"u"){const{languages:n,userLanguage:i,language:r}=navigator;if(n)for(let s=0;s<n.length;s++)t.push(n[s]);i&&t.push(i),r&&t.push(r)}return t.length>0?t:void 0}},$ae={name:"htmlTag",lookup(e){let{htmlTag:t}=e,n;const i=t||(typeof document<"u"?document.documentElement:null);return i&&typeof i.getAttribute=="function"&&(n=i.getAttribute("lang")),n}},Aae={name:"path",lookup(e){var r;let{lookupFromPathIndex:t}=e;if(typeof window>"u")return;const n=window.location.pathname.match(/\/([a-zA-Z-]*)/g);return Array.isArray(n)?(r=n[typeof t=="number"?t:0])==null?void 0:r.replace("/",""):void 0}},Iae={name:"subdomain",lookup(e){var r,s;let{lookupFromSubdomainIndex:t}=e;const n=typeof t=="number"?t+1:1,i=typeof window<"u"&&((s=(r=window.location)==null?void 0:r.hostname)==null?void 0:s.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i));if(i)return i[n]}};let oH=!1;try{document.cookie,oH=!0}catch{}const lH=["querystring","cookie","localStorage","sessionStorage","navigator","htmlTag"];oH||lH.splice(1,1);const Pae=()=>({order:lH,lookupQuerystring:"lng",lookupCookie:"i18next",lookupLocalStorage:"i18nextLng",lookupSessionStorage:"i18nextLng",caches:["localStorage"],excludeCacheFor:["cimode"],convertDetectedLanguage:e=>e});class uH{constructor(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this.type="languageDetector",this.detectors={},this.init(t,n)}init(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{languageUtils:{}},n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};this.services=t,this.options=vae(n,this.options||{},Pae()),typeof this.options.convertDetectedLanguage=="string"&&this.options.convertDetectedLanguage.indexOf("15897")>-1&&(this.options.convertDetectedLanguage=r=>r.replace("-","_")),this.options.lookupFromUrlIndex&&(this.options.lookupFromPathIndex=this.options.lookupFromUrlIndex),this.i18nOptions=i,this.addDetector(xae),this.addDetector(Tae),this.addDetector(Eae),this.addDetector(Sae),this.addDetector(Cae),this.addDetector($ae),this.addDetector(Aae),this.addDetector(Iae),this.addDetector(Mae)}addDetector(t){return this.detectors[t.name]=t,this}detect(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:this.options.order,n=[];return t.forEach(i=>{if(this.detectors[i]){let r=this.detectors[i].lookup(this.options);r&&typeof r=="string"&&(r=[r]),r&&(n=n.concat(r))}}),n=n.filter(i=>i!=null&&!wae(i)).map(i=>this.options.convertDetectedLanguage(i)),this.services&&this.services.languageUtils&&this.services.languageUtils.getBestMatchFromCodes?n:n.length>0?n[0]:null}cacheUserLanguage(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:this.options.caches;n&&(this.options.excludeCacheFor&&this.options.excludeCacheFor.indexOf(t)>-1||n.forEach(i=>{this.detectors[i]&&this.detectors[i].cacheUserLanguage(t,this.options)}))}}uH.type="languageDetector";const kae={en:{translation:{languages:{autoDetect:"Auto Detect",english:"English",chineseTraditional:"Chinese (Traditional)",chineseTraditionalHK:"Chinese (Traditional) HK",chineseSimplified:"Chinese (Simplified)",spanish:"Spanish",japanese:"Japanese",french:"French",german:"German",korean:"Korean",russian:"Russian",portuguese:"Portuguese",italian:"Italian"},translationInput:{online:"Online",offline:"Offline",cameraAriaLabel:"Translate from camera",settingsAriaLabel:"Open settings",placeholderListening:"Listening...",placeholderEnterText:"Enter text to translate",clearText:"Clear text",countdownPrefix:"0:",recordingStop:"Stop recording",recordingStart:"Start recording",cancelTranslation:"Cancel Translation",translateOffline:"Translate using offline model",translate:"Translate",countdown:"Time left: {{seconds}}s"},translationOutput:{modeOnline:"Mode: Online ({{provider}})",modeOfflineInitializing:"Mode: Offline ({{modelName}}) - Initializing...",modeOfflineReady:"Mode: Offline ({{modelName}})",modeOfflineNotReady:"Mode: Offline ({{modelName}}) - Model not ready",modeOfflineNoModel:"Mode: Offline - No model selected",flipScreenAriaLabel:"Flip screen",copyAriaLabel:"Copy translated text",historyAriaLabel:"View translation history",clearAriaLabel:"Clear translated text",placeholder:"Translation",speakStop:"Stop speaking",speakCustomVoice:"Speak with custom voice",speakFemale:"Speak with female voice",speakMale:"Speak with male voice",astStop:"Stop speech translation",astStart:"Start speech translation",astTitle:"Automatic Speech Translation"},settings:{title:"Settings",closeAriaLabel:"Close settings",tabOnline:"Online",tabOffline:"Offline AI",tabSpeech:"Speech",tabTts:"Offline TTS",tabOfflineParams:"Offline Params",tabOcr:"PaddleOCR",subTabModels:"LLM Models",subTabParameters:"Model Parameters",providerLabel:"Provider",providerGemini:"Gemini",providerOpenAI:"OpenAI",openaiUrlLabel:"OpenAI API URL",openaiUrlPlaceholder:"e.g., https://api.openai.com",apiKeyLabel:"API Key",apiKeyPlaceholder:"Enter your Gemini or OpenAI API Key",modelNameLabel:"Model Name",modelNameGeminiPlaceholder:"e.g., gemini-2.5-flash",modelNameOpenAIPlaceholder:"e.g., gpt-4o",hfApiKeyLabel:"Hugging Face API Key",hfApiKeyPlaceholder:"Required to download models",hfApiKeyDescription:"A key is required for model downloads from Hugging Face.",manageModelsLabel:"Select & Download Offline LLM Model",addCustomModelTitle:"Add Custom Model",customModelUrlLabel:"Hugging Face Model URL",customModelUrlPlaceholder:"e.g., https://huggingface.co/org/repo",customModelLibUrlLabel:"Model Library URL (.wasm)",customModelLibUrlPlaceholder:"e.g., https://.../lib.wasm",addCustomModelButton:"Download and Use Custom Model",asrModelLabel:"Select & Download Offline Speech Recognition Model (ASR)",ocrModelLabel:"Select OCR Model",initializeOcr:"Initialize OCR Engine",switchOcr:"Switch/Reload OCR Model",download:"Download",pause:"Pause",resume:"Resume",retry:"Retry",deleteModelAriaLabel:"Delete {{modelName}}",modelCached:"Cached",modelDownload:"Download",modelDownloading:"Downloading...",statusInitializing:"Initializing...",statusError:"Error: {{error}}",enableOfflineLabel:"Enable Offline Translation",enableOfflineDescription:"Use local model for translations.",enableWebSpeechLabel:"Web Speech API",enableWebSpeechDescription:"Use browser's built-in recognition (Online).",enableOfflineAsrLabel:"Offline ASR (Whisper)",enableOfflineAsrDescription:"Use local Whisper model. Works with Online & Offline translation.",enableGemmaAudioLabel:"Gemma 3N Native Audio",enableGemmaAudioDescription:"Use LLM's native audio capability. Requires Offline Translation Mode.",enableTwoStepLabel:"High-Accuracy JPZH Mode",enableTwoStepDescription:"Improves Japanese to Chinese translation via English.",audioProcessingLabel:"Audio Processing (Whisper)",enableNoiseCancellationLabel:"Noise Cancellation",enableNoiseCancellationDescription:"Reduce background noise.",audioGainLabel:"Microphone Gain",clearCacheButton:"Clear LLM Cache",clearCacheDescription:"Remove all downloaded LLM models.",clearAsrCacheButton:"Clear ASR Cache",ttsSettingsLabel:"Text-to-Speech (TTS) Settings",enableCustomTtsLabel:"Enable Custom Offline TTS",enableCustomTtsDescription:"Customize the voice for text-to-speech.",voiceLabel:"Voice",voicePlaceholder:"No voices available for {{languageName}}",rateLabel:"Rate",pitchLabel:"Pitch",offlineParamsDescription:"Advanced parameters for the local offline model. Changes will require the model to be re-initialized.",maxTokensLabel:"Max Tokens",topKLabel:"Top K",temperatureLabel:"Temperature",randomSeedLabel:"Random Seed",supportAudioLabel:"Enable Audio Input (Gemma)",supportAudioDescription:"Allows the model to process audio files.",maxNumImagesLabel:"Enable Image Input (for OCR)",maxNumImagesDescription:"Allows the model to process one image.",clearSettingsButton:"Clear All Settings",saveSettingsButton:"Save Settings",languageLabel:"UI Language",clearAllAriaLabel:"Clear all settings and cached models"},history:{title:"Translation History",closeAriaLabel:"Close history",empty:"No history yet.",selectAriaLabel:"Select translation from {{sourceLang}} to {{targetLang}}",clearAriaLabel:"Clear all translation history",clearButton:"Clear History"},camera:{title:"Camera Translation View",closeAriaLabel:"Close camera view",errorAccess:"Could not access the camera. Please ensure permissions are granted.",errorCapture:"Failed to capture image: {{message}}",errorLoad:"Failed to load image: {{message}}",zoomAriaLabel:"Zoom camera",galleryAriaLabel:"Import from gallery",captureAriaLabel:"Capture and process image",processingAriaLabel:"Processing image",flashOffAriaLabel:"Turn on flash",flashOnAriaLabel:"Turn off flash"},notifications:{offlineModelInitSuccess:"Offline model {{modelIdentifier}} initialized successfully.",offlineModelInitFailed:"Failed to load offline model.",translationFailed:"Translation Failed: {{errorMessage}}",speechError:"Speech synthesis error: {{error}}",speechRecognitionError:"Speech recognition error: {{error}}",mediaRecorderUnsupported:"MediaRecorder API is not supported in this browser.",processingAudio:"[Processing audio...]",noAudioRecorded:"No audio was recorded.",transcriptionFailed:"Transcription Failed: {{errorMessage}}",micPermissionError:"Could not start recording. Please grant microphone permissions.",offlineModelNotReadyRecording:"Offline model is not ready for recording.",offlineSRError:"You are offline. Cannot use online speech recognition.",astFailed:"AST Failed: {{errorMessage}}",astSelectLanguage:"Please select a source language before using speech translation.",astOfflineModelNotReady:"Offline model is not ready for speech translation.",astOfflineError:"You are offline. Cannot use online speech translation.",processingImage:"[Processing image...]",offlineImageError:"Offline model is not ready for image processing.",noTextInImage:"No text found in the image.",offlineImageTranslateError:"You are offline. Cannot use online image translation.",imageProcessingFailed:"Image Processing Failed: {{errorMessage}}",offlineFeatureUnavailable:"This feature is not available in offline mode.",cacheCleared:"Offline model cache has been cleared successfully.",downloadInProgress:"A model is already being downloaded. Please wait.",modelDownloaded:"Model {{modelId}} downloaded successfully.",modelDeleted:"Model {{modelId}} deleted successfully.",customModelUrlError:"Please provide both the model URL and the model library URL.",customModelSelected:"Custom model has been selected.",cacheClearError:"Please enable offline mode and select a model before clearing the cache.",transcribing:"[Transcribing...]",transcribingApi:"[Transcribing via API...]",asrReady:"Speech recognition model is ready.",asrFailed:"Failed to initialize speech recognition model: {{error}}",asrModelDeleted:"ASR model cache cleared successfully.",asrModelUnloaded:"Offline speech model unloaded successfully.",asrOnlineUnavailable:"Offline ASR is only available in Offline Translation Mode.",modelIdleUnloaded:"Offline model unloaded due to inactivity to save resources. It will reload on next use.",ocrNotReady:"OCR engine not ready. Please initialize it in Settings > PaddleOCR v5."},common:{status:{not_started:"Not Started",downloading:"Downloading",paused:"Paused",completed:"Completed",error:"Error",consolidating:"Consolidating...",initializing:"Initializing..."}}}},"zh-TW":{translation:{languages:{autoDetect:"",english:"",chineseTraditional:"",chineseTraditionalHK:" ()",chineseSimplified:"",spanish:"",japanese:"",french:"",german:"",korean:"",russian:"",portuguese:"",italian:""},translationInput:{online:"",offline:"",cameraAriaLabel:"",settingsAriaLabel:"",placeholderListening:"...",placeholderEnterText:"",clearText:"",countdownPrefix:"0:",recordingStop:"",recordingStart:"",cancelTranslation:"",translateOffline:"",translate:"",countdown:"{{seconds}}"},translationOutput:{modeOnline:" ({{provider}})",modeOfflineInitializing:" ({{modelName}}) - ...",modeOfflineReady:" ({{modelName}})",modeOfflineNotReady:" ({{modelName}}) - ",modeOfflineNoModel:" - ",flipScreenAriaLabel:"",copyAriaLabel:"",historyAriaLabel:"",clearAriaLabel:"",placeholder:"",speakStop:"",speakCustomVoice:"",speakFemale:"",speakMale:"",astStop:"",astStart:"",astTitle:""},settings:{title:"",closeAriaLabel:"",tabOnline:"",tabOffline:"AI",tabSpeech:"",tabTts:" TTS",tabOfflineParams:"",tabOcr:"PaddleOCR",subTabModels:"LLM ",subTabParameters:"",providerLabel:"",providerGemini:"Gemini",providerOpenAI:"OpenAI",openaiUrlLabel:"OpenAI API URL",openaiUrlPlaceholder:"https://api.openai.com",apiKeyLabel:"API ",apiKeyPlaceholder:" Gemini  OpenAI API ",modelNameLabel:"",modelNameGeminiPlaceholder:"gemini-2.5-flash",modelNameOpenAIPlaceholder:"gpt-4o",hfApiKeyLabel:"Hugging Face API ",hfApiKeyPlaceholder:"",hfApiKeyDescription:" Hugging Face ",manageModelsLabel:" LLM ",addCustomModelTitle:"",customModelUrlLabel:"Hugging Face  URL",customModelUrlPlaceholder:"https://huggingface.co/org/repo",customModelLibUrlLabel:" URL (.wasm)",customModelLibUrlPlaceholder:"https://.../lib.wasm",addCustomModelButton:"",asrModelLabel:" (ASR)",ocrModelLabel:" OCR ",initializeOcr:" OCR ",switchOcr:"/ OCR ",modelCached:"",modelDownload:"",modelDownloading:"...",deleteModelAriaLabel:" {{modelName}}",download:"",pause:"",resume:"",retry:"",statusInitializing:"...",statusError:"{{error}}",enableOfflineLabel:"",enableOfflineDescription:"",enableWebSpeechLabel:"Web Speech API",enableWebSpeechDescription:" ()",enableOfflineAsrLabel:" ASR (Whisper)",enableOfflineAsrDescription:" Whisper ",enableGemmaAudioLabel:"Gemma 3N ",enableGemmaAudioDescription:" LLM ",enableTwoStepLabel:"  ",enableTwoStepDescription:"",audioProcessingLabel:" (Whisper)",enableNoiseCancellationLabel:"",enableNoiseCancellationDescription:"",audioGainLabel:"",clearCacheButton:" LLM ",clearCacheDescription:" LLM ",clearAsrCacheButton:" ASR ",ttsSettingsLabel:" (TTS) ",enableCustomTtsLabel:" TTS",enableCustomTtsDescription:"",voiceLabel:"",voicePlaceholder:" {{languageName}} ",rateLabel:"",pitchLabel:"",offlineParamsDescription:"",maxTokensLabel:" (Max Tokens)",topKLabel:"Top K",temperatureLabel:" (Temperature)",randomSeedLabel:" (Random Seed)",supportAudioLabel:" (Gemma)",supportAudioDescription:"",maxNumImagesLabel:" ()",maxNumImagesDescription:"",clearSettingsButton:"",saveSettingsButton:"",languageLabel:"",clearAllAriaLabel:""},history:{title:"",closeAriaLabel:"",empty:"",selectAriaLabel:" {{sourceLang}}  {{targetLang}} ",clearAriaLabel:"",clearButton:""},camera:{title:"",closeAriaLabel:"",errorAccess:"",errorCapture:"{{message}}",errorLoad:"{{message}}",zoomAriaLabel:"",galleryAriaLabel:"",captureAriaLabel:"",processingAriaLabel:"",flashOffAriaLabel:"",flashOnAriaLabel:""},notifications:{offlineModelInitSuccess:" {{modelIdentifier}} ",offlineModelInitFailed:"",translationFailed:"{{errorMessage}}",speechError:"{{error}}",speechRecognitionError:"{{error}}",mediaRecorderUnsupported:" MediaRecorder API",processingAudio:"[...]",noAudioRecorded:"",transcriptionFailed:"{{errorMessage}}",micPermissionError:"",offlineModelNotReadyRecording:"",offlineSRError:"",astFailed:"{{errorMessage}}",astSelectLanguage:"",astOfflineModelNotReady:"",astOfflineError:"",processingImage:"[...]",offlineImageError:"",noTextInImage:"",offlineImageTranslateError:"",imageProcessingFailed:"{{errorMessage}}",offlineFeatureUnavailable:"",cacheCleared:"",downloadInProgress:"",modelDownloaded:" {{modelId}} ",modelDeleted:" {{modelId}} ",customModelUrlError:" URL  URL",customModelSelected:"",cacheClearError:"",transcribing:"[...]",transcribingApi:"[ API ...]",asrReady:"",asrFailed:"{{error}}",asrModelDeleted:"ASR ",asrModelUnloaded:"",asrOnlineUnavailable:" ASR ",modelIdleUnloaded:"",ocrNotReady:"OCR   > PaddleOCR v5 "},common:{status:{not_started:"",downloading:"",paused:"",completed:"",error:"",consolidating:"...",initializing:"..."}}}}};Fr.use(uH).use(V9).init({resources:kae,fallbackLng:"en",debug:!0,interpolation:{escapeValue:!1},detection:{order:["localStorage","navigator"],caches:["localStorage"]}});const cH=document.getElementById("root");if(!cH)throw new Error("Could not find root element to mount to");const Dae=I9.createRoot(cH);Dae.render(se.jsx(k$.StrictMode,{children:se.jsx(k$.Suspense,{fallback:"Loading...",children:se.jsx(qse,{})})}));
